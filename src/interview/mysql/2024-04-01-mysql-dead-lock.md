---
lang: zh-CN
title: 在什么情况下会导致mysql死锁？
headerDepth: 0
order: 31
description: 在什么情况下会导致mysql死锁？
---



之前在Java并发中讲解了产生死锁的条件：

1. **互斥条件（Mutual Exclusion）**：共享资源 X 和 Y 只能被一个线程占用；

2. **占有且等待（Hold and Wait）**：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；

3. **不可抢占（No Preemption）**：其他线程不能强行抢占线程 T1 占有的资源；

4. **循环等待条件（Circular Wait）**：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

当以上四个条件同时满足时，就有可能发生死锁。

## 在什么情况下会导致mysql死锁产生

同理MySQL死锁通常在多个事务同时尝试访问相同的多个资源过程中产生的，由于竞争相同的资源而相互等待，导致彼此都在等待对方释放锁，从而导致了死锁。表级锁由于只存储一把锁，所以不会死锁。通常Mysql死锁锁发生在Innodb的行级锁上。

以下是导致MySQL死锁的一些常见情况：

- **并发事务更新相同的行**：当多个事务同时尝试更新相同的数据行时，可能会导致死锁。例如，一个事务在更新某一行时持有了锁，而另一个事务也想要更新同一行但由于该行已被锁定而等待，这可能导致死锁。

- **事务持有锁并请求其他锁**：如果一个事务已经持有了某些资源的锁，并且尝试获取其他资源的锁，但这些资源又被其他事务所持有，就可能导致死锁。

- **不同的事务以不同的顺序获取锁**：当多个事务以不同的顺序请求锁定资源时，可能会导致循环依赖，从而引发死锁。

解决MySQL死锁的方法包括：

- **重试机制**：当检测到死锁时，可以通过捕获错误并重新执行受影响的事务来解决死锁。

- **降低并发性**：减少并发事务的数量或减少事务持有锁的时间可以降低死锁的发生率。这可以通过优化事务设计、减少事务的范围、尽快提交或回滚事务等方式实现。

- **优化索引**：合理设计和使用索引可以减少死锁的发生。良好的索引设计可以减少事务持有锁的时间，并减少死锁的可能性。

- **分析和优化查询**：对于频繁导致死锁的查询，可以通过分析和优化查询语句、修改事务隔离级别等方式来减少死锁的发生。



## 如何排查Mysql死锁



要排查MySQL死锁，您可以执行以下步骤：

1. **查看错误日志**：MySQL服务器的错误日志可能包含有关死锁的信息。另外应用程序也会收到Mysql死锁的信息，通常会以错误日志的形式打印。ß

2. **使用SHOW ENGINE INNODB STATUS命令**：这个命令可以提供有关InnoDB存储引擎的详细信息，包括当前活动的事务、锁信息以及最近发生的死锁。

    ```sql
    SHOW ENGINE INNODB STATUS;
    ```

4. **分析事务**：通过分析正在执行的事务，特别是涉及到可能导致死锁的事务。可以使用`SHOW PROCESSLIST`命令来查看当前正在执行的事务和查询。

5. **使用工具进行分析**：有一些MySQL死锁分析工具可以自动检测和分析死锁，例如pt-deadlock-logger和Percona的Percona Toolkit。这些工具可以帮助您更轻松地识别和解决死锁问题。



## 死锁演示

表数据如下：

![image-20240328231210013](https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/28/image-20240328231210013.png)

事务一：

![image-20240328231141704](../../../../../../Library/Application Support/typora-user-images/image-20240328231141704.png)

事务二：

![image-20240328231109924](https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/28/image-20240328231109924.png)

此时事务 2 等待事务一释放锁，导致死锁。

最终Mysql会执行超时让事务二重试：

![image-20240328231310831](https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/28/image-20240328231310831.png)



此时：可以通过执行commit来提交事务一的事务；并重试事务 二，事务二可以获取事务锁。

![image-20240328231729163](https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/28/image-20240328231729163.png)

<!-- @include: @article-footer.snippet.md -->