



真正的原因是因为生命周期的原因。方法中的局部变量，方法结束后这个变量就要释放掉，而final会保证这个变量始终指向一个对象。

　　首先，内部类和外部类其实是处于同一个级别,反编译中可以看到都是对象级别的类文件，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随者被销毁。问题就来了，如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中(反编译class文件中可以看到)，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。

局部内部类是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。

而匿名内部类也可以说是局部内部类的一种，有时候一个类只使用一次，就可以用匿名内部类，告诉GC只用一次就可以回收了，同时也可以简化代码和方便地定义回调

需要注意的是局部内部类和匿名内部类引用外部变量时，外部的变量需要是final 的：
——————————————