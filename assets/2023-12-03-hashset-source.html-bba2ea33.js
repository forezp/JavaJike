import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as n,f as e}from"./app-599ca765.js";const t={},c=e(`<h2 id="类结构图" tabindex="-1"><a class="header-anchor" href="#类结构图" aria-hidden="true">#</a> 类结构图</h2><p>HashSet 是 java 集合框架中用于存储单列数据。不同于ArrayList可以存储重复元素，HashSet存储的元素不会重复。下面是HashSet的类结构图：</p><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2023/12/3/截屏2023-12-03 15.13.47.png" alt="截屏2023-12-03 15.13.47" style="zoom:50%;"><ul><li><p>HashSet继承了AbstractSet类并实现类Set接口，所以HashSet具有了AbstractSet和Set的功能。</p></li><li><p>HashSet实现了Cloneable接口，表明HashMap支持克隆。</p></li><li><p>HashSet实现了Serializable接口，表明HashSet支持序列，可以将HashSet以流的形式通过ObjesctInputStream/ObjectOutputStream来写/读。</p></li></ul><h2 id="底层数据结构" tabindex="-1"><a class="header-anchor" href="#底层数据结构" aria-hidden="true">#</a> 底层数据结构</h2><p>HashSet 的底层数据结构是基于 HashMap 实现的。在 HashSet 中，实际上是使用 HashSet 的元素作为 HashMap 的键（key），并将一个固定的对象作为 HashMap 的值（value）。</p><p>在 HashSet 中，所有元素都会被映射到 HashMap 中的不同键上（通过 hashCode 和 equals 方法进行判断），因为 HashMap 不允许存在重复的键，所以它天然的保证了 HashSet 中元素的唯一性。</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2023/12/3/1945524-20210708224827426-1261427530.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>HashSet使用HashMap作为底层存储数据的结构，既保存了数组查询和修改元素效率快的优点，也保存了链表在添加和删除元素时效率快的特点。</p><p>HashSet 的性能取决于哈希函数的质量和哈希表的大小。一般情况下，HashSet 的查找、添加和删除操作的时间复杂度为 O(1)。</p><p>但同时HashSet和HashMap一样，是线程安全的。</p><h2 id="简单示例" tabindex="-1"><a class="header-anchor" href="#简单示例" aria-hidden="true">#</a> 简单示例</h2><p>使用代码示例如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> public static void main(String[] args) {
        Set&lt;String&gt; set=new HashSet&lt;&gt;();
        set.add(&quot;1&quot;);
        set.add(&quot;2&quot;);
        set.add(&quot;3&quot;);
        set.add(&quot;3&quot;);
        set.add(&quot;1&quot;);
        for (String s:
             set) {
            System.out.println(s);
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面代码输出：</p><blockquote><p>1<br> 2<br> 3</p></blockquote><h2 id="源码解析" tabindex="-1"><a class="header-anchor" href="#源码解析" aria-hidden="true">#</a> 源码解析</h2><h3 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数" aria-hidden="true">#</a> 构造函数</h3><ol><li>无参构造函数</li></ol><p>HashSet 类有多个构造函数，下面我们来分析其中一个常用的构造函数:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这个构造函数没有参数，用于创建一个空的 HashSet 对象。</li><li>在构造函数中，通过 <code>new HashMap&lt;&gt;()</code> 创建了一个新的 HashMap 对象，并将其赋值给 HashSet 内部的 <code>map</code> 成员变量。</li><li>HashSet 的元素将会以键的形式存储在 HashMap 中，而 HashMap 的值则被忽略，只使用键来判断元素的唯一性。</li></ul><ol start="2"><li>传递一个集合参数的构造函数</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 可以将集合中的数据全部添加到新创建的HashSet集合中，会去除掉重复的值。
 * <span class="token keyword">@param</span>  <span class="token parameter">c</span>   
 */</span>
<span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">.75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="添加元素" tabindex="-1"><a class="header-anchor" href="#添加元素" aria-hidden="true">#</a> 添加元素</h2><p>HashSet 的元素添加操作是通过调用 HashMap 的 <code>put</code> 方法实现的。下面是 HashSet 的 <code>add</code> 方法的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token constant">PRESENT</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>add</code> 方法接受一个元素 <code>e</code> 作为参数，并返回一个布尔值，表示添加元素是否成功。</li><li>在方法内部，通过调用 HashMap 的 <code>put</code> 方法将元素 <code>e</code> 作为键、一个固定的占位符对象（比如 <code>PRESENT</code>）作为值存储在 HashMap 中。</li><li>当调用 <code>put</code> 方法时，如果 HashMap 中之前不存在相同的键，那么会返回 <code>null</code>，表示添加成功。</li><li>如果 HashMap 中已经存在相同的键，那么会将新的值替换旧的值，并返回旧的值。但在 HashSet 中，我们并不关心值的内容，只关心添加操作是否成功。所以，当返回值不为 <code>null</code> 时，表示已经存在相同的元素，添加失败。</li><li><code>add</code> 方法最后根据 <code>put</code> 方法的返回结果，返回一个布尔值，表示添加操作是否成功。</li></ul><h2 id="查找元素" tabindex="-1"><a class="header-anchor" href="#查找元素" aria-hidden="true">#</a> 查找元素</h2><p>HashSet 的 <code>contains(Object o)</code> 方法用于检查 HashSet 中是否包含指定的元素。下面是 <code>contains</code> 方法的源码分析：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>contains</code> 方法接受一个对象 <code>o</code> 作为参数，并返回一个布尔值，表示 HashSet 是否包含该对象。</li><li>在方法内部，它调用 HashMap 的 <code>containsKey</code> 方法来判断 HashMap 中是否包含指定的键 <code>o</code>（即是否存在指定的元素）。</li><li><code>containsKey</code> 方法会根据指定键的哈希值和相等性判断，检查 HashMap 中是否存在该键。如果存在，则返回 <code>true</code>；否则返回 <code>false</code>。</li><li>因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，如果 HashMap 中存在指定的键，即表示 HashSet 中包含指定的元素。</li><li><code>contains</code> 方法最终返回 <code>containsKey</code> 方法的结果。</li></ul><h2 id="删除元素" tabindex="-1"><a class="header-anchor" href="#删除元素" aria-hidden="true">#</a> 删除元素</h2><p>HashSet 的元素删除操作是通过调用 HashMap 的 <code>remove</code> 方法实现的。下面是 HashSet 的 <code>remove</code> 方法的源码分析：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">PRESENT</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>remove</code> 方法接受一个对象 <code>o</code> 作为参数，并返回一个布尔值，表示删除操作是否成功。</li><li>在方法内部，它调用 HashMap 的 <code>remove</code> 方法来删除 HashMap 中指定键 <code>o</code> 对应的键值对。</li><li><code>remove</code> 方法会根据指定键的哈希值和相等性判断，在 HashMap 中找到对应的键值对并删除。如果删除成功，则返回被删除的值；否则返回 <code>null</code>。</li><li>因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，当调用 <code>remove</code> 方法成功时，返回的值应该是固定的占位符对象（比如 <code>PRESENT</code>），表示删除成功。</li><li><code>remove</code> 方法将 <code>remove</code> 方法的返回值与固定的占位符对象 <code>PRESENT</code> 进行比较。如果相等，则表示删除操作成功。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>HashSet 是一种无序、唯一性的集合实现。它基于哈希表的数据结构，通过使用 HashMap 来存储元素，并具有很好的性能特性。</p><p>HashSet 是非线程安全的，如果在多线程环境下使用 HashSet，需要进行同步处理或使用线程安全的替代品，如 <code>ConcurrentHashSet</code></p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/common/wxcode.png" alt="方志朋_官方公众号" tabindex="0" loading="lazy"><figcaption>方志朋_官方公众号</figcaption></figure>`,40),o=[c];function p(i,l){return s(),n("div",null,o)}const r=a(t,[["render",p],["__file","2023-12-03-hashset-source.html.vue"]]);export{r as default};
