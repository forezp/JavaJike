import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c,f as d}from"./app-6342a097.js";const n={},t=d("<p>在绝大多数情况下，<code>COUNT(*)</code> 和 <code>COUNT(1)</code> 的性能是相同的，因为它们都执行了一个聚合操作来计算行数。不过，它们在语义上略有不同。</p><ul><li><code>count(*)</code>包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为null</li><li><code>count(1)</code>包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为null</li><li><code>count(列名)</code>只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null 的计数，即某个字段值为null 时，不统计。</li></ul><p>虽然从理论上讲 <code>COUNT(1)</code> 可能会稍微快一点，因为它不需要检查列的值是否为空，但是在实际情况下，现代数据库优化器通常会将它们优化为相同的执行计划。因此，大多数数据库系统中 <code>COUNT(*)</code> 和 <code>COUNT(1)</code> 的性能基本上是相同的。</p><p>在 MySQL 5.7 的官方手册中有这么一句话：</p><p><em>InnoDB handles SELECT COUNT(<code>\\*</code>) and SELECT COUNT(<code>1</code>) operations in the same way. There is no performance difference.</em></p><p>翻译过来：InnoDB存储引擎中SELECT COUNT(<code>\\*</code>) and SELECT COUNT(<code>1</code>) 执行相同的操作。没有性能上的差异。</p>",6),l=[t];function r(a,s){return o(),c("div",null,l)}const p=e(n,[["render",r],["__file","2024-04-02-count_star.html.vue"]]);export{p as default};
