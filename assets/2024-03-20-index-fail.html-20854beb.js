import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,f as d}from"./app-28e7b64a.js";const n={},t=d('<p>Mysql的索引是为了加快查询性能的，但是有很多情况下，我们对某些字段创建了索引，但是索引并未生效。在实际的工作中或者面试中，Mysql的索引失效是我们必须需要了解的。</p><p>本篇文章将会讲解一些场景不走索引的案例，帮大家更好的理解或者避免踩坑。</p><h3 id="数据准备" tabindex="-1"><a class="header-anchor" href="#数据准备" aria-hidden="true">#</a> 数据准备</h3><p>创建的一张 <code>user</code> 的表，有以下的列：</p><ul><li><code>id</code>：主键。</li><li><code>id_no</code>：长度为 18 的字符型字段，用于存储身份证编号。</li><li><code>username</code>：长度为 32 的字符型字段，用于存储用户名。</li><li><code>age</code>：整数字段，用于存储年龄。</li><li><code>create_time</code>：一个日期时间字段，存储记录创建时间。</li></ul><p>创建了三个索引：</p><ol><li><code>PRIMARY KEY</code>：这是主键索引，针对 <code>id</code> 列。</li><li><code>union_idx</code>：这是一个联合索引，涵盖了 <code>id_no</code>、<code>username</code> 和 <code>age</code> 列。这个索引可以加速查询同时涉及到这三个列的操作。</li><li><code>create_time_idx</code>：这是一个单列索引，针对 <code>create_time</code> 列。这个索引可以加速按照创建时间进行查询的操作。</li></ol><p>创建表字段如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE `user` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,\n  `id_no` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT &#39;身份编号&#39;,\n  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT &#39;用户名&#39;,\n  `age` int(11) DEFAULT NULL COMMENT &#39;年龄&#39;,\n  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,\n  PRIMARY KEY (`id`),\n  KEY `union_idx` (`id_no`,`username`,`age`),\n  KEY `create_time_idx` (`create_time`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化表数据语句如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>INSERT INTO `user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#39;11&#39;, &#39;forezp1&#39;, 11, &#39;2024-03-11 01:01:11&#39;);\nINSERT INTO `user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#39;12&#39;, &#39;forezp2&#39;, 12, &#39;2024-03-11 01:01:11&#39;);\nINSERT INTO `user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#39;13&#39;, &#39;forezp3&#39;, 13, &#39;2024-03-11 01:01:11&#39;);\nINSERT INTO `user` (`id`, `id_no`, `username`, `age`, `create_time`) VALUES (null, &#39;14&#39;, &#39;forezp4&#39;, 14, &#39;2024-03-11 01:01:11&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看数据库版本和查询执行计划：</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317173245764.png" alt="image-20240317173245764" tabindex="0" loading="lazy"><figcaption>image-20240317173245764</figcaption></figure><p>执行以下语句索引生效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> explain select * from user where id_no = &#39;11&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317173625723.png" alt="image-20240317173625723" tabindex="0" loading="lazy"><figcaption>image-20240317173625723</figcaption></figure><h3 id="索引失效的几种情况" tabindex="-1"><a class="header-anchor" href="#索引失效的几种情况" aria-hidden="true">#</a> 索引失效的几种情况</h3><h4 id="_1-使用like操作符" tabindex="-1"><a class="header-anchor" href="#_1-使用like操作符" aria-hidden="true">#</a> 1.使用like操作符</h4><p>MySQL 索引可能会失效，如果查询中使用了不适合索引的操作符，比如对索引列进行了模糊查询（<code>LIKE &#39;%value%&#39;</code>）、。</p><p>执行以下语句，索引会失效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> explain select * from user where id_no like &#39;%1%&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317173428123.png" alt="image-20240317173428123" tabindex="0" loading="lazy"><figcaption>image-20240317173428123</figcaption></figure><h4 id="_2-联合索引不满足列的最左匹配原则" tabindex="-1"><a class="header-anchor" href="#_2-联合索引不满足列的最左匹配原则" aria-hidden="true">#</a> 2.联合索引不满足列的最左匹配原则</h4><p>执行以下语句，索引生效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> explain select * from user where id_no = &#39;11&#39; and username =&#39;forezp1&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317174329135.png" alt="image-20240317174329135" tabindex="0" loading="lazy"><figcaption>image-20240317174329135</figcaption></figure><p>不符合最左匹配原则，索引失效，索引失效的例子如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where  username =&#39;forezp1&#39; and age =11;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317174731940.png" alt="image-20240317174731940" tabindex="0" loading="lazy"><figcaption>image-20240317174731940</figcaption></figure><h4 id="_3-使用了select-from" tabindex="-1"><a class="header-anchor" href="#_3-使用了select-from" aria-hidden="true">#</a> 3.**使用了select * from **</h4><p>正向例子：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select id,id_no,username from user where   age =11;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317175415040.png" alt="image-20240317175415040" tabindex="0" loading="lazy"><figcaption>image-20240317175415040</figcaption></figure><p>反向例子，索引失效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where   age =11;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317175720245.png" alt="image-20240317175720245" tabindex="0" loading="lazy"><figcaption>image-20240317175720245</figcaption></figure><h4 id="_4-查询条件中使用了函数或者运算" tabindex="-1"><a class="header-anchor" href="#_4-查询条件中使用了函数或者运算" aria-hidden="true">#</a> 4.查询条件中使用了函数或者运算</h4><p>在查询条件中使用了函数或者运算，导致查询字段的索引失效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where id+1=3;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317175928211.png" alt="image-20240317175928211" tabindex="0" loading="lazy"><figcaption>image-20240317175928211</figcaption></figure><h4 id="_5-类型进行了隐式转换" tabindex="-1"><a class="header-anchor" href="#_5-类型进行了隐式转换" aria-hidden="true">#</a> 5. 类型进行了隐式转换</h4><p>id_no字段类型为varchar，在SQL语句中使用了int类型，出现了查询字段的隐式转换。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where id_no=11;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317180303974.png" alt="image-20240317180303974" tabindex="0" loading="lazy"><figcaption>image-20240317180303974</figcaption></figure><h4 id="_6-order-by-在某些情况下会导致索引失效" tabindex="-1"><a class="header-anchor" href="#_6-order-by-在某些情况下会导致索引失效" aria-hidden="true">#</a> 6.order by 在某些情况下会导致索引失效</h4><ul><li>如果查询中的<code>ORDER BY</code> 子句涉及到的列没有相应的索引支持，数据库可能会选择进行全表扫描并进行排序操作，而不使用索引，从而导致索引失效。</li><li>如果数据分布不均匀，可能会导致查询优化器认为使用索引扫描不如全表扫描更有效率，尤其是在排序操作中，这可能导致索引失效。</li><li>如果需要排序的数据量非常大，数据库可能会选择不使用索引而选择临时表排序，以避免在内存中进行大量的排序操作，这种情况下也可能导致索引失效。</li></ul><p>以下order by导致索引失效，一是没有where的索引字段，二是表中数据过少，导致索引失效。</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317180949980.png" alt="image-20240317180949980" tabindex="0" loading="lazy"><figcaption>image-20240317180949980</figcaption></figure><h4 id="_7-使用了两列比较" tabindex="-1"><a class="header-anchor" href="#_7-使用了两列比较" aria-hidden="true">#</a> 7.使用了两列比较</h4><p>以下的执行计划可以看出查询语句会失效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where id &gt; age;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317181559037.png" alt="image-20240317181559037" tabindex="0" loading="lazy"><figcaption>image-20240317181559037</figcaption></figure><h4 id="_8-使用or操作" tabindex="-1"><a class="header-anchor" href="#_8-使用or操作" aria-hidden="true">#</a> 8.使用or操作</h4><p>以下的执行计划可以看出查询语句会失效：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>explain select * from user where id = 2 or username = &#39;forezp1&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/3/17/image-20240317182531564.png" alt="image-20240317182531564" tabindex="0" loading="lazy"><figcaption>image-20240317182531564</figcaption></figure><h4 id="_9-mysql会根据数据量而决定走不走索引" tabindex="-1"><a class="header-anchor" href="#_9-mysql会根据数据量而决定走不走索引" aria-hidden="true">#</a> 9.Mysql会根据数据量而决定走不走索引</h4><p>当Mysql发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描。某些场景下即便强制SQL语句走索引，也同样会失效。</p><h4 id="_10-还有一些可能导致索引失效的场景" tabindex="-1"><a class="header-anchor" href="#_10-还有一些可能导致索引失效的场景" aria-hidden="true">#</a> 10.还有一些可能导致索引失效的场景</h4><p>还有一些场景会导致索引失效，但是不一定，会随着Mysql的版本的不同而有不同的结果。</p><ul><li>not in和not exists可能会导致索引失效，在本文的mysql版本是走索引的。</li><li>is not null可能会导致索引失效，在本文的mysql版本是走索引的。</li><li>不等于比较 &lt;&gt; 可能会导致索引失效，在本文的mysql版本是走索引的。</li></ul><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/common/wxcode.png" alt="方志朋_官方公众号" tabindex="0" loading="lazy"><figcaption>方志朋_官方公众号</figcaption></figure>',62),s=[t];function r(l,c){return i(),a("div",null,s)}const m=e(n,[["render",r],["__file","2024-03-20-index-fail.html.vue"]]);export{m as default};
