import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as p,c as l,a,b as s,d as e,f as o}from"./app-b48bb827.js";const i={},r=o(`<h2 id="什么是threadlocal" tabindex="-1"><a class="header-anchor" href="#什么是threadlocal" aria-hidden="true">#</a> 什么是ThreadLocal</h2><p>ThreadLocal是线程本地变量，它提供了线程本地变量的支持。每个ThreadLocal对象都维护了一个独立的变量副本，每个线程都可以访问自己的副本，对其他线程而言是隔离的。</p><ul><li>使用ThreadLocal，可以为每个线程创建独立的变量副本，每个线程可以通过ThreadLocal对象来获取和设置自己的变量副本，不存在多线程间共享的问题。</li><li>ThreadLocal 提供了线程本地的变量副本。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。</li></ul><p>下图可以增强理解：</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/1/6/image-20240106113729346.png" alt="image-20240106113729346" tabindex="0" loading="lazy"><figcaption>image-20240106113729346</figcaption></figure><h2 id="threadlocal的使用示例" tabindex="-1"><a class="header-anchor" href="#threadlocal的使用示例" aria-hidden="true">#</a> ThreadLocal的使用示例</h2><p>下面是一个简单的示例，演示了如何在多个线程中使用ThreadLocal：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span></span><span class="token class-name">AtomicInteger</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AtomicInteger</span><span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Runnable</span> incrementTask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取当前线程的变量副本</span>
            <span class="token class-name">AtomicInteger</span> value <span class="token operator">=</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 对变量进行操作</span>
            value<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 打印当前线程的变量值</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 清除当前线程的变量副本</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建多个线程并执行任务</span>
        <span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>incrementTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>incrementTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> thread3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>incrementTask<span class="token punctuation">)</span><span class="token punctuation">;</span>

        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，首先创建了一个ThreadLocal对象 <code>threadLocal</code>，初始值为一个AtomicInteger对象。每个线程通过 <code>threadLocal.get()</code> 方法获取自己的变量副本，并进行+1操作。最后，通过 <code>threadLocal.remove()</code> 方法清除变量副本。</p><p>运行示例代码，可以看到每个线程都有自己独立的变量副本，并且执行自己的操作，而不会互相干扰。</p><h2 id="threadlocal原理分析" tabindex="-1"><a class="header-anchor" href="#threadlocal原理分析" aria-hidden="true">#</a> ThreadLocal原理分析</h2><p>在线程的内部有一个变量threadLocals，它是一个ThreadLocal.ThreadLocalMap对象，这个对象是一个定制化的Map，用于存储本地变量的。threadLocals的key需要是ThreadLocal对象，所以一个线程可以存储多个ThreadLocal对象：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ThreadLocalMap是由ThreadLocal维护的静态内部类。在使用ThreadLocal的get()、set()方法时，其实都是调用了线程中threadLocals变量的ThreadLocalMap类对应的get()、set()方法。在调用set方法，首先获取当前线程对象：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后通过getMap方法来获取当前线程中的threadLocals：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果Thread中的threadLocals变量为null，会创建一个ThreadLocalMap并赋值给Thread：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果已经存在，则通过ThreadLocalMap的set方法设置值，这里我们可以看到set中key为this，也就是当前ThreadLocal对象，而value值则是我们要存的值。</p><p>对应的get方法源码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们通过一个流程图来汇总一下上述流程：</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/1/6/image-20240106122058598.png" alt="image-20240106122058598" tabindex="0" loading="lazy"><figcaption>image-20240106122058598</figcaption></figure><h2 id="threadlocal的使用场景" tabindex="-1"><a class="header-anchor" href="#threadlocal的使用场景" aria-hidden="true">#</a> ThreadLocal的使用场景</h2><p>ThreadLocal在多线程编程中有各种使用场景。以下是一些常见的使用场景：</p><ol><li><p>线程安全的对象：使用ThreadLocal可以实现每个线程拥有自己的对象实例，从而避免多线程并发访问时的线程安全问题。比如，在Web开发中，可以使用ThreadLocal来保存每个请求的用户身份信息，以便在处理请求的过程中使用，而不需要在每个方法中传递这些信息。</p></li><li><p>数据库连接管理：在多线程环境下，使用ThreadLocal可以确保每个线程都有自己的数据库连接。这样可以避免多个线程共享同一个数据库连接时的并发问题，同时还可以减少连接的创建和销毁开销。</p></li><li><p>事务管理：在某些情况下，需要在多个方法之间共享事务状态。使用ThreadLocal可以在每个线程中保存事务状态，以便在需要时进行回滚或提交。</p></li><li><p>用户级别的上下文信息：在某些应用场景中，需要将某些用户级别的上下文信息在同一个线程中共享，而不需要在每个方法中显式传递这些信息。ThreadLocal可以用于保存用户的上下文信息。比如Log4j的MDC。</p></li><li><p>缓存管理：ThreadLocal可以用于保存每个线程的缓存实例，以避免多个线程共享同一个缓存实例时的并发问题。</p></li></ol><p>需要注意的是，尽管ThreadLocal可以用于保存线程本地的对象实例，但并不是说所有的情况都适合使用ThreadLocal。在使用ThreadLocal时，需要注意线程安全性、内存泄漏以及资源的释放等问题。</p><h2 id="threadlocal内存泄露" tabindex="-1"><a class="header-anchor" href="#threadlocal内存泄露" aria-hidden="true">#</a> ThreadLocal内存泄露</h2><p>ThreadLocal使用不当可能会出现内存泄露，进而可能导致内存溢出。下面我们就来分析一下内存泄露的原因及相关设计思想。</p><h3 id="内存引用链路" tabindex="-1"><a class="header-anchor" href="#内存引用链路" aria-hidden="true">#</a> 内存引用链路</h3><p>在使用ThreadLocal时，每个线程都会在自己的ThreadLocalMap对象中为该ThreadLocal对象创建一个Entry对象，并将ThreadLocal对象作为key，value为业务需要存储的Object。</p><p>假设ThreadLocal对象被定义为静态变量，那么它的生命周期会与ClassLoader相同，并一直存在于内存中，不会被回收。而每个线程的ThreadLocalMap对象则是随着线程的销毁而销毁，而且ThreadLocalMap的Entry对象是使用ThreadLocal的弱引用作为Key创建的，因此当ThreadLocal对象没有其他强引用指向时，它会被垃圾回收，对应的Entry也会被从ThreadLocalMap中删除。这样，在业务中无需担心内存泄漏的问题。</p><figure><img src="https://static-1254191423.cos.ap-shanghai.myqcloud.com/img/2024/1/6/image-20240106124807435.png" alt="image-20240106124807435" tabindex="0" loading="lazy"><figcaption>image-20240106124807435</figcaption></figure><p>下面我们先来了解一下Java中引用的分类。</p><h3 id="java中的引用" tabindex="-1"><a class="header-anchor" href="#java中的引用" aria-hidden="true">#</a> Java中的引用</h3><p>Java中通常会存在以下类型的引用：强引用、弱引用、软引用、虚引用。</p><ul><li>强引用：通常new出来的对象就是强引用类型，只要引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候；</li><li>软引用：使用SoftReference修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。如果回收之后，还没有足够的内存，才会抛出内存溢出异常；</li><li>弱引用：使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。</li><li>虚引用：虚引用是最弱的引用，在Java中使用PhantomReference进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。</li></ul><h3 id="泄露原因分析" tabindex="-1"><a class="header-anchor" href="#泄露原因分析" aria-hidden="true">#</a> 泄露原因分析</h3><p>正常来说，当Thread执行完会被销毁，Thread.threadLocals指向的ThreadLocalMap实例也随之变为垃圾，它里面存放的Entity也会被回收。这种情况是不会发生内存泄漏的。</p><p><strong>发生内存泄露的场景一般存在于线程池的情况下。此时，Thread生命周期比较长（存在循环使用），threadLocals引用一直存在，当其存放的ThreadLocal被回收（弱引用生命周期比较短）后，对应的Entity就成了key为null的实例，但value值不会被回收。如果此Entity一直不被get()、set()、remove()，就一直不会被回收，也就发生了内存泄漏。</strong></p><p>所以，通常在使用完ThreadLocal后需要调用remove()方法进行内存的清除。</p><p>比如在web请求当中，我们可以通过过滤器等进行回收方法的调用：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public void doFilter(ServeletRequest request, ServletResponse){
    try{
        //设置ThreadLocal变量
        localName.set(&quot;程序新视界&quot;);
        chain.doFilter(request, response)
    }finally{
        //调用remove方法溢出threadLocal中的变量
        localName.remove();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="inheritablethreadlocal-父子线程间的数据共享" tabindex="-1"><a class="header-anchor" href="#inheritablethreadlocal-父子线程间的数据共享" aria-hidden="true">#</a> InheritableThreadLocal 父子线程间的数据共享</h2><p>InheritableThreadLocal是ThreadLocal的一个变种，它允许子线程继承父线程的ThreadLocal变量值。</p><p>ThreadLocal变量通常在一个线程内部使用，并且对其他线程是不可见的。但是有时候，我们希望父线程设置的ThreadLocal变量的值可以被其创建的子线程继承和使用。这就是使用InheritableThreadLocal的场景。</p><p>InheritableThreadLocal和ThreadLocal的使用方式非常相似，可以通过set方法设置变量的值，通过get方法获取变量的值。不同之处在于，InheritableThreadLocal可以在父线程和子线程之间实现变量值的传递。当一个线程创建了一个子线程时，子线程会继承父线程中的InheritableThreadLocal的值。</p><p>InheritableThreadLocal的原理和内部实现与ThreadLocal类似，每个线程都维护一个InheritableThreadLocalMap对象，用于保存线程本地变量的值。当一个线程创建子线程时，子线程会复制父线程的InheritableThreadLocalMap，并继承父线程中的InheritableThreadLocal的值。</p><p>需要注意的是，InheritableThreadLocal并不能解决所有线程间的共享数据问题。它只是提供了一种在父子线程之间传递ThreadLocal变量值的机制，并且对其他线程仍然是不可见的。对于多个线程之间需要共享数据的情况，仍然需要使用其他的线程同步机制，如锁、信号量等。</p><p>使用示例：</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalTest</span> <span class="token punctuation">{</span>

   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String<span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">ThreadLocal<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ThreadLocal<span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">InheritableThreadLocal<span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> inheritableThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">InheritableThreadLocal<span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       threadLocal<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       inheritableThreadLocal<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
           System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ThreadLocal value &quot;</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;InheritableThreadLocal value &quot;</span> <span class="token operator">+</span> inheritableThreadLocal<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//运行结果</span>
ThreadLocal <span class="token keyword">value</span> <span class="token keyword">null</span>
InheritableThreadLocal <span class="token keyword">value</span> <span class="token number">123</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，在子线程中，是可以获取到父线程的 <code>InheritableThreadLocal </code>类型变量的值，但是不能获取到 <code>ThreadLocal </code>类型变量的值。</p><p>获取不到<code>ThreadLocal </code>类型的值，我们可以好理解，因为它是线程隔离的嘛。<code>InheritableThreadLocal </code>是如何做到的呢？原理是什么呢？</p><p>在<code>Thread</code>类中，除了成员变量<code>threadLocals</code>之外，还有另一个成员变量：<code>inheritableThreadLocals</code>。它们两类型是一样的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
   <span class="token class-name">ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token class-name">ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Thread</code>类的<code>init</code>方法中，有一段初始化设置：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ThreadGroup g<span class="token punctuation">,</span> Runnable target<span class="token punctuation">,</span> String name<span class="token punctuation">,</span>
                      long stackSize<span class="token punctuation">,</span> AccessControlContext acc<span class="token punctuation">,</span>
                      <span class="token builtin">boolean</span> inheritThreadLocals<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      
        <span class="token operator">...</span><span class="token operator">...</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>
                ThreadLocal<span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Stash the specified stack size in case the VM cares */</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>stackSize <span class="token operator">=</span> stackSize<span class="token punctuation">;</span>

        <span class="token comment">/* Set thread ID */</span>
        tid <span class="token operator">=</span> <span class="token function">nextThreadID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token keyword">static</span> ThreadLocalMap <span class="token function">createInheritedMap</span><span class="token punctuation">(</span>ThreadLocalMap parentMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span>parentMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现，当<code>parent的inheritableThreadLocals</code>不为<code>null</code>时，就会将<code>parent</code>的<code>inheritableThreadLocals</code>，赋值给前线程的<code>inheritableThreadLocals</code>。说白了，就是如果当前线程的<code>inheritableThreadLocals</code>不为<code>null</code>，就从父线程哪里拷贝过来一个过来，类似于另外一个<code>ThreadLocal</code>，但是数据从父线程那里来的。</p><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>`,60),d={href:"https://heapdump.cn/article/2591416",target:"_blank",rel:"noopener noreferrer"},u={href:"https://juejin.cn/post/7126708538440679460",target:"_blank",rel:"noopener noreferrer"};function k(h,v){const n=c("ExternalLinkIcon");return p(),l("div",null,[r,a("p",null,[a("a",d,[s("https://heapdump.cn/article/2591416"),e(n)])]),a("p",null,[a("a",u,[s("https://juejin.cn/post/7126708538440679460"),e(n)])])])}const T=t(i,[["render",k],["__file","2024-01-06-threadlocal.html.vue"]]);export{T as default};
