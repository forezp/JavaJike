const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":200,\"nextId\":200,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#更新计划\",\"2\":\"v-8daa1a0e#更新计划-1\",\"3\":\"v-2e3eac9e\",\"4\":\"v-1473bf53\",\"5\":\"v-1473bf53#目录\",\"6\":\"v-1473bf53@0\",\"7\":\"v-4e65ec78\",\"8\":\"v-4e65ec78@0\",\"9\":\"v-4e65ec78@1\",\"10\":\"v-c151bf32\",\"11\":\"v-c151bf32@0\",\"12\":\"v-c151bf32@1\",\"13\":\"v-438ffe52\",\"14\":\"v-438ffe52#markdown-介绍\",\"15\":\"v-438ffe52#markdown-配置\",\"16\":\"v-438ffe52#markdown-扩展\",\"17\":\"v-438ffe52#vuepress-扩展\",\"18\":\"v-438ffe52#主题扩展\",\"19\":\"v-438ffe52#自定义容器\",\"20\":\"v-438ffe52#代码块\",\"21\":\"v-438ffe52#上下角标\",\"22\":\"v-438ffe52#自定义对齐\",\"23\":\"v-438ffe52#attrs\",\"24\":\"v-438ffe52#脚注\",\"25\":\"v-438ffe52#标记\",\"26\":\"v-438ffe52#任务列表\",\"27\":\"v-438ffe52#图片增强\",\"28\":\"v-438ffe52#卡片\",\"29\":\"v-438ffe52#图表\",\"30\":\"v-438ffe52#echarts\",\"31\":\"v-438ffe52#流程图\",\"32\":\"v-438ffe52#mermaid\",\"33\":\"v-438ffe52#tex-语法\",\"34\":\"v-438ffe52#导入文件\",\"35\":\"v-438ffe52#代码演示\",\"36\":\"v-438ffe52#样式化\",\"37\":\"v-438ffe52#交互演示\",\"38\":\"v-438ffe52#vue-交互演示\",\"39\":\"v-438ffe52#幻灯片\",\"40\":\"v-438ffe52@0\",\"41\":\"v-438ffe52@1\",\"42\":\"v-6e19edb7\",\"43\":\"v-6e19edb7#页面信息\",\"44\":\"v-6e19edb7#页面内容\",\"45\":\"v-6e19edb7#页面结构\",\"46\":\"v-6e19edb7@0\",\"47\":\"v-6e19edb7@1\",\"48\":\"v-fffb8e28\",\"49\":\"v-fffb8e28#功能亮点\",\"50\":\"v-fffb8e28#bar\",\"51\":\"v-fffb8e28#foo\",\"52\":\"v-71b3ae87\",\"53\":\"v-71b3ae87#功能亮点\",\"54\":\"v-71b3ae87#bar\",\"55\":\"v-71b3ae87#foo\",\"56\":\"v-5d5821d6\",\"57\":\"v-5d5821d6#介绍\",\"58\":\"v-5d5821d6#详情\",\"59\":\"v-0b6fc5f8\",\"60\":\"v-5d5c2d30\",\"61\":\"v-5d5c2d30#介绍\",\"62\":\"v-5d5c2d30#详情\",\"63\":\"v-177e1f06\",\"64\":\"v-9cffac66\",\"65\":\"v-9cffac66#设计模式有哪些类型\",\"66\":\"v-9cffac66#创建型模式\",\"67\":\"v-9cffac66#结构型模式\",\"68\":\"v-9cffac66#行为型模式\",\"69\":\"v-9cffac66#面试过程中常问的设计模式\",\"70\":\"v-9cffac66#设计模式的几种原则\",\"71\":\"v-1110218a\",\"72\":\"v-1110218a#什么是单例模式\",\"73\":\"v-1110218a#单例模式的实现\",\"74\":\"v-1110218a#饿汉模式-线程安全-推荐\",\"75\":\"v-1110218a#双重检查-线程安全-推荐\",\"76\":\"v-1110218a#使用内部类模式-线程安全-推荐\",\"77\":\"v-1110218a#其他\",\"78\":\"v-1110218a#懒汉模式-线程不安全-不推荐\",\"79\":\"v-1110218a#懒汉模式-线程不安全-不推荐-1\",\"80\":\"v-1110218a#源码下载\",\"81\":\"v-3be12559\",\"82\":\"v-3be12559#代码实现\",\"83\":\"v-3be12559#使用适配器模式有什么收益\",\"84\":\"v-3be12559#源码下载\",\"85\":\"v-4b45c2fc\",\"86\":\"v-4b45c2fc#uml图\",\"87\":\"v-4b45c2fc#使用案例\",\"88\":\"v-4b45c2fc#为什么要使用装饰器模式\",\"89\":\"v-4b45c2fc#源码下载\",\"90\":\"v-7f97107a\",\"91\":\"v-7f97107a#责任链模式的uml图\",\"92\":\"v-7f97107a#案例实战\",\"93\":\"v-7f97107a#为什么要使用责任链模式\",\"94\":\"v-9b0dc620\",\"95\":\"v-9b0dc620#简单工厂\",\"96\":\"v-9b0dc620#uml图\",\"97\":\"v-9b0dc620#代码实现\",\"98\":\"v-9b0dc620#工厂方法模式\",\"99\":\"v-9b0dc620#uml图-1\",\"100\":\"v-9b0dc620#代码实现-1\",\"101\":\"v-9b0dc620#抽象工厂\",\"102\":\"v-9b0dc620#uml图-2\",\"103\":\"v-9b0dc620#代码实现-2\",\"104\":\"v-63d3fd84\",\"105\":\"v-63d3fd84#观察者模式uml图\",\"106\":\"v-63d3fd84#案例实战\",\"107\":\"v-63d3fd84#为什么要使用观察者模式\",\"108\":\"v-a950132e\",\"109\":\"v-a950132e#静态代理\",\"110\":\"v-a950132e#代码实现\",\"111\":\"v-a950132e#动态代理\",\"112\":\"v-a950132e#java-动态代理\",\"113\":\"v-a950132e#cglib代码\",\"114\":\"v-7e340ee0\",\"115\":\"v-7e340ee0#prometheus教程介绍\",\"116\":\"v-69099ac7\",\"117\":\"v-69099ac7#什么是prometheus\",\"118\":\"v-69099ac7#prometheus提供的特性\",\"119\":\"v-69099ac7#组件\",\"120\":\"v-69099ac7#架构\",\"121\":\"v-69099ac7#prometheus适用的场景\",\"122\":\"v-300045a1\",\"123\":\"v-300045a1#安装prometheus\",\"124\":\"v-300045a1#prometheus配置文件讲解\",\"125\":\"v-300045a1#采集node-exporter的指标\",\"126\":\"v-300045a1#prometheus配置文件热更新\",\"127\":\"v-300045a1#grafana安装\",\"128\":\"v-300045a1#总结\",\"129\":\"v-0890d0c6\",\"130\":\"v-0890d0c6#什么是time-series\",\"131\":\"v-0890d0c6#指标的类型\",\"132\":\"v-0890d0c6#counter-累加器\",\"133\":\"v-0890d0c6#gauge仪表盘\",\"134\":\"v-0890d0c6#histogram直方图\",\"135\":\"v-0890d0c6#summary\",\"136\":\"v-40c62e56\",\"137\":\"v-40c62e56#瞬时向量查询-instant-vector-selectors\",\"138\":\"v-40c62e56#范围向量查询-range-vector-selectors\",\"139\":\"v-40c62e56#offset-时间位移操作\",\"140\":\"v-40c62e56#操作符\",\"141\":\"v-40c62e56#数学操作符\",\"142\":\"v-40c62e56#比较操作符\",\"143\":\"v-40c62e56#逻辑运算符\",\"144\":\"v-40c62e56#向量匹配符号-vector-matching\",\"145\":\"v-40c62e56#分组修改器-group-modifiers\",\"146\":\"v-40c62e56#聚合函数\",\"147\":\"v-40c62e56#其他常见的函数\",\"148\":\"v-40c62e56#计算counter的增长率\",\"149\":\"v-40c62e56#预测指标变化趋势\",\"150\":\"v-40c62e56#计算分位数\",\"151\":\"v-40c62e56#总结\",\"152\":\"v-a5f16108\",\"153\":\"v-a5f16108#方案一-使用spring-boot-starter-actuator\",\"154\":\"v-a5f16108#方案二-使用prometheus\",\"155\":\"v-a5f16108#配置prometheus采集\",\"156\":\"v-a5f16108#配置grafana视图\",\"157\":\"v-9930b448\",\"158\":\"v-9930b448#alertmanager介绍\",\"159\":\"v-9930b448#分组\",\"160\":\"v-9930b448#抑制\",\"161\":\"v-9930b448#静默\",\"162\":\"v-9930b448#alertmanager安装\",\"163\":\"v-9930b448#配置讲解\",\"164\":\"v-9930b448#在prometheus中配置告警规则\",\"165\":\"v-9930b448#alertmanager查看告警消息\",\"166\":\"v-9930b448#webhook\",\"167\":\"v-9930b448#参考文档\",\"168\":\"v-012ad836\",\"169\":\"v-012ad836#定义recoding-rules\",\"170\":\"v-012ad836#recording-rule的最佳实践\",\"171\":\"v-012ad836#命名规范\",\"172\":\"v-012ad836#实战\",\"173\":\"v-4d4f79fa\",\"174\":\"v-4d4f79fa#list-接口\",\"175\":\"v-4d4f79fa#set接口\",\"176\":\"v-4d4f79fa#map接口\",\"177\":\"v-4d4f79fa#总结\",\"178\":\"v-879b283a\",\"179\":\"v-879b283a#重载与重写的区别\",\"180\":\"v-879b283a#抽象类和接口的区别\",\"181\":\"v-879b283a#为什么java不支持多继承\",\"182\":\"v-879b283a#string和stringbuffer、stringbuilder的区别是什么\",\"183\":\"v-879b283a#如何理解面向过程和面向对象\",\"184\":\"v-879b283a#java基本类型为什么需要包装类\",\"185\":\"v-879b283a#如何理解java中的多态\",\"186\":\"v-2f0fbf99\",\"187\":\"v-2f0fbf99#谈谈final、finally、finalize的区别\",\"188\":\"v-e4b894f2\",\"189\":\"v-e4b894f2#和-equals-的区别\",\"190\":\"v-e4b894f2#关系操作符号\",\"191\":\"v-e4b894f2#equals\",\"192\":\"v-e4b894f2#equals-和hashcode的关系\",\"193\":\"v-e4b894f2#java中的异常处理机制\",\"194\":\"v-e4b894f2#jdk、jre、jvm的区别和联系\",\"195\":\"v-9e8a134a\",\"196\":\"v-9e8a134a#final关键字的基本用法\",\"197\":\"v-9e8a134a#为什么内部类引用的外部变量必须用final修饰\",\"198\":\"v-9e8a134a#谈谈final、finally、finalize的区别\",\"199\":\"v-9e8a134a#finally语句到底是在return之前还是之后执行\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[6],\"1\":[1,12],\"2\":[1,12],\"3\":[1],\"4\":[1],\"5\":[1,5],\"6\":[null,null,1],\"7\":[1,18],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[1,7],\"11\":[null,null,1],\"12\":[null,null,1],\"13\":[2,11],\"14\":[2,8],\"15\":[2,13],\"16\":[2,11],\"17\":[2,10],\"18\":[1,10],\"19\":[1,19],\"20\":[1,1],\"21\":[1,3],\"22\":[1,3],\"23\":[1,5],\"24\":[1,3],\"25\":[1,3],\"26\":[1,5],\"27\":[1,2],\"28\":[1,23],\"29\":[1,1],\"30\":[1,1],\"31\":[1,1],\"32\":[1,1],\"33\":[2,10],\"34\":[1,6],\"35\":[1,1],\"36\":[1,5],\"37\":[1,1],\"38\":[2,1],\"39\":[1,3],\"40\":[null,null,1],\"41\":[null,null,1],\"42\":[1,3],\"43\":[1,20],\"44\":[1,17],\"45\":[1,16],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1],\"49\":[1],\"50\":[1,2],\"51\":[1,2],\"52\":[1],\"53\":[1],\"54\":[1,2],\"55\":[1,2],\"56\":[2],\"57\":[1,4],\"58\":[1,2],\"59\":[1,2],\"60\":[2],\"61\":[1,4],\"62\":[1,2],\"63\":[1,2],\"64\":[1,35],\"65\":[2,8],\"66\":[1,21],\"67\":[1,19],\"68\":[1,43],\"69\":[1,21],\"70\":[1,62],\"71\":[1],\"72\":[1,22],\"73\":[1,12],\"74\":[4,29],\"75\":[4,59],\"76\":[4,28],\"77\":[1,4],\"78\":[4,17],\"79\":[4,20],\"80\":[1,15],\"81\":[1,34],\"82\":[1,49],\"83\":[1,31],\"84\":[1],\"85\":[1,17],\"86\":[1,32],\"87\":[1,155],\"88\":[2,24],\"89\":[1],\"90\":[1,8],\"91\":[1,13],\"92\":[1,88],\"93\":[1,41],\"94\":[1],\"95\":[1,10],\"96\":[1,14],\"97\":[1,65],\"98\":[1,10],\"99\":[1,19],\"100\":[1,49],\"101\":[1,15],\"102\":[1,18],\"103\":[1,64],\"104\":[1,8],\"105\":[1,29],\"106\":[1,71],\"107\":[1,33],\"108\":[1,18],\"109\":[1,27],\"110\":[1,43],\"111\":[1,4],\"112\":[2,91],\"113\":[1,108],\"114\":[1],\"115\":[1,14],\"116\":[1],\"117\":[1,22],\"118\":[1,29],\"119\":[1,23],\"120\":[1,30],\"121\":[1,41],\"122\":[1,12],\"123\":[1,37],\"124\":[1,125],\"125\":[2,52],\"126\":[1,17],\"127\":[1,65],\"128\":[1,10],\"129\":[1],\"130\":[2,79],\"131\":[1,41],\"132\":[2,23],\"133\":[1,25],\"134\":[1,66],\"135\":[1,47],\"136\":[1,15],\"137\":[5,55],\"138\":[5,37],\"139\":[2,18],\"140\":[1],\"141\":[1,53],\"142\":[1,20],\"143\":[1,16],\"144\":[3,21],\"145\":[3,46],\"146\":[1,88],\"147\":[1],\"148\":[1,46],\"149\":[1,23],\"150\":[1,51],\"151\":[1,13],\"152\":[1,7],\"153\":[5,106],\"154\":[2,172],\"155\":[1,15],\"156\":[1,22],\"157\":[1,37],\"158\":[1,10],\"159\":[1,16],\"160\":[1,7],\"161\":[1,15],\"162\":[1,66],\"163\":[1,145],\"164\":[1,78],\"165\":[1,8],\"166\":[1,84],\"167\":[1,27],\"168\":[3,9],\"169\":[2,56],\"170\":[2,5],\"171\":[1,69],\"172\":[1,46],\"173\":[2,58],\"174\":[2,122],\"175\":[1,89],\"176\":[1,113],\"177\":[1,13],\"178\":[1],\"179\":[1,94],\"180\":[1,185],\"181\":[1,34],\"182\":[2,46],\"183\":[1,35],\"184\":[1,67],\"185\":[1,77],\"186\":[1],\"187\":[3],\"188\":[1],\"189\":[5,8],\"190\":[3,81],\"191\":[2,78],\"192\":[3,78],\"193\":[1,122],\"194\":[3,48],\"195\":[1],\"196\":[1,99],\"197\":[1,52],\"198\":[3,55],\"199\":[2,95]},\"averageFieldLength\":[1.4055563241106719,31.15287159629246,0.49126766091051804],\"storedFields\":{\"0\":{\"h\":\"方志朋,Java,Spring,Spring Boot,Spring Cloud,Java后端技术\"},\"1\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"2\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"3\":{\"h\":\"幻灯片页\"},\"4\":{\"h\":\"主要功能与配置演示\"},\"5\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"6\":{\"c\":[\"使用指南\"]},\"7\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"禁用\"]},\"10\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"11\":{\"c\":[\"使用指南\"]},\"12\":{\"c\":[\"文章加密\"]},\"13\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"14\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"15\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"16\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"17\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"18\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"19\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"20\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"23\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"24\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"25\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"26\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"27\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"28\":{\"h\":\"卡片\",\"t\":[\"title: Mr.Hope desc: Where there is light, there is hope logo: https://mister-hope.com/logo.svg link: https://mister-hope.com color: rgba(253, 230, 138, 0.15) \",\"查看详情\"]},\"29\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"30\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"31\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"32\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"33\":{\"h\":\"Tex 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"34\":{\"h\":\"导入文件\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\",\"查看详情\"]},\"35\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"36\":{\"h\":\"样式化\",\"t\":[\"向 Mr.Hope 捐赠一杯咖啡。 \",\"查看详情\"]},\"37\":{\"h\":\"交互演示\",\"t\":[\"查看详情\"]},\"38\":{\"h\":\"Vue 交互演示\",\"t\":[\"查看详情\"]},\"39\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"40\":{\"c\":[\"使用指南\"]},\"41\":{\"c\":[\"Markdown\"]},\"42\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"43\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"44\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"45\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"46\":{\"c\":[\"使用指南\"]},\"47\":{\"c\":[\"页面配置\",\"使用指南\"]},\"48\":{\"h\":\"指南\"},\"49\":{\"h\":\"功能亮点\"},\"50\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"51\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"52\":{\"h\":\"指南\"},\"53\":{\"h\":\"功能亮点\"},\"54\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"55\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"56\":{\"h\":\"Foo 功能\"},\"57\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"58\":{\"h\":\"详情\",\"t\":[\"ray\",\"...\"]},\"59\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"60\":{\"h\":\"Bar 功能\"},\"61\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"62\":{\"h\":\"详情\",\"t\":[\"baz\",\"...\"]},\"63\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"64\":{\"h\":\"设计模式面试概述\",\"t\":[\"设计模式是软件开发的一种指导思想，它是为了解决具体的编码问题或者是解决某一类问题而产生的。这些年无论是生产环境遇到的事故，还是自己自己做的一些开源项目中，越来越体会到系统是运营出来的，代码质量是设计出来的。无论是在前期的需求分析、方案设计、代码编写，都需要良好的程序设计，这些都离不开设计模式的思想。所以设计模式是程序员的一项基本功。\",\"那么如何学习好设计模式呢，我觉得需要刻意练习，说的简单一点就是多写、多练、多应用。\",\"这些年技术层出不穷，新的框架、新的工具、新的软件开发模式，都会让程序员在技术的海洋里迷失。无论面对什么的环境，我们需要有一些专注力，刻意的去练习、要深挖技术背后的原因，要做到知其然并知其所以然。不能东一榔头西一棒槌，这样只会原地踏步走。\",\"那本系列教程将会讲述23种经典的设计模式，有两个目标：\",\"优先讲解面试过程中常见遇到的几种设计模式；剩下的设计模式会在写完Java面试系列文章之后做为补充。\",\"尽量以通俗易懂的语言和代码案例去讲述。\"]},\"65\":{\"h\":\"设计模式有哪些类型？\",\"t\":[\"设计模式可以分为三种类型，分别是创建性型设计模式、结构型设计模式和行为型设计模式。每种类型的设计模式又包含了多种设计模式，总共有23种设计模式，如图所示：\",\"image-20231112200737983\"]},\"66\":{\"h\":\"创建型模式\",\"t\":[\"创建型设计模式，用于解耦对象的实例化过程，用于对象的实例化，包含了5种设计模式，在实际的开发过程中是应用非常多的：\",\"单列模式：某个类在全局只有一个实例对象，提供一个全局的访问点。\",\"创建者模式：封装对象的创建过程，可以按照方法去构造对象。\",\"工厂方法模式：它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成\",\"抽象工厂模式：它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\",\"原型模式：通过复制原有的实例来创建新的实例。\"]},\"67\":{\"h\":\"结构型模式\",\"t\":[\"结构型设计模式是多个对象实例的结合或者组装，形成一个更大的对象。\",\"装饰器模式：装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能。\",\"代理模式：将对象的访问控制和代码运行位置转移到代理对象中。\",\"享元模式：通过共享对象池技术，共享对象。\",\"适配器模式：将类的接口转换为客户期望的另一个接口\",\"外观模式：提供统一的方法来访问内部子系统。\",\"桥接模式：将抽象部分和实现部分分离，使它们都可以独立\",\"组合模式：将对象组合成树形结构以表示整个部分的层次结构。\"]},\"68\":{\"h\":\"行为型模式\",\"t\":[\"类和对象如何交互，及划分责任和算法。\",\"策略模式：定义一系列算法，封装每个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化。\",\"模板模式：在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。\",\"命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。\",\"迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。\",\"观察者模式：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。\",\"中介者模式：中介者对象封装了一组对象之间的交互，这组对象会将它们的交互委托给中介者对象，而不是直接交互。\",\"备忘录模式：捕获并外部化对象的内部状态，以便以后可以恢复，所有这些都不会违反封装。\",\"解释器模式：给用于定义语言的语法规则表示，并提供解释器来处理句子中的语法。\",\"状态模式：状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",\"责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。\",\"访问者模式：访问者模式是以行为（某一个操作）作为扩展对象功能的出发点，在不改变已有类的功能的前提下进行批量扩展。\"]},\"69\":{\"h\":\"面试过程中常问的设计模式\",\"t\":[\"设计模式有23种，每种设计模式有非常多的应用，能够熟练使用设计模式，可以极大程度的提高我们写代码的质量。熟练使用23种设计模式是高阶程序员必须掌握的技能。\",\"在面试过程中，面试官不会考察每一种设计模式，笔者作为多年面试官，一般常见的考察的面试模式如下：\",\"单例模式\",\"工厂方法模式\",\"抽象工厂模式\",\"装饰器模式\",\"适配器模式\",\"责任链模式\",\"代理模式\",\"观察者模式\",\"掌握好以上的几种设计模式，应对面试应该是足够的，在接下来的文章中会逐步讲解这几种设计模式。\"]},\"70\":{\"h\":\"设计模式的几种原则\",\"t\":[\"面向对象有个SOLID原则，而设计模式是基于对象实例的，基本上也遵循SOLID 原则。这个原则在面试过程中会经常被问到。\",\"S（Single Responsibility Principle，简称 SRP）：单一职责原则，该类的职责是唯一的，这个职责是唯一引起该类变化的原因。\",\"O（Open–Closed Principle，简称 OCP）：开闭原则，对于扩展是开放的，对于修改是封闭的。\",\"L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。里氏代换原则是继承复用的基石，只有当子类可以替换基类，软件功能在不受影响时，基类功能可以被复用，而子类也能够在基类的基础上增加新的行为。\",\"I（Interface Segregation Principle，简称 ISP）：接口隔离原则，接口互相隔离，一个类对另一个类的依赖应该建立在最小的接口范围内。\",\"D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\",\"除了以上的SOLID 原则，面向对象还有以下的基本原则：\",\"迪米特法则：又被叫做最小知识原则，就是一个对象应该尽量对外少暴露，对象之间尽量少了解。\",\"组合优先原则：在复用代码时，要尽量先使用组合关系来实现，其次才考虑使用继承关系来实现。它和里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。\"]},\"71\":{\"h\":\"单例模式\"},\"72\":{\"h\":\"什么是单例模式\",\"t\":[\"单例模式在允许在全局中只存在一个实例，并提供一个方法，让其他的对象可以访问这个实例。单例模式可以解决一个全局的使用的实例，防止它频繁的被创建或者被销毁，从而提高整个系统的性能。单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的。\",\"在什么样的场景会使用到单列模式呢？\",\"需要表示全局唯一的对象，比如id生成器，比如工具类，或者访问资源配置文件的reader。这些对象一般只提供具体的方法、不提供全局的共享变量。在系统中只需要初始化一个实例，就能够提供给其他对象在各个地方使用。\",\"使用单例模式有什么好处呢？\",\"可以节约系统的资源，防止对象的频繁创建\",\"提升代码的复用性\",\"统一全局的访问点控制，方便统一管理和修改\"]},\"73\":{\"h\":\"单例模式的实现\",\"t\":[\"如下图的UML图，单例模式声明了一个名为 instance 的静态对象和 get­Instance() 的方法，静态对象用来存储对象自身的属性和方法，静态方法用来返回其所属类的一个相同实例。这里我们以单例模式经典的懒汉式初始化方式为例，其代码实现如下：\",\"image-20231030213851667\"]},\"74\":{\"h\":\"饿汉模式（线程安全，推荐）\",\"t\":[\"单例模式不需要对外提供构造方法，只允许通过getInstance()方法获取实例，在下面的案例中，会在程序的类的加载过程中，自动创建hugryInstance的静态实例，然后getInstance()去提供获取对象的服务。这种模式是在类加载的时候就完成了对象的实例化，类加载是加锁的，所以它是线程安全的。这种模式称为饿汉模式。\",\"饿汉模式类似于Spring框架初始化Bean实例，都是在程序启动之初创建。虽然可能会造成一定资源开销和浪费，但是由于简单、安全，所以还是比较推荐的。\",\"public class HugryInstance { private static HugryInstance hugryInstance = new HugryInstance(); private HugryInstance() { } public static HugryInstance getInstance() { return hugryInstance; } } \"]},\"75\":{\"h\":\"双重检查（线程安全，推荐）\",\"t\":[\"这种双重检查模式经常在面试中被考察，近几年由于八股文泛滥，可能问的少一些。\",\"public class LazyInstance { private static volatile LazyInstance instance; private LazyInstance() { } public static LazyInstance getInstance() { if (instance == null) { synchronized (LazyInstance.class) { if (instance == null) { instance = new LazyInstance(); } } } return instance; } } \",\"双重检查模式，它属于懒汉模式，只有第一次调用getSingleton()方法才会初始化实例instance。\",\"同时它是线程安全的，使用同步代码块来保证线程的安全。\",\"使用双重检查来判断实例是否初始化，减少同步创建实例的开销。\",\"那为什么要使用volatile关键字来修饰静态的instance对象呢？\",\"在java中创建一个对象，需要如下几步，伪代码如下：\",\"memory=allocate(); //1：分配内存空间 ctorInstance(); //2:初始化对象 singleton=memory; //3:设置singleton指向刚分配的内存空间 \",\"当线程1在执行上面伪代码时，2和3可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以JVM是允许的。如果此时伪代码发生重排序，步骤变为1->3->2，线程1执行到第3步时，线程2调用getsingleton方法，在判断singleton==null时不为null，则返回singleton。但此时singleton并还没初始化完毕，线程2访问的将是个还没初始化完毕的对象。这时程序会出错！\",\"当声明对象的引用为volatile后，伪代码的2、3的重排序在多线程中将被禁止!\"]},\"76\":{\"h\":\"使用内部类模式（线程安全，推荐）\",\"t\":[\"public class InnerClzSingleton { private InnerClzSingleton(){ } public static InnerClzSingleton getSingleton(){ return Inner.instance; } private static class Inner { private static final InnerClzSingleton instance = new InnerClzSingleton(); } } \",\"使用内部类的模式，有以下的优点在：\",\"延迟初始化，属于懒汉模式，需要第一次调用getSingleton()方法，才会初始化内部类。\",\"线程安全，Jvm在执行类的初始化的时候，会进行加锁初始化，在多线程的情况下，也不会频繁创建对象。\",\"所以它属于线程安全的懒汉模式，和双重检查模式一样，但是代码比双重检查模式简洁。\"]},\"77\":{\"h\":\"其他\",\"t\":[\"单例模式除了上面的写法，还有其他的写法，但是不太推荐。\"]},\"78\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是最简单的懒汉模式的单列模式，这种情况下在多线程下是不安全的，可能会同时存在多个实例的创建。\",\"public class LazyInstanceNoSafe { private static LazyInstanceNoSafe instance; private LazyInstanceNoSafe() { } public static LazyInstanceNoSafe getInstance() { if (instance == null) { instance = new LazyInstanceNoSafe(); } return instance; } } \"]},\"79\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是懒汉模式的线程安全的，但是在方法上加了锁，在访问的时候需要锁占用，会导致一定的资源开销和性能下降。此种模式是不推荐的。\",\"public class LazyInstanceSafe { private static LazyInstanceSafe instance; private LazyInstanceSafe() { } public static synchronized LazyInstanceSafe getInstance() { if (instance == null) { instance = new LazyInstanceSafe(); } return instance; } } \"]},\"80\":{\"h\":\"源码下载\",\"t\":[\"https://github.com/forezp/Java-Labs/tree/main/design-pattern-lab/src/main/java/io/github/forezp/java/design/sington\"]},\"81\":{\"h\":\"适配器模式\",\"t\":[\"今天这一讲，我们主要讲解最常用到的适配器模式。\",\"在程序中，经常需要新的项目中需要对老代码进行适配才能用。适配器模式就是将旧代码和新程序的中间的转换角色。举个现实例子，比如我们的MAC电脑需要连接USB接口的键盘，但是MAC电脑只有typec接口，这时我们需要一个拓展坞，需要把typec接口转换成USB接口，给键盘使用，如图所示：\",\"适配器模式的定义是：将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。\",\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解，它的UML图如下所示：\",\"从 UML 图中，我们可以看出适配器模式中包含三个关键角色：\",\"目标类Target， 适配器类即将要进行适配的抽象类或接口，比如TypeC接口；\",\"适配器类Adapter，是作为适配的中间类，它必须持有或者实现目标类和适配类的接口，比如拓展坞类实现了目标接口TypeC接口，持有适配者的类Keyboard；\",\"需要被适配器转换的对象 Adaptee, 比如图中的键盘（实现了USB接口）。\"]},\"82\":{\"h\":\"代码实现\",\"t\":[\"需要被适配的接口USB接口：\",\"public interface IUsb { void connect(int x, int y); } \",\"需要被适配的接口的实现类，比如案例中Keyboard：\",\"public class Keyboard implements IUsb{ @Override public void connect(int x, int y) { System.out.println(\\\"keyborad 连上了usb接口\\\"); } } \",\"目标接口ITypeC：\",\"public interface ITypeC { void connect(int x, int y,int z); } \",\"ExpansionDockAdapter（拓展坞适配器）实现了ITypeC的目标接口接口，ExpansionDockAdapter并持有需要被适配的IUsb接口，适配器只有同时实现或者持有目标接口和被适配的对象，才能进行适配工作：\",\"public class ExpansionDockAdapter implements ITypeC{ private IUsb iUsb; public ExpansionDockAdapter(IUsb iUsb) { this.iUsb = iUsb; } @Override public void connect(int x, int y, int z) { System.out.println(\\\"拓展坞将Typec接口转换成USB接口\\\"); iUsb.connect(x,y); } } \",\"最后，可以调用客户端对它们调用：\",\"public class McClient { public static void main(String[] args) { Keyboard keyboard = new Keyboard(); ExpansionDockAdapter adapter = new ExpansionDockAdapter(keyboard); System.out.println(\\\"mac连接typec\\\"); adapter.connect(1, 2, 3); } } \"]},\"83\":{\"h\":\"使用适配器模式有什么收益\",\"t\":[\"可能有很多人比较疑惑，如果在目标类中，新写一个方法就可以将需要适配的类进行转换。那么为什么还需要使用适配器模式呢？\",\"首先 ，是为了保持简单性，正如mac电脑一样，它只提供TypeC接口。由拓展坞去做USB或者是HDMI接口的转换。保证了MAC电脑对外接口的简单性。\",\"单一职责，不同的角色做不同的事，没有必要将多个事情给一个角色做完，这样代码会非常的臃肿，难以维护。\",\"可复用，将适配器这个角色进行高度抽象化，可以做到移植可复用\",\"使用适配器模式有以下的优点：\",\"将目标类和适配的类解耦，引入一个适配器类兼容现有目标类，拓展新的适配者类功能，很好的避免了现有类和适配者类的耦合。\",\"单一职责，目标类和适配者类各司其职，互不干扰。\",\"满足里氏替换原则。 目标类和适配者类是通过适配器进行交互的，适配器类只要不影响目标类的接口功能，适配者类无论出现什么新功能，都很方便替换。\"]},\"84\":{\"h\":\"源码下载\"},\"85\":{\"h\":\"装饰器模式\",\"t\":[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能，相当于对原有的类进行类一个包装，它又称为包装器模式。\",\"在Java的IO源码中，使用到了包装器模式，比如在以下的代码中，BufferedReader和FileReader都是使用到包装器模式，各种Reader一层套一层，进行数据的转换或者功能的增强。\",\" fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); \"]},\"86\":{\"h\":\"UML图\",\"t\":[\"image-20231102232111957\",\"上图是装饰器的UML图，在图中一共有三个角色：\",\"组件Component，它是目标接口，定义目标的方法\",\"组件实现类ComponentImpl，它实现了目标接口\",\"装饰器ComponentDecoratorB和ComponentDecoratorA \",\"ComponentDecoratorB，它实现了目标接口，并持有组件实现类ComponentImpl\",\"ComponentDecoratorA，它实现了目标接口，并持有装饰器ComponentDecoratorB\",\"ComponentImpl提供基本的实现方法，在不改变了ComponentImpl的情况下，ComponentDecoratorB和ComponentDecoratorA分别对ComponentImpl进行了增强。\",\"什么时候使用装饰器模式\",\"一般来讲，装饰模式不改变原有类的结构，是不能改变原有的基础功能，只能在原有的基础功能之上做进一步增强。一般情况下，装饰器模式经常使用到以下场景：\",\"一个组件可以有很多个装饰器，不同的装饰器有不同的功能，可以按照需要使用不同装饰器组合。在扩展性上，装饰器非常的灵活。\",\"原有的类不支持继承，比如使用类final关键字的类。\"]},\"87\":{\"h\":\"使用案例\",\"t\":[\"在案例模仿JavaIO的文件流的写入和读取功能，在文件流的基础之上使用装饰器模式，做下面的增强功能：\",\"加密装饰器：对写入文件的字符的加密，对读取的字符进行解密\",\"压缩解压装饰器：对写入字符进行压缩，对读取的字符进行解压\",\"可以通过顺序组合包装的方式来附加扩张功能，比如可以先使用加密装饰器，后使用压缩解压装饰器；也可以把他们的顺序对调。\",\"首先，定义一个目标接口ReaderWriter，它有读取和写入的功能：\",\"public interface ReaderWriter { String read(); void write(String content); } \",\"ReaderWriter的基本实现类是FileReaderWriter，它可以把字符写入到文件中，也可以读取文件的字符。\",\"public class FileReaderWriter implements ReaderWriter { private String filePath; public FileReaderWriter(String filePath) { this.filePath = filePath; } @Override public String read() { StringBuilder sb = new StringBuilder(); File file = new File(filePath); BufferedReader bufferedReader = null; FileReader fileReader = null; try { fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); String s; while ((s = bufferedReader.readLine()) != null) { sb.append(s); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } if (bufferedReader != null) { bufferedReader.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } @Override public void write(String content) { File file = new File(filePath); FileWriter fileWriter = null; BufferedWriter bufferedWriter = null; try { fileWriter = new FileWriter(file); bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(content); bufferedWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileWriter != null) { fileWriter.close(); } if (bufferedWriter != null) { bufferedWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"EncryptionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行加密\",\"在读取文件的字符之后 ，对读取的字符进行解密\",\"public class EncryptionFileReaderWriter implements ReaderWriter{ private ReaderWriter readerWriter; public EncryptionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decode(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(encode(content)); } private String encode(String data) { byte[] result = data.getBytes(); for (int i = 0; i < result.length; i++) { result[i] += (byte) 1; } return Base64.getEncoder().encodeToString(result); } private String decode(String data) { byte[] result = Base64.getDecoder().decode(data); for (int i = 0; i < result.length; i++) { result[i] -= (byte) 1; } return new String(result); } } \",\"CompressionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行压缩\",\"在读取文件的字符之后 ，对读取的字符进行解压\",\"public class CompressionFileReaderWriter implements ReaderWriter { private ReaderWriter readerWriter; public CompressionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decompress(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(compress(content)); } private String compress(String stringData) { byte[] data = stringData.getBytes(); try { ByteArrayOutputStream bout = new ByteArrayOutputStream(512); DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater()); dos.write(data); dos.close(); bout.close(); return Base64.getEncoder().encodeToString(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } private String decompress(String stringData) { byte[] data = Base64.getDecoder().decode(stringData); try { InputStream in = new ByteArrayInputStream(data); InflaterInputStream iin = new InflaterInputStream(in); ByteArrayOutputStream bout = new ByteArrayOutputStream(512); int b; while ((b = iin.read()) != -1) { bout.write(b); } in.close(); iin.close(); bout.close(); return new String(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } } \",\"写一个客户端测试类：\",\"定义一个写入的字符串text\",\"定义文件的写入或者读取的路径\",\"然后使用装饰器模式，嵌套了两个装饰器（加减密装饰器和压缩解缩的装饰器），对写入的字符进行先加密再压缩；对读取的字符进行先解压再解密。\",\"具体实现如下：\",\"public class Client { public static void main(String[] args) { String text = \\\"fangzhipeng.com\\\"; String filePath=\\\"/Users/forezp/Downloads//test.txt\\\"; System.out.println(\\\"原始内容：\\\"+text); ReaderWriter rw = new CompressionFileReaderWriter(new EncryptionFileReaderWriter(new FileReaderWriter(filePath))); rw.write(text); FileReaderWriter fileReaderWriter=new FileReaderWriter(filePath); // System.out.println(\\\"加密后、压缩后的内容为：\\\"+fileReaderWriter.read()); System.out.println(\\\"解密后、解缩后的内容为：\\\"+rw.read()); } } \",\"执行测试类，控制台打出的结果如下：\",\"原始内容：fangzhipeng.com 加密后、压缩后的内容为：Zkt5TVQ5eU1zOXNKTUZrT1Q6ZU17dDlHQkVFSENnOT4= 解密后、解缩后的内容为：fangzhipeng.com\",\"Process finished with exit code 0\"]},\"88\":{\"h\":\"为什么要使用装饰器模式？\",\"t\":[\"在讲解完具体案例后，我们来思考一下，为什么要使用装饰器模式，主要原因：\",\"能够快速的扩展现有类的功能，并能自由组合包装各种装饰器，达到不同的效果，也就是能够根据需求，快速的装载和卸载装饰器\",\"希望继承原有类的功能，但又不方便继承。\",\"使用装饰器模式有以下的优点：\",\"代码的可扩展性和可复用性非常的强，对一些基础类无法修改，需要扩展功能的时候，采用装饰器模式能够快速的扩展功能，同时有不会影响原有的公民\",\"满足单一职责的原则。基本功能实现类和不同的装饰器只实现自己的独一的功能，后面加一些功能，可以增加新的装饰器。\",\"可以快速装载和卸载增强功能\",\"可以快速组合，通过包装不同的装饰器组合来满足自己的业务需求\"]},\"89\":{\"h\":\"源码下载\"},\"90\":{\"h\":\"责任链模式\",\"t\":[\"责任链模式在软件开发中，是会经常使用到的一个设计模式，比如对某一次请求进行不同的规则的校验，这些规则的执行有先后顺序，组成了链式的执行顺序。\",\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理。这些在流水线的处理类对象构成了一个单项链表结构。\"]},\"91\":{\"h\":\"责任链模式的UML图\",\"t\":[\"从该UML中中，责任链模式有两个角色：\",\"处理类Handler，可以是一个接口，也可以是一个抽象类。它有一个核心的处理方法，比如handle_request();\",\"处理类的实现类HandlerA、HandlerB、HandlerC，这几个Handler构成了一个链式的处理顺序。\"]},\"92\":{\"h\":\"案例实战\",\"t\":[\"在工作中，我们经常有一些审批流程，现在使用责任链模式去模拟一个向公司借款的流程。在流程中有三个角色，分别是员工、经历、CFO三个角色，根据借款金额的不同，需要不同的审批角色。\",\"当借款金额小于1000元，只需要财务审批\",\"当借款金额大于1000元小于5000元，需要经理审批\",\"当借款金额大于5000元小于10000元，需要CFO审批\",\"当借款金额大于10000元，审批拒绝。\",\"首先创建一个审批抽象类Aproval，有一个核心的抽象处理方法handle(int amount)和持有一个Aproval对象。\",\"public abstract class Aproval { private Aproval nextApproval; public abstract void handle(int amount); public Aproval getNextApproval() { return nextApproval; } public void setNextApproval(Aproval nextApproval) { this.nextApproval = nextApproval; } } \",\"Staff（财务）继承了Aproval，并实现了handle(int amount)方法，里面有具体的处理逻辑，它只能审批1000元以下的借款。\",\"public class Staff extends Aproval { @Override public void handle(int amount) { if(amount<1000){ System.out.println(\\\"审批通过\\\"); }else { System.out.println(\\\"财物权限不够，需要经理审批\\\"); getNextApproval().handle(amount); } } } \",\"Manager继承了Aproval，并实现了handle(int amount)方法，它能审批5000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class Manager extends Aproval { @Override public void handle(int amount) { if (amount < 5000) { System.out.println(\\\"经理审批通过\\\"); } else { System.out.println(\\\"经理权限不够，需要总裁审批\\\"); getNextApproval().handle(amount); } } } \",\"CFO继承了Aproval，并实现了handle(int amount)方法，它能审批10000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class CFO extends Aproval { @Override public void handle(int amount) { if (amount < 10000) { System.out.println(\\\"cfo审批通过\\\"); } else { System.out.println(\\\"金额太大，审批不通过\\\"); } } } \",\"写一个测试类，将三个审批角色组成一个责任链模式的审批流，并向审批流的第一角色handle(9000)：\",\"public class Client { public static void main(String[] args) { Staff staff = new Staff(); Manager manager = new Manager(); CFO cfo = new CFO(); staff.setNextApproval(manager); manager.setNextApproval(cfo); staff.handle(9000); } } \",\"运行代码处理结果如下：\",\"财物权限不够，需要经理审批 经理权限不够，需要总裁审批 cfo审批通过\"]},\"93\":{\"h\":\"为什么要使用责任链模式\",\"t\":[\"从上面的使用场景，我们可以得出以下的一些结论，使用责任链的原因有：\",\"使用责任链模式可以将一个大而复杂的判断逻辑，分成多个小的逻辑单元，每个逻辑单元组成了链中的一环。每个逻辑单元的功能都是解藕的。\",\"可以动态的扩展责任链中的逻辑单元，当需要扩展新的功能，可以写一个Handler即可\",\"也可以根据需求快速的删除一些逻辑单元，并且可以根据需要快速的组合逻辑单元\",\"从上面的分析原因我们可以得出，使用责任链有以下的优点：\",\"降低逻辑单元之间的耦合度，不同的逻辑单元的处理逻辑不耦合，提高了系统的灵活性和可维护性。\",\"提升代码的可扩展性，可以快速的装载和卸载逻辑单元，提供整个责任链的可扩展性。可以根据不同的需求，制定不同的处理流程，而且不需要修改现有的代码\",\"符合开闭原则：责任链模式将处理逻辑放在链式的逻辑单元中处理，新增一个逻辑功能，并不需要改变原有的逻辑功能\",\"可以灵活的控制责任链中逻辑单元的处理顺序\",\"总之，责任链模式可以提供一种灵活、可扩展和可维护的链式处理的机制，使系统能够更好地应对变化和复杂性。但需要防止责任链模式有过多的处理逻辑单元，如果处理链路过长，系统出错，很难去排查，也有可能影响系统的性能。所以我们在实际的使用过程中，需要权衡一下利弊，根据实际的情况做设计和优化。\"]},\"94\":{\"h\":\"工厂模式\"},\"95\":{\"h\":\"简单工厂\",\"t\":[\"简单工厂模式（Simple Factory Pattern）也称为静态工厂方法模式，属于创建型设计模式的一种。简单工厂模式提供一个简单的工厂类，根据传入参数的不同，返回不同类的实例对象。\"]},\"96\":{\"h\":\"UML图\",\"t\":[\"简单工厂包含如下角色：\",\"工厂类（SimpleSofaFactory）:负责创建实例对象的类，提供一个静态工厂方法用于创建不同的产品对象。工厂类根据客户端传入的参数来创建相应的产品对象。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"97\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象产品类（Sofa），它有一个抽象方法getName()和一个具体方法showName()\",\"public abstract class Sofa { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" sofa\\\"); } } \",\"ChineseSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class ChineseSofa extends Sofa { @Override String getName() { return \\\"china\\\"; } } \",\"AmericaSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class AmericaSofa extends Sofa{ @Override String getName() { return \\\"america\\\"; } } \",\"工厂类（SimpleSofaFactory）根据客户端传入的参数来创建相应的产品对象Sofa。\",\"public class SimpleFactory { public Sofa createCoffee(String type) { Sofa sofa = null; if(\\\"us\\\".equals(type)) { sofa = new AmericaSofa(); } else if(\\\"cn\\\".equals(type)) { sofa = new ChineseSofa(); } return sofa; } } \",\"写一个客户端，测试类：\",\"public class Client { public static void main(String[] args) { SimpleFactory factory = new SimpleFactory(); Sofa sofa = factory.createSofa(\\\"cn\\\"); sofa.showName(); } } \",\"运行结果如下：\",\"china sofa\",\"简单工厂模式是一种常见的设计模式，它具有如下的优点：\",\"工厂类包含了必要的逻辑判断，可以根据客户端的需求，动态地实例化具体的产品类。\",\"系统扩展性好，如果需要增加新的产品类，只需要修改工厂类的逻辑判断即可。\",\"那它的缺点是：\",\"工厂类包含了所有产品对象的创建逻辑，导致工厂类的代码会随着产品类型的增多而变得越来越复杂。\",\"违反了单一职责原则（SRP），工厂类负责了两个职责：创建和业务逻辑判断。\"]},\"98\":{\"h\":\"工厂方法模式\",\"t\":[\"工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成。工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题。\"]},\"99\":{\"h\":\"UML图\",\"t\":[\"image-20231105210628018\",\"工厂方法模式包含以下角色：\",\"抽象工厂（IFactory）：定义了一个工厂方法makeSofa()，用于创建产品对象的接口。\",\"具体工厂（ChineseSofaFactory）：实现抽象工厂类中定义的工厂方法makeSofa，返回一个具体的产品对象Sofa。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"100\":{\"h\":\"代码实现\",\"t\":[\"定义一个接口IFactory，它有一个createSofa()的方法：\",\"public interface IFactory { Sofa createSofa(); } \",\"IFactory的具体实现类ChineseSofaFactory：\",\"public class ChineseSofaFactory implements IFactory { @Override public Sofa createSofa() { return new ChineseSofa(); } } \",\"IFactory的具体实现类AmericaSofaFactory：\",\"public class AmericaSofaFactory implements IFactory{ @Override public Sofa createSofa() { return new AmericaSofa(); } } \",\"写一个客户端用于测试：\",\"public class Client { public static void main(String[] args) { IFactory factory=new ChineseSofaFactory(); Sofa sofa =factory.createSofa(); sofa.showName(); } } \",\"上面的测试输出结果：\",\"china sofa\",\"使用工厂方法模式的好处是：\",\"客户端通过抽象工厂来创建产品对象，可以方便地创建出不同的产品对象，而不需要了解具体的实现类。\",\"不同的产品由不同的工厂创建，符合单一职责原则，相对于简单工厂，具体工厂类的代码更加简洁。\",\"具备良好的扩展性，增加新的产品和新的工厂非常容易，无需修改已有代码。\",\"使用工厂方法模式的缺点是：\",\"大量的类：每个具体产品都需要一个具体工厂类来创建，会导致类的数量增加，增加了系统的复杂度。\"]},\"101\":{\"h\":\"抽象工厂\",\"t\":[\"工厂方法模式中考虑的是一类产品的生产，比如sofa的生产，但现实生活中，有很多同类型的产品生产，比如家具厂除了生产沙发，还生产桌子、椅子。\",\"抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\"]},\"102\":{\"h\":\"UML图\",\"t\":[\"抽象工厂的UML图如下：\",\"抽象工厂模式包含以下角色：\",\"抽象工厂（IFurnitureFactory）：定义了一系列可以创建不同产品对象的方法，每个方法对应一个具体产品类的创建方法。\",\"具体工厂（FurnitureFactory ）：实现了抽象工厂接口，负责创建一族相关的具体产品对象。\",\"抽象产品类（Table）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（ChineseTable）：实现了抽象产品类的属性和方法。\"]},\"103\":{\"h\":\"代码实现\",\"t\":[\"抽象产品类（Table），代码如下：\",\"public abstract class Table { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" table\\\"); } } \",\"具体产品类（ChineseTable），代码如下：\",\"public class ChineseTable extends Table{ @Override String getName() { return \\\"china\\\"; } } \",\"抽象工厂（IFurnitureFactory），定义了makeSofa()和makeTable()方法，代码如下：\",\"public interface IFurnitureFactory { Sofa makeSofa(); Table makeTable(); } \",\"具体工厂（FurnitureFactory ）实现了抽象工厂（IFurnitureFactory）中的创建对象的方法：\",\"public class FurnitureFactory implements IFurnitureFactory { @Override public Sofa makeSofa() { return new ChineseSofa(); } @Override public Table makeTable() { return new ChineseTable(); } } \",\"写一个测试类，该类使用抽象工厂模式创建不同的产品对象，代码如下：\",\"public class Client { public static void main(String[] args) { IFurnitureFactory factory = new FurnitureFactory(); Sofa sofa= factory.makeSofa(); Table table= factory.makeTable(); sofa.showName(); table.showName(); } } \",\"运行上面的代码，输出如下：\",\"china sofa china table\",\"抽象工厂模式提供了一种创建一族相关对象的方法，能够实现不同产品族的兼容性和高度可扩展性，它具有以下的优点：\",\"可以创建一系列相关的产品对象，保证了这些对象之间的兼容性。\",\"客户端代码与具体产品的创建实现了解耦\",\"符合开闭原则，新增一族产品时，只需要增加相应的具体产品类和工厂类即可。\",\"同时它具有以下的缺点：\",\"新增产品族、比较困难，需要修改抽象工厂的接口和具体工厂类。\",\"增加系统的复杂性\"]},\"104\":{\"h\":\"观察者模式\",\"t\":[\"观察者模式（Observer Pattern）是一种行为型设计模式，用于对象之间的一对多的依赖关系，当对象发生改变时，所有依赖于它的对象都会收到通知。\"]},\"105\":{\"h\":\"观察者模式UML图\",\"t\":[\"UML图如下：\",\"image-20231107230028268\",\"从UML图上可以得出，在观察者模式中，有以下的角色：\",\"发布者Publisher：或者被称为被观察者，它维护了一个观察者的列表，并可以动态添加观察者或者删除观察者。\",\"观察者Observer：定义了一个接收发布者消息的方法，当发布者发布消息，观察者会执行该方法。\",\"具体主题（Concrete Subject）：具体主题是主题的具体实现，它维护了一个状态，并在状态改变时通知观察者。\",\"具体观察者（Concrete Observer）：具体观察者是观察者的具体实现，它实现了观察者的更新接口，并定义了观察者接收到通知后的具体行为。\",\"观察者模式在软件开发中有非常多的应用，在GUI中应用的比较多，在消息队列的场景有广泛的应用。\"]},\"106\":{\"h\":\"案例实战\",\"t\":[\"写一个观察者接口Observer，它有一个接收通知对象的方法 notify (Object obj);\",\"package io.github.forezp.java.design.obeserver2; public interface Observer { void notify (Object obj); } \",\"Observer接口的实现类ObserverImpl的代码如下：\",\"package io.github.forezp.java.design.obeserver2; public class ObserverImpl implements Observer { private String name; public ObserverImpl(String name) { this.name = name; } @Override public void notify(Object obj) { System.out.println(name+\\\":\\\"+obj.toString()); } } \",\"消息发布者Publisher接口，可以向它注册观察者对象，也可以用它来向观察者发送消息：\",\"package io.github.forezp.java.design.obeserver2; public interface Publisher { void register(Observer observer); void notify(Object o); } \",\"Publisher接口的实现类PublisherImpl，代码如下：\",\"package io.github.forezp.java.design.obeserver2; import java.util.ArrayList; import java.util.List; public class PublisherImpl implements Publisher { private List<Observer> list = new ArrayList<>(); @Override public void register(Observer observer) { list.add(observer); } @Override public void notify(Object o) { for (int i = 0; i < list.size(); i++) { list.get(i).notify(o); } } } \",\"写一个客户端测试类：\",\"package io.github.forezp.java.design.obeserver2; public class Client { public static void main(String[] args) { Publisher publisher=new PublisherImpl(); publisher.register(new ObserverImpl(\\\"observer1\\\")); publisher.register(new ObserverImpl(\\\"observer2\\\")); publisher.notify(\\\"fangzhipeng.com\\\"); } } \",\"运行结果如下：\",\"observer1:fangzhipeng.com observer2:fangzhipeng.com\"]},\"107\":{\"h\":\"为什么要使用观察者模式\",\"t\":[\"观察者模式的核心思想是将观察者对象注册到发布者对象中，发布者对象可以对所有的观察者发送消息，观察者收到消息后可以做出响应。\",\"使用观察者模式有以下的收益：\",\"主题和观察者之间松耦合，使得发布者和观察者互不影响。对象之间关系也比较清晰。可以利用发布者向所有的观察者发送消息。\",\"可扩展性很强，可以动态地添加和删除观察者，灵活性非常高。如果不使用观察者模式来捕获一个被观察对象的属性变化，那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑，这样不仅增加了代码的耦合性，也让代码扩展变得非常困难。\",\"观察者模式符合开闭原则，增加新的观察者，不需要修改已有的代码。\",\"同时，观察者模式也有一些缺点，比如发布者维护的观察者对象是无顺序的，并且发布者发布消息也是无顺序的，如果需要把证消息发送的顺序，需要做更多的工作。此外，过多的观察者会影响性能，需要做性能测试。\",\"综上所述，观察者模式是一种实用并且简单的设计模式，它能够提高系统的可扩展性和灵活性。但是在使用它的时候需要注意它带来的一些缺点，要做一些优化工作。\"]},\"108\":{\"h\":\"代理模式\",\"t\":[\"代理模式和装饰器模式类似，都是在不改变同一个接口功能的前提下，对原有功能的做扩展或者增强。代理模式并没有做类似于装饰器模式多层嵌套，而是采用灵活的单一结构。在Java语言中并支持动态代理，在很多RPC框架、Spring AOP、Spring事务等领域有着广泛的应用。\",\"代理模式是一种结构性模式，它允许将对象的访问控制和代码运行位置转移到代理对象中。类似于中介，代理对象可以控制客户端对真实对象的访问。代理模式常用于对已有功能的增强，比如访问控制、远程调用。\"]},\"109\":{\"h\":\"静态代理\",\"t\":[\"代理模式分为静态代理和动态代码，一般静态代理使用的比较少，而动态代理在各种框架、中间件有着广泛的应用。\",\"静态代理需要手动创建一个代理类，实现被代理对象的接口，并将实际对象的方法调用转发给它。静态代理的优点是简单易懂，但缺点是需要手动创建代理类，对于需要代理的类数量较多或变化频繁的情况下，代码会变得臃肿难以维护。\",\"从上面的 UML 图中，我们可以看出代理模式有三个关键角色：\",\"抽象主题接口类（Subject）：它定义了一些方法。\",\"主题实现类（RealSubject）：实现了抽象接口类（的所有方法\",\"代理类（StaticProxy）：实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。\"]},\"110\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象主题类：\",\"public interface Subject { void operation(); } \",\"主题实现类（RealSubject）的代码如下：\",\"public class RealSubject implements Subject{ @Override public void operation() { System.out.println(\\\"do somthing\\\"); } } \",\"代理类（StaticProxy）实现了抽象主题类，并持有主题实现类的对象，并在主题实现类的对象的operation()方法之前和之后做了功能的增强，具体代码如下：\",\"public class StaticProxy implements Subject{ private RealSubject realSubject; public StaticProxy(RealSubject realSubject) { this.realSubject = realSubject; } @Override public void operation() { System.out.println(\\\"before operation...\\\"); realSubject.operation(); System.out.println(\\\"after operation...\\\"); } } \",\"写一个客户端实现类，代码如下：\",\"public class Client { public static void main(String[] args) { testStatic(); } public static void testStatic() { StaticProxy staticProxy = new StaticProxy(new RealSubject()); staticProxy.operation(); } } \",\"运行代码，输出如下：\",\"before operation... do somthing after operation...\"]},\"111\":{\"h\":\"动态代理\",\"t\":[\"动态代理可以使用 Java 动态代理机制和CGLIB动态代理。\"]},\"112\":{\"h\":\"Java 动态代理\",\"t\":[\"Java 动态代理是在运行时自动生成代理类并将方法调用转发到实际对象。 Java 动态代理的优点是避免了手动创建代理类的麻烦，但缺点是对于一些无法实现接口的类，无法使用动态代理。\",\"Java 动态代理是使用Java的反射机制来实现动态代理。Java提供了java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。\",\"具体使用Java 动态代理的步骤是先实现InvocationHandler接口。和静态代理类似：在这个接口中，需要对真实的代理对象的功能需要做一下加强，它是实现动态代理的关键，代码如下：\",\"public class ProxyHandler implements InvocationHandler { private Object object; public ProxyHandler(Object object){ this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"Before invoke \\\" + method.getName()); method.invoke(object, args); System.out.println(\\\"After invoke \\\" + method.getName()); return null; } } \",\"实现代理如下：\",\"public class Client { /** * jdk动态代理 */ public static void testJdkProxy() { Subject realSubject = new RealSubject(); ProxyHandler handler = new ProxyHandler(realSubject); Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.operation(); } public static void main(String[] args) { testJdkProxy(); } } \",\"运行代码输出：\",\"Before invoke operation do somthing After invoke operation\",\"Java动态代理是基于反射生产的一个代理类，这个代理类本身已经继承了jdk包中的Proxy对象，而Java是不允许多继承的，所以只能实现接口的方式进行代理。\",\"它的优点如下：\",\"Java动态代理不需要任何依赖\",\"灵活性：动态代理可以在运行时动态生成代理类，\",\"可拓展性：可以通过动态代理实现一些横切关注点，比如日志记录、性能监控等，而无需修改原有的代码。\",\"缺点：\",\"性能开销：由于动态代理是在运行时动态生成代理类，相比直接调用实现类的方法，会带来一定的性能开销\",\"功能限制：动态代理只能对接口进行代理，在某些情况下，无法代理实现类的方法。\"]},\"113\":{\"h\":\"CGLIB代码\",\"t\":[\"在pom文件中引入cglib包，代码如下：\",\" <dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> version>3.2.5</version> </dependency> \",\"CGlib代码模式需要实现MethodInterceptor，并在intercept方法中实现真实对象的功能增强，代码如下：\",\"public class CglibProxyFactory implements MethodInterceptor { private Object target;//维护一个目标对象 public CglibProxyFactory(Object target) { this.target = target; } //为目标对象生成代理对象 public Object getProxyInstance() { //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象代理 return en.create(); } @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"开始cglib拦截\\\"); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\\\"结束cglib拦截\\\"); return returnValue; } } \",\"写一个测试类：\",\"public class Client { public static void main(String[] args) { testCglibProxy(); } /** * 测试cglib */ public static void testCglibProxy() { Subject subject = new RealSubject(); Subject proxy = (Subject) new CglibProxyFactory(subject).getProxyInstance(); proxy.operation(); } } \",\"执行结果如下：\",\"开始cglib拦截 do somthing 结束cglib拦截\",\"CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，用于在运行时扩展Java类和实现动态代理。与Java动态代理不同，CGLIB可以代理非接口类型的类。\",\"CGLIB动态代理的优点:\",\"性能高：相比Java动态代理，CGLIB动态代理通常能够提供更好的性能，因为它是通过生成子类来代理目标类，而不是通过实现接口。\",\"功能强大：CGLIB能够代理普通类和接口类，更灵活地满足额外需求，例如代理私有方法、拦截静态方法等。\",\"无需依赖接口：CGLIB动态代理可以代理没有实现任何接口的类，这使得它可以代理更多类型的类，提供更大的灵活性。\",\"CGLIB动态代理的缺点:\",\"需要额外依赖：CGLIB动态代理需要引入额外的库，增加项目的依赖，相比Java动态代理而言更为复杂。\",\"对final方法和final类的限制：CGLIB无法代理final方法和final类。\",\"不支持自身方法调用：CGLIB无法从代理对象中调用自身的方法，这可能会引起无限循环或抛出异常。\"]},\"114\":{\"h\":\"概览\"},\"115\":{\"h\":\"Prometheus教程介绍\",\"t\":[\"本篇文章为系列教程，旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统。所用到开源组件如下：\",\"Prometheus\",\"Grafana\",\"VictoriaMetrics系列\",\"Node-exporter\",\"Alertmanager\",\"Kafka\",\"Flink\",\"最终的技术架构如下：\",\"image-20230830224136440\"]},\"116\":{\"h\":\"Prometheus概述\"},\"117\":{\"h\":\"什么是Prometheus\",\"t\":[\"Prometheus是一个开源的监控系统，提供了数据采集、告警计算、告警管理等一系列工具包，周边生态非常的丰富。\",\"Prometheus受启发于Google的Brogmon监控系统（类似于Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师以开源软件的形式进行研发，并且于2015年对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF(云原生计算基金会)的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。\",\"Prometheus通过时序数据来收集和存储指标。一个时序数据包含了一个时间戳、值和一个或者是多个key-value键值对。\"]},\"118\":{\"h\":\"Prometheus提供的特性\",\"t\":[\"作为新一代的监控系统，Prometheus和传统的监控系统相比，有着非常大的创新。Prometheus让监控从传统的黑盒子监控提升到了白盒监控；不仅可以监控系统的一些状态，也可以深入到进程内部关键点的监控（白盒监控）。\",\"Prometheus提供一些关键的特性：\",\"多维的数据结构，这个数据结构包括一个指标名和一系列的键值对（指标）。\",\"提供了数据查询的Promql，Promql非常的强大和灵活。\",\"提供了单节点和分布式的数据存储方案。也可以使用第三方时序数据去存储，比如influxdb、thanos、victoriaMetrics\",\"时序数据使用http协议采集，通常是pull模式，也可以使用push模式（通过中间层push_gateway）\",\"采集目标可以使用服务发现的方式（比如k8s系统、consul），也可以通过静态的配置去发现采集目标。\",\"可以和开源组件grafana无缝对接。\"]},\"119\":{\"h\":\"组件\",\"t\":[\"Prometheus生态包含了一系列组件，除了Prometheus很多组件是可选的：\",\"Prometheus server是最核心的组件，用来抓取和存储时序数据的。\",\"Client-libraries（sdks）是用来开发应用指标的工具包\",\"Push_gateway是用来短暂存储push类型指标的\",\"exporters是用来暴露或者导出被监控对象的指标的，比如虚拟机、nginx、mysql等\",\"alertmanager是用来管理告警消息的，比如对消息的去重、静默、恢复等管理\",\"还有一系列其他的组件\",\"大多数Prometheus组件都是使用go语言写的，非常容易的打包和部署。\"]},\"120\":{\"h\":\"架构\",\"t\":[\"下图是Prometheus和它周边生态组件的架构图，这些组件构成了一个完整的监控系统：\",\"Prometheus architecture\",\"Prometheus通过pull的方式去周期性（通常15-30s）采集监控对象的指标，健康对象包含： \",\"直接采集的jobs和exporters\",\"也可以是短生命周期的任务推送到pushgateway的指标\",\"监控对象的发现 \",\"可以是k8s的集群的服务发现\",\"也可以是consul\",\"或者静态的配置文件\",\"prometheus发现到监控目标后，会周期性的去采集指标，并将指标存储在主机的磁盘中\",\"通过了内置的告警规则计算，并将告警消息发送给alertmanager\",\"alertmanager提供了对告警消息的管理、去重、静默、分发，可以配置多种分发方式： \",\"比如email\",\"webhook\",\"prometheus提供了http接口的方式让外部第三方访问数据，比如可以将指标数据展示在grafana上。\"]},\"121\":{\"h\":\"prometheus适用的场景\",\"t\":[\"prometheus可以很好地记录任何纯粹的数字时间序列。它既适合以机器为中心的监视，也适合高度动态的面向服务的体系结构的监视。\",\"在微服务的世界里，它对多维数据收集和查询的支持是一个特别的优势。\",\"Prometheus是为可靠性而设计的。每个Prometheus都是单节点设计的，使用多个节点去采集相通的监控对象可以做到高可用。通过Prometheus建立完善的监控体系，从而达到以下目的：\",\"长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。\",\"对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。\",\"告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。\",\"故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题。\",\"数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息\",\"img\",\"那prometheus不适合什么？\",\"由于prometheus是使用周期性的采集数据，它并不能保证数据的及时性和绝对正确性，如果是想做与money相关的业务，使用prometheus明显是不合适的。\"]},\"122\":{\"h\":\"Prometheus环境搭建\",\"t\":[\"本文是Prometheus环境的搭建和安装，包括prometheus-sever、node-exporter、grafna的安装。安装成功后，配置prometheus采集node-exporter的指标，然后在grafana展示node-exporter采集的指标。\"]},\"123\":{\"h\":\"安装prometheus\",\"t\":[\"去prometheus官网下载prometheus，下载地址为https://prometheus.io/download/ ，目前提供了Linux\\\\windows\\\\mac的版本，笔者这里下载mac版本的。\",\"image-20231008083006727\",\"下载完成后，执行解压：\",\"tar -zxvf prometheus-2.47.1.darwin-amd64.tar.gz cd prometheus-2.47.1.darwin-amd64 \",\"执行启动命令：\",\"./prometheus \",\"笔者是mac电脑，运行时会被系统拒绝运行，需要打开系统偏好设置-安全与隐私，允许prometheus运行。\",\"其他操作系统应该没有这个问题。\",\"启动成功后，访问http://localhost:9090 ，就可以访问prometheus页面了，这个页面提供了对prometheus数据的查询和告警信息的查询，页面展示如下：\",\"image-20231008084050835\"]},\"124\":{\"h\":\"prometheus配置文件讲解\",\"t\":[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus.yml，这个配置文件是prometheus启动的时候会读取的配置。具体如下：\",\"# my global config global: scrape_interval: 15s evaluation_interval: 15s # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] \",\"具体的配置介绍如下：\",\"global.scrape_interval 是全局配置默认采集时间间隔（周期性采集监控目标）\",\"global.evaluation_interval是全局配置告警规则任务的计算\",\"alerting.alertmanagers是配置alertmanagers的地址的，alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",\"rule_files是配置告警规则文件的路径，可以使用通配符\",\"scrape_configs是配置采集任务的，支持多种类型的采集，比如从k8s、consul、也可以配置静态采集任务。上面的配置是采集prometheus自身的监控指标。可以访问prometheus自身的监控指标的暴露端点：http://localhost:9090/metrics，可以得到prometheus的监控指标，内容如下：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 4.5782e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 7.745e-05 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000123743 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000251038 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.002707693 go_gc_duration_seconds_sum 0.009608685 go_gc_duration_seconds_count 35 # HELP go_goroutines Number of goroutines that currently exist. # TYPE go_goroutines gauge go_goroutines 32 # HELP go_info Information about the Go environment. # TYPE go_info gauge go_info{version=\\\"go1.21.1\\\"} 1 # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use. # TYPE go_memstats_alloc_bytes gauge go_memstats_alloc_bytes 2.1363728e+07 # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed. # TYPE go_memstats_alloc_bytes_total counter go_memstats_alloc_bytes_total 3.82033736e+08 # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table. # TYPE go_memstats_buck_hash_sys_bytes gauge go_memstats_buck_hash_sys_bytes 1.489234e+06 ... \"]},\"125\":{\"h\":\"采集Node Exporter的指标\",\"t\":[\"Node Exporter是Prometheus生态的一员，它为主机暴露了硬件和内核相关的指标，比如主机的cpu、内存、磁盘、io读写等。目前支持linux系统、windows系统和mac系统，下载地址为：\",\"https://github.com/prometheus/node_exporter/releases \",\"下载完成后，启动node_exporter，node_exporter的端口为9100，访问http://localhost:9100/metrics，就可以查看node_exporter暴露的端口指标。\",\"在prometheus的配置文prometheus.yml中，增加采集Node Exporter的任务，配置信息如下：\",\"scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] - job_name: \\\"node_exporter\\\" static_configs: - targets: [\\\"localhost:9100\\\"] \",\"重新启动prometheus的程序，prometheus 就可以采集Node_Exporter的指标了。\",\"访问prometheus的网页，http://localhost:9090/graph，在查询框里输入node_filesystem_free_bytes（文件系统里剩余的磁盘字节数），就可以看到各个目录的磁盘剩余字节数了。\",\"image-20231008231356066\"]},\"126\":{\"h\":\"prometheus配置文件热更新\",\"t\":[\"在prometheus启动的时候加上启动参数--web.enable-lifecycle，具体命令如下：\",\"prometheus --web.enable-lifecycle \",\"在更改完配置以后，就可以进行配置的热更新，通过拉prometheus的配置热更新接口，接口如戏：\",\"curl -XPOST http://localhost:9090/-/reload \"]},\"127\":{\"h\":\"grafana安装\",\"t\":[\"Grafana是一个开源的、流行的、炫酷的展示数据的可视化仪表盘，它支持多种类型的数据库，提供了非常多的面板和插件，可以让开发者轻松的实现监控大盘。\",\"grafana可以完美的和prometheus结合，展示prometheus数据。\",\"进入grafana官网下载安装包，笔者是mac，所以下载的是mac版本的，下载命令如下：\",\"curl -O https://dl.grafana.com/enterprise/release/grafana-enterprise-10.1.4.darwin-amd64.tar.gz tar -zxvf grafana-enterprise-10.1.4.darwin-amd64.tar.gz \",\"下载并解压成功后，进入到grafana的安装目录，启动grafana，启动命令如下：\",\"./bin/grafana-server \",\"grafana有很多配置项在conf目录下default.ini文件下，此篇文章不讲解这部分内容。\",\"启动成功后，进入grafana的页面，地址为localhost:3030 ，grafana的默认登陆用户名admin、密码为admin\",\"登陆成功后，需要为grafana配置prometheus的数据源，配置界面的路径和配置如下：\",\"配置完成后保存。\",\"然后去grafana官方网站的dashboard社区找一个node exporter的面板，搜索地址：https://grafana.com/grafana/dashboards/?pg=community&plcmt=topnav&search=node+exporter+mac\",\"搜索成功后，在本地部署的grafana页面导入node exporter的dashboard，页面的导入路径如下：\",\"image-20231010201727866\",\"导入成功后，就可以看到本机的资源dashboard（由node exporter采集的指标生产）\",\"image-20231009220040376\"]},\"128\":{\"h\":\"总结\",\"t\":[\"prometheus作为一个采集组件，采集了node-exporter的指标\",\"同时prometheus作为一个时序数据库，存储了node-expoter的指标时序\",\"grafana作为数据展示前端，读取prometheus的指标时序，并展示在监控大盘上。\"]},\"129\":{\"h\":\"Prometheus的数据模型\"},\"130\":{\"h\":\"什么是time-series\",\"t\":[\"Prometheus通过时间序列来存储所有的数据的。时间序列是指标（有相同指标名和标签构成的）的包含时间和值的流式数据。采用的数据模型是单值模型，且只支持浮点数指标。举个例子：\",\"在前面的文章介绍过如下Prometheus自身的监控，通过/metrics接口暴露，Prometheus可以通过调用/metrics接口来获取自身的数据。指标定义如下：\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \",\"指标是单值模型，即一个指标代表一种含义，如下表示prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 指标在不同时间下的值。\",\"指标名称(name)\",\"code\",\"handler\",\"Timestamp\",\"Value\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984318.82\",\"1205\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984153.822\",\"1194\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984033.817\",\"1186\",\"指标在不同时间有不同的值，被称为time-series（时间序列），time-series中每个点被称为一个样子（sample)，sample由三部分组成：\",\"指标：指标是由指标名和标签组成，它们共同组成描述当前指标的特征 \",\"指标名和标签名的命名需要满足[a-zA-Z_:][a-zA-Z0-9_:]*\",\"对于标签值无约束，但是需要对值的控制字符进行转义\",\"时间戳(timestamp)：时间戳精度为毫秒\",\"值(value)： float64类型的值。\",\"<--------------- metric -------------------------------------><-timestamp -><-value-> prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984318.82 => 1205 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984153.822 => 1194 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984033.817 => 1186 \",\"在grafana上查询指标：prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}；\",\"image-20231012215203283\"]},\"131\":{\"h\":\"指标的类型\",\"t\":[\"Prometheus定义来四种类型的指标：\",\"Counter（累加器），初始值为0，只增不减，或者重启的进程的时候重置为0\",\"Gauge（仪表盘），状态值，可增可减。\",\"Histogram（直方图），用于求分位数，比如p99\",\"Summary（摘要），和直方图类似\",\"但是对于Prometheus的底层数据来说，这些类型的指标在存储的时候，并没有差别，都是以time-series的形式存储在Prometheus的level-db中。而在样本数据采集的时候，在注释中包含了指标的类型，其实在存储的时候是并没有存储的。\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \"]},\"132\":{\"h\":\"Counter 累加器\",\"t\":[\"Counter类型的指标和计数器一样，初始值为零，是单调递增的，除非进程重启重置。一般Counter类型的指标建议以_total结尾。例如prometheus_http_requests_total表示prometheus服务的http请求的数量，prometheus每发生一个请求，prometheus_http_requests_total都会累积1。\",\"使用counter类型的指标，可以很容易一段时间的增量数据，比如求最近5分钟prometheus发生了多少次请求：\",\"increase(prometheus_http_requests_total[5m]) \",\"increase是promql中的一个函数，函数的内容，在下一篇文章将会讲解。\"]},\"133\":{\"h\":\"Gauge仪表盘\",\"t\":[\"Gauge类型的指标主要反映的是当前的状态，它是可增可减的，比如node exporter采集的指标中：node_filesystem_avail_bytes，表示的是当前系统文件系统中磁盘可用的字节数，可用通过prometheus的内置函数计算最近5分钟node_filesystem_avail_bytes的差值。\",\"delta(node_filesystem_avail_bytes{}[5m]) \",\"还可以使用predict_linear函数对指标的数据变化趋势进行预测。例如，预测系统磁盘在6个小时之后的剩余情况：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[1h], 6* 3600) \"]},\"134\":{\"h\":\"Histogram直方图\",\"t\":[\"Histogram直方图是用来统计和分析样本的分布情况。\",\"在很多场景下，我们可以使用求平均值来量化指标。比如我们求某个请求耗时的平均值，但是在大多数情况下，请求都是在100ms以内，而个别情况可能导致请求耗时超过了5s，导致请求耗时的平均值远大于100ms，这个平均值是不能反应的请求的真实状态。\",\"Histogram直方图可以解决上面的问题，例如0-10ms的请求有多少个，10ms-20ms的请求又多少个。例如prometheus的服务的/metrics接口耗时，使用了prometheus_http_request_duration_seconds_bucket指标去统计。\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.1\\\"} 1827 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.2\\\"} 1828 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.4\\\"} 1829 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"1\\\"} 1830 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"3\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"8\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"20\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"60\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"120\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"+Inf\\\"} 1831 \",\"在上面的示例中，使用le标签表示小于的意思。\",\"le=\\\"0.1\\\" 表示小于0.1s，有1827个请求\",\"le=\\\"0.2\\\"表示小于0.2s，有1828个请求\",\"通过这种直方图可以很方便的统计请求耗时分布的真实状态。另外，会统计当前指标的记录总数(以_count作为后缀)和值的总和（以_sum作为后缀），例如：\",\"prometheus_http_request_duration_seconds_sum{handler=\\\"/metrics\\\"} 15.171390910999984 prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"} 1831 \",\"Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。\"]},\"135\":{\"h\":\"summary\",\"t\":[\"summary和Histogram类似，只不过summary是已经在客户端已经计算好的数据，例如go_gc_duration_seconds指标：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 6.3884e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 0.00013637 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000194843 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000421166 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.009242327 go_gc_duration_seconds_sum 0.1255515 go_gc_duration_seconds_count 296 \",\"Histogram和summary的区别在于，summary是在sdk侧已经计算好了分位数，而Histogram是通过histogram_quantile函数在prometheus-server进行计算的。对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多服务端的的资源。\",\"通常情况下，我们都会选择使用Histogram类型的指标去做分位数的统计，而不是使用summary。\"]},\"136\":{\"h\":\"Promql快速入门\",\"t\":[\"prometheus的时间序列是通过指标名和一组标签来唯一定义。指标的名称是监控样本的标识，而标签组是监控样本的多个维度特征的反应，所以可以通过标签进行对指标的筛选、过滤、聚合、转换等计算，计算的结果会产生一条新的时间序列。\",\"promql是Prometheus提供的数据查询语言，可以对时间序列提供丰富的查询。promql被广泛应用于指标视图的配置、告警语句的配置，它是一个基础能力，类似于mysql的sql查询语句。\"]},\"137\":{\"h\":\"瞬时向量查询（Instant vector selectors）\",\"t\":[\"我们可以直接输入指标名查询所有的这个指标名的时间序列，比如：\",\"prometheus_http_requests_total \",\"上面的语句等同于：\",\"prometheus_http_requests_total \",\"可以在grafana上查询，获取了prometheus_http_requests_total指标的不同标签维度的所有指标，一共有53个。\",\"image-20231014210829763\",\"可以筛选出handler=“/metrics\\\"接口的数据，在grafana执行：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"} \",\"image-20231014210912914\",\"另外也可以筛选出handler!=“/metrics\\\"的所有的数据，查询语句为：\",\"prometheus_http_requests_total{handler!=\\\"/metrics\\\"} \",\"也可以使用多个标签值进行进行查询，比如查询handler为\\\"/metrics“和handler为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler=~\\\"/metrics|/api/v1/labels\\\"} \",\"同理，也查询handler不为\\\"/metrics“和handler不为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler!~\\\"/metrics|/api/v1/labels\\\"} \",\"也可以使用.*通配符进行模糊匹配查询：\",\"prometheus_http_requests_total{handler=~\\\"/metric.*\\\"} \",\"小结：\",\"使用标签筛选数据的使用，可以使用完全匹配：\",\"label = value\",\"lable =~ value | value2\",\"也可以进行模糊匹配：\",\"label =~ value.*\",\"取反操作\",\"label != value\",\"Label !~ value1 |value2\",\"Label !~ value.*\"]},\"138\":{\"h\":\"范围向量查询（Range Vector Selectors）\",\"t\":[\"通过Instant vector selectors查询，返回值只会包含该时间序列的最新值的一个样本，它是一个瞬时向量结果。如果我们想查询一个时间区间的样本，可以使用范围矢量查询。范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}[5m] \",\"image-20231014211256244\",\"时间范围除了支持分钟（m)外，还还支持\",\"秒（s)\",\"分钟（m）\",\"小时（h）\",\"天（d）\",\"周（w）\",\"年（y）\"]},\"139\":{\"h\":\"offset 时间位移操作\",\"t\":[\"瞬时向量查询和范围向量查询的表达式中，都是以当前时间为基准的，比如：\",\"prometheus_http_requests_total{}，查询当前时间的最新值\",\"prometheus_http_requests_total{}[5m]，查询的是当前时间的过去五分钟的数据。\",\"如果想查询五分钟前的数据，获取昨天的当前时间同一时刻的五分钟的数据，怎么查询呢，我们可以使用offset关键字：\",\"prometheus_http_requests_total{} offset 5m，查询五分钟前的最新值\",\"prometheus_http_requests_total{}[5m] offset 1d，查询的是昨天的当前时间同一时刻的五分钟的数据\"]},\"140\":{\"h\":\"操作符\"},\"141\":{\"h\":\"数学操作符\",\"t\":[\"Promql支持常见的逻辑和数学操作符，这些操作符使用于瞬时向量的查询，常见的逻辑运算符如下\",\"+ (addition) 加\",\"- (subtraction) 减\",\"* (multiplication) 乘\",\"/ (division) 除\",\"% (modulo) 取模\",\"^ (power/exponentiation) 幂运算\",\"在作用于两个瞬时向量之间，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。如果匹配到了，会将计算结果输出到新的向量上，向量里面的标签是左侧和右侧共同匹配的标签，指标名将会被删除。\",\"例如下面的查询语句不会输出任何结果，因为两个handler标签值不一样。\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}+prometheus_http_requests_total{handler=\\\"/api/v1/labels\\\"} \",\"再比如下面的查询语句的可以输出结果，因为左侧的表达式有一个handler=\\\"/metrics\\\"，右侧的表达式也有一个handler=\\\"/metrics\\\"标签，完全匹配，所以能够输出：\",\"sum(prometheus_http_requests_total{handler=\\\"/metrics\\\"})by(handler)+sum(prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"})by(handler) \"]},\"142\":{\"h\":\"比较操作符\",\"t\":[\"promql还支持常见的比较运算符，比如：\",\"== (equal)\",\"!= (not-equal)\",\"> (greater-than)\",\"< (less-than)\",\">= (greater-or-equal)\",\"<= (less-or-equal)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"143\":{\"h\":\"逻辑运算符\",\"t\":[\"逻辑运算符作用于两个瞬时向量之间，支持的逻辑运算符如下：\",\"and (intersection) 求交集\",\"or (union) 求并集\",\"unless (complement)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"144\":{\"h\":\"向量匹配符号 Vector matching\",\"t\":[\"在上面讲解的操作符，比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算。在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算，promql提供了两个向量匹配符号\",\"on （匹配）\",\"Ignoring （忽略）\",\"使用上面的Vector matching，可以应用于One-to-one vector matches（一对一）和Many-to-one and one-to-many vector matches（一对多或者多对一）\"]},\"145\":{\"h\":\"分组修改器 Group modifiers\",\"t\":[\"分组修改器可以实现many-to-one/one-to-many的向量匹配，通常使用以下的关键字：\",\"group_left\",\"group_right\",\"分组修改器可以一边的标签组赋值给另一边的查询结构。\",\"举例子讲解\",\"比如有以下的时间序列的样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用以下的查询：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"如果不用ignoring修改器，将得不到任何结果。\",\"使用group_left修改器进行查询：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \"]},\"146\":{\"h\":\"聚合函数\",\"t\":[\"Prometheus提供非常的多的聚合函数，可以用来聚合耽搁瞬时向量，聚合完后的结果会生成根据聚合标签生成一个新的序列：\",\"sum (calculate sum over dimensions)\",\"min (select minimum over dimensions)\",\"max (select maximum over dimensions)\",\"avg (calculate the average over dimensions)\",\"group (all values in the resulting vector are 1)\",\"stddev (calculate population standard deviation over dimensions)\",\"stdvar (calculate population standard variance over dimensions)\",\"count (count number of elements in the vector)\",\"count_values (count number of elements with the same value)\",\"bottomk (smallest k elements by sample value)\",\"topk (largest k elements by sample value)\",\"quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\",\"基本查询格式是：\",\"<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>) \",\"比如prometheus_http_requests_total这个指标有4个标签，分别是code、handler、instance、job（其中job为采集任务、instance为被采集的实例，这两个标签对于同一个实例来说基本不变）， timeseries格式如下：\",\"prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} \",\"我们可以计算所有handler、code的的请求总数：\",\"sum by (handler, code) (prometheus_http_requests_total) \",\"它同等于：\",\"sum without (instance, job) (prometheus_http_requests_total) \",\"如果想计算所有的请求的总数：\",\"sum(prometheus_http_requests_total) \",\"获取请求次数最多的5个请求，可以用topk函数：\",\"topk(5,sum by (handler, code) (prometheus_http_requests_total)) \"]},\"147\":{\"h\":\"其他常见的函数\"},\"148\":{\"h\":\"计算counter的增长率\",\"t\":[\"可以使用increase函数计算增量数据，比如计算最近5分钟的请求次数：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"这里使用prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]获取最近五分钟的样本，用increase函数算出五分钟的增量。\",\"那么每秒的增量率，可以将上面的结果除以300，可以使用以下的表达式进行计算：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m])/(60*5) \",\"除了使用increase函数计算增量外，可以使用rate函数计算速率，上面的表达式等价于：\",\"rate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于请求数量在5分钟的时间窗口内，可能在某一时刻访问量突增，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。\",\"为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。\",\"irate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \"]},\"149\":{\"h\":\"预测指标变化趋势\",\"t\":[\"predict_linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据，函数的格式如下：\",\"predict_linear(v range-vector, t scalar) \",\"例如，基于5小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[5h], 24 * 3600) < 0 \"]},\"150\":{\"h\":\"计算分位数\",\"t\":[\"Histogram类型的指标可以使用histogram_quantile函数进行计算，函数格式为：\",\"histogram_quantile(φ scalar, b instant-vector) \",\"例如有以下的指标prometheus_http_request_duration_seconds_bucket\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\", job=\\\"prometheus\\\", le=\\\"0.1\\\"} 3767 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.2\\\"} 3769 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.4\\\"} 3773 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"1\\\"} 3775 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"3\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"8\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"20\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"60\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"120\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"Infinity\\\"} 3776 \",\"计算handler=\\\"/metrics\\\"接口的p90耗时：\",\"histogram_quantile(0.9, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \",\"计算p99耗时的表达式如下：\",\"histogram_quantile(0.99, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \"]},\"151\":{\"h\":\"总结\",\"t\":[\"本文快速的讲解了promql的查询、操作符、函数，并通过案例进行了实战。详细内容可以查看官方网站：https://prometheus.io/docs/prometheus/latest/querying/basics/\"]},\"152\":{\"h\":\"在SpringBoot项目中使用Prometheus监控\",\"t\":[\"本篇文章主要讲解如何在SpringBoot项目中使用Prometheus监控，实现方式有两种，一种是使用Springboot自带的spring-boot-starter-actuator；另一种是使用Prometheus的Java客户端\"]},\"153\":{\"h\":\"方案一：使用spring-boot-starter-actuator\",\"t\":[\"SpringBoot已经有来Micrometer的指标库，它默认集成在spring-boot-starter-actuator的依赖包中（要求SpringBoot>=2.0版本）。\",\"新建一个SpringBoot项目，在项目中引入以下的依赖：\",\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <version>1.11.4</version> </dependency> \",\"其中micrometer-registry-prometheus依赖是将Micrometer的指标转换成prometheus格式的指标。\",\"然后在springboot的配置文件application.properties中开启prometheus的暴露接口：\",\"management.endpoints.web.exposure.include=prometheus \",\"在SpringBoot项目创建一个测试接口：\",\"@Controller public class BasicController { // http://127.0.0.1:8080/hello?name=lisi @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后，在浏览器上请求http://127.0.0.1:8080/actuator/prometheus\",\"可以得到/hello接口相关的指标，当然actuator有很多内置的指标，在这里就不展开讲解了 。\",\"# HELP http_server_requests_seconds # TYPE http_server_requests_seconds summary http_server_requests_seconds_count{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 7.0 http_server_requests_seconds_sum{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.071374449 # HELP http_server_requests_seconds_max # TYPE http_server_requests_seconds_max gauge http_server_requests_seconds_max{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.049234863 \",\"在这里有三个指标，分别为\",\"http_server_requests_seconds_count 请求的总次数\",\"http_server_requests_seconds_sum 请求的总耗时\",\"http_server_requests_seconds_max 请求的最大耗时\",\"这个内置指标对请求耗时统计不是做的很好，只能求到最大的耗时和平均耗时，如果要求分位耗时，其实是做不到。而使用Prometheus的Java客户端是可以做到分位耗时的。\"]},\"154\":{\"h\":\"方案二：使用Prometheus\",\"t\":[\"Prometheus官方提供了Java客户端，用于Java程序的指标暴露。在SpringBoot项目中的pom文件引入以下的依赖：\",\" <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-instrumentation-jvm</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-exporter-httpserver</artifactId> <version>1.0.0</version> </dependency> \",\"其中prometheus-metrics-core包是指标的关键包；prometheus-metrics-instrumentation-jvm是用于暴露JVM相关的指标（可选）；prometheus-metrics-exporter-httpserver是用于导出指标的服务（可选）；\",\"同样的，在项目中有一个测试接口，如下：\",\" @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } \",\"然后，需要创建两个指标，如下：\",\"Counter类型的http_count_total，用于统计请求的数量，包括两个标签uri（请求路径）和status（请求状态码）\",\"Histogram类型的http_count_seconds，用于统计请求的耗时，包括两个标签uri（请求路径）和status（请求状态码）\",\"然后创建一个HandlerInterceptorAdapter的拦截器，用于指标数据的统计：\",\"在preHandle方法中记录请求的开始时间startTime\",\"在afterCompletion方法中，统计请求的次数和请求耗时，\",\"完整的代码如下：\",\"package io.github.forezp.prometheuslab.aop; import io.prometheus.metrics.core.metrics.Counter; import io.prometheus.metrics.core.metrics.Histogram; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ApiStatInterceptor extends HandlerInterceptorAdapter { Counter counter = Counter.builder() .name(\\\"http_count_total\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); Histogram histogram = Histogram.builder() .name(\\\"http_count_seconds\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); request.setAttribute(\\\"startTime\\\", startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { long startTime = (Long) request.getAttribute(\\\"startTime\\\"); long endTime = System.currentTimeMillis(); String uri=request.getRequestURI(); counter.labelValues(uri,\\\"ok\\\").inc(); histogram.labelValues(uri,\\\"ok\\\").observe(endTime-startTime); } } \",\"然后将ApiStatInterceptor注册到WebMvcConfigurer中：\",\"@Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new ApiStatInterceptor()); } } \",\"开启HTTPServer，并已bean的形式注册：\",\" @Bean public HTTPServer createHttpServer() throws IOException { HTTPServer server = HTTPServer.builder() .port(9400) .buildAndStart(); return server; } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后在浏览器上访问http://localhost:9400/metrics，可以看到有两个指标http_count_total和http_count_seconds，指标数据如下：\",\"# HELP http_count_total example counter # TYPE http_count_total counter http_count_total{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2.0 # HELP http_count_seconds example counter # TYPE http_count_seconds histogram http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.005\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.01\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.025\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.05\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.1\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.25\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"1.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"2.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"5.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"10.0\\\"} 1 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"+Inf\\\"} 2 http_count_seconds_count{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2 http_count_seconds_sum{status=\\\"ok\\\",uri=\\\"/hello\\\"} 44.0 \"]},\"155\":{\"h\":\"配置Prometheus采集\",\"t\":[\"在Springboot的项目中增加springboot指标的采集，配置如下：\",\"scrape_configs: - job_name: \\\"springboot\\\" static_configs: - targets: [\\\"localhost:9400\\\"] \",\"配置完成后，重新启动prometheus或者热加载，重新加载一下配置。\"]},\"156\":{\"h\":\"配置grafana视图\",\"t\":[\"在grafana中为Springboot项目配置试图，比如配置每分钟的请求量，配置的表达式如下：\",\"sum(increase(http_count_total{}[1m]))by (uri) \",\"image-20231021115719027\",\"配置请求的p95耗时，配置的表达式如下：\",\"histogram_quantile(0.95,sum(increase(http_count_seconds_bucket{}[1m]))by(uri,le)) \",\"image-20231021115611700\"]},\"157\":{\"h\":\"Prometheus告警与Alertmanager实战\",\"t\":[\"Prometheus的告警分为两部分内容：\",\"Prometheus server中的告警规则、告警发送。\",\"告警消息的处理程序Alertmanager，Alertmanager的主要功能包括告警消息的分组、路由分发、抑制和静默等核心功能\",\"工作流程包括：\",\"配置和启动Alertmanager\",\"在Prometheus server中配置Alertmanager的地址，用于向Alertmanager发送告警消息\",\"在Prometheus server中配置告警规则\",\"一个简单版的Prometheus的架构图如下：\",\"image-20231021170507878\",\"Prometheus作为采集端，采集Node-exporter、sdk client的数据\",\"Prometheus作为存储端，起到了时序数据库的作用，存储采集到的数据\",\"同时Prometheus读取告警规则文件，在进程内部计算告警规则，如果有告警发生，则向Alertmanager发送告警消息\",\"Alertmanager作为告警收敛的组件，在它内部进行告警消息的管理，最终将消息发送给第三方组件，通常是webhook\",\"最后webhook发送给告警平台。\",\"在前面的文章已经讲解过Prometheus采集数据和查询数据，在本篇文章中将会讲述Prometheus告警与Alertmanager实战。\"]},\"158\":{\"h\":\"Alertmanager介绍\",\"t\":[\"Alertmanager处理来自客户端的告警消息，例如Prometheus server，包括消息的去重、分组、路由、抑制和静默等核心功能。先了解这些核心概念，然后通过配置文件的形式来具体讲解。\"]},\"159\":{\"h\":\"分组\",\"t\":[\"分组是将同一组多个的相同的告警消息合并成一个高级消息。这在系统出现大量故障的时候非常有用，如果系统发出成千上万条相同的告警消息，对处理者来说是一个灾难。\",\"比如，某个数据库出现网络故障，导致连接它的应用的几百个实例都出现异常，如果不进行分组合并，则会出现几百上千的告警消息，很可能淹没掉一些其他的告警消息，导致告警处理者漏处理一些告警消息，从而导致一些系统问题。\",\"分组是\",\"告警分组，告警时间间隔，以及告警的接受方式可以通过Alertmanager的配置文件进行配置\"]},\"160\":{\"h\":\"抑制\",\"t\":[\"抑制是当某一告警已经发出，可以停止重复发送由此告警引发的其它告警的机制。\",\"例如，当集群不可用访问出发了告警，通过Alertmanager的配置可以忽略与该集群有关的其它告警功能。这样可以避免接受一些与实际问题相关的告警。\"]},\"161\":{\"h\":\"静默\",\"t\":[\"静默提供了一个标签匹配的设置，如果告警消息符合匹配，Alertmanager则不会发送消息到下游。\",\"Alertmanager 通过配置文件去配置一些配置，然后通过命令行的方式的启动它。Alertmanager 可以在运行时重新加载其配置，通过向Alertmanager 进程发送 SIGHUP信号或者请求Alertmanager 的 /-/reload 接口（POST请求）。\"]},\"162\":{\"h\":\"Alertmanager安装\",\"t\":[\"下载地址：https://prometheus.io/download/\",\"启动alertmanager可以使用以下命令：\",\"./alertmanager --config.file=alertmanager.yml \",\"在启动之前，需要修改alertmanager的配置文件，默认的配置文件如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 30s group_interval: 5m repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"配置文件中包含了4个部分，分别是：\",\"全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容； 告警路由（route）：根据标签匹配，确定当前告警应该如何处理； 接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用； 抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生\"]},\"163\":{\"h\":\"配置讲解\",\"t\":[\"每个部分包含的可配置的参数很多，参数的配置会在以后的文章中讲解，在此篇文章只讲解最基础的和几个重要的配置：\",\"gloabl配置\",\"resolve_timeout\",\"当告警消息没有endTs这个时间戳参数时，Alertmanager会启动它的告警恢复逻辑。当启动告警恢复逻辑时，Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）。这个对于prometheus的告警消息来说，它会含有endTs这个时间戳参数，所以这个resolve_timeout对于prometheus的告警消息是不生效的。\",\"route配置\",\"group_by 默认alertname\",\"The labels by which incoming alerts are grouped together.\",\"将告警消息按照某个标签分组，比如按照alertname\",\"group_wait（default: 30s）\",\"How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) 一组告警第一次发送之前等待的时间。用于等待抑制告警，或等待同一组告警采集更多初始告警后一起发送。（一般设置为0秒 ~ 几分钟\",\"group_interval（default: 5m）\",\"How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) 一组已发送初始通知的告警接收到新告警后，再次发送通知前等待的时间（一般设置为5分钟或更多）\",\"repeat_interval（default: 4h）\",\"How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). 一条成功发送的告警，在再次发送通知之前等待的时间。 （通常设置为3小时或更长时间）。\",\"receivers配置\",\"Receiver可以集成邮箱、微信、邮箱等，本文使用webHook的方式，即Alertmanager通过http接口调用来发送告警消息。\",\"inhibit_rules 配置\",\"抑制允许根据另一组警报的存在来静音一组警报。这允许在系统或服务之间建立依赖关系，以便在中断期间仅发送一组互连警报中最相关的警报。\",\"当存在与另一组匹配器匹配的警报（源）时，禁止规则会静音与一组匹配器匹配的警报（目标）。目标警报和源警报在相等列表中的标签名称必须具有相同的标签值。\",\"inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"比如当发生severity=critical的告警时，会屏蔽掉severity=warning的告警，前提条件是两个告警的alertname、dev、instance的标签值相等。\",\"根据实际情况，最终我的配置修改成如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 10s group_interval: 30s repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:8080/webhook' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"重新启动alertmanager，获取通过热加载的方式重新加载配置文件。\",\"在浏览器中访问localhost:9093，可以看到alertmanager的界面。\"]},\"164\":{\"h\":\"在prometheus中配置告警规则\",\"t\":[\"在prometheus的启动程序的同级目录下面，建一个first_rule.yml的文件，这个文件是告警规则计算的配置，内容如下：\",\"groups: - name: test rules: - alert: HighQps expr: sum(increase(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m])) > 1 for: 1m labels: severity: page env: test region: wuhan annotations: summary: HighQps description: '{{ $value }}' \",\"在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：\",\"alert：告警规则的名称。\",\"expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。\",\"for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。\",\"labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。\",\"annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。\",\"在Prometheus的配置文件中，增加告警规则的配置：\",\"alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:909 rule_files: - ./first_rule.yml \",\"最好创建一个目录专门存储告警规则文件，然后用*.yml去配置所有的告警规则文件。\",\"访问Prometheus的规则文件界面（http://127.0.0.1:9090/rules），可以看到的规则状态如下：\",\"image-20231021174512876\",\"等待1分钟，访问Prometheus的告警页面界面（http://127.0.0.1:9090/alerts?search=），可以看到已经有一条告警消息已经发送给Alertmanager\",\"image-20231021174854220\"]},\"165\":{\"h\":\"Alertmanager查看告警消息\",\"t\":[\"访问alertmanager的界面（http://localhost:9093/#/alerts），显示告警消息已经收到：\",\"image-20231021174948512\"]},\"166\":{\"h\":\"webhook\",\"t\":[\"Alertmanager收到告警消息后，如果判断需要发送消息给下游的Webhook程序，将通过POST的http请求发送下游程序，发送的告警消息的JSON格式如下：\",\"https://prometheus.io/docs/alerting/latest/configuration/#webhook_config\",\"{ \\\"version\\\": \\\"4\\\", \\\"groupKey\\\": <string>, // key identifying the group of alerts (e.g. to deduplicate) \\\"truncatedAlerts\\\": <int>, // how many alerts have been truncated due to \\\"max_alerts\\\" \\\"status\\\": \\\"<resolved|firing>\\\", \\\"receiver\\\": <string>, \\\"groupLabels\\\": <object>, \\\"commonLabels\\\": <object>, \\\"commonAnnotations\\\": <object>, \\\"externalURL\\\": <string>, // backlink to the Alertmanager. \\\"alerts\\\": [ { \\\"status\\\": \\\"<resolved|firing>\\\", \\\"labels\\\": <object>, \\\"annotations\\\": <object>, \\\"startsAt\\\": \\\"<rfc3339>\\\", \\\"endsAt\\\": \\\"<rfc3339>\\\", \\\"generatorURL\\\": <string>, // identifies the entity that caused the alert \\\"fingerprint\\\": <string> // fingerprint to identify the alert }, ... ] } \",\"对应的Java实体如下：\",\" public class Webhook { public String receiver; public String status; public ArrayList<Alert> alerts; public Map<String,String> groupLabels; public Map<String,String> commonLabels; public Map<String,String> commonAnnotations; public String externalURL; public String version; public String groupKey; public int truncatedAlerts public static class Alert { public String status; public Map<String,String> labels; public Map<String,String> annotations; public Date startsAt; public Date endsAt; public String generatorURL; public String fingerprint; } } \",\"在Springboot项目中，写一个接口如下：\",\" @PostMapping(\\\"/webhook\\\") public String webhook(@RequestBody Webhook webhook) { logger.info(webhook.toString()); return \\\"ok\\\"; } \",\"这样webhook的程序收到告警消息后，就可以具体的执行告警逻辑，比如将告警消息发送给运维人员的邮箱。\"]},\"167\":{\"h\":\"参考文档\",\"t\":[\"https://blog.csdn.net/qq_37843943/article/details/120665690\",\"https://www.jianshu.com/p/c661e8050434\",\"https://blog.51cto.com/starsliao/5763175\",\"https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/prometheus-alert-rule\"]},\"168\":{\"h\":\"Prometheus预处理计算-Recording Rule\",\"t\":[\"prometheus支持两种规则表达式，一种是告警告警规则表达式，另外一种是预计算规则recording rule。recording rule是预先计算成本较高的表达式，并将计算结果保存在一组新的时间序列上。预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多。\"]},\"169\":{\"h\":\"定义Recoding rules\",\"t\":[\"Prometheus会定时的根据拉取expr定时表达式的数据，并将数据的结果存储在新的时间序列中，新的序列名称为record中的值。如果expr表达式的计算结果包含标签，则会把标签添加到新的序列中，如果labels配置中含有额外的标签也会放到新的timeseries中。\",\"和alert rule类似，每个Recording rule的规则定义如下：\",\"groups: - name: example rules: - record: job:http_inprogress_requests:sum expr: sum(http_inprogress_requests) by (job) \",\"rule_group可以配置两个参数：\",\"name，group的名称，需要全局唯一\",\"interval, rule_group执行的时间间隔，如果没有配置，则默认是global.evaluation_interval\",\"Groups.rules选项是recording-rule的具体配置，可以有以下几个配置项：\",\"record ： expr执行后生成新的指标的名称，指标名称的定义可以参考下面一小节\",\"expr：具体预处理生成指标的表达式。\",\"labels：可以在新生成的指标上额外加一些标签。\",\"记录和告警规则存在于规则组中。组内的规则以固定的时间间隔按顺序运行，评估时间相同。记录规则的名称必须是有效的指标名称。警报规则的名称必须是有效的标签值。\",\"另外如果没有配置groups的interval配置，recording的计算规则和alert的计算规则，都可以通过以下配置，进行全局的计算频次的设置：\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"170\":{\"h\":\"recording rule的最佳实践\",\"t\":[\"recording rule的命令规范很重要，一个好的命名规范可以一目了然的知道规则的含义，避免出现一些无意义的计算。\"]},\"171\":{\"h\":\"命名规范\",\"t\":[\"通过recording rule产生的新的指标，应该遵循通用的方式：level:metric:operations\",\"level 表示聚合的级别和规则标签的输出\",\"metric 是和预聚合前的名称保存一致\",\"Operations 是应用于指标的操作函数列表，最新的操作函数在前。\",\"当对counter类型使用rate或者是irate操作，去掉_total的后缀\",\"当对指标用作除法,并且是求百分数，可以使用_per_\",\"例如：\",\"- record: instance_path:requests:rate5m expr: rate(requests_total{job=\\\"myjob\\\"}[5m]) \",\"上面的表达式rate(requests_total{job=\\\"myjob\\\"}[5m])，有两个标签分别是instance和path，所以它的level可以命名为instance_path；对meric使用了rate操作将metric原来的名称去掉_total；最后使用是rate操作\",\"最终根据上面的表达式得到的指标的名称是instance_path:requests:rate5m；我们可以根据指标的名称可以反推出指标的表达式，这样真的一目了然。\",\"其他例子：\",\"- record: instance_path:request_failures:rate5m expr: rate(request_failures_total{job=\\\"myjob\\\"}[5m]) - record: instance_path:request_failures_per_requests:ratio_rate5m expr: |2 instance_path:request_failures:rate5m{job=\\\"myjob\\\"} / instance_path:requests:rate5m{job=\\\"myjob\\\"} # Aggregate up numerator and denominator, then divide to get path-level ratio. - record: path:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) # No labels left from instrumentation or distinguishing instances, # so we use 'job' as the level. - record: job:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance, path)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance, path)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) \"]},\"172\":{\"h\":\"实战\",\"t\":[\"新建一个recoding_rule.yml的文件，在文件中写一个指标聚合的表达式，该表达式的计算时间间隔为1分钟，表达式的含义是计算每分钟handler=\\\"/metrics\\\"的请求量，另外在新生成的指标上添加一个新的标签region，具体表达式格式如下：\",\"groups: - name: recording_rule interval: 1m rules: - record: instance_handler_code:prometheus_http_requests:rate1m expr: sum(rate(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m]) )by(instance,handler,code) labels: region: wuhan \",\"在Prometheus的yaml配置文件中，通过rule_files定义recoding rule规则文件的路径。\",\"rule_files: - ./first_rule.yml - ./recoding_rule.yml \",\"重新启动Prometheus，在Prometheus的页面上可以查看新指标的数据，如下：\",\"image-20231023210926364\"]},\"173\":{\"h\":\"Java Collection概述\",\"t\":[\"Java Collection 集合是 Java 编程语言中用于存储和操作对象的框架。它提供了一组接口和类，用于处理不同类型的集合，如List、Set、Queue、Map等。\",\"下面是Java Collection 框架的一些关键概念：\",\"集合接口（Collection Interface）：是 Java Collection 框架的根接口，它定义了集合的基本操作，如添加、删除、遍历等。常见的集合接口包括 List、Set 和 Queue。\",\"列表（List）：以有序的方式存储对象的集合，允许重复元素。常见的列表实现类有 ArrayList 和 LinkedList。\",\"集（Set）：以无序的方式存储对象的集合，不允许重复元素。常见的集实现类有 HashSet 和 TreeSet。\",\"队列（Queue）：一种先进先出（FIFO）的数据结构，用于保存元素并控制元素的插入、删除操作。常见的队列实现类有 LinkedList 和 PriorityQueue。\",\"散列（Map）：以键值对（Key-Value）的形式存储数据，每个键都是唯一的。常见的映射实现类有 HashMap 和 TreeMap。它是Collection框架的一部分，虽然它不是Collection Interface的继承接口。\",\"Java Collection 框架的类的思维导图如下：\"]},\"174\":{\"h\":\"List 接口\",\"t\":[\"Java 的 List 接口是 Collection 接口的继承接口之一，用于表示有序的元素集合，允许元素的重复。List 接口中的元素按照插入的顺序存储，并且可以通过索引进行访问和操作。\",\"List 接口的主要特点包括：\",\"有序性：List 中的元素按照插入的顺序进行存储，元素的顺序可以根据插入和删除操作的顺序动态改变。\",\"可重复性：List 允许包含重复的元素，相同的元素可以出现在列表的不同位置。\",\"可变大小：List 的大小可以根据需要进行动态调整，可以添加或删除元素。\",\"List 接口定义了很多常用的方法，用于添加、删除、获取和操作列表中的元素。例如：\",\"添加元素：使用 add、addAll 方法将元素或集合添加到列表中。\",\"删除元素：使用 remove、removeAll 方法删除指定元素或集合中的元素。\",\"获取元素：使用 get、indexOf、lastIndexOf 方法获取元素或元素的索引。\",\"修改元素：使用 set 方法修改列表中指定位置的元素。\",\"列表操作：使用 subList、sort、reverse 方法实现对列表的操作，如截取子列表、排序、反转等。\",\"遍历列表：使用迭代器、增强的 for 循环或 forEach 方法遍历列表中的元素。\",\"举个例子演示如何使用 List 接口：\",\"import java.util.ArrayList; import java.util.List; public class ListExample { public static void main(String[] args) { // 创建一个 List 对象 List<String> fruits = new ArrayList<>(); // 添加元素到列表中 fruits.add(\\\"Apple\\\"); fruits.add(\\\"Banana\\\"); fruits.add(\\\"Orange\\\"); fruits.add(\\\"Mango\\\"); // 获取列表的大小 int size = fruits.size(); System.out.println(\\\"List size: \\\" + size); // 访问列表中的元素 String firstFruit = fruits.get(0); System.out.println(\\\"First fruit: \\\" + firstFruit); // 遍历列表中的元素 System.out.println(\\\"Fruits:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 检查列表中是否包含某个元素 boolean containsApple = fruits.contains(\\\"Apple\\\"); System.out.println(\\\"Contains Apple? \\\" + containsApple); // 修改列表中的元素 fruits.set(1, \\\"Grapes\\\"); System.out.println(\\\"Updated list:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 删除列表中的元素 fruits.remove(2); System.out.println(\\\"Updated list after removing element:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 清空列表 fruits.clear(); System.out.println(\\\"List is empty? \\\" + fruits.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"List size: 4 First fruit: Apple Fruits: Apple Banana Orange Mango Contains Apple? true Updated list: Apple Grapes Orange Mango Updated list after removing element: Apple Grapes Mango List is empty? true \"]},\"175\":{\"h\":\"Set接口\",\"t\":[\"Set 接口是 Collection 接口的子接口之一，用于存储不重复的元素。Set 中的元素没有固定的顺序，且不允许包含重复的元素。\",\"Set 接口的主要特点包括：\",\"不重复性：Set 中的元素是唯一的，不会包含重复的元素。添加重复元素时，添加操作会失败并返回 false。\",\"无序性：Set 中的元素没有固定的顺序。具体的排列顺序可能因实现类或元素的添加顺序而不同。\",\"快速查找：Set 提供了高效的查找操作，可以快速判断一个元素是否存在于集合中。\",\"Set 接口继承自 Collection 接口，因此包含了一些常用的方法，例如添加元素、删除元素、判断元素是否存在、获取集合大小等。\",\"举个简单的示例，演示如何使用 Set 接口：\",\"import java.util.HashSet; import java.util.Set; public class SetExample { public static void main(String[] args) { // 创建一个 Set 对象 Set<String> names = new HashSet<>(); // 添加元素到集合中 names.add(\\\"Alice\\\"); names.add(\\\"Bob\\\"); names.add(\\\"Charlie\\\"); names.add(\\\"Bob\\\"); // 重复元素，将不会被添加进去 // 获取集合的大小 int size = names.size(); System.out.println(\\\"Set size: \\\" + size); // 遍历集合中的元素 System.out.println(\\\"Names:\\\"); for (String name : names) { System.out.println(name); } // 检查集合中是否包含某个元素 boolean containsBob = names.contains(\\\"Bob\\\"); System.out.println(\\\"Contains Bob? \\\" + containsBob); // 从集合中删除元素 names.remove(\\\"Charlie\\\"); System.out.println(\\\"Updated set:\\\"); for (String name : names) { System.out.println(name); } // 清空集合 names.clear(); System.out.println(\\\"Set is empty? \\\" + names.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Set size: 3 Names: Bob Charlie Alice Contains Bob? true Updated set: Bob Alice Set is empty? true \",\"上面的例子演示了如何创建 Set 对象，添加、获取、遍历和删除集合中的元素，以及判断集合是否为空。\"]},\"176\":{\"h\":\"Map接口\",\"t\":[\"Map 接口是集合框架中用于存储键值对（Key-Value）的映射关系。每个键值对都是一个条目（Entry），键是唯一的，值可以重复。它和Collection接口属于并列的关系。\",\"Map 接口的主要特点如下：\",\"键的唯一性：Map 中的键是唯一的，不允许重复。如果使用相同的键插入多个值，后面的值会覆盖前面的值。\",\"快速查找：Map 提供了根据键快速查找对应值的方法。\",\"无固定顺序：Map 中的键值对没有固定的顺序。具体的迭代顺序可能因实现类或元素的插入顺序而不同。\",\"Map 接口定义了常用的操作方法，例如添加键值对、删除键值对、获取键值对数量、按键查找值等。常用的 Map 接口的实现类有 HashMap、LinkedHashMap 和 TreeMap。\",\"举个例子演示如何使用 HashMap：\",\"import java.util.HashMap; import java.util.Map; public class HashMapExample { public static void main(String[] args) { // 创建一个 HashMap 对象 Map<String, Integer> scores = new HashMap<>(); // 添加键值对到 HashMap 中 scores.put(\\\"Alice\\\", 95); scores.put(\\\"Bob\\\", 80); scores.put(\\\"Charlie\\\", 90); // 获取键对应的值 int aliceScore = scores.get(\\\"Alice\\\"); System.out.println(\\\"Alice's score: \\\" + aliceScore); // 检查 HashMap 中是否包含某个键 boolean containsKey = scores.containsKey(\\\"Bob\\\"); System.out.println(\\\"Contains key 'Bob'? \\\" + containsKey); // 获取 HashMap 的大小（键值对数量） int size = scores.size(); System.out.println(\\\"HashMap size: \\\" + size); // 遍历 HashMap 中的键值对 System.out.println(\\\"Scores:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 修改某个键对应的值 scores.put(\\\"Bob\\\", 85); System.out.println(\\\"Updated score for Bob: \\\" + scores.get(\\\"Bob\\\")); // 删除某个键值对 scores.remove(\\\"Charlie\\\"); System.out.println(\\\"After removing Charlie:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 清空 HashMap scores.clear(); System.out.println(\\\"HashMap is empty? \\\" + scores.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Alice's score: 95 Contains key 'Bob'? true HashMap size: 3 Scores: Alice: 95 Bob: 80 Charlie: 90 Updated score for Bob: 85 After removing Charlie: Alice: 95 Bob: 85 HashMap is empty? true \",\"上面的例子演示了如何创建 HashMap ，以及添加、获取、遍历和删元素对象，以及判断 HashMap 的大小和是否为空。\"]},\"177\":{\"h\":\"总结\",\"t\":[\"本文介绍了Java中的Collection框架，包括了最常见的List、Set和Map接口，以及常见的实现类。然后用案例讲解了这些类的使用。\",\"在如今Java面试八股文满天飞的时代，上面的内容可能不会被面试官问到，因为太基础了，但是Java集合的源码或者手写Java Collection的实现还是经常被问到。所以在接下来的文章会从源码和Java Collection的手写实现两个维度来讲解常见的集合类的具体实现。\"]},\"178\":{\"h\":\"java基础高频面试题1\"},\"179\":{\"h\":\"重载与重写的区别\",\"t\":[\"重载（Overloading）和重写（Overriding）是Java语言中的两个重要概念，它们都是用于类的方法。正是由于重载和重写，类的多态性得到了充分的展现。\",\"重载（Overloading）：\",\"重载指的是在一个类中定义多个方法，这些方法具有相同的方法名称，但是参数的个数不同，或者参数的类型不同，或者是参数的顺序不同。重载的方法通过调用时的参数的类型或者数量、顺序来区分调用了哪个方法。重载的方法的返回结果的类型也可以是不同的，但是不能返回结果的类型来定义方法的重载。\",\"重载有以下的特点：\",\"方法名称相同，参数的类型可以不同、参数的个数也可以不同、参数的顺序也可以不同\",\"不同的重载方法可以返回不同的结果；但是不同的返回结果不能作为方法重载的定义。\",\"编译是通过方法的不同的参数来确定方法\",\"代码示例：\",\"public class OverLodingDemo { public static void main(String[] args) { OverLodingDemo demo=new OverLodingDemo(); demo.greeting(\\\"lisi\\\"); demo.greeting(\\\"lisi\\\",\\\"wangwu\\\"); } public void greeting(String name){ System.out.println(\\\"hello \\\"+name); } public void greeting(String name1,String name2){ System.out.println(\\\"hello \\\"+name1 ); System.out.println(\\\"hello \\\"+name2 ); } } \",\"在上面的例子中，有两个greeting方法，这两个greeting方法有不同的参数个数，属于方法的重载。\",\"重写（Overriding）：\",\"重写是指子类对父类方法的重写，它是子类对父类的同名方法且具有相同的参数的重新实现。子类通过重写父类的方法来修改或者扩展父类方法的行为。\",\"被重写的方法具有以下的特点：\",\"子类的方法名称和父类完全相同，且具有相同的参数和返回结构类型\",\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别。\",\"它是动态绑定来确定运行时对象的实际方法的调用。\",\"举个简单的例子，有Animal的父类，有一个eat的方法：\",\"public class Animal { public void eat(){ System.out.println(\\\"animal eat\\\"); } } \",\"Sheep继承了Animal父类，并重写了eat方法：\",\"public class Sheep extends Animal{ @Override public void eat(){ System.out.println(\\\"sheep eat grass\\\"); } } \",\"Dog继承了Animal父类，没有重写了eat方法：\",\"public class Dog extends Animal{ } \",\"写一个测试类：\",\"public class OverwrittingDemo { public static void main(String[] args) { Animal sheep=new Sheep(); sheep.eat(); Animal dog=new Dog(); dog.eat(); } } \",\"执行结果如下：\",\"sheep eat grass animal eat\",\"总结：\",\"重载是针对于同个类中，重新是发生在子类和父类的继承关系之间。\",\"重载是根据方法的参数列表进行区分，重写是根据方法的名称和参数列表进行区分。\",\"重载方法在编译时静态地绑定，而重写方法在运行时动态地绑定。\",\"重载方法可以有不同的返回类型，而重写方法必须具有相同的返回类型。\"]},\"180\":{\"h\":\"抽象类和接口的区别\",\"t\":[\"抽象类\",\"抽象类通过使用关键字 \\\"abstract\\\" 来声明，它不能被实例化，只能用作基类或父类来使用。抽象类用于定义通用的属性和行为，可以包含抽象方法、普通方法、字段以及构造方法。抽象方法只有方法签名，没有方法体。抽象方法必须在非抽象子类中被重写实现。\",\"抽象类通常为其子类提供一个通用的模板，子类必须实现抽象类中的抽象方法。\",\"以下是一个抽象类的示例：\",\"public abstract class Shape { private String color; public Shape(String color) { this.color = color; } abstract double getArea(); } public class Circle extends Shape{ private double radius; public Circle(String color, double radius) { super(color); this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } } public class Demo { public static void main(String[] args) { Shape circle=new Circle(\\\"blue\\\",23); System.out.println(circle.getArea()); } } \",\"在上面的这个例子中，抽象类 Shape 声明了抽象方法 getArea() 。Circle 是其子类，并实现了抽象方法。需要注意的是虽然抽象类Shape具有构造函数，但是它是不能给被实例化的。可以通过抽象类的引用变量来指向它的实现类的实例。在上述示例中，可以使用 Shape 类型的引用变量 引用了 Circle 的实例对象。\",\"接口\",\"接口使用interface关键字定义的，它定义了一组方法的方法，通常是抽象方法，这些方法只有方法签名，没有方法体。这些抽象方法通常是定义了一组规范或者行为，但是没有实现。\",\"接口可以被类实现，一个类可以实现多个接口，而且同一个接口可以被多个类实现，从而使得一个实现类有不同接口的多态性。\",\"在接口定义中，方法默认是抽象类并且是pulic方法，所以在定义接口方法时不需要添加关键字 public和abstract。接口定义中可以包含常量、默认方法（Java 8 及以上版本）、静态方法（Java 8 及以上版本）和私有方法（Java 9 及以上版本）。\",\"以下是一个接口的示例：\",\" interface Animal { int LEGS = 4; // 常量 void makeSound(); // 抽象方法 default void sleep() { // 默认方法 System.out.println(\\\"Animal is sleeping.\\\"); } static void eat() { // 静态方法 System.out.println(\\\"Animal is eating.\\\"); } private void run() { // 私有方法 System.out.println(\\\"Animal is running.\\\"); } } public class Dog implements Animal{ @Override public void makeSound() { System.out.println(\\\"dog bark\\\"); } } public class AnimalDemo { public static void main(String[] args) { Dog dog = new Dog(); dog.makeSound(); dog.sleep(); Animal.eat(); } } \",\"在上面的例子中，\",\"接口Animal，定义了常量 LEGS 和抽象方法 makeSound()，以及默认方法 sleep() 和静态方法 eat()。Dog 类实现了 Animal 接口，实现了 makeSound() 方法。\",\"注意几点：\",\"类通过使用关键字 \\\"implements\\\" 来实现接口。一个类可以实现多个接口\",\"接口中的常量默认是静态常量。默认被 public static final 关键字修饰，可以直接通过接口名直接访问。\",\"接口的默认方法可以被实现该接口的类直接使用，实现类也可以重写接口的默认方法。\",\"静态方法在接口中提供了一些与接口相关的工具方法，可以直接通过接口名调用。\",\"私有方法在接口中定义一些辅助方法，只能在接口内部被调用，不能被实现类调用。\",\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为。通过实现接口，我们可以实现代码的解耦和类之间的松耦合。接口还为多重继承提供了解决方案，使得一个类可以具备多种类型的行为。\",\"抽象类VS接口\",\"抽象类和接口是Java中用于实现抽象和多态性的两个关键概念。它们有一些共同点，但也有一些区别。\",\"区别如下：\",\"实现方式：\",\"抽象类：通过关键字 abstract 定义的类，可以包含普通方法和抽象方法，可以有实例变量和构造方法。可以被继承，用于构建类的继承层级结构。\",\"接口：通过关键字 interface 定义的，只能包含常量和抽象方法（Java 8 之后，接口也可以包含默认方法和静态方法）。没有实例变量和构造方法。可以被类实现，用于实现类的多态性。\",\"多继承的支持：\",\"抽象类：Java只支持单继承，一个类只能继承一个抽象类。\",\"接口：Java支持多实现，一个类可以实现多个接口。\",\"构造方法：\",\"抽象类：可以有构造方法，用于实例化抽象类的对象。\",\"接口：不能有构造方法，接口只提供方法的声明，不能实例化对象。\",\"方法实现：\",\"抽象类：可以包含普通方法的实现。子类可以选择性地重写或调用父类的普通方法。\",\"接口：只能包含抽象方法的声明，不包含方法的实现。实现接口的类必须提供所有抽象方法的具体实现。\",\"设计目的：\",\"抽象类：用于描述一种通用的概念，如动物类、车类等，提供一些通用方法的实现，用作其他类的基类。\",\"接口：用于定义一组合同类型的操作，描述了一个类应该具备的行为，提供了一种通用的规范，用于实现类的多态性。\",\"需要注意的是，如果一个类既需要作为其他类的基类，又需要进行多种类型的实现，那么在设计时可以考虑将类设计为抽象类，并实现相关接口。这样可以兼顾抽象类和接口的优势。\"]},\"181\":{\"h\":\"为什么Java不支持多继承\",\"t\":[\"多继承是指一个类可以从多个父类继承属性和方法。尽管多继承在某些情况下可能很有用，但它也带来了一些问题。\",\"命名冲突：当一个类从多个父类继承相同名称的属性或方法时，可能会产生命名冲突。解决这些冲突需要额外的语法规则和解析过程，增加了语言的复杂性和理解上的困惑。\",\"菱形继承问题：多继承可能导致菱形继承问题，即当一个类同时继承自两个具有共同父类的类时，可能在继承链中得到两个相同的父类实例，导致不确定性。\",\"Java不支持多继承是为了避免多继承带来的上述问题。\",\"Java选择了单继承并使用了接口（interface）来解决多继承的需要。一个类可以实现多个接口，从而达到类似多继承的效果。使用接口可以避免命名冲突和菱形继承问题，并且提供了更灵活的类组合方式。\",\"在Java中，接口的设计可以更好地支持代码的组织和抽象，同时提供了更好的可维护性和扩展性。Java的设计理念是\\\"Prefer composition over inheritance\\\"（倾向于组合而非继承），鼓励使用组合和接口实现代码的复用和扩展。这种设计思想能够提高代码的可读性、可维护性和可扩展性。\"]},\"182\":{\"h\":\"String和StringBuffer、StringBuilder的区别是什么\",\"t\":[\"在Java中，String、StringBuffer和StringBuilder是用于处理字符串的类，它们之间有以下区别：\",\"可变性： \",\"String是不可变（Immutable）的类，一旦创建就不能被修改。每次对String进行修改操作都会创建一个新的String对象，原来的String对象不会被改变。\",\"StringBuffer和StringBuilder是可变（Mutable）的类，可以在原有对象的基础上进行修改。可以对其进行修改、删除、替换等操作，而不会创建新的对象。\",\"线程安全性： \",\"String是线程安全的，可以被多个线程同时访问而不会导致错误。\",\"StringBuffer是线程安全的，它的方法都使用了synchronized关键字来进行同步，保证了线程安全。\",\"StringBuilder是非线程安全的，在单线程环境中，StringBuilder的性能比StringBuffer性能更好。\",\"性能： \",\"由于String是不可变的，每次对String进行修改时都要创建一个新的对象，当需要频繁修改字符串时会产生大量的垃圾对象，对性能会有一定的影响。\",\"StringBuffer和StringBuilder是可变的，对字符串进行操作时不需要创建新的对象，因此在频繁修改字符串的场景下，性能较好。\",\"使用场景：\",\"当字符串不需要修改时，可以使用String。\",\"当需要对字符串进行频繁的修改时，建议使用StringBuffer或StringBuilder。\",\"如果在多线程环境下执行字符串操作，建议使用StringBuffer来保证线程安全。\",\"如果在单线程环境下进行字符串操作，可以使用StringBuilder来获得更好的性能。\"]},\"183\":{\"h\":\"如何理解面向过程和面向对象\",\"t\":[\"面向过程（Procedural Programming）和面向对象（Object-Oriented Programming）是两种不同的编程范式。\",\"面向过程是一种基于步骤和函数的编程方法。在面向过程编程中，程序被分解为可重用的功能模块，每个模块都包含一系列的操作步骤。程序按照一定的顺序执行这些步骤来完成任务。面向过程的关注点主要在于解决问题的步骤和流程。\",\"相比之下，面向对象是一种基于对象和类的编程方法。在面向对象编程中，程序由相互作用的对象组成，每个对象都是某个类的实例。每个对象都有自己的状态（属性）和行为（方法）。对象之间通过消息传递来进行通信和协作。面向对象的关注点主要在于构建对象的结构和定义对象的行为。\",\"面向过程和面向对象都有各自的优点和适用场景。面向过程更适合简单的任务和算法，它更直观、易于理解和调试。面向对象更适合复杂的应用，它具有更好的可维护性、可扩展性和重用性。\",\"在实际编程中，可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法，或者结合两者的特点使用混合编程。\"]},\"184\":{\"h\":\"Java基本类型为什么需要包装类\",\"t\":[\"Java基本类型（比如int、char、float、double等）需要包装类的原因有以下几个方面：\",\"泛型支持：Java的泛型不支持基本类型，只能使用对象类型。所以如果想要在泛型中使用一个基本类型的值，就需要将其包装成相应的对象类型。\",\"null赋值: 基本类型的取值范围是有限的，不能表示空值或null。使用包装类可以使得变量可以被赋值为null，方便更好地表示一个变量无值的状态。\",\"面向对象：Java是一种面向对象的语言，基本类型不是对象。如果使用基本类型，就无法访问其对象方法和属性。使用包装类可以让基本类型像一个对象一样使用。\",\"方法重载：Java不允许在方法中使用同名的不同类型的参数。因为基本类型的参数值之间无法进行隐式转换，所以需要使用包装类来为这些基本类型提供一个相应的对象类型，以便方法可以在这些对象类型之间进行选择。\",\"其他一些功能：包装类还提供了许多其他功能，比如数学运算、类型转换和字符串解析等。\",\"Java提供了对应的包装类来对基本类型进行包装，例如Integer、Character、Float、Double等等。这些包装类实现了相应类型的对象类型，提供了访问基本类型数据的方法。\",\"对于包装类，还有一些需要注意的点：\",\"包装类都是不可变的，一旦创建，其值就不能被修改。\",\"包装类的值比较应该使用equals()方法而不是==，因为包装类对象在使用==比较时，比较的是引用而不是值，这可能导致意外的结果。\",\"在自动装箱和拆箱时，Java会自动调用相应的包装类方法。\",\"例如，以下代码演示了使用包装类实现基本类型的自动装箱和拆箱：\",\"Integer i = 10; // 自动装箱 int j = i; // 自动拆箱 \",\"在这个例子中，编译器会自动将10包装成一个Integer对象，并将其赋值给i。在下一行，编译器又将i自动拆箱成int值，然后赋值给j。\"]},\"185\":{\"h\":\"如何理解java中的多态\",\"t\":[\"在 Java 中，多态是面向对象编程的一个核心概念，它允许我们使用父类的引用变量来引用子类的对象实例。多态主要体现在方法的重写和方法的动态绑定上。\",\"具体来说，可以通过以下几个方面来理解 Java 中的多态：\",\"父类引用指向子类对象实例。这样做的好处是可以通过统一的接口来操作不同的子类对象，实现了代码的灵活性和扩展性。\",\"方法的重写：子类可以重写（覆盖）从父类继承过来的方法。当使用父类引用指向子类对象时，通过父类引用调用重写的方法时，实际上会调用子类中的方法，这就实现了运行时的动态绑定。\",\"动态绑定：Java 的方法调用是基于运行时类型而不是编译时类型。也就是说，当调用一个对象的方法时，实际调用的是该对象的实际类型中定义的方法。这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象，实现了多态性的特性。\",\"多态性是继承的一个重要应用，它让我们可以使用父类的引用变量来引用不同子类的对象，并根据实际对象的类型来执行对应的方法。这样做的好处是实现了代码的灵活性、可扩展性和易维护性。\",\"例如，假设有一个抽象类 Animal 和它的两个子类 Cat 和 Dog，它们都有一个共同的方法 makeSound()：\",\"abstract class Animal { public abstract void makeSound(); } class Cat extends Animal { @Override public void makeSound() { System.out.println(\\\"Meow!\\\"); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\\\"Woof!\\\"); } } \",\"现在我们可以通过 Animal 类的引用变量来引用 Cat 或 Dog 对象，并根据实际对象的类型来调用 makeSound() 方法：\",\"Animal animal1 = new Cat(); Animal animal2 = new Dog(); animal1.makeSound(); // 输出 \\\"Meow!\\\" animal2.makeSound(); // 输出 \\\"Woof!\\\" \",\"在这个例子中，我们使用父类 Animal 的引用变量 animal1 和 animal2 分别引用了 Cat 和 Dog 对象。当调用 makeSound() 方法时，由于动态绑定的机制，实际上调用的是 Cat 和 Dog 对象中重写的 makeSound() 方法。\",\"需要注意的是在使用父类引用的变量去调用方法时，只能调用父类中声明的方法和子类中重写了父类的方法。要调用子类特有的方法，需要将父类引用的变量进行转换成子类的类型。\"]},\"186\":{\"h\":\"\"},\"187\":{\"h\":\"谈谈final、finally、finalize的区别\"},\"188\":{\"h\":\"java基础高频面试题2\"},\"189\":{\"h\":\"\\\"==\\\" 和 \\\"equals\\\" 的区别\",\"t\":[\"\\\"==\\\" 和 \\\"equals\\\" 都可以用于比较 Java 中的对象，但是它们之间有一些区别。\"]},\"190\":{\"h\":\"关系操作符号“==”\",\"t\":[\"基本数据类型\",\"在Java中有八种基本数据类型：\",\"浮点型：float(4 byte), double(8 byte)\",\"整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)\",\"字符型: char(2 byte)\",\"布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)\",\"对于基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符 “== ”来进行比较时，比较的就是“值”本身。要注意的是，浮点型和整型都是有符号类型的（最高位仅用于表示正负，不参与计算【以 byte 为例，其范围为 -2^7 ~ 2^7 - 1，-0即-128】），而char是无符号类型的（所有位均参与计算，所以char类型取值范围为0~2^16-1）。\",\"举个例子：\",\"int a = 5; int b = 5; System.out.println(a == b); // true \",\"引用类型变量\",\"在Java中，引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址。如果使用== 操作符去判断引用类型的变量，则比较的内容是判断两个变量的引用是否相等，即它们是否指向同一个对象。如果两个变量的引用指向同一个对象，那么它们之间的 == 比较结果为 true。如果两个引用指向不同的对象，那么它们之间的 ==比较结果为 false。例如：\",\"String str1 = \\\"abc\\\"; String str2 = \\\"abc\\\"; String str3 = new String(\\\"abc\\\"); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false \",\"在上述示例中，str1 和 str2 都指向常量池中的同一个字符串对象，因此它们之间的 == 比较结果为 true。而 str3 则指向一个新创建的字符串对象，所以它们之间的 == 比较结果为 false。\"]},\"191\":{\"h\":\"\\\"equals\\\"\",\"t\":[\"在初学Java的时候，很多人会说在比较对象的时候，“==”操作符是比较两个变量的内存地址，equals()是比较对象的内容，其实不然。\",\"在Object类中，equals()方法是比较两个对象的内存地址是否相等，代码如下：\",\"public boolean equals(Object obj){ return (this == obj); } \",\"为什么会有人把equals方法当做是比较两个内容的比较呢？是因为在String、Double等封装类中，已经重写了(ov了Object类的equals()方法。比如在String内中，它比较的是对字符串内容的比较：\",\"public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } \",\"在String类的方法中，先比较的是字符串地址是否相等，如果相等，则字符串内容肯定是相等；然后地址不相等，则比较字符串内容是否相等。\",\"在实际的开发中，我们对对象内容的比较，通常都需要重写equals()方法。当我们重写equals()方法，需要遵循以下几个规则：\",\"自反性：对于任何非null的引用值x，x.equals(x)应返回true。\",\"对称性：对于任何非null的引用值x和y，如果x.equals(y)返回true，则y.equals(x)也应返回true。\",\"传递性：对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，则x.equals(z)也应返回true。\",\"一致性：对于任何非null的引用值x和y，如果用于比较的对象信息没有被修改，则x.equals(y)的多次调用应始终返回相同的结果。\",\"非空性：对于任何非null的引用值x，x.equals(null)应返回false。\"]},\"192\":{\"h\":\"\\\"equals\\\" 和hashcode的关系\",\"t\":[\"当我们在重写equals()方法时，通常也需要重写hashCode()方法。这是因为我们在使用基于散列的数据结构，比如如哈希表，以及一些集合类（如HashSet、HashMap）时，hashCode()方法的返回值将被用作对象的索引。\",\"当我们重写equals()方法时，经常选择使用对象的一些属性进行比较，以确定两个对象是否相等。在这种情况下，为了保持一致性，我们需要使用相同的属性来计算hashCode()值。\",\"如果我们没有重写hashCode()方法，那么hashCode()的默认行为是使用对象的内存地址计算哈希码，这与equals()方法的比较内容无关。这将导致具有相等内容的对象，通过hashCode()方法计算出来的哈希码可能不相等，这将导致在存储和查找对象时出现问题。\",\"所以，正确地重写hashCode()方法是很重要的。以下是一些在重写hashCode()方法时需要注意的规则：\",\"一致性：在对象的生命周期中，只要对象的属性没有发生改变，那么hashCode()应始终返回相同的值。\",\"相等性：如果两个对象根据equals()方法比较相等，那么它们的hashCode()方法应返回相同的值。\",\"分布均匀性：尽量避免不同对象返回相同的hashCode()值，以减少哈希冲突的概率，提高散列存储结构的性能。\",\"一种常用的方式来重写hashCode()方法是，根据对象的每个属性计算一个哈希码，然后将这些哈希码组合在一起，以获得最终的哈希码。这可以通过使用乘法和加法等算法来实现。如果某个属性可以为null，则需要特殊处理，以避免空指针异常。\",\"比如在String类中，hashCode()方法的定义如下：\",\" public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i < value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } \"]},\"193\":{\"h\":\"java中的异常处理机制\",\"t\":[\"Java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况，以确保程序的正常执行。\",\"异常类层次结构\",\"在Java中，Exception、Error和Throwable是一个类层次结构中的相关类。\",\" <<class>> Throwable ---------------- | | <<class>> <<class>> Exception Error | ------------------ | | checked unchecked \",\"Throwable是所有异常类的根类，它位于异常类的最顶层。它定义了可以被抛出和捕获的异常对象的基本功能。Throwable有两个重要的子类：Exception和Error。\",\"Exception是可控制的异常类，通常表示程序中可预见的异常情况，可以被捕获并进行相应处理。它是Throwable的一个子类。\",\"Exception又分为两种类型：checked异常和unchecked异常。checked异常需要在代码中进行处理或声明，否则编译器会报错；unchecked异常不要求在代码中进行处理或声明。\",\"自定义异常：Java允许开发者自定义异常类，以便更好地抽象和组织程序中可能发生的异常情况。自定义异常类通常继承自Exception或RuntimeException类\",\"Error是不可控制的严重问题的异常类，通常表示系统的严重错误或问题，大多数情况下不会被程序显式地捕获和处理，而是由Java运行时环境（JVM）来处理。Error也是Throwable的一个子类。\",\"异常处理语句\",\"Java语言中提供了一些列的异常处理关键字和处理模板。\",\"抛出异常，使用throw语句。可以使用throw语句在程序中主动抛出异常，从而触发异常处理机制。\",\"声明异常：使用throws关键字，在方法签名中明确指定可能抛出的异常类型，这样调用者就能清楚地知道需要处理哪些异常。\",\"捕获异常，常使用try-catch-finally异常处理语句模板 \",\"try块：try块用于包裹可能发生异常的代码片段。当try块中的代码发生异常时，异常将被抛出，程序流程将跳转到catch块或finally块。\",\"catch块：catch块用于捕获并处理指定类型的异常。catch块可以捕获多个异常类型，并按照顺序处理异常。\",\"finally块：finally块用于定义无论是否发生异常都需要执行的代码，例如释放资源。finally块在try块或catch块执行完毕后执行。\",\"举个例子，演示了try-catch-finally的用法：\",\"public class ExceptionExample { public static void main(String[] args) { try { int result = divide(10, 0); System.out.println(\\\"结果：\\\" + result); } catch (ArithmeticException e) { System.out.println(\\\"除零错误：\\\" + e.getMessage()); } finally { System.out.println(\\\"执行finally块\\\"); } } public static int divide(int num1, int num2) { return num1 / num2; } } \",\"在上述代码中，定义了一个divide方法，用于计算两个数的除法操作。由于除数为0会产生算术异常（ArithmeticException），我们使用try-catch语句对可能发生异常的代码块进行了包裹。\",\"在try代码块中，我们调用了divide方法并将结果存储在result变量中。\",\"如果在此过程中发生了异常，程序会立即跳转到catch代码块中，并执行与异常类型匹配的处理代码。在\",\"无论是否发生异常，finally代码块中的代码始终会执行。\",\"执行上述代码，输出如下：\",\"除零错误：/ by zero 执行finally块 \",\"Java的异常处理机制是Java程序设计中非常重要的一个方面，它能够有效地处理程序中可能发生的异常情况，并提供了良好的可读性和可维护性。通过合理地使用try-catch-finally块，对异常进行合适的处理，防止程序因为出现异常而奔溃，是程序的稳定性和健壮性的一种保护机制。\"]},\"194\":{\"h\":\"JDK、JRE、JVM的区别和联系\",\"t\":[\"JDK（Java Development Kit）是Java开发工具包，提供了一套完整的开发工具，包括编译器（javac）、调试器（jdb）、打包工具（jar）等。使用JDK可以进行Java应用程序的开发和构建，生成可执行的Java应用程序。JDK还提供了各种开发文档和示例代码，帮助开发者学习和使用Java。\",\"JRE（Java Runtime Environment）是Java运行时环境，是在目标机器上运行Java应用程序所需的最小环境。它包含了JVM（Java Virtual Machine）和Java类库。当用户在目标机器上运行Java应用程序时，需要先安装JRE。JRE只提供了Java应用程序的运行环境，不包含开发工具。\",\"JVM（Java Virtual Machine）是Java虚拟机，是Java平台的核心部分。它是一个抽象的计算机，可以在不同的操作系统上运行Java程序，实现了Java的跨平台特性。JVM解析Java字节码，并将其转换为底层操作系统可以执行的机器码。它还具有内存管理、垃圾回收等功能，确保Java应用程序的安全、高效执行。\",\"他们之间的关系如下：\",\"JDK包含JRE，因为在开发Java应用程序时需要运行Java程序来进行测试和调试。\",\"JRE包含JVM，因为在运行Java应用程序时需要虚拟机来解释和执行Java字节码。\"]},\"195\":{\"h\":\"final关键字详解\"},\"196\":{\"h\":\"final关键字的基本用法\",\"t\":[\"final关键字，用于表示不可变，表示变量或者方法定义后不能被修改或者重写。final关键字可以用于修饰类、方法和变量。\",\"修饰类：当类被声明为final时，表明该类不能被继承。它是一个最终类，不能有子类继承它。\",\"public final class FinalTest { } \",\"修饰方法: 当方法被声明为final时，该方法不能被子类重写。子类只能继承父类中的final方法，但不能修改其实现。\",\"public class FinalMethodDemo { public final void test(){ System.out.println(\\\"test\\\"); } static class FinalMethodeDemo2 extends FinalMethodDemo{ //编译不通过 @Override public void test(){ System.out.println(\\\"test\\\"); } } } \",\"FinalMethodeDemo2是不能重新它的父类FinalMethodDemo的final方法的，编译的时候会报错。idea会提示错误，如下图所示：\",\"修饰变量: 当变量被声明为final时，该变量的值不能被修改，即它成为一个常量。一旦被赋值，就不能再更改。\",\"对于实例变量（成员变量），可以在代码块中赋值，也可以在构造函数中赋值，一旦赋值就不能被改变：\",\" private final String s1=\\\"s1\\\"; // { // s1=\\\"s1\\\"; //在代码快中赋值 // } private static final String s2; static { s2=\\\"s2\\\"; //在静态代码快中赋值 } private final String s3; //在构造函数中赋值 public FinalTest(String s3) { this.s3 = s3; } \",\"对于被final修饰的局部变量，在使用前必须赋值。\",\" public void test2(){ final String s; s=\\\"ss\\\"; System.out.println(s);//在使用final变量前必须赋值 } \",\"如果被final修饰的变量时引用类型，则在变量初始化后，就不能再指向另一个对象了，但是变量的值是可以被修改的。示例代码如下：\",\"public class FinalObject { public static void main(String[] args) { final int[] arrays=new int[]{1,2,3}; // arrays=null; 非法 final Person person=new Person(\\\"sam\\\",1); person.setAge(2); // person=null; 非法 } static class Person { private String Name; private int age; public Person(String name, int age) { Name = name; this.age = age; } public String getName() { return Name; } public void setName(String name) { Name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } } \",\"final关键字的使用可以增加代码的可读性，提高代码的安全性，以及优化性能。它可以在合适的场景中使用，例如常量、线程安全等需要不可变性的情况。\"]},\"197\":{\"h\":\"为什么内部类引用的外部变量必须用final修饰\",\"t\":[\"JDK1.8之后，如果将局部变量（或表达式）传递给匿名内部类或Lambda表达式作为捕捉的变量，它们会被隐式地视为final，是不可以被更改的。\",\"为什么会这样呢？\",\"public abstract class Task { public abstract void run(); } public class FinalDemo { public void run1(final String taskname) { Task task = new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname +\\\" run\\\"); } }; task.run(); } public void run2(final String taskname) { new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname+\\\" run\\\"); } }.run(); } public static void main(String[] args) { FinalDemo demo = new FinalDemo(); demo.run1(\\\"task1\\\"); demo.run2(\\\"task2\\\"); } } \",\"首先，内部类和外部类其实是处于同一个级别，反编译中可以看到都是对象级别的类文件，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁。\",\"如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。\",\"如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中(反编译class文件中可以看到)，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。\"]},\"198\":{\"h\":\"谈谈final、finally、finalize的区别\",\"t\":[\"final是Java中的修饰符，可以用来修饰类、方法和变量，表示不可改变的\",\"修饰类：当类被声明为final时，该类不能被继承，成为最终类。\",\"修饰方法：当方法被声明为final时，该方法不能被子类重写，成为最终方法。\",\"修饰变量：当变量被声明为final时，该变量的值一旦被赋值，不能被修改，成为常量。\",\"finally：finally是Java中的关键字，用于异常处理的最后一个代码块，在try-catch语句中使用。无论是否发生异常，finally块中的代码都会被执行。\",\"try { // 可能会发生异常的代码 } catch (Exception e) { // 异常处理逻辑 } finally { // 最终会执行的代码块 } \",\"finally块通常用于释放资源、关闭连接等必须执行的操作，以确保代码的可靠性。即使在try块或catch块中出现return语句，finally块中的代码也会在方法返回之前执行。\",\"finalize：finalize是一个方法，它是在对象被垃圾回收器回收之前调用的。每个类都可以重写finalize方法来执行对象的清理操作。\",\"需要注意的是，finalize方法已经过时，不推荐使用了。因为垃圾回收器的工作是由Java虚拟机自动处理的，无法保证finalize方法的及时执行。更好的做法是使用try-finally或其他资源管理机制来确保资源的释放。\",\"@Override protected void finalize() throws Throwable { // 进行资源释放或清理操作 super.finalize(); } \"]},\"199\":{\"h\":\"finally语句到底是在return之前还是之后执行？\",\"t\":[\"在回答这个问题前，先来说一下finally语句是不会被执行的情况：\",\"try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要条件是：相应的try语句一定被执行到。\",\"在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，finally语句也不会被执行到。\",\"finally语句到底是在return之前还是之后执行？\",\"当没有发生异常时：如果在try块中没有发生异常，finally语句将在try块执行完毕后立即执行。然后，程序将继续执行后续的代码。finally块中的代码将在return语句执行之后、方法返回之前执行。\",\"请看下面的示例代码：\",\"public class FinalReturn1 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a = 1; try { return a; } finally { a = 2; //idea提示：The value 2 assigned to 'a' is never used System.out.println(\\\"Finally block executed.\\\"); } } } \",\"在这个示例中，无论try块中是否发生异常，finally块中的代码都会被执行。控制台会输出以下内容：\",\"Finally block executed. 1 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在catch中再次使用了return操作，则会覆盖try里面的return操作。\",\"package io.github.forezp.javabasiclab.finaltest; public class FinalReturn2 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 2 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\",\"public class FinalReturn3 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); a=3; return 4; } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 4 \",\"总结来说，finally语句在Java中用于定义一段无论是否发生异常都会执行的代码块。它在try块或catch块中的代码执行完毕后立即执行，并且在方法返回之前被执行。\",\"在try或catch块中使用return语句时，finally块中的代码也会在return语句执行后执行。(finally语句中没有使用return操作)\",\"如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\"]}},\"dirtCount\":0,\"index\":[[\"控制台会输出以下内容\",{\"1\":{\"199\":3}}],[\"控制台打出的结果如下\",{\"1\":{\"87\":1}}],[\"成为常量\",{\"1\":{\"198\":1}}],[\"成为最终方法\",{\"1\":{\"198\":1}}],[\"成为最终类\",{\"1\":{\"198\":1}}],[\"成员变量\",{\"1\":{\"196\":1}}],[\"然而内部类的某个方法还没有执行完\",{\"1\":{\"197\":1}}],[\"然后执行相应的catch块\",{\"1\":{\"199\":2}}],[\"然后将这些哈希码组合在一起\",{\"1\":{\"192\":1}}],[\"然后将apistatinterceptor注册到webmvcconfigurer中\",{\"1\":{\"154\":1}}],[\"然后地址不相等\",{\"1\":{\"191\":1}}],[\"然后赋值给j\",{\"1\":{\"184\":1}}],[\"然后用案例讲解了这些类的使用\",{\"1\":{\"177\":1}}],[\"然后用\",{\"1\":{\"164\":1}}],[\"然后通过命令行的方式的启动它\",{\"1\":{\"161\":1}}],[\"然后通过配置文件的形式来具体讲解\",{\"1\":{\"158\":1}}],[\"然后创建一个handlerinterceptoradapter的拦截器\",{\"1\":{\"154\":1}}],[\"然后\",{\"1\":{\"153\":1,\"154\":1,\"199\":1}}],[\"然后在浏览器上访问http\",{\"1\":{\"154\":1}}],[\"然后在springboot的配置文件application\",{\"1\":{\"153\":1}}],[\"然后在grafana展示node\",{\"1\":{\"122\":1}}],[\"然后去grafana官方网站的dashboard社区找一个node\",{\"1\":{\"127\":1}}],[\"然后使用装饰器模式\",{\"1\":{\"87\":1}}],[\"然后getinstance\",{\"1\":{\"74\":1}}],[\"反编译class文件中可以看到\",{\"1\":{\"197\":1}}],[\"反编译中可以看到都是对象级别的类文件\",{\"1\":{\"197\":1}}],[\"反转等\",{\"1\":{\"174\":1}}],[\"传递给匿名内部类或lambda表达式作为捕捉的变量\",{\"1\":{\"197\":1}}],[\"传递性\",{\"1\":{\"191\":1}}],[\"示例代码如下\",{\"1\":{\"196\":1}}],[\"修饰变量\",{\"1\":{\"196\":1,\"198\":1}}],[\"修饰方法\",{\"1\":{\"196\":1,\"198\":1}}],[\"修饰类\",{\"1\":{\"196\":1,\"198\":1}}],[\"修改某个键对应的值\",{\"1\":{\"176\":1}}],[\"修改列表中的元素\",{\"1\":{\"174\":1}}],[\"修改元素\",{\"1\":{\"174\":1}}],[\"他们之间的关系如下\",{\"1\":{\"194\":1}}],[\"高效执行\",{\"1\":{\"194\":1}}],[\"确保java应用程序的安全\",{\"1\":{\"194\":1}}],[\"确定当前告警应该如何处理\",{\"1\":{\"162\":1}}],[\"垃圾回收等功能\",{\"1\":{\"194\":1}}],[\"帮助开发者学习和使用java\",{\"1\":{\"194\":1}}],[\"生成可执行的java应用程序\",{\"1\":{\"194\":1}}],[\"等\",{\"1\":{\"194\":1}}],[\"等待1分钟\",{\"1\":{\"164\":1}}],[\"打包工具\",{\"1\":{\"194\":1}}],[\"调试器\",{\"1\":{\"194\":1}}],[\"捕获异常\",{\"1\":{\"193\":1}}],[\"捕获并外部化对象的内部状态\",{\"1\":{\"68\":1}}],[\"声明异常\",{\"1\":{\"193\":1}}],[\"声明了抽象方法\",{\"1\":{\"180\":1}}],[\"抛出异常\",{\"1\":{\"193\":1,\"199\":2}}],[\"异常处理逻辑\",{\"1\":{\"198\":1}}],[\"异常处理语句\",{\"1\":{\"193\":1}}],[\"异常将被抛出\",{\"1\":{\"193\":1}}],[\"异常类层次结构\",{\"1\":{\"193\":1}}],[\"否则编译器会报错\",{\"1\":{\"193\":1}}],[\"否则将匹配不到\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"非法\",{\"1\":{\"196\":2}}],[\"非空性\",{\"1\":{\"191\":1}}],[\"非常容易的打包和部署\",{\"1\":{\"119\":1}}],[\"先来说一下finally语句是不会被执行的情况\",{\"1\":{\"199\":1}}],[\"先比较的是字符串地址是否相等\",{\"1\":{\"191\":1}}],[\"先了解这些核心概念\",{\"1\":{\"158\":1}}],[\"已经重写了\",{\"1\":{\"191\":1}}],[\"已解决\",{\"1\":{\"163\":1}}],[\"变量直接存储的是\",{\"1\":{\"190\":1}}],[\"仅规定其只能够取字面值\",{\"1\":{\"190\":1}}],[\"布尔型\",{\"1\":{\"190\":1}}],[\"布局与功能禁用\",{\"0\":{\"7\":1}}],[\"字符型\",{\"1\":{\"190\":1}}],[\"字段以及构造方法\",{\"1\":{\"180\":1}}],[\"整型\",{\"1\":{\"190\":1}}],[\"浮点型和整型都是有符号类型的\",{\"1\":{\"190\":1}}],[\"浮点型\",{\"1\":{\"190\":1}}],[\"谈谈final\",{\"0\":{\"187\":1,\"198\":1}}],[\"输出\",{\"1\":{\"185\":2}}],[\"输出如下\",{\"1\":{\"103\":1,\"110\":1,\"193\":1}}],[\"现在我们可以通过\",{\"1\":{\"185\":1}}],[\"现在使用责任链模式去模拟一个向公司借款的流程\",{\"1\":{\"92\":1}}],[\"假设有一个抽象类\",{\"1\":{\"185\":1}}],[\"覆盖\",{\"1\":{\"185\":1}}],[\"父类引用指向子类对象实例\",{\"1\":{\"185\":1}}],[\"泛型支持\",{\"1\":{\"184\":1}}],[\"易于理解和调试\",{\"1\":{\"183\":1}}],[\"属性\",{\"1\":{\"183\":1}}],[\"属于方法的重载\",{\"1\":{\"179\":1}}],[\"属于创建型设计模式的一种\",{\"1\":{\"95\":1}}],[\"属于懒汉模式\",{\"1\":{\"76\":1}}],[\"建议使用stringbuffer来保证线程安全\",{\"1\":{\"182\":1}}],[\"建议使用stringbuffer或stringbuilder\",{\"1\":{\"182\":1}}],[\"建一个first\",{\"1\":{\"164\":1}}],[\"替换等操作\",{\"1\":{\"182\":1}}],[\"鼓励使用组合和接口实现代码的复用和扩展\",{\"1\":{\"181\":1}}],[\"倾向于组合而非继承\",{\"1\":{\"181\":1}}],[\"菱形继承问题\",{\"1\":{\"181\":1}}],[\"尽量避免不同对象返回相同的hashcode\",{\"1\":{\"192\":1}}],[\"尽量以通俗易懂的语言和代码案例去讲述\",{\"1\":{\"64\":1}}],[\"尽管多继承在某些情况下可能很有用\",{\"1\":{\"181\":1}}],[\"又需要进行多种类型的实现\",{\"1\":{\"180\":1}}],[\"又被叫做最小知识原则\",{\"1\":{\"70\":1}}],[\"描述了一个类应该具备的行为\",{\"1\":{\"180\":1}}],[\"车类等\",{\"1\":{\"180\":1}}],[\"构造方法\",{\"1\":{\"180\":1}}],[\"之后\",{\"1\":{\"180\":1,\"199\":2}}],[\"区别如下\",{\"1\":{\"180\":1}}],[\"关闭连接等必须执行的操作\",{\"1\":{\"198\":1}}],[\"关系操作符号\",{\"0\":{\"190\":1}}],[\"关键字修饰\",{\"1\":{\"180\":1}}],[\"关于这些扩展\",{\"1\":{\"17\":1}}],[\"注意几点\",{\"1\":{\"180\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"42\":1}}],[\"私有方法在接口中定义一些辅助方法\",{\"1\":{\"180\":1}}],[\"私有方法\",{\"1\":{\"180\":1}}],[\"及以上版本\",{\"1\":{\"180\":3}}],[\"及划分责任和算法\",{\"1\":{\"68\":1}}],[\"引用类型的变量存储的并不是\",{\"1\":{\"190\":1}}],[\"引用类型变量\",{\"1\":{\"190\":1}}],[\"引用了\",{\"1\":{\"180\":1}}],[\"引入一个适配器类兼容现有目标类\",{\"1\":{\"83\":1}}],[\"普通方法\",{\"1\":{\"180\":1}}],[\"没有实例变量和构造方法\",{\"1\":{\"180\":1}}],[\"没有方法体\",{\"1\":{\"180\":2}}],[\"没有重写了eat方法\",{\"1\":{\"179\":1}}],[\"没有必要将多个事情给一个角色做完\",{\"1\":{\"83\":1}}],[\"子类只能继承父类中的final方法\",{\"1\":{\"196\":1}}],[\"子类可以重写\",{\"1\":{\"185\":1}}],[\"子类可以选择性地重写或调用父类的普通方法\",{\"1\":{\"180\":1}}],[\"子类必须实现抽象类中的抽象方法\",{\"1\":{\"180\":1}}],[\"子类的方法名称和父类完全相同\",{\"1\":{\"179\":1}}],[\"子类通过重写父类的方法来修改或者扩展父类方法的行为\",{\"1\":{\"179\":1}}],[\"被重写的方法具有以下的特点\",{\"1\":{\"179\":1}}],[\"被称为time\",{\"1\":{\"130\":1}}],[\"顺序来区分调用了哪个方法\",{\"1\":{\"179\":1}}],[\"正确地重写hashcode\",{\"1\":{\"192\":1}}],[\"正是由于重载和重写\",{\"1\":{\"179\":1}}],[\"正如mac电脑一样\",{\"1\":{\"83\":1}}],[\"常使用try\",{\"1\":{\"193\":1}}],[\"常量\",{\"1\":{\"180\":1}}],[\"常用的\",{\"1\":{\"176\":1}}],[\"常见的映射实现类有\",{\"1\":{\"173\":1}}],[\"常见的队列实现类有\",{\"1\":{\"173\":1}}],[\"常见的集实现类有\",{\"1\":{\"173\":1}}],[\"常见的集合接口包括\",{\"1\":{\"173\":1}}],[\"常见的列表实现类有\",{\"1\":{\"173\":1}}],[\"常见的逻辑运算符如下\",{\"1\":{\"141\":1}}],[\"按键查找值等\",{\"1\":{\"176\":1}}],[\"键值对数量\",{\"1\":{\"176\":1}}],[\"键的唯一性\",{\"1\":{\"176\":1}}],[\"键是唯一的\",{\"1\":{\"176\":1}}],[\"清空\",{\"1\":{\"176\":1}}],[\"清空集合\",{\"1\":{\"175\":1}}],[\"清空列表\",{\"1\":{\"174\":1}}],[\"检查\",{\"1\":{\"176\":1}}],[\"检查集合中是否包含某个元素\",{\"1\":{\"175\":1}}],[\"检查列表中是否包含某个元素\",{\"1\":{\"174\":1}}],[\"判断元素是否存在\",{\"1\":{\"175\":1}}],[\"快速查找\",{\"1\":{\"175\":1,\"176\":1}}],[\"快速的装载和卸载装饰器\",{\"1\":{\"88\":1}}],[\"添加键值对到\",{\"1\":{\"176\":1}}],[\"添加\",{\"1\":{\"175\":1}}],[\"添加操作会失败并返回\",{\"1\":{\"175\":1}}],[\"添加重复元素时\",{\"1\":{\"175\":1}}],[\"添加元素到集合中\",{\"1\":{\"175\":1}}],[\"添加元素到列表中\",{\"1\":{\"174\":1}}],[\"添加元素\",{\"1\":{\"174\":1}}],[\"且具有相同的参数和返回结构类型\",{\"1\":{\"179\":1}}],[\"且不允许包含重复的元素\",{\"1\":{\"175\":1}}],[\"且只支持浮点数指标\",{\"1\":{\"130\":1}}],[\"循环或\",{\"1\":{\"174\":1}}],[\"增强的\",{\"1\":{\"174\":1}}],[\"增加了语言的复杂性和理解上的困惑\",{\"1\":{\"181\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"100\":1}}],[\"增加告警规则的配置\",{\"1\":{\"164\":1}}],[\"增加采集node\",{\"1\":{\"125\":1}}],[\"增加项目的依赖\",{\"1\":{\"113\":1}}],[\"增加新的观察者\",{\"1\":{\"107\":1}}],[\"增加新的产品和新的工厂非常容易\",{\"1\":{\"100\":1}}],[\"增加系统的复杂性\",{\"1\":{\"103\":1}}],[\"遍历和删元素对象\",{\"1\":{\"176\":1}}],[\"遍历和删除集合中的元素\",{\"1\":{\"175\":1}}],[\"遍历\",{\"1\":{\"176\":1}}],[\"遍历集合中的元素\",{\"1\":{\"175\":1}}],[\"遍历列表中的元素\",{\"1\":{\"174\":1}}],[\"遍历列表\",{\"1\":{\"174\":1}}],[\"遍历等\",{\"1\":{\"173\":1}}],[\"排序\",{\"1\":{\"174\":1}}],[\"元素的顺序可以根据插入和删除操作的顺序动态改变\",{\"1\":{\"174\":1}}],[\"虽然它不是collection\",{\"1\":{\"173\":1}}],[\"虽然可能会造成一定资源开销和浪费\",{\"1\":{\"74\":1}}],[\"散列\",{\"1\":{\"173\":1}}],[\"队列\",{\"1\":{\"173\":1}}],[\"集\",{\"1\":{\"173\":1}}],[\"集合接口\",{\"1\":{\"173\":1}}],[\"集合是\",{\"1\":{\"173\":1}}],[\"列表操作\",{\"1\":{\"174\":1}}],[\"列表\",{\"1\":{\"173\":1}}],[\"删除某个键值对\",{\"1\":{\"176\":1}}],[\"删除键值对\",{\"1\":{\"176\":1}}],[\"删除列表中的元素\",{\"1\":{\"174\":1}}],[\"删除元素\",{\"1\":{\"174\":1,\"175\":1}}],[\"删除操作\",{\"1\":{\"173\":1}}],[\"删除\",{\"1\":{\"173\":1,\"174\":1,\"182\":1}}],[\"框架的类的思维导图如下\",{\"1\":{\"173\":1}}],[\"框架的根接口\",{\"1\":{\"173\":1}}],[\"框架的一些关键概念\",{\"1\":{\"173\":1}}],[\"编译的时候会报错\",{\"1\":{\"196\":1}}],[\"编译不通过\",{\"1\":{\"196\":1}}],[\"编译器又将i自动拆箱成int值\",{\"1\":{\"184\":1}}],[\"编译器会自动将10包装成一个integer对象\",{\"1\":{\"184\":1}}],[\"编译是通过方法的不同的参数来确定方法\",{\"1\":{\"179\":1}}],[\"编程语言中用于存储和操作对象的框架\",{\"1\":{\"173\":1}}],[\"编辑此页链接\",{\"1\":{\"7\":1}}],[\"表明该类不能被继承\",{\"1\":{\"196\":1}}],[\"表达式的含义是计算每分钟handler=\",{\"1\":{\"172\":1}}],[\"表示不可改变的\",{\"1\":{\"198\":1}}],[\"表示变量或者方法定义后不能被修改或者重写\",{\"1\":{\"196\":1}}],[\"表示聚合的级别和规则标签的输出\",{\"1\":{\"171\":1}}],[\"表示小于0\",{\"1\":{\"134\":2}}],[\"表示的是当前系统文件系统中磁盘可用的字节数\",{\"1\":{\"133\":1}}],[\"该变量的值一旦被赋值\",{\"1\":{\"198\":1}}],[\"该变量的值不能被修改\",{\"1\":{\"196\":1}}],[\"该方法不能被子类重写\",{\"1\":{\"196\":1,\"198\":1}}],[\"该表达式的计算时间间隔为1分钟\",{\"1\":{\"172\":1}}],[\"该类不能被继承\",{\"1\":{\"198\":1}}],[\"该类使用抽象工厂模式创建不同的产品对象\",{\"1\":{\"103\":1}}],[\"该类的职责是唯一的\",{\"1\":{\"70\":1}}],[\"应始终返回相同的值\",{\"1\":{\"192\":1}}],[\"应返回false\",{\"1\":{\"191\":1}}],[\"应返回true\",{\"1\":{\"191\":1}}],[\"应该遵循通用的方式\",{\"1\":{\"171\":1}}],[\"应对面试应该是足够的\",{\"1\":{\"69\":1}}],[\"命名冲突\",{\"1\":{\"181\":1}}],[\"命名规范\",{\"0\":{\"171\":1}}],[\"命令模式\",{\"1\":{\"68\":1}}],[\"避免出现一些无意义的计算\",{\"1\":{\"170\":1}}],[\"避免出现对业务的影响\",{\"1\":{\"121\":1}}],[\"警报规则的名称必须是有效的标签值\",{\"1\":{\"169\":1}}],[\"警告容器\",{\"1\":{\"19\":1}}],[\"记录规则的名称必须是有效的指标名称\",{\"1\":{\"169\":1}}],[\"记录和告警规则存在于规则组中\",{\"1\":{\"169\":1}}],[\"预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多\",{\"1\":{\"168\":1}}],[\"预测指标变化趋势\",{\"0\":{\"149\":1}}],[\"预测系统磁盘在6个小时之后的剩余情况\",{\"1\":{\"133\":1}}],[\"qq\",{\"1\":{\"167\":1}}],[\"queue\",{\"1\":{\"173\":3}}],[\"querying\",{\"1\":{\"151\":1}}],[\"quantile函数进行计算\",{\"1\":{\"150\":1}}],[\"quantile函数在prometheus\",{\"1\":{\"135\":1}}],[\"quantile\",{\"1\":{\"134\":1,\"146\":2,\"150\":3,\"156\":1}}],[\"quantile=\",{\"1\":{\"124\":5,\"135\":5}}],[\"参数的顺序也可以不同\",{\"1\":{\"179\":1}}],[\"参数的个数也可以不同\",{\"1\":{\"179\":1}}],[\"参数的类型可以不同\",{\"1\":{\"179\":1}}],[\"参数的配置会在以后的文章中讲解\",{\"1\":{\"163\":1}}],[\"参考文档\",{\"0\":{\"167\":1}}],[\"发送的告警消息的json格式如下\",{\"1\":{\"166\":1}}],[\"发布者对象可以对所有的观察者发送消息\",{\"1\":{\"107\":1}}],[\"发布者publisher\",{\"1\":{\"105\":1}}],[\"显示告警消息已经收到\",{\"1\":{\"165\":1}}],[\"允许包含重复的元素\",{\"1\":{\"174\":1}}],[\"允许元素的重复\",{\"1\":{\"174\":1}}],[\"允许重复元素\",{\"1\":{\"173\":1}}],[\"允许用户指定要附加到告警上的一组附加标签\",{\"1\":{\"164\":1}}],[\"允许prometheus运行\",{\"1\":{\"123\":1}}],[\"评估时间相同\",{\"1\":{\"169\":1}}],[\"评估等待时间\",{\"1\":{\"164\":1}}],[\"评论\",{\"1\":{\"7\":1,\"45\":1}}],[\"$value\",{\"1\":{\"164\":1}}],[\"前提条件是两个告警的alertname\",{\"1\":{\"163\":1}}],[\"禁止规则会静音与一组匹配器匹配的警报\",{\"1\":{\"163\":1}}],[\"禁用\",{\"2\":{\"9\":1}}],[\"禁用了如下功能\",{\"1\":{\"7\":1}}],[\"禁用展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"源\",{\"1\":{\"163\":1}}],[\"源码下载\",{\"0\":{\"80\":1,\"84\":1,\"89\":1}}],[\"即使在try块或catch块中出现return语句\",{\"1\":{\"198\":1}}],[\"即它成为一个常量\",{\"1\":{\"196\":1}}],[\"即它们是否指向同一个对象\",{\"1\":{\"190\":1}}],[\"即当一个类同时继承自两个具有共同父类的类时\",{\"1\":{\"181\":1}}],[\"即alertmanager通过http接口调用来发送告警消息\",{\"1\":{\"163\":1}}],[\"即一个指标代表一种含义\",{\"1\":{\"130\":1}}],[\"邮箱等\",{\"1\":{\"163\":1}}],[\"微信\",{\"1\":{\"163\":1}}],[\"再次发送通知前等待的时间\",{\"1\":{\"163\":1}}],[\"再比如下面的查询语句的可以输出结果\",{\"1\":{\"141\":1}}],[\"几分钟\",{\"1\":{\"163\":1}}],[\"或表达式\",{\"1\":{\"197\":1}}],[\"或\",{\"1\":{\"185\":1}}],[\"或等待同一组告警采集更多初始告警后一起发送\",{\"1\":{\"163\":1}}],[\"或者结合两者的特点使用混合编程\",{\"1\":{\"183\":1}}],[\"或者是参数的顺序不同\",{\"1\":{\"179\":1}}],[\"或者参数的类型不同\",{\"1\":{\"179\":1}}],[\"或者重启的进程的时候重置为0\",{\"1\":{\"131\":1}}],[\"或者静态的配置文件\",{\"1\":{\"120\":1}}],[\"或者被称为被观察者\",{\"1\":{\"105\":1}}],[\"或者访问资源配置文件的reader\",{\"1\":{\"72\":1}}],[\"默认被\",{\"1\":{\"180\":1}}],[\"默认方法\",{\"1\":{\"180\":2}}],[\"默认alertname\",{\"1\":{\"163\":1}}],[\"默认的配置文件如下\",{\"1\":{\"162\":1}}],[\"合理设置抑制规则可以减少垃圾告警的产生\",{\"1\":{\"162\":1}}],[\"接收人一般配合告警路由使用\",{\"1\":{\"162\":1}}],[\"接收人是一个抽象的概念\",{\"1\":{\"162\":1}}],[\"接收人\",{\"1\":{\"162\":1}}],[\"接口只提供方法的声明\",{\"1\":{\"180\":1}}],[\"接口也可以包含默认方法和静态方法\",{\"1\":{\"180\":1}}],[\"接口还为多重继承提供了解决方案\",{\"1\":{\"180\":1}}],[\"接口中的常量默认是静态常量\",{\"1\":{\"180\":1}}],[\"接口中的元素按照插入的顺序存储\",{\"1\":{\"174\":1}}],[\"接口animal\",{\"1\":{\"180\":1}}],[\"接口定义中可以包含常量\",{\"1\":{\"180\":1}}],[\"接口定义了常用的操作方法\",{\"1\":{\"176\":1}}],[\"接口定义了很多常用的方法\",{\"1\":{\"174\":1}}],[\"接口可以被类实现\",{\"1\":{\"180\":1}}],[\"接口使用interface关键字定义的\",{\"1\":{\"180\":1}}],[\"接口继承自\",{\"1\":{\"175\":1}}],[\"接口是集合框架中用于存储键值对\",{\"1\":{\"176\":1}}],[\"接口是\",{\"1\":{\"174\":1,\"175\":1}}],[\"接口\",{\"0\":{\"174\":1},\"1\":{\"161\":1,\"174\":1,\"175\":2,\"180\":7}}],[\"接口的设计可以更好地支持代码的组织和抽象\",{\"1\":{\"181\":1}}],[\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为\",{\"1\":{\"180\":1}}],[\"接口的默认方法可以被实现该接口的类直接使用\",{\"1\":{\"180\":1}}],[\"接口的实现类有\",{\"1\":{\"176\":1}}],[\"接口的主要特点如下\",{\"1\":{\"176\":1}}],[\"接口的主要特点包括\",{\"1\":{\"174\":1,\"175\":1}}],[\"接口的子接口之一\",{\"1\":{\"175\":1}}],[\"接口的继承接口之一\",{\"1\":{\"174\":1}}],[\"接口的p90耗时\",{\"1\":{\"150\":1}}],[\"接口的数据\",{\"1\":{\"137\":1}}],[\"接口如戏\",{\"1\":{\"126\":1}}],[\"接口互相隔离\",{\"1\":{\"70\":1}}],[\"接口隔离原则\",{\"1\":{\"70\":1}}],[\"全局配置\",{\"1\":{\"162\":1}}],[\"抑制允许根据另一组警报的存在来静音一组警报\",{\"1\":{\"163\":1}}],[\"抑制规则\",{\"1\":{\"162\":1}}],[\"抑制是当某一告警已经发出\",{\"1\":{\"160\":1}}],[\"抑制\",{\"0\":{\"160\":1}}],[\"抑制和静默等核心功能\",{\"1\":{\"157\":1,\"158\":1}}],[\"则在变量初始化后\",{\"1\":{\"196\":1}}],[\"则需要特殊处理\",{\"1\":{\"192\":1}}],[\"则x\",{\"1\":{\"191\":2}}],[\"则y\",{\"1\":{\"191\":1}}],[\"则比较字符串内容是否相等\",{\"1\":{\"191\":1}}],[\"则比较的内容是判断两个变量的引用是否相等\",{\"1\":{\"190\":1}}],[\"则字符串内容肯定是相等\",{\"1\":{\"191\":1}}],[\"则指向一个新创建的字符串对象\",{\"1\":{\"190\":1}}],[\"则默认是global\",{\"1\":{\"169\":1}}],[\"则会覆盖之前try或者catch里面的return操作\",{\"1\":{\"199\":2}}],[\"则会覆盖try里面的return操作\",{\"1\":{\"199\":1}}],[\"则会把标签添加到新的序列中\",{\"1\":{\"169\":1}}],[\"则会出现几百上千的告警消息\",{\"1\":{\"159\":1}}],[\"则向alertmanager发送告警消息\",{\"1\":{\"157\":1}}],[\"则返回singleton\",{\"1\":{\"75\":1}}],[\"存储采集到的数据\",{\"1\":{\"157\":1}}],[\"存储了node\",{\"1\":{\"128\":1}}],[\"起到了时序数据库的作用\",{\"1\":{\"157\":1}}],[\"路由\",{\"1\":{\"158\":1}}],[\"路由分发\",{\"1\":{\"157\":1}}],[\"路径导航\",{\"1\":{\"7\":1,\"45\":1}}],[\"完整的代码如下\",{\"1\":{\"154\":1}}],[\"完全匹配\",{\"1\":{\"141\":1}}],[\"统计请求的次数和请求耗时\",{\"1\":{\"154\":1}}],[\"统一全局的访问点控制\",{\"1\":{\"72\":1}}],[\"另一种是使用prometheus的java客户端\",{\"1\":{\"152\":1}}],[\"另外在新生成的指标上添加一个新的标签region\",{\"1\":{\"172\":1}}],[\"另外如果没有配置groups的interval配置\",{\"1\":{\"169\":1}}],[\"另外一种是预计算规则recording\",{\"1\":{\"168\":1}}],[\"另外也可以筛选出handler\",{\"1\":{\"137\":1}}],[\"另外\",{\"1\":{\"134\":1}}],[\"详细内容可以查看官方网站\",{\"1\":{\"151\":1}}],[\"详情\",{\"0\":{\"58\":1,\"62\":1}}],[\"详情容器\",{\"1\":{\"19\":1}}],[\"来处理\",{\"1\":{\"193\":1}}],[\"来进行比较时\",{\"1\":{\"190\":1}}],[\"来解决多继承的需要\",{\"1\":{\"181\":1}}],[\"来解析\",{\"1\":{\"16\":1}}],[\"来实现接口\",{\"1\":{\"180\":1}}],[\"来声明\",{\"1\":{\"180\":1}}],[\"来预测主机可用磁盘空间的是否在24个小时候被占满\",{\"1\":{\"149\":1}}],[\"长尾问题\",{\"1\":{\"148\":2}}],[\"长期趋势分析\",{\"1\":{\"121\":1}}],[\"容易陷入\",{\"1\":{\"148\":1}}],[\"≤\",{\"1\":{\"146\":2}}],[\"φ\",{\"1\":{\"146\":2,\"150\":1}}],[\"得到的结果是\",{\"1\":{\"145\":2}}],[\"举例子讲解\",{\"1\":{\"145\":1}}],[\"举个简单的例子\",{\"1\":{\"179\":1}}],[\"举个简单的示例\",{\"1\":{\"175\":1}}],[\"举个例子演示如何使用\",{\"1\":{\"174\":1,\"176\":1}}],[\"举个例子\",{\"1\":{\"130\":1,\"190\":1,\"193\":1}}],[\"举个现实例子\",{\"1\":{\"81\":1}}],[\"忽略\",{\"1\":{\"144\":1}}],[\"匹配\",{\"1\":{\"144\":1}}],[\"求并集\",{\"1\":{\"143\":1}}],[\"求交集\",{\"1\":{\"143\":1}}],[\"逻辑运算符作用于两个瞬时向量之间\",{\"1\":{\"143\":1}}],[\"逻辑运算符\",{\"0\":{\"143\":1}}],[\"右侧的表达式也有一个handler=\",{\"1\":{\"141\":1}}],[\"左侧的标签条目和右侧的标签条目必须要相同\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"幂运算\",{\"1\":{\"141\":1}}],[\"^\",{\"1\":{\"141\":1}}],[\"取模\",{\"1\":{\"141\":1}}],[\"取反操作\",{\"1\":{\"137\":1}}],[\"乘\",{\"1\":{\"141\":1}}],[\"减\",{\"1\":{\"141\":1}}],[\"减少同步创建实例的开销\",{\"1\":{\"75\":1}}],[\"数学操作符\",{\"0\":{\"141\":1}}],[\"数据可视化\",{\"1\":{\"121\":1}}],[\"操作符是比较两个变量的内存地址\",{\"1\":{\"191\":1}}],[\"操作符去判断引用类型的变量\",{\"1\":{\"190\":1}}],[\"操作符\",{\"0\":{\"140\":1},\"1\":{\"151\":1}}],[\"怎么查询呢\",{\"1\":{\"139\":1}}],[\"获取键对应的值\",{\"1\":{\"176\":1}}],[\"获取键值对数量\",{\"1\":{\"176\":1}}],[\"获取\",{\"1\":{\"175\":1,\"176\":2}}],[\"获取集合的大小\",{\"1\":{\"175\":1}}],[\"获取集合大小等\",{\"1\":{\"175\":1}}],[\"获取列表的大小\",{\"1\":{\"174\":1}}],[\"获取元素\",{\"1\":{\"174\":1}}],[\"获取和操作列表中的元素\",{\"1\":{\"174\":1}}],[\"获取通过热加载的方式重新加载配置文件\",{\"1\":{\"163\":1}}],[\"获取最近五分钟的样本\",{\"1\":{\"148\":1}}],[\"获取请求次数最多的5个请求\",{\"1\":{\"146\":1}}],[\"获取昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"139\":1}}],[\"获取了prometheus\",{\"1\":{\"137\":1}}],[\"天\",{\"1\":{\"138\":1}}],[\"小时\",{\"1\":{\"138\":1}}],[\"小结\",{\"1\":{\"137\":1}}],[\"秒\",{\"1\":{\"138\":1}}],[\"外\",{\"1\":{\"138\":1}}],[\"外观模式\",{\"1\":{\"67\":1}}],[\"范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围\",{\"1\":{\"138\":1}}],[\"范围向量查询\",{\"0\":{\"138\":1}}],[\"|2\",{\"1\":{\"171\":3}}],[\"|value2\",{\"1\":{\"137\":1}}],[\"|\",{\"1\":{\"137\":1,\"169\":1,\"193\":5}}],[\"~3h\",{\"1\":{\"163\":1}}],[\"~5m\",{\"1\":{\"163\":1}}],[\"~0s\",{\"1\":{\"163\":1}}],[\"~\",{\"1\":{\"137\":3,\"163\":1,\"190\":1}}],[\"查询的是昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"139\":1}}],[\"查询的是当前时间的过去五分钟的数据\",{\"1\":{\"139\":1}}],[\"查询五分钟前的最新值\",{\"1\":{\"139\":1}}],[\"查询当前时间的最新值\",{\"1\":{\"139\":1}}],[\"查询语句为\",{\"1\":{\"137\":1}}],[\"查看详情\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"瞬时向量查询和范围向量查询的表达式中\",{\"1\":{\"139\":1}}],[\"瞬时向量查询\",{\"0\":{\"137\":1}}],[\"计算p99耗时的表达式如下\",{\"1\":{\"150\":1}}],[\"计算handler=\",{\"1\":{\"150\":1}}],[\"计算分位数\",{\"0\":{\"150\":1}}],[\"计算counter的增长率\",{\"0\":{\"148\":1}}],[\"计算的结果会产生一条新的时间序列\",{\"1\":{\"136\":1}}],[\"计划\",{\"1\":{\"26\":2}}],[\"转换等计算\",{\"1\":{\"136\":1}}],[\"聚合完后的结果会生成根据聚合标签生成一个新的序列\",{\"1\":{\"146\":1}}],[\"聚合函数\",{\"0\":{\"146\":1}}],[\"聚合\",{\"1\":{\"136\":1}}],[\"过滤\",{\"1\":{\"136\":1}}],[\"过多的观察者会影响性能\",{\"1\":{\"107\":1}}],[\"函数\",{\"1\":{\"151\":1}}],[\"函数格式为\",{\"1\":{\"150\":1}}],[\"函数的格式如下\",{\"1\":{\"149\":1}}],[\"函数的内容\",{\"1\":{\"132\":1}}],[\"函数计算出其值的分位数\",{\"1\":{\"134\":1}}],[\"600\",{\"1\":{\"145\":4}}],[\"60\",{\"1\":{\"134\":1,\"148\":1,\"150\":1}}],[\"6\",{\"1\":{\"133\":1,\"135\":1,\"145\":3}}],[\"除零错误\",{\"1\":{\"193\":2}}],[\"除\",{\"1\":{\"141\":1}}],[\"除非进程重启重置\",{\"1\":{\"132\":1}}],[\"除了使用increase函数计算增量外\",{\"1\":{\"148\":1}}],[\"除了prometheus很多组件是可选的\",{\"1\":{\"119\":1}}],[\"除了以上的solid\",{\"1\":{\"70\":1}}],[\"摘要\",{\"1\":{\"131\":1}}],[\"直方图\",{\"1\":{\"131\":1}}],[\"直接采集的jobs和exporters\",{\"1\":{\"120\":1}}],[\"状态值\",{\"1\":{\"131\":1}}],[\"状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",{\"1\":{\"68\":1}}],[\"状态模式\",{\"1\":{\"68\":1}}],[\"仪表盘\",{\"1\":{\"131\":1}}],[\"初始值为零\",{\"1\":{\"132\":1}}],[\"初始值为0\",{\"1\":{\"131\":1}}],[\"初始化对象\",{\"1\":{\"75\":1}}],[\"累加器\",{\"0\":{\"132\":1},\"1\":{\"131\":1}}],[\"值可以重复\",{\"1\":{\"176\":1}}],[\"值\",{\"1\":{\"130\":1,\"190\":3,\"192\":2}}],[\"值和一个或者是多个key\",{\"1\":{\"117\":1}}],[\"8之后\",{\"1\":{\"197\":1}}],[\"85\",{\"1\":{\"176\":3}}],[\"80\",{\"1\":{\"176\":2}}],[\"8080\",{\"1\":{\"153\":3,\"154\":1,\"163\":1}}],[\"8\",{\"1\":{\"134\":1,\"150\":1,\"180\":3,\"190\":2}}],[\"817\",{\"1\":{\"130\":2}}],[\"822\",{\"1\":{\"130\":2}}],[\"82\",{\"1\":{\"130\":2}}],[\"82033736e+08\",{\"1\":{\"124\":1}}],[\"时\",{\"1\":{\"163\":1,\"192\":1}}],[\"时间位移操作\",{\"0\":{\"139\":1}}],[\"时间范围除了支持分钟\",{\"1\":{\"138\":1}}],[\"时间范围通过时间范围选择器\",{\"1\":{\"138\":1}}],[\"时间戳精度为毫秒\",{\"1\":{\"130\":1}}],[\"时间戳\",{\"1\":{\"130\":1}}],[\"时间序列\",{\"1\":{\"130\":1}}],[\"时间序列是指标\",{\"1\":{\"130\":1}}],[\"时序数据使用http协议采集\",{\"1\":{\"118\":1}}],[\"读取prometheus的指标时序\",{\"1\":{\"128\":1}}],[\"搜索成功后\",{\"1\":{\"127\":1}}],[\"搜索地址\",{\"1\":{\"127\":1}}],[\"登陆成功后\",{\"1\":{\"127\":1}}],[\"密码为admin\",{\"1\":{\"127\":1}}],[\"密码加密的文章\",{\"0\":{\"10\":1}}],[\"地址为localhost\",{\"1\":{\"127\":1}}],[\"进程发送\",{\"1\":{\"161\":1}}],[\"进入grafana的页面\",{\"1\":{\"127\":1}}],[\"进入grafana官网下载安装包\",{\"1\":{\"127\":1}}],[\"进入到grafana的安装目录\",{\"1\":{\"127\":1}}],[\"进行资源释放或清理操作\",{\"1\":{\"198\":1}}],[\"进行全局的计算频次的设置\",{\"1\":{\"169\":1}}],[\"进行定义\",{\"1\":{\"138\":1}}],[\"进行数据的转换或者功能的增强\",{\"1\":{\"85\":1}}],[\"进行引用\",{\"1\":{\"44\":2}}],[\"炫酷的展示数据的可视化仪表盘\",{\"1\":{\"127\":1}}],[\"流行的\",{\"1\":{\"127\":1}}],[\"流程图\",{\"0\":{\"31\":1}}],[\"重写是根据方法的名称和参数列表进行区分\",{\"1\":{\"179\":1}}],[\"重写是指子类对父类方法的重写\",{\"1\":{\"179\":1}}],[\"重写\",{\"1\":{\"179\":1}}],[\"重载方法可以有不同的返回类型\",{\"1\":{\"179\":1}}],[\"重载方法在编译时静态地绑定\",{\"1\":{\"179\":1}}],[\"重载是根据方法的参数列表进行区分\",{\"1\":{\"179\":1}}],[\"重载是针对于同个类中\",{\"1\":{\"179\":1}}],[\"重载有以下的特点\",{\"1\":{\"179\":1}}],[\"重载的方法的返回结果的类型也可以是不同的\",{\"1\":{\"179\":1}}],[\"重载的方法通过调用时的参数的类型或者数量\",{\"1\":{\"179\":1}}],[\"重载指的是在一个类中定义多个方法\",{\"1\":{\"179\":1}}],[\"重载\",{\"1\":{\"179\":2}}],[\"重载与重写的区别\",{\"0\":{\"179\":1}}],[\"重复元素\",{\"1\":{\"175\":1}}],[\"重新是发生在子类和父类的继承关系之间\",{\"1\":{\"179\":1}}],[\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别\",{\"1\":{\"179\":1}}],[\"重新启动alertmanager\",{\"1\":{\"163\":1}}],[\"重新启动prometheus\",{\"1\":{\"172\":1}}],[\"重新启动prometheus或者热加载\",{\"1\":{\"155\":1}}],[\"重新启动prometheus的程序\",{\"1\":{\"125\":1}}],[\"重新加载一下配置\",{\"1\":{\"155\":1}}],[\"重要的内容\",{\"1\":{\"25\":1}}],[\"95\",{\"1\":{\"156\":1,\"176\":4}}],[\"9400\",{\"1\":{\"154\":2,\"155\":1}}],[\"99\",{\"1\":{\"150\":1}}],[\"9\",{\"1\":{\"130\":1,\"150\":1,\"180\":1}}],[\"9100\",{\"1\":{\"125\":2}}],[\"90\",{\"1\":{\"176\":2}}],[\"909\",{\"1\":{\"164\":1}}],[\"9093\",{\"1\":{\"124\":1,\"163\":1,\"165\":1}}],[\"9090\",{\"1\":{\"123\":1,\"124\":2,\"125\":2,\"126\":1,\"146\":1,\"150\":10,\"164\":2}}],[\"9000\",{\"1\":{\"92\":2}}],[\"启动alertmanager可以使用以下命令\",{\"1\":{\"162\":1}}],[\"启动命令如下\",{\"1\":{\"127\":1}}],[\"启动grafana\",{\"1\":{\"127\":1}}],[\"启动node\",{\"1\":{\"125\":1}}],[\"启动成功后\",{\"1\":{\"123\":1,\"127\":1}}],[\"磁盘\",{\"1\":{\"125\":1}}],[\"内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁\",{\"1\":{\"197\":1}}],[\"内部类和外部类其实是处于同一个级别\",{\"1\":{\"197\":1}}],[\"内存\",{\"1\":{\"125\":1}}],[\"内容如下\",{\"1\":{\"124\":1,\"164\":1}}],[\"内容\",{\"1\":{\"16\":1}}],[\"75\",{\"1\":{\"124\":1,\"135\":1}}],[\"745e\",{\"1\":{\"124\":1}}],[\"7\",{\"1\":{\"124\":1,\"153\":1}}],[\"4h\",{\"1\":{\"163\":1}}],[\"44\",{\"1\":{\"154\":1}}],[\"4<\",{\"1\":{\"153\":1}}],[\"404\",{\"1\":{\"145\":4}}],[\"489234e+06\",{\"1\":{\"124\":1}}],[\"4\",{\"1\":{\"124\":1,\"127\":2,\"134\":1,\"150\":1,\"166\":1,\"174\":1,\"180\":1,\"190\":2,\"199\":2}}],[\"47\",{\"1\":{\"123\":2}}],[\"支持的逻辑运算符如下\",{\"1\":{\"143\":1}}],[\"支持多种类型的采集\",{\"1\":{\"124\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"27\":1}}],[\"周\",{\"1\":{\"138\":1}}],[\"周期性采集监控目标\",{\"1\":{\"124\":1}}],[\"周边生态非常的丰富\",{\"1\":{\"117\":1}}],[\"访问列表中的元素\",{\"1\":{\"174\":1}}],[\"访问alertmanager的界面\",{\"1\":{\"165\":1}}],[\"访问prometheus的告警页面界面\",{\"1\":{\"164\":1}}],[\"访问prometheus的规则文件界面\",{\"1\":{\"164\":1}}],[\"访问prometheus的网页\",{\"1\":{\"125\":1}}],[\"访问http\",{\"1\":{\"123\":1,\"125\":1}}],[\"访问者模式是以行为\",{\"1\":{\"68\":1}}],[\"访问者模式\",{\"1\":{\"68\":1}}],[\"笔者是mac\",{\"1\":{\"127\":1}}],[\"笔者是mac电脑\",{\"1\":{\"123\":1}}],[\"笔者这里下载mac版本的\",{\"1\":{\"123\":1}}],[\"笔者作为多年面试官\",{\"1\":{\"69\":1}}],[\"安装prometheus\",{\"0\":{\"123\":1}}],[\"安装成功后\",{\"1\":{\"122\":1}}],[\"安全与隐私\",{\"1\":{\"123\":1}}],[\"安全\",{\"1\":{\"74\":1}}],[\"安全的在\",{\"1\":{\"19\":1}}],[\"包装类的值比较应该使用equals\",{\"1\":{\"184\":1}}],[\"包装类都是不可变的\",{\"1\":{\"184\":1}}],[\"包装类还提供了许多其他功能\",{\"1\":{\"184\":1}}],[\"包括编译器\",{\"1\":{\"194\":1}}],[\"包括了最常见的list\",{\"1\":{\"177\":1}}],[\"包括消息的去重\",{\"1\":{\"158\":1}}],[\"包括两个标签uri\",{\"1\":{\"154\":2}}],[\"包括prometheus\",{\"1\":{\"122\":1}}],[\"包含了5种设计模式\",{\"1\":{\"66\":1}}],[\"包含\",{\"1\":{\"19\":1}}],[\"以确保代码的可靠性\",{\"1\":{\"198\":1}}],[\"以确保程序的正常执行\",{\"1\":{\"193\":1}}],[\"以确定两个对象是否相等\",{\"1\":{\"192\":1}}],[\"以避免空指针异常\",{\"1\":{\"192\":1}}],[\"以获得最终的哈希码\",{\"1\":{\"192\":1}}],[\"以减少哈希冲突的概率\",{\"1\":{\"192\":1}}],[\"以下是一些在重写hashcode\",{\"1\":{\"192\":1}}],[\"以下是一个接口的示例\",{\"1\":{\"180\":1}}],[\"以下是一个抽象类的示例\",{\"1\":{\"180\":1}}],[\"以下代码演示了使用包装类实现基本类型的自动装箱和拆箱\",{\"1\":{\"184\":1}}],[\"以键值对\",{\"1\":{\"173\":1}}],[\"以无序的方式存储对象的集合\",{\"1\":{\"173\":1}}],[\"以有序的方式存储对象的集合\",{\"1\":{\"173\":1}}],[\"以及优化性能\",{\"1\":{\"196\":1}}],[\"以及一些集合类\",{\"1\":{\"192\":1}}],[\"以及默认方法\",{\"1\":{\"180\":1}}],[\"以及常见的实现类\",{\"1\":{\"177\":1}}],[\"以及判断\",{\"1\":{\"176\":1}}],[\"以及判断集合是否为空\",{\"1\":{\"175\":1}}],[\"以及添加\",{\"1\":{\"176\":1}}],[\"以及告警的接受方式可以通过alertmanager的配置文件进行配置\",{\"1\":{\"159\":1}}],[\"以及服务运行状态等直观的信息\",{\"1\":{\"121\":1}}],[\"以\",{\"1\":{\"134\":2,\"190\":1}}],[\"以便更好地抽象和组织程序中可能发生的异常情况\",{\"1\":{\"193\":1}}],[\"以便方法可以在这些对象类型之间进行选择\",{\"1\":{\"184\":1}}],[\"以便在中断期间仅发送一组互连警报中最相关的警报\",{\"1\":{\"163\":1}}],[\"以便以后可以恢复\",{\"1\":{\"68\":1}}],[\"以便\",{\"1\":{\"13\":1}}],[\"资源使用情况\",{\"1\":{\"121\":1}}],[\"故障分析与定位\",{\"1\":{\"121\":1}}],[\"监控系统需要迅速反应并通知管理员\",{\"1\":{\"121\":1}}],[\"监控对象的发现\",{\"1\":{\"120\":1}}],[\"两个版本的系统运行资源使用情况的差异如何\",{\"1\":{\"121\":1}}],[\"两者都是开闭原则的具体实现规范\",{\"1\":{\"70\":1}}],[\"例如常量\",{\"1\":{\"196\":1}}],[\"例如释放资源\",{\"1\":{\"193\":1}}],[\"例如integer\",{\"1\":{\"184\":1}}],[\"例如添加键值对\",{\"1\":{\"176\":1}}],[\"例如添加元素\",{\"1\":{\"175\":1}}],[\"例如有以下的指标prometheus\",{\"1\":{\"150\":1}}],[\"例如下面的查询语句不会输出任何结果\",{\"1\":{\"141\":1}}],[\"例如go\",{\"1\":{\"135\":1}}],[\"例如0\",{\"1\":{\"134\":1}}],[\"例如prometheus的服务的\",{\"1\":{\"134\":1}}],[\"例如prometheus\",{\"1\":{\"132\":1,\"158\":1}}],[\"例如\",{\"1\":{\"121\":1,\"133\":1,\"134\":1,\"138\":1,\"148\":1,\"149\":1,\"160\":1,\"171\":1,\"174\":1,\"184\":1,\"185\":1,\"190\":1}}],[\"例如代理私有方法\",{\"1\":{\"113\":1}}],[\"去掉\",{\"1\":{\"171\":1}}],[\"去prometheus官网下载prometheus\",{\"1\":{\"123\":1}}],[\"去重\",{\"1\":{\"120\":1}}],[\"去提供获取对象的服务\",{\"1\":{\"74\":1}}],[\"健康对象包含\",{\"1\":{\"120\":1}}],[\"架构\",{\"0\":{\"120\":1}}],[\"大多数情况下不会被程序显式地捕获和处理\",{\"1\":{\"193\":1}}],[\"大多数prometheus组件都是使用go语言写的\",{\"1\":{\"119\":1}}],[\"大量的类\",{\"1\":{\"100\":1}}],[\"恢复等管理\",{\"1\":{\"119\":1}}],[\"静默提供了一个标签匹配的设置\",{\"1\":{\"161\":1}}],[\"静默\",{\"0\":{\"161\":1},\"1\":{\"119\":1,\"120\":1}}],[\"静态方法在接口中提供了一些与接口相关的工具方法\",{\"1\":{\"180\":1}}],[\"静态方法\",{\"1\":{\"180\":2}}],[\"静态方法用来返回其所属类的一个相同实例\",{\"1\":{\"73\":1}}],[\"静态代理的优点是简单易懂\",{\"1\":{\"109\":1}}],[\"静态代理需要手动创建一个代理类\",{\"1\":{\"109\":1}}],[\"静态代理\",{\"0\":{\"109\":1}}],[\"静态对象用来存储对象自身的属性和方法\",{\"1\":{\"73\":1}}],[\"用作其他类的基类\",{\"1\":{\"180\":1}}],[\"用increase函数算出五分钟的增量\",{\"1\":{\"148\":1}}],[\"用来抓取和存储时序数据的\",{\"1\":{\"119\":1}}],[\"用于异常处理的最后一个代码块\",{\"1\":{\"198\":1}}],[\"用于计算两个数的除法操作\",{\"1\":{\"193\":1}}],[\"用于计算是否有时间序列满足该条件\",{\"1\":{\"164\":1}}],[\"用于定义一组合同类型的操作\",{\"1\":{\"180\":1}}],[\"用于定义一些全局的公共参数\",{\"1\":{\"162\":1}}],[\"用于描述一种通用的概念\",{\"1\":{\"180\":1}}],[\"用于实例化抽象类的对象\",{\"1\":{\"180\":1}}],[\"用于实现类的多态性\",{\"1\":{\"180\":2}}],[\"用于构建类的继承层级结构\",{\"1\":{\"180\":1}}],[\"用于存储不重复的元素\",{\"1\":{\"175\":1}}],[\"用于添加\",{\"1\":{\"174\":1}}],[\"用于表示不可变\",{\"1\":{\"196\":1}}],[\"用于表示有序的元素集合\",{\"1\":{\"174\":1}}],[\"用于表示只有当触发条件持续一段时间后才发送告警\",{\"1\":{\"164\":1}}],[\"用于保存元素并控制元素的插入\",{\"1\":{\"173\":1}}],[\"用于处理不同类型的集合\",{\"1\":{\"173\":1}}],[\"用于指定一组附加信息\",{\"1\":{\"164\":1}}],[\"用于指标数据的统计\",{\"1\":{\"154\":1}}],[\"用于等待抑制告警\",{\"1\":{\"163\":1}}],[\"用于向alertmanager发送告警消息\",{\"1\":{\"157\":1}}],[\"用于统计请求的耗时\",{\"1\":{\"154\":1}}],[\"用于统计请求的数量\",{\"1\":{\"154\":1}}],[\"用于java程序的指标暴露\",{\"1\":{\"154\":1}}],[\"用于求分位数\",{\"1\":{\"131\":1}}],[\"用于在运行时扩展java类和实现动态代理\",{\"1\":{\"113\":1}}],[\"用于对象之间的一对多的依赖关系\",{\"1\":{\"104\":1}}],[\"用于对象的实例化\",{\"1\":{\"66\":1}}],[\"用于创建产品对象的接口\",{\"1\":{\"99\":1}}],[\"用于解耦对象的实例化过程\",{\"1\":{\"66\":1}}],[\"采用的数据模型是单值模型\",{\"1\":{\"130\":1}}],[\"采用装饰器模式能够快速的扩展功能\",{\"1\":{\"88\":1}}],[\"采集了node\",{\"1\":{\"128\":1}}],[\"采集node\",{\"0\":{\"125\":1},\"1\":{\"157\":1}}],[\"采集监控对象的指标\",{\"1\":{\"120\":1}}],[\"采集目标可以使用服务发现的方式\",{\"1\":{\"118\":1}}],[\"通配符进行模糊匹配查询\",{\"1\":{\"137\":1}}],[\"通常表示系统的严重错误或问题\",{\"1\":{\"193\":1}}],[\"通常表示程序中可预见的异常情况\",{\"1\":{\"193\":1}}],[\"通常也需要重写hashcode\",{\"1\":{\"192\":1}}],[\"通常都需要重写equals\",{\"1\":{\"191\":1}}],[\"通常设置为3小时或更长时间\",{\"1\":{\"163\":1}}],[\"通常是抽象方法\",{\"1\":{\"180\":1}}],[\"通常是webhook\",{\"1\":{\"157\":1}}],[\"通常是pull模式\",{\"1\":{\"118\":1}}],[\"通常使用以下的关键字\",{\"1\":{\"145\":1}}],[\"通常情况下\",{\"1\":{\"135\":1}}],[\"通常15\",{\"1\":{\"120\":1}}],[\"通过合理地使用try\",{\"1\":{\"193\":1}}],[\"通过hashcode\",{\"1\":{\"192\":1}}],[\"通过父类引用调用重写的方法时\",{\"1\":{\"185\":1}}],[\"通过关键字\",{\"1\":{\"180\":2}}],[\"通过实现接口\",{\"1\":{\"180\":1}}],[\"通过rule\",{\"1\":{\"172\":1}}],[\"通过recording\",{\"1\":{\"171\":1}}],[\"通过向alertmanager\",{\"1\":{\"161\":1}}],[\"通过配置文件去配置一些配置\",{\"1\":{\"161\":1}}],[\"通过alertmanager的配置可以忽略与该集群有关的其它告警功能\",{\"1\":{\"160\":1}}],[\"通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态\",{\"1\":{\"148\":1}}],[\"通过instant\",{\"1\":{\"138\":1}}],[\"通过以下表达式可以选择最近5分钟内的所有样本数据\",{\"1\":{\"138\":1}}],[\"通过这种直方图可以很方便的统计请求耗时分布的真实状态\",{\"1\":{\"134\":1}}],[\"通过拉prometheus的配置热更新接口\",{\"1\":{\"126\":1}}],[\"通过可视化仪表盘能够直接获取系统的运行状态\",{\"1\":{\"121\":1}}],[\"通过监控能够方便的对系统进行跟踪和比较\",{\"1\":{\"121\":1}}],[\"通过对不同监控监控以及历史数据的分析\",{\"1\":{\"121\":1}}],[\"通过对磁盘空间增长率的判断\",{\"1\":{\"121\":1}}],[\"通过对监控样本数据的持续收集和统计\",{\"1\":{\"121\":1}}],[\"通过prometheus建立完善的监控体系\",{\"1\":{\"121\":1}}],[\"通过了内置的告警规则计算\",{\"1\":{\"120\":1}}],[\"通过中间层push\",{\"1\":{\"118\":1}}],[\"通过包装不同的装饰器组合来满足自己的业务需求\",{\"1\":{\"88\":1}}],[\"通过共享对象池技术\",{\"1\":{\"67\":1}}],[\"通过复制原有的实例来创建新的实例\",{\"1\":{\"66\":1}}],[\"通过\",{\"1\":{\"15\":1,\"18\":1,\"130\":1}}],[\"指标数据如下\",{\"1\":{\"154\":1}}],[\"指标的名称是监控样本的标识\",{\"1\":{\"136\":1}}],[\"指标的类型\",{\"0\":{\"131\":1}}],[\"指标名将会被删除\",{\"1\":{\"141\":1}}],[\"指标名和标签名的命名需要满足\",{\"1\":{\"130\":1}}],[\"指标名称的定义可以参考下面一小节\",{\"1\":{\"169\":1}}],[\"指标名称\",{\"1\":{\"130\":1}}],[\"指标是由指标名和标签组成\",{\"1\":{\"130\":1}}],[\"指标是单值模型\",{\"1\":{\"130\":1}}],[\"指标在不同时间有不同的值\",{\"1\":{\"130\":1}}],[\"指标在不同时间下的值\",{\"1\":{\"130\":1}}],[\"指标定义如下\",{\"1\":{\"130\":1}}],[\"指标\",{\"1\":{\"118\":1,\"130\":1}}],[\"指南\",{\"0\":{\"48\":1,\"52\":1}}],[\"白盒监控\",{\"1\":{\"118\":1}}],[\"云平台配合\",{\"1\":{\"117\":1}}],[\"云原生计算基金会\",{\"1\":{\"117\":1}}],[\"能更好地与容器平台\",{\"1\":{\"117\":1}}],[\"能够找到并解决根源问题\",{\"1\":{\"121\":1}}],[\"能够实现不同产品族的兼容性和高度可扩展性\",{\"1\":{\"103\":1}}],[\"能够快速的扩展现有类的功能\",{\"1\":{\"88\":1}}],[\"能够熟练使用设计模式\",{\"1\":{\"69\":1}}],[\"同样的\",{\"1\":{\"154\":1}}],[\"同操作运算符一样\",{\"1\":{\"142\":1,\"143\":1}}],[\"同理\",{\"1\":{\"137\":1}}],[\"同年6月正式发布1\",{\"1\":{\"117\":1}}],[\"同时提供了更好的可维护性和扩展性\",{\"1\":{\"181\":1}}],[\"同时prometheus读取告警规则文件\",{\"1\":{\"157\":1}}],[\"同时prometheus作为一个时序数据库\",{\"1\":{\"128\":1}}],[\"同时\",{\"1\":{\"107\":1}}],[\"同时它具有以下的缺点\",{\"1\":{\"103\":1}}],[\"同时它是线程安全的\",{\"1\":{\"75\":1}}],[\"同时有不会影响原有的公民\",{\"1\":{\"88\":1}}],[\"告警规则的名称\",{\"1\":{\"164\":1}}],[\"告警路由\",{\"1\":{\"162\":1}}],[\"告警时间间隔\",{\"1\":{\"159\":1}}],[\"告警分组\",{\"1\":{\"159\":1}}],[\"告警消息的处理程序alertmanager\",{\"1\":{\"157\":1}}],[\"告警发送\",{\"1\":{\"157\":1}}],[\"告警语句的配置\",{\"1\":{\"136\":1}}],[\"告警\",{\"1\":{\"121\":1}}],[\"告警管理等一系列工具包\",{\"1\":{\"117\":1}}],[\"告警计算\",{\"1\":{\"117\":1}}],[\"最高位仅用于表示正负\",{\"1\":{\"190\":1}}],[\"最新的操作函数在前\",{\"1\":{\"171\":1}}],[\"最好创建一个目录专门存储告警规则文件\",{\"1\":{\"164\":1}}],[\"最终会执行的代码块\",{\"1\":{\"198\":1}}],[\"最终根据上面的表达式得到的指标的名称是instance\",{\"1\":{\"171\":1}}],[\"最终我的配置修改成如下\",{\"1\":{\"163\":1}}],[\"最终将消息发送给第三方组件\",{\"1\":{\"157\":1}}],[\"最终的技术架构如下\",{\"1\":{\"115\":1}}],[\"最后使用是rate操作\",{\"1\":{\"171\":1}}],[\"最后webhook发送给告警平台\",{\"1\":{\"157\":1}}],[\"最后\",{\"1\":{\"82\":1}}],[\"kit\",{\"1\":{\"194\":1}}],[\"key\",{\"1\":{\"166\":1,\"173\":1,\"176\":3}}],[\"keyborad\",{\"1\":{\"82\":1}}],[\"keyboard\",{\"1\":{\"82\":5}}],[\"k\",{\"1\":{\"146\":2}}],[\"kafka\",{\"1\":{\"115\":1}}],[\"旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统\",{\"1\":{\"115\":1}}],[\"本身\",{\"1\":{\"190\":2}}],[\"本篇文章主要讲解如何在springboot项目中使用prometheus监控\",{\"1\":{\"152\":1}}],[\"本篇文章为系列教程\",{\"1\":{\"115\":1}}],[\"本文介绍了java中的collection框架\",{\"1\":{\"177\":1}}],[\"本文使用webhook的方式\",{\"1\":{\"163\":1}}],[\"本文快速的讲解了promql的查询\",{\"1\":{\"151\":1}}],[\"本文是prometheus环境的搭建和安装\",{\"1\":{\"122\":1}}],[\"本页面就是一个示例\",{\"1\":{\"7\":1}}],[\"概览\",{\"0\":{\"114\":1}}],[\"拦截静态方法等\",{\"1\":{\"113\":1}}],[\"更好的做法是使用try\",{\"1\":{\"198\":1}}],[\"更灵活地满足额外需求\",{\"1\":{\"113\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"45\":1}}],[\"更新时间\",{\"1\":{\"7\":1}}],[\"更新计划\",{\"0\":{\"1\":1,\"2\":1}}],[\"测试cglib\",{\"1\":{\"113\":1}}],[\"测试类\",{\"1\":{\"97\":1}}],[\"结果\",{\"1\":{\"193\":1}}],[\"结束cglib拦截\",{\"1\":{\"113\":2}}],[\"结构型设计模式是多个对象实例的结合或者组装\",{\"1\":{\"67\":1}}],[\"结构型设计模式和行为型设计模式\",{\"1\":{\"65\":1}}],[\"结构型模式\",{\"0\":{\"67\":1}}],[\"执行上述代码\",{\"1\":{\"193\":1}}],[\"执行finally块\",{\"1\":{\"193\":2}}],[\"执行启动命令\",{\"1\":{\"123\":1}}],[\"执行解压\",{\"1\":{\"123\":1}}],[\"执行结果如下\",{\"1\":{\"113\":1,\"179\":1}}],[\"执行目标对象的方法\",{\"1\":{\"113\":1}}],[\"执行测试类\",{\"1\":{\"87\":1}}],[\"开启httpserver\",{\"1\":{\"154\":1}}],[\"开始cglib拦截\",{\"1\":{\"113\":2}}],[\"开闭原则\",{\"1\":{\"70\":1}}],[\"工作流程包括\",{\"1\":{\"157\":1}}],[\"工具类\",{\"1\":{\"113\":1}}],[\"工厂类负责了两个职责\",{\"1\":{\"97\":1}}],[\"工厂类包含了所有产品对象的创建逻辑\",{\"1\":{\"97\":1}}],[\"工厂类包含了必要的逻辑判断\",{\"1\":{\"97\":1}}],[\"工厂类根据客户端传入的参数来创建相应的产品对象\",{\"1\":{\"96\":1}}],[\"工厂类\",{\"1\":{\"96\":1,\"97\":1}}],[\"工厂模式\",{\"0\":{\"94\":1}}],[\"工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"101\":1}}],[\"工厂方法模式包含以下角色\",{\"1\":{\"99\":1}}],[\"工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题\",{\"1\":{\"98\":1}}],[\"工厂方法模式\",{\"0\":{\"98\":1},\"1\":{\"66\":1,\"69\":1,\"98\":1}}],[\"维护一个目标对象\",{\"1\":{\"113\":1}}],[\"性能较好\",{\"1\":{\"182\":1}}],[\"性能\",{\"1\":{\"182\":1}}],[\"性能高\",{\"1\":{\"113\":1}}],[\"性能开销\",{\"1\":{\"112\":1}}],[\"性能监控等\",{\"1\":{\"112\":1}}],[\"缺点\",{\"1\":{\"112\":1}}],[\"灵活性\",{\"1\":{\"112\":1}}],[\"灵活性非常高\",{\"1\":{\"107\":1}}],[\"动态绑定\",{\"1\":{\"185\":1}}],[\"动态代理只能对接口进行代理\",{\"1\":{\"112\":1}}],[\"动态代理可以在运行时动态生成代理类\",{\"1\":{\"112\":1}}],[\"动态代理可以使用\",{\"1\":{\"111\":1}}],[\"动态代理的步骤是先实现invocationhandler接口\",{\"1\":{\"112\":1}}],[\"动态代理的优点是避免了手动创建代理类的麻烦\",{\"1\":{\"112\":1}}],[\"动态代理是使用java的反射机制来实现动态代理\",{\"1\":{\"112\":1}}],[\"动态代理是在运行时自动生成代理类并将方法调用转发到实际对象\",{\"1\":{\"112\":1}}],[\"动态代理机制和cglib动态代理\",{\"1\":{\"111\":1}}],[\"动态代理\",{\"0\":{\"111\":1,\"112\":1}}],[\"动态地实例化具体的产品类\",{\"1\":{\"97\":1}}],[\"远程调用\",{\"1\":{\"108\":1}}],[\"综上所述\",{\"1\":{\"107\":1}}],[\"消息发布者publisher接口\",{\"1\":{\"106\":1}}],[\"观察者收到消息后可以做出响应\",{\"1\":{\"107\":1}}],[\"观察者会执行该方法\",{\"1\":{\"105\":1}}],[\"观察者observer\",{\"1\":{\"105\":1}}],[\"观察者模式是一种实用并且简单的设计模式\",{\"1\":{\"107\":1}}],[\"观察者模式也有一些缺点\",{\"1\":{\"107\":1}}],[\"观察者模式符合开闭原则\",{\"1\":{\"107\":1}}],[\"观察者模式的核心思想是将观察者对象注册到发布者对象中\",{\"1\":{\"107\":1}}],[\"观察者模式在软件开发中有非常多的应用\",{\"1\":{\"105\":1}}],[\"观察者模式uml图\",{\"0\":{\"105\":1}}],[\"观察者模式\",{\"0\":{\"104\":1},\"1\":{\"68\":1,\"69\":1,\"104\":1}}],[\"比较结果为\",{\"1\":{\"190\":3}}],[\"比较的就是\",{\"1\":{\"190\":1}}],[\"比较的是引用而不是值\",{\"1\":{\"184\":1}}],[\"比较操作符\",{\"0\":{\"142\":1}}],[\"比较困难\",{\"1\":{\"103\":1}}],[\"比如如哈希表\",{\"1\":{\"192\":1}}],[\"比如在string类中\",{\"1\":{\"192\":1}}],[\"比如在string内中\",{\"1\":{\"191\":1}}],[\"比如在以下的代码中\",{\"1\":{\"85\":1}}],[\"比如数学运算\",{\"1\":{\"184\":1}}],[\"比如将告警消息发送给运维人员的邮箱\",{\"1\":{\"166\":1}}],[\"比如用于描述告警详细信息的文字等\",{\"1\":{\"164\":1}}],[\"比如当发生severity=critical的告警时\",{\"1\":{\"163\":1}}],[\"比如按照alertname\",{\"1\":{\"163\":1}}],[\"比如配置每分钟的请求量\",{\"1\":{\"156\":1}}],[\"比如计算最近5分钟的请求次数\",{\"1\":{\"148\":1}}],[\"比如prometheus\",{\"1\":{\"146\":1}}],[\"比如p99\",{\"1\":{\"131\":1}}],[\"比如有以下的时间序列的样本\",{\"1\":{\"145\":1}}],[\"比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算\",{\"1\":{\"144\":1}}],[\"比如查询handler为\",{\"1\":{\"137\":1}}],[\"比如\",{\"1\":{\"137\":1,\"139\":1,\"142\":1,\"159\":1}}],[\"比如我们求某个请求耗时的平均值\",{\"1\":{\"134\":1}}],[\"比如我们的mac电脑需要连接usb接口的键盘\",{\"1\":{\"81\":1}}],[\"比如node\",{\"1\":{\"133\":1}}],[\"比如求最近5分钟prometheus发生了多少次请求\",{\"1\":{\"132\":1}}],[\"比如主机的cpu\",{\"1\":{\"125\":1}}],[\"比如从k8s\",{\"1\":{\"124\":1}}],[\"比如可以将指标数据展示在grafana上\",{\"1\":{\"120\":1}}],[\"比如可以先使用加密装饰器\",{\"1\":{\"87\":1}}],[\"比如email\",{\"1\":{\"120\":1}}],[\"比如对消息的去重\",{\"1\":{\"119\":1}}],[\"比如对某一次请求进行不同的规则的校验\",{\"1\":{\"90\":1}}],[\"比如虚拟机\",{\"1\":{\"119\":1}}],[\"比如k8s系统\",{\"1\":{\"118\":1}}],[\"比如int\",{\"1\":{\"184\":1}}],[\"比如influxdb\",{\"1\":{\"118\":1}}],[\"比如id生成器\",{\"1\":{\"72\":1}}],[\"比如日志记录\",{\"1\":{\"112\":1}}],[\"比如访问控制\",{\"1\":{\"108\":1}}],[\"比如发布者维护的观察者对象是无顺序的\",{\"1\":{\"107\":1}}],[\"比如家具厂除了生产沙发\",{\"1\":{\"101\":1}}],[\"比如sofa的生产\",{\"1\":{\"101\":1}}],[\"比如handle\",{\"1\":{\"91\":1}}],[\"比如使用类final关键字的类\",{\"1\":{\"86\":1}}],[\"比如案例中keyboard\",{\"1\":{\"82\":1}}],[\"比如图中的键盘\",{\"1\":{\"81\":1}}],[\"比如拓展坞类实现了目标接口typec接口\",{\"1\":{\"81\":1}}],[\"比如typec接口\",{\"1\":{\"81\":1}}],[\"比如工具类\",{\"1\":{\"72\":1}}],[\"客户端代码与具体产品的创建实现了解耦\",{\"1\":{\"103\":1}}],[\"客户端通过抽象工厂来创建产品对象\",{\"1\":{\"100\":1}}],[\"保证了线程安全\",{\"1\":{\"182\":1}}],[\"保证了这些对象之间的兼容性\",{\"1\":{\"103\":1}}],[\"保证了mac电脑对外接口的简单性\",{\"1\":{\"83\":1}}],[\"负责创建一族相关的具体产品对象\",{\"1\":{\"102\":1}}],[\"负责创建实例对象的类\",{\"1\":{\"96\":1}}],[\"椅子\",{\"1\":{\"101\":1}}],[\"无固定顺序\",{\"1\":{\"176\":1}}],[\"无序性\",{\"1\":{\"175\":1}}],[\"无需依赖接口\",{\"1\":{\"113\":1}}],[\"无需修改已有代码\",{\"1\":{\"100\":1}}],[\"无法保证finalize方法的及时执行\",{\"1\":{\"198\":1}}],[\"无法代理实现类的方法\",{\"1\":{\"112\":1}}],[\"无法使用动态代理\",{\"1\":{\"112\":1}}],[\"无论try块中是否发生异常\",{\"1\":{\"199\":1}}],[\"无论是否有匹配的catch块\",{\"1\":{\"199\":2}}],[\"无论是否发生异常\",{\"1\":{\"193\":1,\"198\":1}}],[\"无论是在前期的需求分析\",{\"1\":{\"64\":1}}],[\"无论面对什么的环境\",{\"1\":{\"64\":1}}],[\"具备良好的扩展性\",{\"1\":{\"100\":1}}],[\"具体来说\",{\"1\":{\"185\":1}}],[\"具体的迭代顺序可能因实现类或元素的插入顺序而不同\",{\"1\":{\"176\":1}}],[\"具体的排列顺序可能因实现类或元素的添加顺序而不同\",{\"1\":{\"175\":1}}],[\"具体的配置介绍如下\",{\"1\":{\"124\":1}}],[\"具体表达式格式如下\",{\"1\":{\"172\":1}}],[\"具体预处理生成指标的表达式\",{\"1\":{\"169\":1}}],[\"具体命令如下\",{\"1\":{\"126\":1}}],[\"具体如下\",{\"1\":{\"124\":1}}],[\"具体使用java\",{\"1\":{\"112\":1}}],[\"具体代码如下\",{\"1\":{\"110\":1}}],[\"具体观察者是观察者的具体实现\",{\"1\":{\"105\":1}}],[\"具体观察者\",{\"1\":{\"105\":1}}],[\"具体主题是主题的具体实现\",{\"1\":{\"105\":1}}],[\"具体主题\",{\"1\":{\"105\":1}}],[\"具体工厂类的代码更加简洁\",{\"1\":{\"100\":1}}],[\"具体工厂\",{\"1\":{\"99\":1,\"102\":1,\"103\":1}}],[\"具体产品类\",{\"1\":{\"96\":1,\"99\":1,\"102\":1,\"103\":1}}],[\"具体实现如下\",{\"1\":{\"87\":1}}],[\"符合单一职责原则\",{\"1\":{\"100\":1}}],[\"符合开闭原则\",{\"1\":{\"93\":1,\"103\":1}}],[\"违反了单一职责原则\",{\"1\":{\"97\":1}}],[\"系统扩展性好\",{\"1\":{\"97\":1}}],[\"系统出错\",{\"1\":{\"93\":1}}],[\"运行以上代码\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"运行时会被系统拒绝运行\",{\"1\":{\"123\":1}}],[\"运行代码输出\",{\"1\":{\"112\":1}}],[\"运行代码\",{\"1\":{\"110\":1}}],[\"运行代码处理结果如下\",{\"1\":{\"92\":1}}],[\"运行上面的代码\",{\"1\":{\"103\":1}}],[\"运行结果如下\",{\"1\":{\"97\":1,\"106\":1}}],[\"由node\",{\"1\":{\"127\":1}}],[\"由于final所修饰的值始终无法改变\",{\"1\":{\"197\":1}}],[\"由于除数为0会产生算术异常\",{\"1\":{\"193\":1}}],[\"由于动态绑定的机制\",{\"1\":{\"185\":1}}],[\"由于动态代理是在运行时动态生成代理类\",{\"1\":{\"112\":1}}],[\"由于string是不可变的\",{\"1\":{\"182\":1}}],[\"由于prometheus是使用周期性的采集数据\",{\"1\":{\"121\":1}}],[\"由工厂类创建的对象的抽象类或接口\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"由拓展坞去做usb或者是hdmi接口的转换\",{\"1\":{\"83\":1}}],[\"抽象方法\",{\"1\":{\"180\":1}}],[\"抽象方法必须在非抽象子类中被重写实现\",{\"1\":{\"180\":1}}],[\"抽象方法只有方法签名\",{\"1\":{\"180\":1}}],[\"抽象类和接口是java中用于实现抽象和多态性的两个关键概念\",{\"1\":{\"180\":1}}],[\"抽象类和接口的区别\",{\"0\":{\"180\":1}}],[\"抽象类vs接口\",{\"1\":{\"180\":1}}],[\"抽象类通常为其子类提供一个通用的模板\",{\"1\":{\"180\":1}}],[\"抽象类通过使用关键字\",{\"1\":{\"180\":1}}],[\"抽象类用于定义通用的属性和行为\",{\"1\":{\"180\":1}}],[\"抽象类\",{\"1\":{\"180\":7}}],[\"抽象主题接口类\",{\"1\":{\"109\":1}}],[\"抽象工厂的uml图如下\",{\"1\":{\"102\":1}}],[\"抽象工厂\",{\"0\":{\"101\":1},\"1\":{\"99\":1,\"102\":1,\"103\":1}}],[\"抽象工厂模式提供了一种创建一族相关对象的方法\",{\"1\":{\"103\":1}}],[\"抽象工厂模式包含以下角色\",{\"1\":{\"102\":1}}],[\"抽象工厂模式\",{\"1\":{\"66\":1,\"69\":1,\"101\":1}}],[\"抽象产品类\",{\"1\":{\"96\":1,\"99\":1,\"102\":1,\"103\":1}}],[\"返回true\",{\"1\":{\"191\":2}}],[\"返回值只会包含该时间序列的最新值的一个样本\",{\"1\":{\"138\":1}}],[\"返回一个具体的产品对象sofa\",{\"1\":{\"99\":1}}],[\"返回不同类的实例对象\",{\"1\":{\"95\":1}}],[\"返回顶部按钮\",{\"1\":{\"7\":1,\"45\":1}}],[\"根据对象的每个属性计算一个哈希码\",{\"1\":{\"192\":1}}],[\"根据实际情况\",{\"1\":{\"163\":1}}],[\"根据实际的情况做设计和优化\",{\"1\":{\"93\":1}}],[\"根据标签匹配\",{\"1\":{\"162\":1}}],[\"根据客户端传入的参数来创建相应的产品对象sofa\",{\"1\":{\"97\":1}}],[\"根据传入参数的不同\",{\"1\":{\"95\":1}}],[\"根据借款金额的不同\",{\"1\":{\"92\":1}}],[\"很多人会说在比较对象的时候\",{\"1\":{\"191\":1}}],[\"很可能淹没掉一些其他的告警消息\",{\"1\":{\"159\":1}}],[\"很难去排查\",{\"1\":{\"93\":1}}],[\"很好的避免了现有类和适配者类的耦合\",{\"1\":{\"83\":1}}],[\"总结来说\",{\"1\":{\"199\":1}}],[\"总结\",{\"0\":{\"128\":1,\"151\":1,\"177\":1},\"1\":{\"179\":1}}],[\"总之\",{\"1\":{\"93\":1}}],[\"总共有23种设计模式\",{\"1\":{\"65\":1}}],[\"制定不同的处理流程\",{\"1\":{\"93\":1}}],[\"降低逻辑单元之间的耦合度\",{\"1\":{\"93\":1}}],[\"每次对string进行修改时都要创建一个新的对象\",{\"1\":{\"182\":1}}],[\"每次对string进行修改操作都会创建一个新的string对象\",{\"1\":{\"182\":1}}],[\"每个类都可以重写finalize方法来执行对象的清理操作\",{\"1\":{\"198\":1}}],[\"每个对象都有自己的状态\",{\"1\":{\"183\":1}}],[\"每个对象都是某个类的实例\",{\"1\":{\"183\":1}}],[\"每个模块都包含一系列的操作步骤\",{\"1\":{\"183\":1}}],[\"每个键值对都是一个条目\",{\"1\":{\"176\":1}}],[\"每个键都是唯一的\",{\"1\":{\"173\":1}}],[\"每个recording\",{\"1\":{\"169\":1}}],[\"每个部分包含的可配置的参数很多\",{\"1\":{\"163\":1}}],[\"每个prometheus都是单节点设计的\",{\"1\":{\"121\":1}}],[\"每个方法对应一个具体产品类的创建方法\",{\"1\":{\"102\":1}}],[\"每个具体产品都需要一个具体工厂类来创建\",{\"1\":{\"100\":1}}],[\"每个逻辑单元的功能都是解藕的\",{\"1\":{\"93\":1}}],[\"每个逻辑单元组成了链中的一环\",{\"1\":{\"93\":1}}],[\"每种设计模式有非常多的应用\",{\"1\":{\"69\":1}}],[\"每种类型的设计模式又包含了多种设计模式\",{\"1\":{\"65\":1}}],[\"金额太大\",{\"1\":{\"92\":1}}],[\"5763175\",{\"1\":{\"167\":1}}],[\"5782e\",{\"1\":{\"124\":1}}],[\"51cto\",{\"1\":{\"167\":1}}],[\"512\",{\"1\":{\"87\":2}}],[\"5h\",{\"1\":{\"149\":1}}],[\"501\",{\"1\":{\"145\":1}}],[\"5001\",{\"1\":{\"162\":1}}],[\"500\",{\"1\":{\"145\":5}}],[\"5000\",{\"1\":{\"92\":1}}],[\"5m\",{\"1\":{\"132\":1,\"133\":1,\"138\":1,\"139\":3,\"148\":5,\"162\":2,\"163\":2,\"171\":3}}],[\"5\",{\"1\":{\"124\":1,\"135\":1,\"146\":1,\"148\":1,\"154\":3,\"190\":2}}],[\"5<\",{\"1\":{\"113\":1}}],[\"财物权限不够\",{\"1\":{\"92\":2}}],[\"财务\",{\"1\":{\"92\":1}}],[\"审批不通过\",{\"1\":{\"92\":1}}],[\"审批通过\",{\"1\":{\"92\":1}}],[\"审批拒绝\",{\"1\":{\"92\":1}}],[\"里面有具体的处理逻辑\",{\"1\":{\"92\":1}}],[\"里氏代换原则是继承复用的基石\",{\"1\":{\"70\":1}}],[\"里氏替换原则\",{\"1\":{\"70\":1}}],[\"继承了aproval\",{\"1\":{\"92\":1}}],[\"经常选择使用对象的一些属性进行比较\",{\"1\":{\"192\":1}}],[\"经常需要新的项目中需要对老代码进行适配才能用\",{\"1\":{\"81\":1}}],[\"经理权限不够\",{\"1\":{\"92\":2}}],[\"经理审批通过\",{\"1\":{\"92\":1}}],[\"经历\",{\"1\":{\"92\":1}}],[\"案例实战\",{\"0\":{\"92\":1,\"106\":1}}],[\"处理类的实现类handlera\",{\"1\":{\"91\":1}}],[\"处理类handler\",{\"1\":{\"91\":1}}],[\"后面的值会覆盖前面的值\",{\"1\":{\"176\":1}}],[\"后面加一些功能\",{\"1\":{\"88\":1}}],[\"后使用压缩解压装饰器\",{\"1\":{\"87\":1}}],[\"满足单一职责的原则\",{\"1\":{\"88\":1}}],[\"满足里氏替换原则\",{\"1\":{\"83\":1}}],[\"希望继承原有类的功能\",{\"1\":{\"88\":1}}],[\"达到不同的效果\",{\"1\":{\"88\":1}}],[\"解决这些冲突需要额外的语法规则和解析过程\",{\"1\":{\"181\":1}}],[\"解缩后的内容为\",{\"1\":{\"87\":2}}],[\"解密后\",{\"1\":{\"87\":2}}],[\"解释器模式\",{\"1\":{\"68\":1}}],[\"压缩后的内容为\",{\"1\":{\"87\":2}}],[\"压缩解压装饰器\",{\"1\":{\"87\":1}}],[\"+name2\",{\"1\":{\"179\":1}}],[\"+name1\",{\"1\":{\"179\":1}}],[\"+name\",{\"1\":{\"179\":1}}],[\"+sum\",{\"1\":{\"141\":1}}],[\"+prometheus\",{\"1\":{\"141\":1}}],[\"+inf\",{\"1\":{\"134\":1,\"154\":1}}],[\"+obj\",{\"1\":{\"106\":1}}],[\"+\",{\"1\":{\"97\":1,\"103\":1,\"112\":2,\"141\":1,\"153\":1,\"154\":1,\"174\":4,\"175\":3,\"176\":9,\"192\":1,\"193\":2,\"197\":3}}],[\"+rw\",{\"1\":{\"87\":1}}],[\"+filereaderwriter\",{\"1\":{\"87\":1}}],[\"+text\",{\"1\":{\"87\":1}}],[\"+=\",{\"1\":{\"87\":1}}],[\"updated\",{\"1\":{\"174\":4,\"175\":2,\"176\":2}}],[\"up\",{\"1\":{\"171\":1}}],[\"url\",{\"1\":{\"162\":1,\"163\":1}}],[\"uri\",{\"1\":{\"154\":4,\"156\":2}}],[\"uri=request\",{\"1\":{\"154\":1}}],[\"uri=\",{\"1\":{\"153\":3,\"154\":15}}],[\"unchecked异常不要求在代码中进行处理或声明\",{\"1\":{\"193\":1}}],[\"unchecked\",{\"1\":{\"193\":1}}],[\"unknown\",{\"1\":{\"153\":1,\"154\":1}}],[\"unless\",{\"1\":{\"143\":1}}],[\"union\",{\"1\":{\"143\":1}}],[\"util\",{\"1\":{\"106\":2,\"174\":2,\"175\":2,\"176\":2}}],[\"usually\",{\"1\":{\"163\":3}}],[\"user\",{\"1\":{\"153\":1,\"154\":1}}],[\"users\",{\"1\":{\"87\":1}}],[\"used\",{\"1\":{\"124\":1,\"199\":1}}],[\"use\",{\"1\":{\"124\":1,\"171\":1}}],[\"us\",{\"1\":{\"97\":1}}],[\"uml图如下\",{\"1\":{\"105\":1}}],[\"uml图\",{\"0\":{\"86\":1,\"96\":1,\"99\":1,\"102\":1}}],[\"uml\",{\"1\":{\"81\":1,\"109\":1}}],[\"加\",{\"1\":{\"141\":1}}],[\"加减密装饰器和压缩解缩的装饰器\",{\"1\":{\"87\":1}}],[\"加密后\",{\"1\":{\"87\":2}}],[\"加密装饰器\",{\"1\":{\"87\":1}}],[\"加密展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"嵌套了两个装饰器\",{\"1\":{\"87\":1}}],[\"写一个接口如下\",{\"1\":{\"166\":1}}],[\"写一个观察者接口observer\",{\"1\":{\"106\":1}}],[\"写一个客户端实现类\",{\"1\":{\"110\":1}}],[\"写一个客户端用于测试\",{\"1\":{\"100\":1}}],[\"写一个客户端\",{\"1\":{\"97\":1}}],[\"写一个客户端测试类\",{\"1\":{\"87\":1,\"106\":1}}],[\"写一个测试类\",{\"1\":{\"92\":1,\"103\":1,\"113\":1,\"179\":1}}],[\"写作日期为\",{\"1\":{\"43\":1}}],[\"<<class>>\",{\"1\":{\"193\":3}}],[\"<duration>\",{\"1\":{\"169\":1}}],[\"<dependency>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"<rfc3339>\",{\"1\":{\"166\":2}}],[\"<resolved|firing>\",{\"1\":{\"166\":2}}],[\"<object>\",{\"1\":{\"166\":5}}],[\"<int>\",{\"1\":{\"166\":1}}],[\"<string>\",{\"1\":{\"166\":5}}],[\"<scope>test<\",{\"1\":{\"153\":1}}],[\"<version>1\",{\"1\":{\"153\":1,\"154\":3}}],[\"<vector\",{\"1\":{\"146\":1}}],[\"<groupid>io\",{\"1\":{\"153\":1,\"154\":3}}],[\"<groupid>org\",{\"1\":{\"153\":2}}],[\"<groupid>cglib<\",{\"1\":{\"113\":1}}],[\"<label\",{\"1\":{\"146\":1}}],[\"<artifactid>prometheus\",{\"1\":{\"154\":3}}],[\"<artifactid>micrometer\",{\"1\":{\"153\":1}}],[\"<artifactid>spring\",{\"1\":{\"153\":2}}],[\"<artifactid>cglib<\",{\"1\":{\"113\":1}}],[\"<aggr\",{\"1\":{\"146\":1}}],[\"<=\",{\"1\":{\"142\":1}}],[\"<\",{\"1\":{\"87\":2,\"92\":2,\"106\":1,\"113\":1,\"130\":1,\"142\":1,\"149\":1,\"153\":3,\"154\":3,\"192\":1}}],[\"woof\",{\"1\":{\"185\":2}}],[\"we\",{\"1\":{\"171\":1}}],[\"webmvcconfigurer\",{\"1\":{\"154\":1}}],[\"webconfig\",{\"1\":{\"154\":1}}],[\"web\",{\"1\":{\"126\":2,\"153\":1,\"154\":2,\"162\":2,\"163\":2}}],[\"webhook\",{\"0\":{\"166\":1},\"1\":{\"120\":1,\"162\":1,\"163\":2,\"166\":7}}],[\"www\",{\"1\":{\"167\":1}}],[\"wuhan\",{\"1\":{\"164\":1,\"172\":1}}],[\"wangwu\",{\"1\":{\"179\":1}}],[\"warning\",{\"1\":{\"162\":1,\"163\":2}}],[\"wait\",{\"1\":{\"162\":1,\"163\":6}}],[\"w\",{\"1\":{\"138\":1}}],[\"windows系统和mac系统\",{\"1\":{\"125\":1}}],[\"windows\",{\"1\":{\"123\":1}}],[\"without\",{\"1\":{\"146\":1,\"171\":4}}],[\"without|by\",{\"1\":{\"146\":1}}],[\"with\",{\"1\":{\"87\":1,\"146\":1}}],[\"which\",{\"1\":{\"163\":2}}],[\"while\",{\"1\":{\"87\":2,\"191\":1}}],[\"where\",{\"1\":{\"28\":1}}],[\"write\",{\"1\":{\"87\":10}}],[\"也返回true\",{\"1\":{\"191\":1}}],[\"也应返回true\",{\"1\":{\"191\":2}}],[\"也就是说\",{\"1\":{\"185\":1}}],[\"也就是能够根据需求\",{\"1\":{\"88\":1}}],[\"也查询handler不为\",{\"1\":{\"137\":1}}],[\"也适合高度动态的面向服务的体系结构的监视\",{\"1\":{\"121\":1}}],[\"也让代码扩展变得非常困难\",{\"1\":{\"107\":1}}],[\"也称为静态工厂方法模式\",{\"1\":{\"95\":1}}],[\"也有可能影响系统的性能\",{\"1\":{\"93\":1}}],[\"也可以在构造函数中赋值\",{\"1\":{\"196\":1}}],[\"也可以进行模糊匹配\",{\"1\":{\"137\":1}}],[\"也可以配置静态采集任务\",{\"1\":{\"124\":1}}],[\"也可以是consul\",{\"1\":{\"120\":1}}],[\"也可以是短生命周期的任务推送到pushgateway的指标\",{\"1\":{\"120\":1}}],[\"也可以是一个抽象类\",{\"1\":{\"91\":1}}],[\"也可以通过静态的配置去发现采集目标\",{\"1\":{\"118\":1}}],[\"也可以使用\",{\"1\":{\"137\":1}}],[\"也可以使用多个标签值进行进行查询\",{\"1\":{\"137\":1}}],[\"也可以使用push模式\",{\"1\":{\"118\":1}}],[\"也可以使用第三方时序数据去存储\",{\"1\":{\"118\":1}}],[\"也可以深入到进程内部关键点的监控\",{\"1\":{\"118\":1}}],[\"也可以用它来向观察者发送消息\",{\"1\":{\"106\":1}}],[\"也可以根据需求快速的删除一些逻辑单元\",{\"1\":{\"93\":1}}],[\"也可以读取文件的字符\",{\"1\":{\"87\":1}}],[\"也可以把他们的顺序对调\",{\"1\":{\"87\":1}}],[\"也不会频繁创建对象\",{\"1\":{\"76\":1}}],[\"做下面的增强功能\",{\"1\":{\"87\":1}}],[\"装饰模式不改变原有类的结构\",{\"1\":{\"86\":1}}],[\"装饰器非常的灵活\",{\"1\":{\"86\":1}}],[\"装饰器componentdecoratorb和componentdecoratora\",{\"1\":{\"86\":1}}],[\"装饰器模式经常使用到以下场景\",{\"1\":{\"86\":1}}],[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能\",{\"1\":{\"67\":1,\"85\":1}}],[\"装饰器模式\",{\"0\":{\"85\":1},\"1\":{\"67\":1,\"69\":1}}],[\"什么是time\",{\"0\":{\"130\":1}}],[\"什么是prometheus\",{\"0\":{\"117\":1}}],[\"什么是单例模式\",{\"0\":{\"72\":1}}],[\"什么时候使用装饰器模式\",{\"1\":{\"86\":1}}],[\"组内的规则以固定的时间间隔按顺序运行\",{\"1\":{\"169\":1}}],[\"组成了链式的执行顺序\",{\"1\":{\"90\":1}}],[\"组件\",{\"0\":{\"119\":1}}],[\"组件实现类componentimpl\",{\"1\":{\"86\":1}}],[\"组件component\",{\"1\":{\"86\":1}}],[\"组合优先原则\",{\"1\":{\"70\":1}}],[\"组合模式\",{\"1\":{\"67\":1}}],[\"各种reader一层套一层\",{\"1\":{\"85\":1}}],[\"相应的try语句一定被执行到\",{\"1\":{\"199\":1}}],[\"相等性\",{\"1\":{\"192\":1}}],[\"相同的元素可以出现在列表的不同位置\",{\"1\":{\"174\":1}}],[\"相比之下\",{\"1\":{\"183\":1}}],[\"相比java动态代理而言更为复杂\",{\"1\":{\"113\":1}}],[\"相比java动态代理\",{\"1\":{\"113\":1}}],[\"相比直接调用实现类的方法\",{\"1\":{\"112\":1}}],[\"相对于简单工厂\",{\"1\":{\"100\":1}}],[\"相当于对原有的类进行类一个包装\",{\"1\":{\"85\":1}}],[\"相关信息\",{\"1\":{\"15\":1}}],[\"适配者类无论出现什么新功能\",{\"1\":{\"83\":1}}],[\"适配器只有同时实现或者持有目标接口和被适配的对象\",{\"1\":{\"82\":1}}],[\"适配器类只要不影响目标类的接口功能\",{\"1\":{\"83\":1}}],[\"适配器类adapter\",{\"1\":{\"81\":1}}],[\"适配器类即将要进行适配的抽象类或接口\",{\"1\":{\"81\":1}}],[\"适配器可以让不兼容的两个类一起协同工作\",{\"1\":{\"81\":1}}],[\"适配器模式的定义是\",{\"1\":{\"81\":1}}],[\"适配器模式就是将旧代码和新程序的中间的转换角色\",{\"1\":{\"81\":1}}],[\"适配器模式\",{\"0\":{\"81\":1},\"1\":{\"67\":1,\"69\":1}}],[\"互不干扰\",{\"1\":{\"83\":1}}],[\"拓展新的适配者类功能\",{\"1\":{\"83\":1}}],[\"拓展坞将typec接口转换成usb接口\",{\"1\":{\"82\":1}}],[\"拓展坞适配器\",{\"1\":{\"82\":1}}],[\"难以维护\",{\"1\":{\"83\":1}}],[\"首先创建一个审批抽象类aproval\",{\"1\":{\"92\":1}}],[\"首先\",{\"1\":{\"83\":1,\"87\":1,\"197\":1}}],[\"新建一个recoding\",{\"1\":{\"172\":1}}],[\"新建一个springboot项目\",{\"1\":{\"153\":1}}],[\"新增产品族\",{\"1\":{\"103\":1}}],[\"新增一族产品时\",{\"1\":{\"103\":1}}],[\"新增一个逻辑功能\",{\"1\":{\"93\":1}}],[\"新写一个方法就可以将需要适配的类进行转换\",{\"1\":{\"83\":1}}],[\"新的序列名称为record中的值\",{\"1\":{\"169\":1}}],[\"新的软件开发模式\",{\"1\":{\"64\":1}}],[\"新的工具\",{\"1\":{\"64\":1}}],[\"新的框架\",{\"1\":{\"64\":1}}],[\"才能进行适配工作\",{\"1\":{\"82\":1}}],[\"才会初始化内部类\",{\"1\":{\"76\":1}}],[\"zero\",{\"1\":{\"193\":1}}],[\"z0\",{\"1\":{\"130\":1}}],[\"za\",{\"1\":{\"130\":2}}],[\"zxvf\",{\"1\":{\"123\":1,\"127\":1}}],[\"zkt5tvq5eu1zoxnktuzrt1q6zu17ddlhqkvfsennot4=\",{\"1\":{\"87\":1}}],[\"z\",{\"1\":{\"82\":2,\"130\":1,\"191\":2}}],[\"连上了usb接口\",{\"1\":{\"82\":1}}],[\"y和z\",{\"1\":{\"191\":1}}],[\"yunlzheng\",{\"1\":{\"167\":1}}],[\"yml去配置所有的告警规则文件\",{\"1\":{\"164\":1}}],[\"yml的文件\",{\"1\":{\"164\":1,\"172\":1}}],[\"yml中\",{\"1\":{\"125\":1}}],[\"yml\",{\"1\":{\"124\":3,\"162\":1,\"164\":1,\"172\":2}}],[\"y\",{\"1\":{\"82\":5,\"138\":1,\"191\":3}}],[\"xpost\",{\"1\":{\"126\":1}}],[\"x\",{\"1\":{\"82\":5,\"191\":4}}],[\"实际上调用的是\",{\"1\":{\"185\":1}}],[\"实际上会调用子类中的方法\",{\"1\":{\"185\":1}}],[\"实际调用的是该对象的实际类型中定义的方法\",{\"1\":{\"185\":1}}],[\"实际的文章内容\",{\"1\":{\"10\":1}}],[\"实战\",{\"0\":{\"172\":1}}],[\"实现接口的类必须提供所有抽象方法的具体实现\",{\"1\":{\"180\":1}}],[\"实现方式\",{\"1\":{\"180\":1}}],[\"实现方式有两种\",{\"1\":{\"152\":1}}],[\"实现类也可以重写接口的默认方法\",{\"1\":{\"180\":1}}],[\"实现代理如下\",{\"1\":{\"112\":1}}],[\"实现被代理对象的接口\",{\"1\":{\"109\":1}}],[\"实现抽象工厂类中定义的工厂方法makesofa\",{\"1\":{\"99\":1}}],[\"实现了java的跨平台特性\",{\"1\":{\"194\":1}}],[\"实现了多态性的特性\",{\"1\":{\"185\":1}}],[\"实现了代码的灵活性和扩展性\",{\"1\":{\"185\":1}}],[\"实现了\",{\"1\":{\"180\":1}}],[\"实现了抽象主题类\",{\"1\":{\"110\":1}}],[\"实现了抽象主题类的方法\",{\"1\":{\"109\":1}}],[\"实现了抽象接口类\",{\"1\":{\"109\":1}}],[\"实现了抽象工厂\",{\"1\":{\"103\":1}}],[\"实现了抽象工厂接口\",{\"1\":{\"102\":1}}],[\"实现了抽象产品类的属性和方法\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"实现了itypec的目标接口接口\",{\"1\":{\"82\":1}}],[\"实现了usb接口\",{\"1\":{\"81\":1}}],[\"持有适配者的类keyboard\",{\"1\":{\"81\":1}}],[\"目前支持linux系统\",{\"1\":{\"125\":1}}],[\"目前提供了linux\",{\"1\":{\"123\":1}}],[\"目标警报和源警报在相等列表中的标签名称必须具有相同的标签值\",{\"1\":{\"163\":1}}],[\"目标\",{\"1\":{\"163\":1}}],[\"目标类和适配者类是通过适配器进行交互的\",{\"1\":{\"83\":1}}],[\"目标类和适配者类各司其职\",{\"1\":{\"83\":1}}],[\"目标类target\",{\"1\":{\"81\":1}}],[\"目标接口itypec\",{\"1\":{\"82\":1}}],[\"目录\",{\"0\":{\"5\":1}}],[\"从父类继承过来的方法\",{\"1\":{\"185\":1}}],[\"从集合中删除元素\",{\"1\":{\"175\":1}}],[\"从而触发异常处理机制\",{\"1\":{\"193\":1}}],[\"从而达到类似多继承的效果\",{\"1\":{\"181\":1}}],[\"从而达到以下目的\",{\"1\":{\"121\":1}}],[\"从而使得一个实现类有不同接口的多态性\",{\"1\":{\"180\":1}}],[\"从而导致一些系统问题\",{\"1\":{\"159\":1}}],[\"从而能够对问题进行快速的处理或者提前预防问题的发生\",{\"1\":{\"121\":1}}],[\"从而提高整个系统的性能\",{\"1\":{\"72\":1}}],[\"从2012年开始由前google工程师以开源软件的形式进行研发\",{\"1\":{\"117\":1}}],[\"从uml图上可以得出\",{\"1\":{\"105\":1}}],[\"从上面的\",{\"1\":{\"109\":1}}],[\"从上面的分析原因我们可以得出\",{\"1\":{\"93\":1}}],[\"从上面的使用场景\",{\"1\":{\"93\":1}}],[\"从该uml中中\",{\"1\":{\"91\":1}}],[\"从\",{\"1\":{\"81\":1}}],[\"给键盘使用\",{\"1\":{\"81\":1}}],[\"给用于定义语言的语法规则表示\",{\"1\":{\"68\":1}}],[\"今天这一讲\",{\"1\":{\"81\":1}}],[\"gitbook\",{\"1\":{\"167\":1}}],[\"github\",{\"1\":{\"80\":2,\"92\":2,\"106\":5,\"125\":1,\"154\":1,\"199\":1}}],[\"g\",{\"1\":{\"166\":1}}],[\"gloabl配置\",{\"1\":{\"163\":1}}],[\"global\",{\"1\":{\"124\":4,\"162\":2,\"163\":1,\"169\":1}}],[\"gauge类型的指标主要反映的是当前的状态\",{\"1\":{\"133\":1}}],[\"gauge仪表盘\",{\"0\":{\"133\":1}}],[\"gauge\",{\"1\":{\"124\":4,\"131\":1,\"153\":1}}],[\"garbage\",{\"1\":{\"124\":1,\"135\":1}}],[\"gateway是用来短暂存储push类型指标的\",{\"1\":{\"119\":1}}],[\"gateway\",{\"1\":{\"118\":1}}],[\"gc\",{\"1\":{\"124\":9,\"135\":10}}],[\"go1\",{\"1\":{\"124\":1}}],[\"goroutines\",{\"1\":{\"124\":4}}],[\"go\",{\"1\":{\"124\":25,\"135\":9}}],[\"gz\",{\"1\":{\"123\":1,\"127\":2}}],[\"greeting\",{\"1\":{\"179\":4}}],[\"greater\",{\"1\":{\"142\":2}}],[\"group执行的时间间隔\",{\"1\":{\"169\":1}}],[\"group的名称\",{\"1\":{\"169\":1}}],[\"group可以配置两个参数\",{\"1\":{\"169\":1}}],[\"grouplabels\",{\"1\":{\"166\":2}}],[\"groupkey\",{\"1\":{\"166\":2}}],[\"groups\",{\"1\":{\"164\":1,\"169\":2,\"172\":1}}],[\"grouped\",{\"1\":{\"163\":1}}],[\"group\",{\"0\":{\"145\":1},\"1\":{\"145\":3,\"146\":1,\"162\":3,\"163\":9,\"166\":1}}],[\"groupid>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"grass\",{\"1\":{\"179\":2}}],[\"grapes\",{\"1\":{\"174\":3}}],[\"graph\",{\"1\":{\"125\":1}}],[\"grafna的安装\",{\"1\":{\"122\":1}}],[\"grafana作为数据展示前端\",{\"1\":{\"128\":1}}],[\"grafana的默认登陆用户名admin\",{\"1\":{\"127\":1}}],[\"grafana有很多配置项在conf目录下default\",{\"1\":{\"127\":1}}],[\"grafana可以完美的和prometheus结合\",{\"1\":{\"127\":1}}],[\"grafana是一个开源的\",{\"1\":{\"127\":1}}],[\"grafana安装\",{\"0\":{\"127\":1}}],[\"grafana\",{\"1\":{\"115\":1,\"127\":6}}],[\"generatorurl\",{\"1\":{\"166\":2}}],[\"generation\",{\"1\":{\"113\":1}}],[\"getmessage\",{\"1\":{\"193\":1}}],[\"getage\",{\"1\":{\"196\":1}}],[\"getarea\",{\"1\":{\"180\":4}}],[\"getattribute\",{\"1\":{\"154\":1}}],[\"getvalue\",{\"1\":{\"176\":2}}],[\"getkey\",{\"1\":{\"176\":2}}],[\"getrequesturi\",{\"1\":{\"154\":1}}],[\"getproxyinstance\",{\"1\":{\"113\":2}}],[\"getinterfaces\",{\"1\":{\"112\":1}}],[\"getinstance\",{\"1\":{\"74\":1,\"75\":1,\"78\":1,\"79\":1}}],[\"getclassloader\",{\"1\":{\"112\":1}}],[\"getclass\",{\"1\":{\"112\":2,\"113\":1}}],[\"get\",{\"1\":{\"106\":1,\"145\":6,\"153\":3,\"171\":1,\"174\":2,\"176\":2}}],[\"getname\",{\"1\":{\"97\":4,\"103\":3,\"112\":2,\"196\":1}}],[\"getnextapproval\",{\"1\":{\"92\":3}}],[\"getdecoder\",{\"1\":{\"87\":2}}],[\"getencoder\",{\"1\":{\"87\":2}}],[\"getbytes\",{\"1\":{\"87\":2}}],[\"getsingleton\",{\"1\":{\"76\":1}}],[\"get­instance\",{\"1\":{\"73\":1}}],[\"下载地址\",{\"1\":{\"162\":1}}],[\"下载地址为\",{\"1\":{\"125\":1}}],[\"下载地址为https\",{\"1\":{\"123\":1}}],[\"下载并解压成功后\",{\"1\":{\"127\":1}}],[\"下载命令如下\",{\"1\":{\"127\":1}}],[\"下载完成后\",{\"1\":{\"123\":1,\"125\":1}}],[\"下图是prometheus和它周边生态组件的架构图\",{\"1\":{\"120\":1}}],[\"下面是java\",{\"1\":{\"173\":1}}],[\"下面是懒汉模式的线程安全的\",{\"1\":{\"79\":1}}],[\"下面是最简单的懒汉模式的单列模式\",{\"1\":{\"78\":1}}],[\"下一篇\",{\"1\":{\"7\":1}}],[\"懒汉模式\",{\"0\":{\"78\":1,\"79\":1}}],[\"jar\",{\"1\":{\"194\":1}}],[\"javabasiclab\",{\"1\":{\"199\":1}}],[\"java会将这个变量复制一份作为成员变量内置于内部类中\",{\"1\":{\"197\":1}}],[\"java会自动调用相应的包装类方法\",{\"1\":{\"184\":1}}],[\"javac\",{\"1\":{\"194\":1}}],[\"java语言中提供了一些列的异常处理关键字和处理模板\",{\"1\":{\"193\":1}}],[\"java允许开发者自定义异常类\",{\"1\":{\"193\":1}}],[\"java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况\",{\"1\":{\"193\":1}}],[\"java中的异常处理机制\",{\"0\":{\"193\":1}}],[\"java提供了对应的包装类来对基本类型进行包装\",{\"1\":{\"184\":1}}],[\"java提供了java\",{\"1\":{\"112\":1}}],[\"java不允许在方法中使用同名的不同类型的参数\",{\"1\":{\"184\":1}}],[\"java不支持多继承是为了避免多继承带来的上述问题\",{\"1\":{\"181\":1}}],[\"java是一种面向对象的语言\",{\"1\":{\"184\":1}}],[\"java的异常处理机制是java程序设计中非常重要的一个方面\",{\"1\":{\"193\":1}}],[\"java的泛型不支持基本类型\",{\"1\":{\"184\":1}}],[\"java的设计理念是\",{\"1\":{\"181\":1}}],[\"java基础高频面试题2\",{\"0\":{\"188\":1}}],[\"java基础高频面试题1\",{\"0\":{\"178\":1}}],[\"java基本类型\",{\"1\":{\"184\":1}}],[\"java基本类型为什么需要包装类\",{\"0\":{\"184\":1}}],[\"java选择了单继承并使用了接口\",{\"1\":{\"181\":1}}],[\"java支持多实现\",{\"1\":{\"180\":1}}],[\"java只支持单继承\",{\"1\":{\"180\":1}}],[\"javax\",{\"1\":{\"154\":2}}],[\"java动态代理不需要任何依赖\",{\"1\":{\"112\":1}}],[\"java动态代理是基于反射生产的一个代理类\",{\"1\":{\"112\":1}}],[\"java后端技术\",{\"0\":{\"0\":1}}],[\"java\",{\"0\":{\"0\":1,\"112\":1,\"173\":1},\"1\":{\"80\":3,\"92\":2,\"106\":7,\"111\":1,\"112\":3,\"173\":4,\"174\":3,\"175\":2,\"176\":2,\"180\":4,\"185\":3,\"189\":1,\"194\":4}}],[\"jdb\",{\"1\":{\"194\":1}}],[\"jdk1\",{\"1\":{\"197\":1}}],[\"jdk包含jre\",{\"1\":{\"194\":1}}],[\"jdk还提供了各种开发文档和示例代码\",{\"1\":{\"194\":1}}],[\"jdk\",{\"0\":{\"194\":1},\"1\":{\"194\":1}}],[\"jdk动态代理\",{\"1\":{\"112\":1}}],[\"jre包含jvm\",{\"1\":{\"194\":1}}],[\"jre只提供了java应用程序的运行环境\",{\"1\":{\"194\":1}}],[\"jre\",{\"0\":{\"194\":1},\"1\":{\"194\":1}}],[\"j\",{\"1\":{\"184\":1}}],[\"ji\",{\"1\":{\"167\":1}}],[\"jianshu\",{\"1\":{\"167\":1}}],[\"jvm解析java字节码\",{\"1\":{\"194\":1}}],[\"jvm的区别和联系\",{\"0\":{\"194\":1}}],[\"jvm\",{\"1\":{\"193\":1,\"194\":1}}],[\"jvm规范没有明确规定其所占的空间大小\",{\"1\":{\"190\":1}}],[\"jvm是用于暴露jvm相关的指标\",{\"1\":{\"154\":1}}],[\"jvm<\",{\"1\":{\"154\":1}}],[\"jvm在执行类的初始化的时候\",{\"1\":{\"76\":1}}],[\"job=\",{\"1\":{\"133\":1,\"146\":1,\"149\":1,\"150\":10,\"171\":9}}],[\"job\",{\"1\":{\"124\":1,\"125\":2,\"146\":2,\"155\":1,\"169\":2,\"171\":2}}],[\"延迟初始化\",{\"1\":{\"76\":1}}],[\"有一个eat的方法\",{\"1\":{\"179\":1}}],[\"有一个核心的抽象处理方法handle\",{\"1\":{\"92\":1}}],[\"有animal的父类\",{\"1\":{\"179\":1}}],[\"有序性\",{\"1\":{\"174\":1}}],[\"有两个greeting方法\",{\"1\":{\"179\":1}}],[\"有两个标签分别是instance和path\",{\"1\":{\"171\":1}}],[\"有两个目标\",{\"1\":{\"64\":1}}],[\"有1828个请求\",{\"1\":{\"134\":1}}],[\"有1827个请求\",{\"1\":{\"134\":1}}],[\"有相同指标名和标签构成的\",{\"1\":{\"130\":1}}],[\"有着非常大的创新\",{\"1\":{\"118\":1}}],[\"有以下的角色\",{\"1\":{\"105\":1}}],[\"有以下的优点在\",{\"1\":{\"76\":1}}],[\"有很多同类型的产品生产\",{\"1\":{\"101\":1}}],[\"伪代码的2\",{\"1\":{\"75\":1}}],[\"伪代码如下\",{\"1\":{\"75\":1}}],[\"当发生异常时\",{\"1\":{\"199\":2}}],[\"当发布者发布消息\",{\"1\":{\"105\":1}}],[\"当没有发生异常时\",{\"1\":{\"199\":1}}],[\"当变量被声明为final时\",{\"1\":{\"196\":1,\"198\":1}}],[\"当方法被声明为final时\",{\"1\":{\"196\":1,\"198\":1}}],[\"当类被声明为final时\",{\"1\":{\"196\":1,\"198\":1}}],[\"当用户在目标机器上运行java应用程序时\",{\"1\":{\"194\":1}}],[\"当try块中的代码发生异常时\",{\"1\":{\"193\":1}}],[\"当我们在重写equals\",{\"1\":{\"192\":1}}],[\"当我们重写equals\",{\"1\":{\"191\":1,\"192\":1}}],[\"当调用\",{\"1\":{\"185\":1}}],[\"当调用一个对象的方法时\",{\"1\":{\"185\":1}}],[\"当使用父类引用指向子类对象时\",{\"1\":{\"185\":1}}],[\"当字符串不需要修改时\",{\"1\":{\"182\":1}}],[\"当需要对字符串进行频繁的修改时\",{\"1\":{\"182\":1}}],[\"当需要频繁修改字符串时会产生大量的垃圾对象\",{\"1\":{\"182\":1}}],[\"当需要扩展新的功能\",{\"1\":{\"93\":1}}],[\"当一个类从多个父类继承相同名称的属性或方法时\",{\"1\":{\"181\":1}}],[\"当对指标用作除法\",{\"1\":{\"171\":1}}],[\"当对counter类型使用rate或者是irate操作\",{\"1\":{\"171\":1}}],[\"当对象发生改变时\",{\"1\":{\"104\":1}}],[\"当存在与另一组匹配器匹配的警报\",{\"1\":{\"163\":1}}],[\"当启动告警恢复逻辑时\",{\"1\":{\"163\":1}}],[\"当告警消息没有endts这个时间戳参数时\",{\"1\":{\"163\":1}}],[\"当集群不可用访问出发了告警\",{\"1\":{\"160\":1}}],[\"当然actuator有很多内置的指标\",{\"1\":{\"153\":1}}],[\"当中\",{\"1\":{\"148\":1}}],[\"当比较运算符左右与两个瞬时向量之间\",{\"1\":{\"142\":1,\"143\":1}}],[\"当问题发生后\",{\"1\":{\"121\":1}}],[\"当系统出现或者即将出现故障时\",{\"1\":{\"121\":1}}],[\"当借款金额大于10000元\",{\"1\":{\"92\":1}}],[\"当借款金额大于1000元小于5000元\",{\"1\":{\"92\":1}}],[\"当借款金额大于5000元小于10000元\",{\"1\":{\"92\":1}}],[\"当借款金额小于1000元\",{\"1\":{\"92\":1}}],[\"当声明对象的引用为volatile后\",{\"1\":{\"75\":1}}],[\"当线程1在执行上面伪代码时\",{\"1\":{\"75\":1}}],[\"线程不安全\",{\"0\":{\"78\":1,\"79\":1}}],[\"线程2访问的将是个还没初始化完毕的对象\",{\"1\":{\"75\":1}}],[\"线程2调用getsingleton方法\",{\"1\":{\"75\":1}}],[\"线程1执行到第3步时\",{\"1\":{\"75\":1}}],[\"线程安全等需要不可变性的情况\",{\"1\":{\"196\":1}}],[\"线程安全性\",{\"1\":{\"182\":1}}],[\"线程安全\",{\"0\":{\"74\":1,\"75\":1,\"76\":1},\"1\":{\"76\":1}}],[\">=\",{\"1\":{\"142\":1}}],[\">\",{\"1\":{\"130\":1,\"142\":1,\"164\":1,\"192\":1}}],[\"><\",{\"1\":{\"130\":2}}],[\">2\",{\"1\":{\"75\":1}}],[\">3\",{\"1\":{\"75\":1}}],[\"步骤变为1\",{\"1\":{\"75\":1}}],[\"因为垃圾回收器的工作是由java虚拟机自动处理的\",{\"1\":{\"198\":1}}],[\"因为在运行java应用程序时需要虚拟机来解释和执行java字节码\",{\"1\":{\"194\":1}}],[\"因为在开发java应用程序时需要运行java程序来进行测试和调试\",{\"1\":{\"194\":1}}],[\"因为包装类对象在使用==比较时\",{\"1\":{\"184\":1}}],[\"因为基本类型的参数值之间无法进行隐式转换\",{\"1\":{\"184\":1}}],[\"因为太基础了\",{\"1\":{\"177\":1}}],[\"因为左侧的表达式有一个handler=\",{\"1\":{\"141\":1}}],[\"因为两个handler标签值不一样\",{\"1\":{\"141\":1}}],[\"因为它是通过生成子类来代理目标类\",{\"1\":{\"113\":1}}],[\"因为重排序并不影响运行结果\",{\"1\":{\"75\":1}}],[\"因此它们之间的\",{\"1\":{\"190\":1}}],[\"因此在频繁修改字符串的场景下\",{\"1\":{\"182\":1}}],[\"因此包含了一些常用的方法\",{\"1\":{\"175\":1}}],[\"因此可以借助于\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"13\":1,\"190\":1}}],[\"设计目的\",{\"1\":{\"180\":1}}],[\"设计模式的几种原则\",{\"0\":{\"70\":1}}],[\"设计模式有23种\",{\"1\":{\"69\":1}}],[\"设计模式有哪些类型\",{\"0\":{\"65\":1}}],[\"设计模式可以分为三种类型\",{\"1\":{\"65\":1}}],[\"设计模式是软件开发的一种指导思想\",{\"1\":{\"64\":1}}],[\"设计模式面试概述\",{\"0\":{\"64\":1}}],[\"设置回调函数\",{\"1\":{\"113\":1}}],[\"设置父类\",{\"1\":{\"113\":1}}],[\"设置singleton指向刚分配的内存空间\",{\"1\":{\"75\":1}}],[\"31\",{\"1\":{\"192\":1}}],[\"37843943\",{\"1\":{\"167\":1}}],[\"3776\",{\"1\":{\"150\":6}}],[\"3775\",{\"1\":{\"150\":1}}],[\"3773\",{\"1\":{\"150\":1}}],[\"3769\",{\"1\":{\"150\":1}}],[\"3767\",{\"1\":{\"150\":1}}],[\"34\",{\"1\":{\"145\":1}}],[\"3884e\",{\"1\":{\"135\":1}}],[\"3600\",{\"1\":{\"133\":1,\"149\":1}}],[\"30\",{\"1\":{\"145\":2}}],[\"3030\",{\"1\":{\"127\":1}}],[\"30s\",{\"1\":{\"120\":1,\"162\":1,\"163\":2}}],[\"32\",{\"1\":{\"124\":1}}],[\"35\",{\"1\":{\"124\":1}}],[\"3的重排序在多线程中将被禁止\",{\"1\":{\"75\":1}}],[\"3\",{\"1\":{\"75\":1,\"82\":1,\"124\":1,\"134\":1,\"145\":1,\"150\":1,\"175\":1,\"176\":1,\"196\":1}}],[\"需要先安装jre\",{\"1\":{\"194\":1}}],[\"需要遵循以下几个规则\",{\"1\":{\"191\":1}}],[\"需要将父类引用的变量进行转换成子类的类型\",{\"1\":{\"185\":1}}],[\"需要包装类的原因有以下几个方面\",{\"1\":{\"184\":1}}],[\"需要注意的是在使用父类引用的变量去调用方法时\",{\"1\":{\"185\":1}}],[\"需要注意的是\",{\"1\":{\"180\":1,\"198\":1}}],[\"需要注意的是虽然抽象类shape具有构造函数\",{\"1\":{\"180\":1}}],[\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率\",{\"1\":{\"148\":1}}],[\"需要全局唯一\",{\"1\":{\"169\":1}}],[\"需要修改alertmanager的配置文件\",{\"1\":{\"162\":1}}],[\"需要修改抽象工厂的接口和具体工厂类\",{\"1\":{\"103\":1}}],[\"需要创建两个指标\",{\"1\":{\"154\":1}}],[\"需要为grafana配置prometheus的数据源\",{\"1\":{\"127\":1}}],[\"需要打开系统偏好设置\",{\"1\":{\"123\":1}}],[\"需要对问题进行调查和处理\",{\"1\":{\"121\":1}}],[\"需要对真实的代理对象的功能需要做一下加强\",{\"1\":{\"112\":1}}],[\"需要额外依赖\",{\"1\":{\"113\":1}}],[\"需要做性能测试\",{\"1\":{\"107\":1}}],[\"需要做更多的工作\",{\"1\":{\"107\":1}}],[\"需要权衡一下利弊\",{\"1\":{\"93\":1}}],[\"需要总裁审批\",{\"1\":{\"92\":2}}],[\"需要cfo审批\",{\"1\":{\"92\":1}}],[\"需要经理审批\",{\"1\":{\"92\":3}}],[\"需要不同的审批角色\",{\"1\":{\"92\":1}}],[\"需要扩展功能的时候\",{\"1\":{\"88\":1}}],[\"需要被适配的接口的实现类\",{\"1\":{\"82\":1}}],[\"需要被适配的接口usb接口\",{\"1\":{\"82\":1}}],[\"需要被适配器转换的对象\",{\"1\":{\"81\":1}}],[\"需要把typec接口转换成usb接口\",{\"1\":{\"81\":1}}],[\"需要第一次调用getsingleton\",{\"1\":{\"76\":1}}],[\"需要如下几步\",{\"1\":{\"75\":1}}],[\"需要表示全局唯一的对象\",{\"1\":{\"72\":1}}],[\"n\",{\"1\":{\"191\":3}}],[\"num2\",{\"1\":{\"193\":2}}],[\"num1\",{\"1\":{\"193\":2}}],[\"numerator\",{\"1\":{\"171\":1}}],[\"number\",{\"1\":{\"124\":4,\"146\":2}}],[\"null赋值\",{\"1\":{\"184\":1}}],[\"null\",{\"1\":{\"75\":2,\"78\":1,\"79\":1,\"87\":11,\"97\":1,\"112\":1,\"191\":1}}],[\"nginx\",{\"1\":{\"119\":1}}],[\"no\",{\"1\":{\"171\":1}}],[\"none\",{\"1\":{\"153\":3}}],[\"notification\",{\"1\":{\"163\":4}}],[\"notify\",{\"1\":{\"106\":7}}],[\"not\",{\"1\":{\"142\":1}}],[\"node\",{\"1\":{\"115\":1,\"122\":1,\"125\":4,\"133\":4,\"149\":2}}],[\"name2\",{\"1\":{\"179\":1}}],[\"name1\",{\"1\":{\"179\":1}}],[\"names\",{\"1\":{\"175\":14}}],[\"name=lisi\",{\"1\":{\"153\":2,\"154\":1}}],[\"name+\",{\"1\":{\"106\":1}}],[\"name\",{\"1\":{\"106\":4,\"124\":1,\"125\":2,\"130\":1,\"153\":4,\"154\":6,\"155\":1,\"162\":1,\"163\":1,\"164\":1,\"169\":2,\"172\":1,\"175\":4,\"176\":4,\"179\":1,\"196\":8}}],[\"never\",{\"1\":{\"199\":1}}],[\"net\",{\"1\":{\"167\":1}}],[\"nextapproval\",{\"1\":{\"92\":5}}],[\"newproxyinstance\",{\"1\":{\"112\":1}}],[\"new\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"82\":2,\"85\":2,\"87\":18,\"92\":3,\"97\":3,\"100\":2,\"103\":3,\"106\":3,\"110\":2,\"112\":2,\"113\":3,\"154\":1,\"163\":1,\"174\":1,\"175\":1,\"176\":1,\"180\":1,\"185\":2,\"190\":1,\"197\":3}}],[\"可变性\",{\"1\":{\"182\":1}}],[\"可变大小\",{\"1\":{\"174\":1}}],[\"可维护性和可扩展性\",{\"1\":{\"181\":1}}],[\"可重复性\",{\"1\":{\"174\":1}}],[\"可选参数\",{\"1\":{\"164\":1}}],[\"可选\",{\"1\":{\"154\":2}}],[\"可用通过prometheus的内置函数计算最近5分钟node\",{\"1\":{\"133\":1}}],[\"可增可减\",{\"1\":{\"131\":1}}],[\"可拓展性\",{\"1\":{\"112\":1}}],[\"可扩展性和易维护性\",{\"1\":{\"185\":1}}],[\"可扩展性和重用性\",{\"1\":{\"183\":1}}],[\"可扩展性很强\",{\"1\":{\"107\":1}}],[\"可扩展和可维护的链式处理的机制\",{\"1\":{\"93\":1}}],[\"可复用\",{\"1\":{\"83\":1}}],[\"可能在继承链中得到两个相同的父类实例\",{\"1\":{\"181\":1}}],[\"可能在某一时刻访问量突增\",{\"1\":{\"148\":1}}],[\"可能会发生异常的代码\",{\"1\":{\"198\":1}}],[\"可能会产生命名冲突\",{\"1\":{\"181\":1}}],[\"可能会同时存在多个实例的创建\",{\"1\":{\"78\":1}}],[\"可能有很多人比较疑惑\",{\"1\":{\"83\":1}}],[\"可能问的少一些\",{\"1\":{\"75\":1}}],[\"可以对其进行修改\",{\"1\":{\"182\":1}}],[\"可以对时间序列提供丰富的查询\",{\"1\":{\"136\":1}}],[\"可以被捕获并进行相应处理\",{\"1\":{\"193\":1}}],[\"可以被多个线程同时访问而不会导致错误\",{\"1\":{\"182\":1}}],[\"可以被类实现\",{\"1\":{\"180\":1}}],[\"可以被继承\",{\"1\":{\"180\":1}}],[\"可以有构造方法\",{\"1\":{\"180\":1}}],[\"可以有实例变量和构造方法\",{\"1\":{\"180\":1}}],[\"可以有以下几个配置项\",{\"1\":{\"169\":1}}],[\"可以包含普通方法的实现\",{\"1\":{\"180\":1}}],[\"可以包含普通方法和抽象方法\",{\"1\":{\"180\":1}}],[\"可以包含抽象方法\",{\"1\":{\"180\":1}}],[\"可以直接通过接口名调用\",{\"1\":{\"180\":1}}],[\"可以直接通过接口名直接访问\",{\"1\":{\"180\":1}}],[\"可以添加或删除元素\",{\"1\":{\"174\":1}}],[\"可以看到已经有一条告警消息已经发送给alertmanager\",{\"1\":{\"164\":1}}],[\"可以看到的规则状态如下\",{\"1\":{\"164\":1}}],[\"可以看到alertmanager的界面\",{\"1\":{\"163\":1}}],[\"可以看到有两个指标http\",{\"1\":{\"154\":1}}],[\"可以在代码块中赋值\",{\"1\":{\"196\":1}}],[\"可以在不同的操作系统上运行java程序\",{\"1\":{\"194\":1}}],[\"可以在原有对象的基础上进行修改\",{\"1\":{\"182\":1}}],[\"可以在新生成的指标上额外加一些标签\",{\"1\":{\"169\":1}}],[\"可以在运行时重新加载其配置\",{\"1\":{\"161\":1}}],[\"可以在grafana上查询\",{\"1\":{\"137\":1}}],[\"可以停止重复发送由此告警引发的其它告警的机制\",{\"1\":{\"160\":1}}],[\"可以得到\",{\"1\":{\"153\":1}}],[\"可以得到prometheus的监控指标\",{\"1\":{\"124\":1}}],[\"可以将上面的结果除以300\",{\"1\":{\"148\":1}}],[\"可以用来修饰类\",{\"1\":{\"198\":1}}],[\"可以用来聚合耽搁瞬时向量\",{\"1\":{\"146\":1}}],[\"可以用topk函数\",{\"1\":{\"146\":1}}],[\"可以应用于one\",{\"1\":{\"144\":1}}],[\"可以使用throw语句在程序中主动抛出异常\",{\"1\":{\"193\":1}}],[\"可以使用stringbuilder来获得更好的性能\",{\"1\":{\"182\":1}}],[\"可以使用string\",{\"1\":{\"182\":1}}],[\"可以使用\",{\"1\":{\"171\":1,\"180\":1}}],[\"可以使用如下表达式\",{\"1\":{\"149\":1}}],[\"可以使用rate函数计算速率\",{\"1\":{\"148\":1}}],[\"可以使用以下的表达式进行计算\",{\"1\":{\"148\":1}}],[\"可以使用increase函数计算增量数据\",{\"1\":{\"148\":1}}],[\"可以使用范围矢量查询\",{\"1\":{\"138\":1}}],[\"可以使用完全匹配\",{\"1\":{\"137\":1}}],[\"可以使用通配符\",{\"1\":{\"124\":1}}],[\"可以筛选出handler=\",{\"1\":{\"137\":1}}],[\"可以很容易一段时间的增量数据\",{\"1\":{\"132\":1}}],[\"可以让开发者轻松的实现监控大盘\",{\"1\":{\"127\":1}}],[\"可以访问prometheus自身的监控指标的暴露端点\",{\"1\":{\"124\":1}}],[\"可以配置多种分发方式\",{\"1\":{\"120\":1}}],[\"可以是k8s的集群的服务发现\",{\"1\":{\"120\":1}}],[\"可以是一个接口\",{\"1\":{\"91\":1}}],[\"可以和开源组件grafana无缝对接\",{\"1\":{\"118\":1}}],[\"可以通过以下几个方面来理解\",{\"1\":{\"185\":1}}],[\"可以通过抽象类的引用变量来指向它的实现类的实例\",{\"1\":{\"180\":1}}],[\"可以通过动态代理实现一些横切关注点\",{\"1\":{\"112\":1}}],[\"可以通过顺序组合包装的方式来附加扩张功能\",{\"1\":{\"87\":1}}],[\"可以动态地添加和删除观察者\",{\"1\":{\"107\":1}}],[\"可以动态的扩展责任链中的逻辑单元\",{\"1\":{\"93\":1}}],[\"可以利用发布者向所有的观察者发送消息\",{\"1\":{\"107\":1}}],[\"可以向它注册观察者对象\",{\"1\":{\"106\":1}}],[\"可以创建一系列相关的产品对象\",{\"1\":{\"103\":1}}],[\"可以方便地创建出不同的产品对象\",{\"1\":{\"100\":1}}],[\"可以灵活的控制责任链中逻辑单元的处理顺序\",{\"1\":{\"93\":1}}],[\"可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法\",{\"1\":{\"183\":1}}],[\"可以根据客户端的需求\",{\"1\":{\"97\":1}}],[\"可以根据不同的需求\",{\"1\":{\"93\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"13\":1}}],[\"可以写一个handler即可\",{\"1\":{\"93\":1}}],[\"可以快速判断一个元素是否存在于集合中\",{\"1\":{\"175\":1}}],[\"可以快速的装载和卸载逻辑单元\",{\"1\":{\"93\":1}}],[\"可以快速组合\",{\"1\":{\"88\":1}}],[\"可以快速装载和卸载增强功能\",{\"1\":{\"88\":1}}],[\"可以增加新的装饰器\",{\"1\":{\"88\":1}}],[\"可以按照需要使用不同装饰器组合\",{\"1\":{\"86\":1}}],[\"可以按照方法去构造对象\",{\"1\":{\"66\":1}}],[\"可以做到移植可复用\",{\"1\":{\"83\":1}}],[\"可以调用客户端对它们调用\",{\"1\":{\"82\":1}}],[\"可以节约系统的资源\",{\"1\":{\"72\":1}}],[\"可以极大程度的提高我们写代码的质量\",{\"1\":{\"69\":1}}],[\"近几年由于八股文泛滥\",{\"1\":{\"75\":1}}],[\"双重检查模式\",{\"1\":{\"75\":1}}],[\"双重检查\",{\"0\":{\"75\":1}}],[\"类的引用变量来引用\",{\"1\":{\"185\":1}}],[\"类的多态性得到了充分的展现\",{\"1\":{\"179\":1}}],[\"类型转换和字符串解析等\",{\"1\":{\"184\":1}}],[\"类型的引用变量\",{\"1\":{\"180\":1}}],[\"类通过使用关键字\",{\"1\":{\"180\":1}}],[\"类实现了\",{\"1\":{\"180\":1}}],[\"类似于mysql的sql查询语句\",{\"1\":{\"136\":1}}],[\"类似于kubernetes是从google的brog系统演变而来\",{\"1\":{\"117\":1}}],[\"类似于中介\",{\"1\":{\"108\":1}}],[\"类加载是加锁的\",{\"1\":{\"74\":1}}],[\"类和对象如何交互\",{\"1\":{\"68\":1}}],[\"自反性\",{\"1\":{\"191\":1}}],[\"自动拆箱\",{\"1\":{\"184\":1}}],[\"自动装箱\",{\"1\":{\"184\":1}}],[\"自动创建hugryinstance的静态实例\",{\"1\":{\"74\":1}}],[\"自定义异常类通常继承自exception或runtimeexception类\",{\"1\":{\"193\":1}}],[\"自定义异常\",{\"1\":{\"193\":1}}],[\"自定义标签\",{\"1\":{\"164\":1}}],[\"自定义标题\",{\"1\":{\"19\":5}}],[\"自定义它们\",{\"1\":{\"45\":1}}],[\"自定义对齐\",{\"0\":{\"22\":1}}],[\"自定义容器\",{\"0\":{\"19\":1}}],[\"会根据异常类型在catch块中进行匹配\",{\"1\":{\"199\":2}}],[\"会屏蔽掉severity=warning的告警\",{\"1\":{\"163\":1}}],[\"会将计算结果输出到新的向量上\",{\"1\":{\"141\":1}}],[\"会统计当前指标的记录总数\",{\"1\":{\"134\":1}}],[\"会周期性的去采集指标\",{\"1\":{\"120\":1}}],[\"会带来一定的性能开销\",{\"1\":{\"112\":1}}],[\"会导致类的数量增加\",{\"1\":{\"100\":1}}],[\"会导致一定的资源开销和性能下降\",{\"1\":{\"79\":1}}],[\"会进行加锁初始化\",{\"1\":{\"76\":1}}],[\"会在程序的类的加载过程中\",{\"1\":{\"74\":1}}],[\"会使用\",{\"1\":{\"16\":1}}],[\"只要对象的属性没有发生改变\",{\"1\":{\"192\":1}}],[\"只能调用父类中声明的方法和子类中重写了父类的方法\",{\"1\":{\"185\":1}}],[\"只能使用对象类型\",{\"1\":{\"184\":1}}],[\"只能包含抽象方法的声明\",{\"1\":{\"180\":1}}],[\"只能包含常量和抽象方法\",{\"1\":{\"180\":1}}],[\"只能在接口内部被调用\",{\"1\":{\"180\":1}}],[\"只能在原有的基础功能之上做进一步增强\",{\"1\":{\"86\":1}}],[\"只能用作基类或父类来使用\",{\"1\":{\"180\":1}}],[\"只能求到最大的耗时和平均耗时\",{\"1\":{\"153\":1}}],[\"只不过summary是已经在客户端已经计算好的数据\",{\"1\":{\"135\":1}}],[\"只增不减\",{\"1\":{\"131\":1}}],[\"只需要增加相应的具体产品类和工厂类即可\",{\"1\":{\"103\":1}}],[\"只需要修改工厂类的逻辑判断即可\",{\"1\":{\"97\":1}}],[\"只需要财务审批\",{\"1\":{\"92\":1}}],[\"只有第一次调用getsingleton\",{\"1\":{\"75\":1}}],[\"只有当子类可以替换基类\",{\"1\":{\"70\":1}}],[\"只允许通过getinstance\",{\"1\":{\"74\":1}}],[\"推荐\",{\"0\":{\"74\":1,\"75\":1,\"76\":1}}],[\"饿汉模式类似于spring框架初始化bean实例\",{\"1\":{\"74\":1}}],[\"饿汉模式\",{\"0\":{\"74\":1}}],[\"其范围为\",{\"1\":{\"190\":1}}],[\"其值就不能被修改\",{\"1\":{\"184\":1}}],[\"其实不然\",{\"1\":{\"191\":1}}],[\"其实是做不到\",{\"1\":{\"153\":1}}],[\"其实在存储的时候是并没有存储的\",{\"1\":{\"131\":1}}],[\"其中prometheus\",{\"1\":{\"154\":1}}],[\"其中micrometer\",{\"1\":{\"153\":1}}],[\"其中job为采集任务\",{\"1\":{\"146\":1}}],[\"其无法反应在时间窗口内样本数据的突发变化\",{\"1\":{\"148\":1}}],[\"其他一些功能\",{\"1\":{\"184\":1}}],[\"其他例子\",{\"1\":{\"171\":1}}],[\"其他常见的函数\",{\"0\":{\"147\":1}}],[\"其他操作系统应该没有这个问题\",{\"1\":{\"123\":1}}],[\"其他\",{\"0\":{\"77\":1}}],[\"其代码实现如下\",{\"1\":{\"73\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"70\":1}}],[\"防止程序因为出现异常而奔溃\",{\"1\":{\"193\":1}}],[\"防止对象的频繁创建\",{\"1\":{\"72\":1}}],[\"防止它频繁的被创建或者被销毁\",{\"1\":{\"72\":1}}],[\"就不能再指向另一个对象了\",{\"1\":{\"196\":1}}],[\"就不能再更改\",{\"1\":{\"196\":1}}],[\"就无法访问其对象方法和属性\",{\"1\":{\"184\":1}}],[\"就需要将其包装成相应的对象类型\",{\"1\":{\"184\":1}}],[\"就可以具体的执行告警逻辑\",{\"1\":{\"166\":1}}],[\"就可以看到本机的资源dashboard\",{\"1\":{\"127\":1}}],[\"就可以看到各个目录的磁盘剩余字节数了\",{\"1\":{\"125\":1}}],[\"就可以进行配置的热更新\",{\"1\":{\"126\":1}}],[\"就可以采集node\",{\"1\":{\"125\":1}}],[\"就可以查看node\",{\"1\":{\"125\":1}}],[\"就可以访问prometheus页面了\",{\"1\":{\"123\":1}}],[\"就能够提供给其他对象在各个地方使用\",{\"1\":{\"72\":1}}],[\"就是一个对象应该尽量对外少暴露\",{\"1\":{\"70\":1}}],[\"就是将实例化工作交给子类完成\",{\"1\":{\"66\":1,\"98\":1}}],[\"让其他的对象可以访问这个实例\",{\"1\":{\"72\":1}}],[\"迪米特法则\",{\"1\":{\"70\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"96\":1}}],[\"简单工厂模式是一种常见的设计模式\",{\"1\":{\"97\":1}}],[\"简单工厂模式提供一个简单的工厂类\",{\"1\":{\"95\":1}}],[\"简单工厂模式\",{\"1\":{\"95\":1}}],[\"简单工厂\",{\"0\":{\"95\":1}}],[\"简单的说就是要求对抽象接口进行编程\",{\"1\":{\"70\":1}}],[\"简称\",{\"1\":{\"70\":5}}],[\"程序将继续执行后续的代码\",{\"1\":{\"199\":1}}],[\"程序会立即跳转到catch代码块中\",{\"1\":{\"193\":1}}],[\"程序流程将跳转到catch块或finally块\",{\"1\":{\"193\":1}}],[\"程序由相互作用的对象组成\",{\"1\":{\"183\":1}}],[\"程序按照一定的顺序执行这些步骤来完成任务\",{\"1\":{\"183\":1}}],[\"程序被分解为可重用的功能模块\",{\"1\":{\"183\":1}}],[\"程序要依赖于抽象接口\",{\"1\":{\"70\":1}}],[\"程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的\",{\"1\":{\"70\":1}}],[\"依赖反转原则\",{\"1\":{\"70\":1}}],[\"due\",{\"1\":{\"166\":1}}],[\"duration\",{\"1\":{\"124\":10,\"134\":13,\"135\":11,\"141\":1,\"150\":13}}],[\"distinguishing\",{\"1\":{\"171\":1}}],[\"divide\",{\"1\":{\"171\":1,\"193\":2}}],[\"division\",{\"1\":{\"141\":1}}],[\"dimensions\",{\"1\":{\"146\":7}}],[\"dip\",{\"1\":{\"70\":1}}],[\"db中\",{\"1\":{\"131\":1}}],[\"dl\",{\"1\":{\"127\":1}}],[\"date\",{\"1\":{\"166\":2}}],[\"data\",{\"1\":{\"87\":8}}],[\"dashboards\",{\"1\":{\"127\":1}}],[\"darwin\",{\"1\":{\"123\":2,\"127\":2}}],[\"double等封装类中\",{\"1\":{\"191\":1}}],[\"double等等\",{\"1\":{\"184\":1}}],[\"double等\",{\"1\":{\"184\":1}}],[\"double\",{\"1\":{\"180\":4,\"190\":1}}],[\"dog=new\",{\"1\":{\"179\":1}}],[\"dog\",{\"1\":{\"179\":3,\"180\":8,\"185\":6}}],[\"dog继承了animal父类\",{\"1\":{\"179\":1}}],[\"docs\",{\"1\":{\"151\":1,\"166\":1}}],[\"download\",{\"1\":{\"123\":1,\"162\":1}}],[\"downloads\",{\"1\":{\"87\":1}}],[\"do\",{\"1\":{\"110\":2,\"112\":1,\"113\":1}}],[\"dos\",{\"1\":{\"87\":3}}],[\"demo\",{\"1\":{\"179\":2,\"180\":1,\"197\":3}}],[\"demo=new\",{\"1\":{\"179\":1}}],[\"denominator\",{\"1\":{\"171\":1}}],[\"details\",{\"1\":{\"167\":1}}],[\"deduplicate\",{\"1\":{\"166\":1}}],[\"development\",{\"1\":{\"194\":1}}],[\"dev\",{\"1\":{\"162\":1,\"163\":3}}],[\"deviation\",{\"1\":{\"146\":1}}],[\"default\",{\"1\":{\"163\":3,\"169\":1,\"180\":1}}],[\"defaultvalue\",{\"1\":{\"153\":1,\"154\":1}}],[\"deflater\",{\"1\":{\"87\":1}}],[\"deflateroutputstream\",{\"1\":{\"87\":2}}],[\"del\",{\"1\":{\"145\":1}}],[\"delta\",{\"1\":{\"133\":1}}],[\"decompress\",{\"1\":{\"87\":2}}],[\"decode\",{\"1\":{\"87\":4}}],[\"design\",{\"1\":{\"80\":2,\"92\":2,\"106\":5}}],[\"description\",{\"1\":{\"164\":1}}],[\"desc\",{\"1\":{\"28\":1}}],[\"dependency>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"dependency\",{\"1\":{\"70\":1}}],[\"d\",{\"1\":{\"70\":1,\"138\":1}}],[\"基于promql表达式告警触发条件\",{\"1\":{\"164\":1}}],[\"基于5小时的样本数据\",{\"1\":{\"149\":1}}],[\"基本数据类型\",{\"1\":{\"190\":1}}],[\"基本类型不是对象\",{\"1\":{\"184\":1}}],[\"基本类型的取值范围是有限的\",{\"1\":{\"184\":1}}],[\"基本查询格式是\",{\"1\":{\"146\":1}}],[\"基本功能实现类和不同的装饰器只实现自己的独一的功能\",{\"1\":{\"88\":1}}],[\"基本上也遵循solid\",{\"1\":{\"70\":1}}],[\"基类功能可以被复用\",{\"1\":{\"70\":1}}],[\"软件功能在不受影响时\",{\"1\":{\"70\":1}}],[\"ov了object类的equals\",{\"1\":{\"191\":1}}],[\"overwrittingdemo\",{\"1\":{\"179\":1}}],[\"overlodingdemo\",{\"1\":{\"179\":3}}],[\"overloading\",{\"1\":{\"179\":2}}],[\"overriding\",{\"1\":{\"179\":2}}],[\"override\",{\"1\":{\"82\":2,\"87\":6,\"92\":3,\"97\":2,\"100\":2,\"103\":3,\"106\":3,\"110\":2,\"112\":1,\"113\":1,\"154\":4,\"179\":1,\"180\":2,\"185\":2,\"196\":1,\"197\":2,\"198\":1}}],[\"over\",{\"1\":{\"146\":7,\"181\":1}}],[\"ok\",{\"1\":{\"154\":17,\"166\":1}}],[\"op>\",{\"1\":{\"146\":1}}],[\"operations\",{\"1\":{\"171\":2}}],[\"operation\",{\"1\":{\"110\":9,\"112\":3,\"113\":1}}],[\"open\",{\"1\":{\"70\":1}}],[\"one\",{\"1\":{\"144\":3,\"145\":2}}],[\"on\",{\"1\":{\"144\":1}}],[\"oriented\",{\"1\":{\"183\":1}}],[\"orange\",{\"1\":{\"174\":3}}],[\"org\",{\"1\":{\"154\":2}}],[\"or\",{\"1\":{\"142\":2,\"143\":1,\"163\":3,\"171\":1}}],[\"offset\",{\"0\":{\"139\":1},\"1\":{\"139\":2}}],[\"of\",{\"1\":{\"124\":6,\"130\":1,\"131\":1,\"135\":2,\"146\":2,\"163\":2,\"166\":1}}],[\"observe\",{\"1\":{\"154\":1}}],[\"observer2\",{\"1\":{\"106\":2}}],[\"observer1\",{\"1\":{\"106\":2}}],[\"observerimpl\",{\"1\":{\"106\":4}}],[\"observer接口的实现类observerimpl的代码如下\",{\"1\":{\"106\":1}}],[\"observer\",{\"1\":{\"104\":1,\"105\":1,\"106\":7}}],[\"obeserver2\",{\"1\":{\"106\":5}}],[\"obj\",{\"1\":{\"106\":3,\"191\":2}}],[\"object\",{\"1\":{\"106\":5,\"112\":10,\"113\":7,\"154\":3,\"183\":1,\"191\":2}}],[\"outcome=\",{\"1\":{\"153\":3}}],[\"out\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"174\":10,\"175\":7,\"176\":9,\"179\":5,\"180\":5,\"185\":2,\"190\":3,\"193\":3,\"196\":3,\"197\":2,\"199\":8}}],[\"ocp\",{\"1\":{\"70\":1}}],[\"o\",{\"1\":{\"70\":1,\"106\":3,\"113\":1,\"127\":1}}],[\"原来的string对象不会被改变\",{\"1\":{\"182\":1}}],[\"原始内容\",{\"1\":{\"87\":2}}],[\"原有的类不支持继承\",{\"1\":{\"86\":1}}],[\"原则\",{\"1\":{\"70\":2}}],[\"原型模式\",{\"1\":{\"66\":1}}],[\"面向过程更适合简单的任务和算法\",{\"1\":{\"183\":1}}],[\"面向过程和面向对象都有各自的优点和适用场景\",{\"1\":{\"183\":1}}],[\"面向过程的关注点主要在于解决问题的步骤和流程\",{\"1\":{\"183\":1}}],[\"面向过程是一种基于步骤和函数的编程方法\",{\"1\":{\"183\":1}}],[\"面向过程\",{\"1\":{\"183\":1}}],[\"面向对象\",{\"1\":{\"184\":1}}],[\"面向对象更适合复杂的应用\",{\"1\":{\"183\":1}}],[\"面向对象的关注点主要在于构建对象的结构和定义对象的行为\",{\"1\":{\"183\":1}}],[\"面向对象是一种基于对象和类的编程方法\",{\"1\":{\"183\":1}}],[\"面向对象还有以下的基本原则\",{\"1\":{\"70\":1}}],[\"面向对象有个solid原则\",{\"1\":{\"70\":1}}],[\"面试官不会考察每一种设计模式\",{\"1\":{\"69\":1}}],[\"面试过程中常问的设计模式\",{\"0\":{\"69\":1}}],[\"掌握好以上的几种设计模式\",{\"1\":{\"69\":1}}],[\"熟练使用23种设计模式是高阶程序员必须掌握的技能\",{\"1\":{\"69\":1}}],[\"作为新一代的监控系统\",{\"1\":{\"118\":1}}],[\"作为扩展对象功能的出发点\",{\"1\":{\"68\":1}}],[\"作者设置为\",{\"1\":{\"43\":1}}],[\"某个数据库出现网络故障\",{\"1\":{\"159\":1}}],[\"某个类在全局只有一个实例对象\",{\"1\":{\"66\":1}}],[\"某一个操作\",{\"1\":{\"68\":1}}],[\"责任链模式可以提供一种灵活\",{\"1\":{\"93\":1}}],[\"责任链模式将处理逻辑放在链式的逻辑单元中处理\",{\"1\":{\"93\":1}}],[\"责任链模式有两个角色\",{\"1\":{\"91\":1}}],[\"责任链模式的uml图\",{\"0\":{\"91\":1}}],[\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理\",{\"1\":{\"90\":1}}],[\"责任链模式在软件开发中\",{\"1\":{\"90\":1}}],[\"责任链模式\",{\"0\":{\"90\":1},\"1\":{\"68\":1,\"69\":1}}],[\"并执行与异常类型匹配的处理代码\",{\"1\":{\"193\":1}}],[\"并按照顺序处理异常\",{\"1\":{\"193\":1}}],[\"并根据实际对象的类型来调用\",{\"1\":{\"185\":1}}],[\"并根据实际对象的类型来执行对应的方法\",{\"1\":{\"185\":1}}],[\"并实现相关接口\",{\"1\":{\"180\":1}}],[\"并实现了抽象方法\",{\"1\":{\"180\":1}}],[\"并实现了handle\",{\"1\":{\"92\":3}}],[\"并重写了eat方法\",{\"1\":{\"179\":1}}],[\"并已bean的形式注册\",{\"1\":{\"154\":1}}],[\"并通过案例进行了实战\",{\"1\":{\"151\":1}}],[\"并没有差别\",{\"1\":{\"131\":1}}],[\"并展示在监控大盘上\",{\"1\":{\"128\":1}}],[\"并将其转换为底层操作系统可以执行的机器码\",{\"1\":{\"194\":1}}],[\"并将其赋值给i\",{\"1\":{\"184\":1}}],[\"并将数据的结果存储在新的时间序列中\",{\"1\":{\"169\":1}}],[\"并将计算结果保存在一组新的时间序列上\",{\"1\":{\"168\":1}}],[\"并将告警消息发送给alertmanager\",{\"1\":{\"120\":1}}],[\"并将指标存储在主机的磁盘中\",{\"1\":{\"120\":1}}],[\"并将实际对象的方法调用转发给它\",{\"1\":{\"109\":1}}],[\"并在intercept方法中实现真实对象的功能增强\",{\"1\":{\"113\":1}}],[\"并在主题实现类的对象的operation\",{\"1\":{\"110\":1}}],[\"并在状态改变时通知观察者\",{\"1\":{\"105\":1}}],[\"并隐藏在代理后面可能其他类的实现\",{\"1\":{\"109\":1}}],[\"并且在方法返回之前被执行\",{\"1\":{\"199\":1}}],[\"并且y\",{\"1\":{\"191\":1}}],[\"并且提供了更灵活的类组合方式\",{\"1\":{\"181\":1}}],[\"并且可以通过索引进行访问和操作\",{\"1\":{\"174\":1}}],[\"并且可以根据需要快速的组合逻辑单元\",{\"1\":{\"93\":1}}],[\"并且是求百分数\",{\"1\":{\"171\":1}}],[\"并且体现出更好的灵敏度\",{\"1\":{\"148\":1}}],[\"并且于2015年对外发布早期版本\",{\"1\":{\"117\":1}}],[\"并且发布者发布消息也是无顺序的\",{\"1\":{\"107\":1}}],[\"并定义了观察者接收到通知后的具体行为\",{\"1\":{\"105\":1}}],[\"并可以动态添加观察者或者删除观察者\",{\"1\":{\"105\":1}}],[\"并不需要改变原有的逻辑功能\",{\"1\":{\"93\":1}}],[\"并向审批流的第一角色handle\",{\"1\":{\"92\":1}}],[\"并能自由组合包装各种装饰器\",{\"1\":{\"88\":1}}],[\"并持有主题实现类的对象\",{\"1\":{\"110\":1}}],[\"并持有readerwriter的实现类filereaderwriter\",{\"1\":{\"87\":2}}],[\"并持有装饰器componentdecoratorb\",{\"1\":{\"86\":1}}],[\"并持有组件实现类componentimpl\",{\"1\":{\"86\":1}}],[\"并提供了良好的可读性和可维护性\",{\"1\":{\"193\":1}}],[\"并提供一个方法\",{\"1\":{\"72\":1}}],[\"并提供解释器来处理句子中的语法\",{\"1\":{\"68\":1}}],[\"并使它们可以互换\",{\"1\":{\"68\":1}}],[\"所用到开源组件如下\",{\"1\":{\"115\":1}}],[\"所有位均参与计算\",{\"1\":{\"190\":1}}],[\"所有依赖于它的对象都会收到通知\",{\"1\":{\"104\":1}}],[\"所有这些都不会违反封装\",{\"1\":{\"68\":1}}],[\"所以这个变量所指向的内存区域就不会变\",{\"1\":{\"197\":1}}],[\"所以这个resolve\",{\"1\":{\"163\":1}}],[\"所以\",{\"1\":{\"192\":1}}],[\"所以char类型取值范围为0~2^16\",{\"1\":{\"190\":1}}],[\"所以需要使用包装类来为这些基本类型提供一个相应的对象类型\",{\"1\":{\"184\":1}}],[\"所以如果想要在泛型中使用一个基本类型的值\",{\"1\":{\"184\":1}}],[\"所以在定义接口方法时不需要添加关键字\",{\"1\":{\"180\":1}}],[\"所以在接下来的文章会从源码和java\",{\"1\":{\"177\":1}}],[\"所以能够输出\",{\"1\":{\"141\":1}}],[\"所以可以通过标签进行对指标的筛选\",{\"1\":{\"136\":1}}],[\"所以下载的是mac版本的\",{\"1\":{\"127\":1}}],[\"所以只能实现接口的方式进行代理\",{\"1\":{\"112\":1}}],[\"所以我们在实际的使用过程中\",{\"1\":{\"93\":1}}],[\"所以它们之间的\",{\"1\":{\"190\":1}}],[\"所以它的level可以命名为instance\",{\"1\":{\"171\":1}}],[\"所以它属于线程安全的懒汉模式\",{\"1\":{\"76\":1}}],[\"所以它是线程安全的\",{\"1\":{\"74\":1}}],[\"所以jvm是允许的\",{\"1\":{\"75\":1}}],[\"所以还是比较推荐的\",{\"1\":{\"74\":1}}],[\"所以设计模式是程序员的一项基本功\",{\"1\":{\"64\":1}}],[\"备忘录模式\",{\"1\":{\"68\":1}}],[\"而\",{\"1\":{\"190\":1}}],[\"而是由java运行时环境\",{\"1\":{\"193\":1}}],[\"而是与其关联的对象在内存中的地址\",{\"1\":{\"190\":1}}],[\"而是采用灵活的单一结构\",{\"1\":{\"108\":1}}],[\"而char是无符号类型的\",{\"1\":{\"190\":1}}],[\"而且同一个接口可以被多个类实现\",{\"1\":{\"180\":1}}],[\"而且不需要修改现有的代码\",{\"1\":{\"93\":1}}],[\"而重写方法必须具有相同的返回类型\",{\"1\":{\"179\":1}}],[\"而重写方法在运行时动态地绑定\",{\"1\":{\"179\":1}}],[\"而使用prometheus的java客户端是可以做到分位耗时的\",{\"1\":{\"153\":1}}],[\"而标签组是监控样本的多个维度特征的反应\",{\"1\":{\"136\":1}}],[\"而histogram则会消耗更多服务端的的资源\",{\"1\":{\"135\":1}}],[\"而histogram是通过histogram\",{\"1\":{\"135\":1}}],[\"而个别情况可能导致请求耗时超过了5s\",{\"1\":{\"134\":1}}],[\"而在样本数据采集的时候\",{\"1\":{\"131\":1}}],[\"而无需修改原有的代码\",{\"1\":{\"112\":1}}],[\"而无需指定具体实现类\",{\"1\":{\"66\":1,\"101\":1}}],[\"而java是不允许多继承的\",{\"1\":{\"112\":1}}],[\"而动态代理在各种框架\",{\"1\":{\"109\":1}}],[\"而不会创建新的对象\",{\"1\":{\"182\":1}}],[\"而不是使用summary\",{\"1\":{\"135\":1}}],[\"而不是通过实现接口\",{\"1\":{\"113\":1}}],[\"而不是直接交互\",{\"1\":{\"68\":1}}],[\"而不需要了解具体的实现类\",{\"1\":{\"100\":1}}],[\"而子类也能够在基类的基础上增加新的行为\",{\"1\":{\"70\":1}}],[\"而设计模式是基于对象实例的\",{\"1\":{\"70\":1}}],[\"定义的\",{\"1\":{\"180\":1}}],[\"定义的类\",{\"1\":{\"180\":1}}],[\"定义recoding\",{\"0\":{\"169\":1}}],[\"定义了常量\",{\"1\":{\"180\":1}}],[\"定义了makesofa\",{\"1\":{\"103\":1}}],[\"定义了一个divide方法\",{\"1\":{\"193\":1}}],[\"定义了一个接收发布者消息的方法\",{\"1\":{\"105\":1}}],[\"定义了一个工厂方法makesofa\",{\"1\":{\"99\":1}}],[\"定义了一系列可以创建不同产品对象的方法\",{\"1\":{\"102\":1}}],[\"定义了产品类的属性和方法\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"定义文件的写入或者读取的路径\",{\"1\":{\"87\":1}}],[\"定义一个抽象主题类\",{\"1\":{\"110\":1}}],[\"定义一个抽象产品类\",{\"1\":{\"97\":1}}],[\"定义一个接口ifactory\",{\"1\":{\"100\":1}}],[\"定义一个写入的字符串text\",{\"1\":{\"87\":1}}],[\"定义一个目标接口readerwriter\",{\"1\":{\"87\":1}}],[\"定义一系列算法\",{\"1\":{\"68\":1}}],[\"定义目标的方法\",{\"1\":{\"86\":1}}],[\"定义对象之间的一对多依赖关系\",{\"1\":{\"68\":1}}],[\"不包含开发工具\",{\"1\":{\"194\":1}}],[\"不包含方法的实现\",{\"1\":{\"180\":1}}],[\"不参与计算\",{\"1\":{\"190\":1}}],[\"不能被修改\",{\"1\":{\"198\":1}}],[\"不能被实现类调用\",{\"1\":{\"180\":1}}],[\"不能有子类继承它\",{\"1\":{\"196\":1}}],[\"不能有构造方法\",{\"1\":{\"180\":1}}],[\"不能表示空值或null\",{\"1\":{\"184\":1}}],[\"不能实例化对象\",{\"1\":{\"180\":1}}],[\"不能东一榔头西一棒槌\",{\"1\":{\"64\":1}}],[\"不允许重复\",{\"1\":{\"176\":1}}],[\"不允许重复元素\",{\"1\":{\"173\":1}}],[\"不会包含重复的元素\",{\"1\":{\"175\":1}}],[\"不会输出结果\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"不重复性\",{\"1\":{\"175\":1}}],[\"不仅可以监控系统的一些状态\",{\"1\":{\"118\":1}}],[\"不支持自身方法调用\",{\"1\":{\"113\":1}}],[\"不需要修改已有的代码\",{\"1\":{\"107\":1}}],[\"不同的重载方法可以返回不同的结果\",{\"1\":{\"179\":1}}],[\"不同的产品由不同的工厂创建\",{\"1\":{\"100\":1}}],[\"不同的逻辑单元的处理逻辑不耦合\",{\"1\":{\"93\":1}}],[\"不同的装饰器有不同的功能\",{\"1\":{\"86\":1}}],[\"不同的角色做不同的事\",{\"1\":{\"83\":1}}],[\"不推荐使用了\",{\"1\":{\"198\":1}}],[\"不推荐\",{\"0\":{\"78\":1,\"79\":1}}],[\"不提供全局的共享变量\",{\"1\":{\"72\":1}}],[\"不要对实现进行编程\",{\"1\":{\"70\":1}}],[\"不要依赖于具体实现\",{\"1\":{\"70\":1}}],[\"不暴露该对象的内部结构\",{\"1\":{\"68\":1}}],[\"一旦赋值就不能被改变\",{\"1\":{\"196\":1}}],[\"一旦被赋值\",{\"1\":{\"196\":1}}],[\"一旦创建\",{\"1\":{\"184\":1}}],[\"一旦创建就不能被修改\",{\"1\":{\"182\":1}}],[\"一致性\",{\"1\":{\"191\":1,\"192\":1}}],[\"一条告警规则主要由以下几部分组成\",{\"1\":{\"164\":1}}],[\"一条成功发送的告警\",{\"1\":{\"163\":1}}],[\"一组已发送初始通知的告警接收到新告警后\",{\"1\":{\"163\":1}}],[\"一组告警第一次发送之前等待的时间\",{\"1\":{\"163\":1}}],[\"一种常用的方式来重写hashcode\",{\"1\":{\"192\":1}}],[\"一种先进先出\",{\"1\":{\"173\":1}}],[\"一种是告警告警规则表达式\",{\"1\":{\"168\":1}}],[\"一种是使用springboot自带的spring\",{\"1\":{\"152\":1}}],[\"一种遍历访问聚合对象中各个元素的方法\",{\"1\":{\"68\":1}}],[\"一对多或者多对一\",{\"1\":{\"144\":1}}],[\"一对一\",{\"1\":{\"144\":1}}],[\"一共有53个\",{\"1\":{\"137\":1}}],[\"一般设置为5分钟或更多\",{\"1\":{\"163\":1}}],[\"一般设置为0秒\",{\"1\":{\"163\":1}}],[\"一般counter类型的指标建议以\",{\"1\":{\"132\":1}}],[\"一般静态代理使用的比较少\",{\"1\":{\"109\":1}}],[\"一般情况下\",{\"1\":{\"86\":1}}],[\"一般来讲\",{\"1\":{\"86\":1}}],[\"一般常见的考察的面试模式如下\",{\"1\":{\"69\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"180\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"180\":3,\"181\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口范围内\",{\"1\":{\"70\":1}}],[\"一个好的命名规范可以一目了然的知道规则的含义\",{\"1\":{\"170\":1}}],[\"一个简单版的prometheus的架构图如下\",{\"1\":{\"157\":1}}],[\"一个时序数据包含了一个时间戳\",{\"1\":{\"117\":1}}],[\"一个组件可以有很多个装饰器\",{\"1\":{\"86\":1}}],[\"一个拥有\",{\"1\":{\"23\":1}}],[\"迭代器模式\",{\"1\":{\"68\":1}}],[\"模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤\",{\"1\":{\"68\":1}}],[\"模板模式\",{\"1\":{\"68\":1}}],[\"策略让算法独立于使用它的客户端而变化\",{\"1\":{\"68\":1}}],[\"策略模式\",{\"1\":{\"68\":1}}],[\"封装每个算法\",{\"1\":{\"68\":1}}],[\"封装对象的创建过程\",{\"1\":{\"66\":1}}],[\"行为型模式\",{\"0\":{\"68\":1}}],[\"使得一个类可以具备多种类型的行为\",{\"1\":{\"180\":1}}],[\"使得发布者和观察者互不影响\",{\"1\":{\"107\":1}}],[\"使得可以用不同的请求来进行参数化\",{\"1\":{\"68\":1}}],[\"使系统能够更好地应对变化和复杂性\",{\"1\":{\"93\":1}}],[\"使用jdk可以进行java应用程序的开发和构建\",{\"1\":{\"194\":1}}],[\"使用throws关键字\",{\"1\":{\"193\":1}}],[\"使用throw语句\",{\"1\":{\"193\":1}}],[\"使用包装类可以让基本类型像一个对象一样使用\",{\"1\":{\"184\":1}}],[\"使用包装类可以使得变量可以被赋值为null\",{\"1\":{\"184\":1}}],[\"使用场景\",{\"1\":{\"182\":1}}],[\"使用接口可以避免命名冲突和菱形继承问题\",{\"1\":{\"181\":1}}],[\"使用迭代器\",{\"1\":{\"174\":1}}],[\"使用\",{\"1\":{\"174\":5}}],[\"使用prometheus\",{\"0\":{\"154\":1}}],[\"使用prometheus明显是不合适的\",{\"1\":{\"121\":1}}],[\"使用spring\",{\"0\":{\"153\":1}}],[\"使用group\",{\"1\":{\"145\":1}}],[\"使用以下的查询\",{\"1\":{\"145\":1}}],[\"使用上面的vector\",{\"1\":{\"144\":1}}],[\"使用标签筛选数据的使用\",{\"1\":{\"137\":1}}],[\"使用le标签表示小于的意思\",{\"1\":{\"134\":1}}],[\"使用了prometheus\",{\"1\":{\"134\":1}}],[\"使用counter类型的指标\",{\"1\":{\"132\":1}}],[\"使用多个节点去采集相通的监控对象可以做到高可用\",{\"1\":{\"121\":1}}],[\"使用观察者模式有以下的收益\",{\"1\":{\"107\":1}}],[\"使用工厂方法模式的缺点是\",{\"1\":{\"100\":1}}],[\"使用工厂方法模式的好处是\",{\"1\":{\"100\":1}}],[\"使用责任链有以下的优点\",{\"1\":{\"93\":1}}],[\"使用责任链模式可以将一个大而复杂的判断逻辑\",{\"1\":{\"93\":1}}],[\"使用责任链的原因有\",{\"1\":{\"93\":1}}],[\"使用装饰器模式有以下的优点\",{\"1\":{\"88\":1}}],[\"使用案例\",{\"0\":{\"87\":1}}],[\"使用到了包装器模式\",{\"1\":{\"85\":1}}],[\"使用适配器模式有以下的优点\",{\"1\":{\"83\":1}}],[\"使用适配器模式有什么收益\",{\"0\":{\"83\":1}}],[\"使用内部类的模式\",{\"1\":{\"76\":1}}],[\"使用内部类模式\",{\"0\":{\"76\":1}}],[\"使用双重检查来判断实例是否初始化\",{\"1\":{\"75\":1}}],[\"使用同步代码块来保证线程的安全\",{\"1\":{\"75\":1}}],[\"使用单例模式有什么好处呢\",{\"1\":{\"72\":1}}],[\"使用指南\",{\"1\":{\"43\":2},\"2\":{\"6\":1,\"8\":1,\"11\":1,\"40\":1,\"46\":1,\"47\":1}}],[\"使的多个对象都有处理这个请求的机会\",{\"1\":{\"68\":1}}],[\"使它们都可以独立\",{\"1\":{\"67\":1}}],[\"桥接模式\",{\"1\":{\"67\":1}}],[\"将不会被添加进去\",{\"1\":{\"175\":1}}],[\"将会输出以下结果\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"将通过post的http请求发送下游程序\",{\"1\":{\"166\":1}}],[\"将告警消息按照某个标签分组\",{\"1\":{\"163\":1}}],[\"将得不到任何结果\",{\"1\":{\"145\":1}}],[\"将三个审批角色组成一个责任链模式的审批流\",{\"1\":{\"92\":1}}],[\"将目标类和适配的类解耦\",{\"1\":{\"83\":1}}],[\"将适配器这个角色进行高度抽象化\",{\"1\":{\"83\":1}}],[\"将请求的发送者和接收者解耦\",{\"1\":{\"68\":1}}],[\"将命令请求封装为一个对象\",{\"1\":{\"68\":1}}],[\"将一些步骤推迟到子类中\",{\"1\":{\"68\":1}}],[\"将对象组合成树形结构以表示整个部分的层次结构\",{\"1\":{\"67\":1}}],[\"将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"67\":1}}],[\"将抽象部分和实现部分分离\",{\"1\":{\"67\":1}}],[\"将类的接口转换为客户期望的另一个接口\",{\"1\":{\"67\":1,\"81\":1}}],[\"共享对象\",{\"1\":{\"67\":1}}],[\"享元模式\",{\"1\":{\"67\":1}}],[\"代理类\",{\"1\":{\"109\":1,\"110\":1}}],[\"代理对象可以控制客户端对真实对象的访问\",{\"1\":{\"108\":1}}],[\"代理模式分为静态代理和动态代码\",{\"1\":{\"109\":1}}],[\"代理模式常用于对已有功能的增强\",{\"1\":{\"108\":1}}],[\"代理模式是一种结构性模式\",{\"1\":{\"108\":1}}],[\"代理模式并没有做类似于装饰器模式多层嵌套\",{\"1\":{\"108\":1}}],[\"代理模式和装饰器模式类似\",{\"1\":{\"108\":1}}],[\"代理模式\",{\"0\":{\"108\":1},\"1\":{\"67\":1,\"69\":1}}],[\"代码示例\",{\"1\":{\"179\":1}}],[\"代码会变得臃肿难以维护\",{\"1\":{\"109\":1}}],[\"代码如下\",{\"1\":{\"103\":4,\"106\":1,\"110\":1,\"112\":1,\"113\":2,\"191\":1}}],[\"代码的可扩展性和可复用性非常的强\",{\"1\":{\"88\":1}}],[\"代码实现\",{\"0\":{\"82\":1,\"97\":1,\"100\":1,\"103\":1,\"110\":1}}],[\"代码编写\",{\"1\":{\"64\":1}}],[\"代码质量是设计出来的\",{\"1\":{\"64\":1}}],[\"代码演示\",{\"0\":{\"35\":1}}],[\"代码块\",{\"0\":{\"20\":1}}],[\"代码\",{\"1\":{\"19\":1}}],[\"形成一个更大的对象\",{\"1\":{\"67\":1}}],[\"但不能修改其实现\",{\"1\":{\"196\":1}}],[\"但它也带来了一些问题\",{\"1\":{\"181\":1}}],[\"但也有一些区别\",{\"1\":{\"180\":1}}],[\"但缺点是对于一些无法实现接口的类\",{\"1\":{\"112\":1}}],[\"但缺点是需要手动创建代理类\",{\"1\":{\"109\":1}}],[\"但现实生活中\",{\"1\":{\"101\":1}}],[\"但需要防止责任链模式有过多的处理逻辑单元\",{\"1\":{\"93\":1}}],[\"但又不方便继承\",{\"1\":{\"88\":1}}],[\"但此时singleton并还没初始化完毕\",{\"1\":{\"75\":1}}],[\"但是变量的值是可以被修改的\",{\"1\":{\"196\":1}}],[\"但是它们之间有一些区别\",{\"1\":{\"189\":1}}],[\"但是它是不能给被实例化的\",{\"1\":{\"180\":1}}],[\"但是没有实现\",{\"1\":{\"180\":1}}],[\"但是不同的返回结果不能作为方法重载的定义\",{\"1\":{\"179\":1}}],[\"但是不能返回结果的类型来定义方法的重载\",{\"1\":{\"179\":1}}],[\"但是不太推荐\",{\"1\":{\"77\":1}}],[\"但是参数的个数不同\",{\"1\":{\"179\":1}}],[\"但是java集合的源码或者手写java\",{\"1\":{\"177\":1}}],[\"但是其反应出的是瞬时增长率\",{\"1\":{\"148\":1}}],[\"但是通过计算在时间窗口内的平均增长率却无法反应出该问题\",{\"1\":{\"148\":1}}],[\"但是对于prometheus的底层数据来说\",{\"1\":{\"131\":1}}],[\"但是需要对值的控制字符进行转义\",{\"1\":{\"130\":1}}],[\"但是在大多数情况下\",{\"1\":{\"134\":1}}],[\"但是在使用它的时候需要注意它带来的一些缺点\",{\"1\":{\"107\":1}}],[\"但是在方法上加了锁\",{\"1\":{\"79\":1}}],[\"但是mac电脑只有typec接口\",{\"1\":{\"81\":1}}],[\"但是代码比双重检查模式简洁\",{\"1\":{\"76\":1}}],[\"但是由于简单\",{\"1\":{\"74\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"44\":1}}],[\"但由子类来决定要实例化哪个类\",{\"1\":{\"66\":1,\"98\":1}}],[\"它在try块或catch块中的代码执行完毕后立即执行\",{\"1\":{\"199\":1}}],[\"它还具有内存管理\",{\"1\":{\"194\":1}}],[\"它包含了jvm\",{\"1\":{\"194\":1}}],[\"它位于异常类的最顶层\",{\"1\":{\"193\":1}}],[\"它比较的是对字符串内容的比较\",{\"1\":{\"191\":1}}],[\"它让我们可以使用父类的引用变量来引用不同子类的对象\",{\"1\":{\"185\":1}}],[\"它允许我们使用父类的引用变量来引用子类的对象实例\",{\"1\":{\"185\":1}}],[\"它允许将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"108\":1}}],[\"它更直观\",{\"1\":{\"183\":1}}],[\"它不能被实例化\",{\"1\":{\"180\":1}}],[\"它们会被隐式地视为final\",{\"1\":{\"197\":1}}],[\"它们都有一个共同的方法\",{\"1\":{\"185\":1}}],[\"它们都是用于类的方法\",{\"1\":{\"179\":1}}],[\"它们之间有以下区别\",{\"1\":{\"182\":1}}],[\"它们有一些共同点\",{\"1\":{\"180\":1}}],[\"它们共同组成描述当前指标的特征\",{\"1\":{\"130\":1}}],[\"它和collection接口属于并列的关系\",{\"1\":{\"176\":1}}],[\"它和里氏替换原则相辅相成的\",{\"1\":{\"70\":1}}],[\"它定义了可以被抛出和捕获的异常对象的基本功能\",{\"1\":{\"193\":1}}],[\"它定义了集合的基本操作\",{\"1\":{\"173\":1}}],[\"它定义了一组方法的方法\",{\"1\":{\"180\":1}}],[\"它定义了一些方法\",{\"1\":{\"109\":1}}],[\"它定义了一个创建对象的接口\",{\"1\":{\"66\":1,\"98\":1}}],[\"它提供了一组接口和类\",{\"1\":{\"173\":1}}],[\"它提供了一个创建一系列相关对象的接口\",{\"1\":{\"66\":1,\"101\":1}}],[\"它会含有endts这个时间戳参数\",{\"1\":{\"163\":1}}],[\"它可以在合适的场景中使用\",{\"1\":{\"196\":1}}],[\"它可以是一个邮箱也可以是微信\",{\"1\":{\"162\":1}}],[\"它可以把字符写入到文件中\",{\"1\":{\"87\":1}}],[\"它默认集成在spring\",{\"1\":{\"153\":1}}],[\"它同等于\",{\"1\":{\"146\":1}}],[\"它支持多种类型的数据库\",{\"1\":{\"127\":1}}],[\"它为主机暴露了硬件和内核相关的指标\",{\"1\":{\"125\":1}}],[\"它并不能保证数据的及时性和绝对正确性\",{\"1\":{\"121\":1}}],[\"它对多维数据收集和查询的支持是一个特别的优势\",{\"1\":{\"121\":1}}],[\"它既适合以机器为中心的监视\",{\"1\":{\"121\":1}}],[\"它能够有效地处理程序中可能发生的异常情况\",{\"1\":{\"193\":1}}],[\"它能够提高系统的可扩展性和灵活性\",{\"1\":{\"107\":1}}],[\"它能审批10000元以下的借款\",{\"1\":{\"92\":1}}],[\"它能审批5000元以下的借款\",{\"1\":{\"92\":1}}],[\"它维护了一个状态\",{\"1\":{\"105\":1}}],[\"它维护了一个观察者的列表\",{\"1\":{\"105\":1}}],[\"它具有更好的可维护性\",{\"1\":{\"183\":1}}],[\"它具有以下的优点\",{\"1\":{\"103\":1}}],[\"它具有如下的优点\",{\"1\":{\"97\":1}}],[\"它只能审批1000元以下的借款\",{\"1\":{\"92\":1}}],[\"它只提供typec接口\",{\"1\":{\"83\":1}}],[\"它有一个接收通知对象的方法\",{\"1\":{\"106\":1}}],[\"它有一个createsofa\",{\"1\":{\"100\":1}}],[\"它有一个抽象方法getname\",{\"1\":{\"97\":1}}],[\"它有一个核心的处理方法\",{\"1\":{\"91\":1}}],[\"它有读取和写入的功能\",{\"1\":{\"87\":1}}],[\"它实现了观察者的更新接口\",{\"1\":{\"105\":1}}],[\"它实现了readerwriter接口\",{\"1\":{\"87\":2}}],[\"它实现了目标接口\",{\"1\":{\"86\":3}}],[\"它是在对象被垃圾回收器回收之前调用的\",{\"1\":{\"198\":1}}],[\"它是throwable的一个子类\",{\"1\":{\"193\":1}}],[\"它是动态绑定来确定运行时对象的实际方法的调用\",{\"1\":{\"179\":1}}],[\"它是子类对父类的同名方法且具有相同的参数的重新实现\",{\"1\":{\"179\":1}}],[\"它是collection框架的一部分\",{\"1\":{\"173\":1}}],[\"它是一个最终类\",{\"1\":{\"196\":1}}],[\"它是一个抽象的计算机\",{\"1\":{\"194\":1}}],[\"它是一个瞬时向量结果\",{\"1\":{\"138\":1}}],[\"它是一个基础能力\",{\"1\":{\"136\":1}}],[\"它是可增可减的\",{\"1\":{\"133\":1}}],[\"它是实现动态代理的关键\",{\"1\":{\"112\":1}}],[\"它是目标接口\",{\"1\":{\"86\":1}}],[\"它是为了解决具体的编码问题或者是解决某一类问题而产生的\",{\"1\":{\"64\":1}}],[\"它又称为包装器模式\",{\"1\":{\"85\":1}}],[\"它必须持有或者实现目标类和适配类的接口\",{\"1\":{\"81\":1}}],[\"它的方法都使用了synchronized关键字来进行同步\",{\"1\":{\"182\":1}}],[\"它的优点如下\",{\"1\":{\"112\":1}}],[\"它的uml图如下所示\",{\"1\":{\"81\":1}}],[\"它的所有依赖项都会自动得到通知和更新\",{\"1\":{\"68\":1}}],[\"它属于懒汉模式\",{\"1\":{\"75\":1}}],[\"创建一个\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"创建子类对象代理\",{\"1\":{\"113\":1}}],[\"创建和业务逻辑判断\",{\"1\":{\"97\":1}}],[\"创建者模式\",{\"1\":{\"66\":1}}],[\"创建型设计模式\",{\"1\":{\"66\":1}}],[\"创建型模式\",{\"0\":{\"66\":1}}],[\"单一职责\",{\"1\":{\"83\":2}}],[\"单一职责原则\",{\"1\":{\"70\":1}}],[\"单例模式除了上面的写法\",{\"1\":{\"77\":1}}],[\"单例模式不需要对外提供构造方法\",{\"1\":{\"74\":1}}],[\"单例模式声明了一个名为\",{\"1\":{\"73\":1}}],[\"单例模式的实现\",{\"0\":{\"73\":1}}],[\"单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的\",{\"1\":{\"72\":1}}],[\"单例模式可以解决一个全局的使用的实例\",{\"1\":{\"72\":1}}],[\"单例模式在允许在全局中只存在一个实例\",{\"1\":{\"72\":1}}],[\"单例模式\",{\"0\":{\"71\":1},\"1\":{\"69\":1}}],[\"单列模式\",{\"1\":{\"66\":1}}],[\"单词\",{\"1\":{\"23\":1}}],[\"在回答这个问题前\",{\"1\":{\"199\":1}}],[\"在try或catch块中使用return语句时\",{\"1\":{\"199\":1}}],[\"在try块中有system\",{\"1\":{\"199\":1}}],[\"在try\",{\"1\":{\"198\":1}}],[\"在try代码块中\",{\"1\":{\"193\":1}}],[\"在使用final变量前必须赋值\",{\"1\":{\"196\":1}}],[\"在使用前必须赋值\",{\"1\":{\"196\":1}}],[\"在使用关系操作符\",{\"1\":{\"190\":1}}],[\"在构造函数中赋值\",{\"1\":{\"196\":1}}],[\"在静态代码快中赋值\",{\"1\":{\"196\":1}}],[\"在代码快中赋值\",{\"1\":{\"196\":1}}],[\"在方法签名中明确指定可能抛出的异常类型\",{\"1\":{\"193\":1}}],[\"在对象的生命周期中\",{\"1\":{\"192\":1}}],[\"在string类的方法中\",{\"1\":{\"191\":1}}],[\"在springboot的项目中增加springboot指标的采集\",{\"1\":{\"155\":1}}],[\"在springboot项目中\",{\"1\":{\"166\":1}}],[\"在springboot项目中的pom文件引入以下的依赖\",{\"1\":{\"154\":1}}],[\"在springboot项目中使用prometheus监控\",{\"0\":{\"152\":1}}],[\"在springboot项目创建一个测试接口\",{\"1\":{\"153\":1}}],[\"在object类中\",{\"1\":{\"191\":1}}],[\"在初学java的时候\",{\"1\":{\"191\":1}}],[\"在\",{\"1\":{\"185\":1,\"193\":1}}],[\"在自动装箱和拆箱时\",{\"1\":{\"184\":1}}],[\"在实际的开发中\",{\"1\":{\"191\":1}}],[\"在实际的开发过程中是应用非常多的\",{\"1\":{\"66\":1}}],[\"在实际编程中\",{\"1\":{\"183\":1}}],[\"在面向对象编程中\",{\"1\":{\"183\":1}}],[\"在面向过程编程中\",{\"1\":{\"183\":1}}],[\"在面试过程中\",{\"1\":{\"69\":1}}],[\"在单线程环境中\",{\"1\":{\"182\":1}}],[\"在接口定义中\",{\"1\":{\"180\":1}}],[\"在接下来的文章中会逐步讲解这几种设计模式\",{\"1\":{\"69\":1}}],[\"在上述代码中\",{\"1\":{\"193\":1}}],[\"在上述示例中\",{\"1\":{\"180\":1,\"190\":1}}],[\"在上面的这个例子中\",{\"1\":{\"180\":1}}],[\"在上面的例子中\",{\"1\":{\"179\":1,\"180\":1}}],[\"在上面的示例中\",{\"1\":{\"134\":1}}],[\"在上面讲解的操作符\",{\"1\":{\"144\":1}}],[\"在如今java面试八股文满天飞的时代\",{\"1\":{\"177\":1}}],[\"在文件中写一个指标聚合的表达式\",{\"1\":{\"172\":1}}],[\"在文件流的基础之上使用装饰器模式\",{\"1\":{\"87\":1}}],[\"在等待期间新产生告警的状态为pending\",{\"1\":{\"164\":1}}],[\"在每一个group中我们可以定义多个告警规则\",{\"1\":{\"164\":1}}],[\"在告警规则文件中\",{\"1\":{\"164\":1}}],[\"在浏览器中访问localhost\",{\"1\":{\"163\":1}}],[\"在浏览器上请求http\",{\"1\":{\"153\":1}}],[\"在浏览器上请求测试接口http\",{\"1\":{\"153\":1,\"154\":1}}],[\"在再次发送通知之前等待的时间\",{\"1\":{\"163\":1}}],[\"在此篇文章只讲解最基础的和几个重要的配置\",{\"1\":{\"163\":1}}],[\"在启动之前\",{\"1\":{\"162\":1}}],[\"在本篇文章中将会讲述prometheus告警与alertmanager实战\",{\"1\":{\"157\":1}}],[\"在本地部署的grafana页面导入node\",{\"1\":{\"127\":1}}],[\"在前面的文章已经讲解过prometheus采集数据和查询数据\",{\"1\":{\"157\":1}}],[\"在前面的文章介绍过如下prometheus自身的监控\",{\"1\":{\"130\":1}}],[\"在它内部进行告警消息的管理\",{\"1\":{\"157\":1}}],[\"在进程内部计算告警规则\",{\"1\":{\"157\":1}}],[\"在aftercompletion方法中\",{\"1\":{\"154\":1}}],[\"在项目中有一个测试接口\",{\"1\":{\"154\":1}}],[\"在项目中引入以下的依赖\",{\"1\":{\"153\":1}}],[\"在这种情况下\",{\"1\":{\"192\":1}}],[\"在这个示例中\",{\"1\":{\"199\":1}}],[\"在这个例子中\",{\"1\":{\"184\":1,\"185\":1}}],[\"在这个接口中\",{\"1\":{\"112\":1}}],[\"在这里有三个指标\",{\"1\":{\"153\":1}}],[\"在这里就不展开讲解了\",{\"1\":{\"153\":1}}],[\"在作用于两个瞬时向量之间\",{\"1\":{\"141\":1}}],[\"在很多场景下\",{\"1\":{\"134\":1}}],[\"在很多rpc框架\",{\"1\":{\"108\":1}}],[\"在下一行\",{\"1\":{\"184\":1}}],[\"在下一篇文章将会讲解\",{\"1\":{\"132\":1}}],[\"在下面的案例中\",{\"1\":{\"74\":1}}],[\"在注释中包含了指标的类型\",{\"1\":{\"131\":1}}],[\"在grafana中为springboot项目配置试图\",{\"1\":{\"156\":1}}],[\"在grafana执行\",{\"1\":{\"137\":1}}],[\"在grafana上查询指标\",{\"1\":{\"130\":1}}],[\"在gui中应用的比较多\",{\"1\":{\"105\":1}}],[\"在更改完配置以后\",{\"1\":{\"126\":1}}],[\"在查询框里输入node\",{\"1\":{\"125\":1}}],[\"在prehandle方法中记录请求的开始时间starttime\",{\"1\":{\"154\":1}}],[\"在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算\",{\"1\":{\"144\":1}}],[\"在prometheus的页面上可以查看新指标的数据\",{\"1\":{\"172\":1}}],[\"在prometheus的yaml配置文件中\",{\"1\":{\"172\":1}}],[\"在prometheus的配置文件中\",{\"1\":{\"164\":1}}],[\"在prometheus的配置文prometheus\",{\"1\":{\"125\":1}}],[\"在prometheus的启动程序的同级目录下面\",{\"1\":{\"164\":1}}],[\"在prometheus中配置告警规则\",{\"0\":{\"164\":1}}],[\"在prometheus\",{\"1\":{\"157\":2}}],[\"在prometheus启动的时候加上启动参数\",{\"1\":{\"126\":1}}],[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus\",{\"1\":{\"124\":1}}],[\"在pom文件中引入cglib包\",{\"1\":{\"113\":1}}],[\"在不同容量情况下系统的并发和负载变化如何\",{\"1\":{\"121\":1}}],[\"在不改变了componentimpl的情况下\",{\"1\":{\"86\":1}}],[\"在不改变已有类的功能的前提下进行批量扩展\",{\"1\":{\"68\":1}}],[\"在微服务的世界里\",{\"1\":{\"121\":1}}],[\"在某些情况下\",{\"1\":{\"112\":1}}],[\"在消息队列的场景有广泛的应用\",{\"1\":{\"105\":1}}],[\"在观察者模式中\",{\"1\":{\"105\":1}}],[\"在流程中有三个角色\",{\"1\":{\"92\":1}}],[\"在工作中\",{\"1\":{\"92\":1}}],[\"在讲解完具体案例后\",{\"1\":{\"88\":1}}],[\"在读取文件的字符之后\",{\"1\":{\"87\":2}}],[\"在写入文件之前\",{\"1\":{\"87\":2}}],[\"在案例模仿javaio的文件流的写入和读取功能\",{\"1\":{\"87\":1}}],[\"在扩展性上\",{\"1\":{\"86\":1}}],[\"在图中一共有三个角色\",{\"1\":{\"86\":1}}],[\"在java中有八种基本数据类型\",{\"1\":{\"190\":1}}],[\"在java中\",{\"1\":{\"181\":1,\"182\":1,\"190\":1,\"193\":1}}],[\"在java中创建一个对象\",{\"1\":{\"75\":1}}],[\"在java语言中并支持动态代理\",{\"1\":{\"108\":1}}],[\"在java的io源码中\",{\"1\":{\"85\":1}}],[\"在程序中\",{\"1\":{\"81\":1}}],[\"在访问的时候需要锁占用\",{\"1\":{\"79\":1}}],[\"在多线程的情况下\",{\"1\":{\"76\":1}}],[\"在判断singleton==null时不为null\",{\"1\":{\"75\":1}}],[\"在系统中只需要初始化一个实例\",{\"1\":{\"72\":1}}],[\"在什么样的场景会使用到单列模式呢\",{\"1\":{\"72\":1}}],[\"在复用代码时\",{\"1\":{\"70\":1}}],[\"在操作中定义算法的框架\",{\"1\":{\"68\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"7\":1}}],[\"如在try语句之前就返回了\",{\"1\":{\"199\":1}}],[\"如hashset\",{\"1\":{\"192\":1}}],[\"如何理解java中的多态\",{\"0\":{\"185\":1}}],[\"如何理解面向过程和面向对象\",{\"0\":{\"183\":1}}],[\"如动物类\",{\"1\":{\"180\":1}}],[\"如截取子列表\",{\"1\":{\"174\":1}}],[\"如添加\",{\"1\":{\"173\":1}}],[\"如list\",{\"1\":{\"173\":1}}],[\"如全局的smtp配置\",{\"1\":{\"162\":1}}],[\"如下图所示\",{\"1\":{\"196\":1}}],[\"如下图的uml图\",{\"1\":{\"73\":1}}],[\"如下\",{\"1\":{\"154\":2,\"172\":1}}],[\"如下表示prometheus\",{\"1\":{\"130\":1}}],[\"如果定义为final\",{\"1\":{\"197\":1}}],[\"如果外部类的方法中的变量不定义final\",{\"1\":{\"197\":1}}],[\"如果将局部变量\",{\"1\":{\"197\":1}}],[\"如果被final修饰的变量时引用类型\",{\"1\":{\"196\":1}}],[\"如果某个属性可以为null\",{\"1\":{\"192\":1}}],[\"如果我们没有重写hashcode\",{\"1\":{\"192\":1}}],[\"如果我们想查询一个时间区间的样本\",{\"1\":{\"138\":1}}],[\"如果用于比较的对象信息没有被修改\",{\"1\":{\"191\":1}}],[\"如果x\",{\"1\":{\"191\":2}}],[\"如果相等\",{\"1\":{\"191\":1}}],[\"如果两个对象根据equals\",{\"1\":{\"192\":1}}],[\"如果两个引用指向不同的对象\",{\"1\":{\"190\":1}}],[\"如果两个变量的引用指向同一个对象\",{\"1\":{\"190\":1}}],[\"如果使用==\",{\"1\":{\"190\":1}}],[\"如果使用基本类型\",{\"1\":{\"184\":1}}],[\"如果使用相同的键插入多个值\",{\"1\":{\"176\":1}}],[\"如果在finally中再次使用了return操作\",{\"1\":{\"199\":2}}],[\"如果在catch中再次使用了return操作\",{\"1\":{\"199\":1}}],[\"如果在try块中发生了异常\",{\"1\":{\"199\":2}}],[\"如果在try块中没有发生异常\",{\"1\":{\"199\":1}}],[\"如果在此过程中发生了异常\",{\"1\":{\"193\":1}}],[\"如果在单线程环境下进行字符串操作\",{\"1\":{\"182\":1}}],[\"如果在多线程环境下执行字符串操作\",{\"1\":{\"182\":1}}],[\"如果在目标类中\",{\"1\":{\"83\":1}}],[\"如果一个类既需要作为其他类的基类\",{\"1\":{\"180\":1}}],[\"如果没有配置\",{\"1\":{\"169\":1}}],[\"如果labels配置中含有额外的标签也会放到新的timeseries中\",{\"1\":{\"169\":1}}],[\"如果expr表达式的计算结果包含标签\",{\"1\":{\"169\":1}}],[\"如果判断需要发送消息给下游的webhook程序\",{\"1\":{\"166\":1}}],[\"如果告警消息符合匹配\",{\"1\":{\"161\":1}}],[\"如果系统发出成千上万条相同的告警消息\",{\"1\":{\"159\":1}}],[\"如果有告警发生\",{\"1\":{\"157\":1}}],[\"如果要求分位耗时\",{\"1\":{\"153\":1}}],[\"如果想计算所有的请求的总数\",{\"1\":{\"146\":1}}],[\"如果想查询五分钟前的数据\",{\"1\":{\"139\":1}}],[\"如果不进行分组合并\",{\"1\":{\"159\":1}}],[\"如果不用ignoring修改器\",{\"1\":{\"145\":1}}],[\"如果不使用观察者模式来捕获一个被观察对象的属性变化\",{\"1\":{\"107\":1}}],[\"如果匹配到了\",{\"1\":{\"141\":1}}],[\"如果是想做与money相关的业务\",{\"1\":{\"121\":1}}],[\"如果需要把证消息发送的顺序\",{\"1\":{\"107\":1}}],[\"如果需要增加新的产品类\",{\"1\":{\"97\":1}}],[\"如果处理链路过长\",{\"1\":{\"93\":1}}],[\"如果此时伪代码发生重排序\",{\"1\":{\"75\":1}}],[\"如果你不了解它\",{\"1\":{\"15\":1}}],[\"如果你是一个新手\",{\"1\":{\"14\":1}}],[\"如图所示\",{\"1\":{\"65\":1,\"81\":1}}],[\"分布均匀性\",{\"1\":{\"192\":1}}],[\"分组是\",{\"1\":{\"159\":1}}],[\"分组是将同一组多个的相同的告警消息合并成一个高级消息\",{\"1\":{\"159\":1}}],[\"分组\",{\"0\":{\"159\":1},\"1\":{\"158\":1}}],[\"分组修改器可以一边的标签组赋值给另一边的查询结构\",{\"1\":{\"145\":1}}],[\"分组修改器可以实现many\",{\"1\":{\"145\":1}}],[\"分组修改器\",{\"0\":{\"145\":1}}],[\"分别引用了\",{\"1\":{\"185\":1}}],[\"分别为\",{\"1\":{\"153\":1}}],[\"分别是\",{\"1\":{\"162\":1}}],[\"分别是code\",{\"1\":{\"146\":1}}],[\"分别是员工\",{\"1\":{\"92\":1}}],[\"分别是创建性型设计模式\",{\"1\":{\"65\":1}}],[\"分钟\",{\"1\":{\"138\":1}}],[\"分发\",{\"1\":{\"120\":1}}],[\"分成多个小的逻辑单元\",{\"1\":{\"93\":1}}],[\"分配内存空间\",{\"1\":{\"75\":1}}],[\"分类为\",{\"1\":{\"43\":1}}],[\"剩下的设计模式会在写完java面试系列文章之后做为补充\",{\"1\":{\"64\":1}}],[\"优先讲解面试过程中常见遇到的几种设计模式\",{\"1\":{\"64\":1}}],[\"那prometheus不适合什么\",{\"1\":{\"121\":1}}],[\"那它的缺点是\",{\"1\":{\"97\":1}}],[\"那么当外部类方法执行完毕的时候\",{\"1\":{\"197\":1}}],[\"那么它们的hashcode\",{\"1\":{\"192\":1}}],[\"那么它们之间的\",{\"1\":{\"190\":2}}],[\"那么hashcode\",{\"1\":{\"192\":2}}],[\"那么在设计时可以考虑将类设计为抽象类\",{\"1\":{\"180\":1}}],[\"那么每秒的增量率\",{\"1\":{\"148\":1}}],[\"那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑\",{\"1\":{\"107\":1}}],[\"那么为什么还需要使用适配器模式呢\",{\"1\":{\"83\":1}}],[\"那么如何学习好设计模式呢\",{\"1\":{\"64\":1}}],[\"那为什么要使用volatile关键字来修饰静态的instance对象呢\",{\"1\":{\"75\":1}}],[\"那本系列教程将会讲述23种经典的设计模式\",{\"1\":{\"64\":1}}],[\"要注意的是\",{\"1\":{\"190\":1}}],[\"要调用子类特有的方法\",{\"1\":{\"185\":1}}],[\"要求springboot>=2\",{\"1\":{\"153\":1}}],[\"要做一些优化工作\",{\"1\":{\"107\":1}}],[\"要做到知其然并知其所以然\",{\"1\":{\"64\":1}}],[\"要尽量先使用组合关系来实现\",{\"1\":{\"70\":1}}],[\"要深挖技术背后的原因\",{\"1\":{\"64\":1}}],[\"刻意的去练习\",{\"1\":{\"64\":1}}],[\"都指向常量池中的同一个字符串对象\",{\"1\":{\"190\":1}}],[\"都可以用于比较\",{\"1\":{\"189\":1}}],[\"都可以通过以下配置\",{\"1\":{\"169\":1}}],[\"都是以当前时间为基准的\",{\"1\":{\"139\":1}}],[\"都是以time\",{\"1\":{\"131\":1}}],[\"都是在不改变同一个接口功能的前提下\",{\"1\":{\"108\":1}}],[\"都是在程序启动之初创建\",{\"1\":{\"74\":1}}],[\"都很方便替换\",{\"1\":{\"83\":1}}],[\"都会让程序员在技术的海洋里迷失\",{\"1\":{\"64\":1}}],[\"都需要良好的程序设计\",{\"1\":{\"64\":1}}],[\"多态性是继承的一个重要应用\",{\"1\":{\"185\":1}}],[\"多态主要体现在方法的重写和方法的动态绑定上\",{\"1\":{\"185\":1}}],[\"多态是面向对象编程的一个核心概念\",{\"1\":{\"185\":1}}],[\"多继承可能导致菱形继承问题\",{\"1\":{\"181\":1}}],[\"多继承是指一个类可以从多个父类继承属性和方法\",{\"1\":{\"181\":1}}],[\"多继承的支持\",{\"1\":{\"180\":1}}],[\"多维的数据结构\",{\"1\":{\"118\":1}}],[\"多应用\",{\"1\":{\"64\":1}}],[\"多练\",{\"1\":{\"64\":1}}],[\"说的简单一点就是多写\",{\"1\":{\"64\":1}}],[\"方便更好地表示一个变量无值的状态\",{\"1\":{\"184\":1}}],[\"方便统一管理和修改\",{\"1\":{\"72\":1}}],[\"方案二\",{\"0\":{\"154\":1}}],[\"方案一\",{\"0\":{\"153\":1}}],[\"方案设计\",{\"1\":{\"64\":1}}],[\"方法返回之前执行\",{\"1\":{\"199\":1}}],[\"方法和变量\",{\"1\":{\"196\":1,\"198\":1}}],[\"方法应返回相同的值\",{\"1\":{\"192\":1}}],[\"方法比较相等\",{\"1\":{\"192\":1}}],[\"方法是\",{\"1\":{\"192\":1}}],[\"方法是很重要的\",{\"1\":{\"192\":1}}],[\"方法是比较两个对象的内存地址是否相等\",{\"1\":{\"191\":1}}],[\"方法计算出来的哈希码可能不相等\",{\"1\":{\"192\":1}}],[\"方法的定义如下\",{\"1\":{\"192\":1}}],[\"方法的比较内容无关\",{\"1\":{\"192\":1}}],[\"方法的返回值将被用作对象的索引\",{\"1\":{\"192\":1}}],[\"方法的重写\",{\"1\":{\"185\":1}}],[\"方法时需要注意的规则\",{\"1\":{\"192\":1}}],[\"方法时\",{\"1\":{\"185\":1,\"192\":2}}],[\"方法而不是==\",{\"1\":{\"184\":1}}],[\"方法重载\",{\"1\":{\"184\":1}}],[\"方法实现\",{\"1\":{\"180\":1}}],[\"方法实现对列表的操作\",{\"1\":{\"174\":1}}],[\"方法默认是抽象类并且是pulic方法\",{\"1\":{\"180\":1}}],[\"方法名称相同\",{\"1\":{\"179\":1}}],[\"方法遍历列表中的元素\",{\"1\":{\"174\":1}}],[\"方法修改列表中指定位置的元素\",{\"1\":{\"174\":1}}],[\"方法获取元素或元素的索引\",{\"1\":{\"174\":1}}],[\"方法获取实例\",{\"1\":{\"74\":1}}],[\"方法删除指定元素或集合中的元素\",{\"1\":{\"174\":1}}],[\"方法将元素或集合添加到列表中\",{\"1\":{\"174\":1}}],[\"方法之前和之后做了功能的增强\",{\"1\":{\"110\":1}}],[\"方法\",{\"1\":{\"76\":1,\"92\":3,\"103\":1,\"180\":1,\"183\":1,\"185\":2,\"191\":3,\"192\":2}}],[\"方法才会初始化实例instance\",{\"1\":{\"75\":1}}],[\"方志朋\",{\"0\":{\"0\":1}}],[\"越来越体会到系统是运营出来的\",{\"1\":{\"64\":1}}],[\"还还支持\",{\"1\":{\"138\":1}}],[\"还可以使用predict\",{\"1\":{\"133\":1}}],[\"还可以提升性能\",{\"1\":{\"75\":1}}],[\"还有一些需要注意的点\",{\"1\":{\"184\":1}}],[\"还有一系列其他的组件\",{\"1\":{\"119\":1}}],[\"还有其他的写法\",{\"1\":{\"77\":1}}],[\"还生产桌子\",{\"1\":{\"101\":1}}],[\"还是自己自己做的一些开源项目中\",{\"1\":{\"64\":1}}],[\"还不会编写\",{\"1\":{\"14\":1}}],[\"这也说明了finally语句被执行的必要条件是\",{\"1\":{\"199\":1}}],[\"这可以通过使用乘法和加法等算法来实现\",{\"1\":{\"192\":1}}],[\"这可能导致意外的结果\",{\"1\":{\"184\":1}}],[\"这可能会引起无限循环或抛出异常\",{\"1\":{\"113\":1}}],[\"这将导致在存储和查找对象时出现问题\",{\"1\":{\"192\":1}}],[\"这将导致具有相等内容的对象\",{\"1\":{\"192\":1}}],[\"这与equals\",{\"1\":{\"192\":1}}],[\"这就实现了运行时的动态绑定\",{\"1\":{\"185\":1}}],[\"这两个greeting方法有不同的参数个数\",{\"1\":{\"179\":1}}],[\"这两个标签对于同一个实例来说基本不变\",{\"1\":{\"146\":1}}],[\"这允许在系统或服务之间建立依赖关系\",{\"1\":{\"163\":1}}],[\"这在系统出现大量故障的时候非常有用\",{\"1\":{\"159\":1}}],[\"这里使用prometheus\",{\"1\":{\"148\":1}}],[\"这里我们以单例模式经典的懒汉式初始化方式为例\",{\"1\":{\"73\":1}}],[\"这使得它可以代理更多类型的类\",{\"1\":{\"113\":1}}],[\"这几个handler构成了一个链式的处理顺序\",{\"1\":{\"91\":1}}],[\"这时我们需要一个拓展坞\",{\"1\":{\"81\":1}}],[\"这时程序会出错\",{\"1\":{\"75\":1}}],[\"这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象\",{\"1\":{\"185\":1}}],[\"这种设计思想能够提高代码的可读性\",{\"1\":{\"181\":1}}],[\"这种方式可以避免在时间窗口范围内的\",{\"1\":{\"148\":1}}],[\"这种情况下在多线程下是不安全的\",{\"1\":{\"78\":1}}],[\"这种双重检查模式经常在面试中被考察\",{\"1\":{\"75\":1}}],[\"这种模式称为饿汉模式\",{\"1\":{\"74\":1}}],[\"这种模式是在类加载的时候就完成了对象的实例化\",{\"1\":{\"74\":1}}],[\"这个时候他所引用的外部变量已经找不到了\",{\"1\":{\"197\":1}}],[\"这个局部变量肯定也就被gc了\",{\"1\":{\"197\":1}}],[\"这个文件是告警规则计算的配置\",{\"1\":{\"164\":1}}],[\"这个对于prometheus的告警消息来说\",{\"1\":{\"163\":1}}],[\"这个内置指标对请求耗时统计不是做的很好\",{\"1\":{\"153\":1}}],[\"这个平均值是不能反应的请求的真实状态\",{\"1\":{\"134\":1}}],[\"这个配置文件是prometheus启动的时候会读取的配置\",{\"1\":{\"124\":1}}],[\"这个页面提供了对prometheus数据的查询和告警信息的查询\",{\"1\":{\"123\":1}}],[\"这个数据结构包括一个指标名和一系列的键值对\",{\"1\":{\"118\":1}}],[\"这个代理类本身已经继承了jdk包中的proxy对象\",{\"1\":{\"112\":1}}],[\"这个职责是唯一引起该类变化的原因\",{\"1\":{\"70\":1}}],[\"这个原则在面试过程中会经常被问到\",{\"1\":{\"70\":1}}],[\"这组对象会将它们的交互委托给中介者对象\",{\"1\":{\"68\":1}}],[\"这样的语句\",{\"1\":{\"199\":1}}],[\"这样的话\",{\"1\":{\"197\":1}}],[\"这样finally语句就不会执行\",{\"1\":{\"199\":1}}],[\"这样调用者就能清楚地知道需要处理哪些异常\",{\"1\":{\"193\":1}}],[\"这样做的好处是实现了代码的灵活性\",{\"1\":{\"185\":1}}],[\"这样做的好处是可以通过统一的接口来操作不同的子类对象\",{\"1\":{\"185\":1}}],[\"这样可以兼顾抽象类和接口的优势\",{\"1\":{\"180\":1}}],[\"这样可以避免接受一些与实际问题相关的告警\",{\"1\":{\"160\":1}}],[\"这样真的一目了然\",{\"1\":{\"171\":1}}],[\"这样webhook的程序收到告警消息后\",{\"1\":{\"166\":1}}],[\"这样不仅增加了代码的耦合性\",{\"1\":{\"107\":1}}],[\"这样代码会非常的臃肿\",{\"1\":{\"83\":1}}],[\"这样就降低了客户与实现模块间的耦合\",{\"1\":{\"70\":1}}],[\"这样当一个对象改变状态时\",{\"1\":{\"68\":1}}],[\"这样只会原地踏步走\",{\"1\":{\"64\":1}}],[\"这些包装类实现了相应类型的对象类型\",{\"1\":{\"184\":1}}],[\"这些抽象方法通常是定义了一组规范或者行为\",{\"1\":{\"180\":1}}],[\"这些方法只有方法签名\",{\"1\":{\"180\":1}}],[\"这些方法具有相同的方法名称\",{\"1\":{\"179\":1}}],[\"这些操作符使用于瞬时向量的查询\",{\"1\":{\"141\":1}}],[\"这些类型的指标在存储的时候\",{\"1\":{\"131\":1}}],[\"这些组件构成了一个完整的监控系统\",{\"1\":{\"120\":1}}],[\"这些在流水线的处理类对象构成了一个单项链表结构\",{\"1\":{\"90\":1}}],[\"这些规则的执行有先后顺序\",{\"1\":{\"90\":1}}],[\"这些对象一般只提供具体的方法\",{\"1\":{\"72\":1}}],[\"这些年技术层出不穷\",{\"1\":{\"64\":1}}],[\"这些年无论是生产环境遇到的事故\",{\"1\":{\"64\":1}}],[\"这些都离不开设计模式的思想\",{\"1\":{\"64\":1}}],[\"这是因为我们在使用基于散列的数据结构\",{\"1\":{\"192\":1}}],[\"这是脚注内容\",{\"1\":{\"39\":1}}],[\"这是项目主页的案例\",{\"1\":{\"1\":1,\"2\":1}}],[\"功能强大\",{\"1\":{\"113\":1}}],[\"功能限制\",{\"1\":{\"112\":1}}],[\"功能详情\",{\"1\":{\"59\":1,\"63\":1}}],[\"功能\",{\"0\":{\"56\":1,\"60\":1},\"1\":{\"57\":1,\"61\":1}}],[\"功能亮点\",{\"0\":{\"49\":1,\"53\":1}}],[\"few\",{\"1\":{\"163\":1}}],[\"fruit\",{\"1\":{\"174\":8}}],[\"fruits\",{\"1\":{\"174\":17}}],[\"from\",{\"1\":{\"171\":1}}],[\"frontmatter\",{\"1\":{\"7\":1,\"15\":3,\"43\":1,\"45\":1}}],[\"front\",{\"1\":{\"1\":1,\"2\":1}}],[\"free\",{\"1\":{\"125\":1,\"133\":1,\"149\":1}}],[\"freed\",{\"1\":{\"124\":1}}],[\"float\",{\"1\":{\"184\":2,\"190\":1}}],[\"float64类型的值\",{\"1\":{\"130\":1}}],[\"flink\",{\"1\":{\"115\":1}}],[\"flush\",{\"1\":{\"87\":1}}],[\"furniturefactory\",{\"1\":{\"102\":1,\"103\":3}}],[\"false\",{\"1\":{\"175\":1,\"190\":4,\"191\":2}}],[\"failures\",{\"1\":{\"171\":8}}],[\"factory=new\",{\"1\":{\"100\":1}}],[\"factory\",{\"1\":{\"95\":1,\"97\":2,\"98\":1,\"101\":1,\"103\":3}}],[\"fangzhipeng\",{\"1\":{\"87\":3,\"106\":3}}],[\"fifo\",{\"1\":{\"173\":1}}],[\"firstfruit\",{\"1\":{\"174\":2}}],[\"first\",{\"1\":{\"124\":1,\"164\":1,\"172\":1,\"174\":2}}],[\"fingerprint\",{\"1\":{\"166\":3}}],[\"finished\",{\"1\":{\"87\":1}}],[\"finalreturn3\",{\"1\":{\"199\":1}}],[\"finalreturn2\",{\"1\":{\"199\":1}}],[\"finalreturn1\",{\"1\":{\"199\":1}}],[\"finalize方法已经过时\",{\"1\":{\"198\":1}}],[\"finalize是一个方法\",{\"1\":{\"198\":1}}],[\"finalize\",{\"1\":{\"198\":3}}],[\"finalize的区别\",{\"0\":{\"187\":1,\"198\":1}}],[\"final是java中的修饰符\",{\"1\":{\"198\":1}}],[\"finaldemo\",{\"1\":{\"197\":3}}],[\"finalobject\",{\"1\":{\"196\":1}}],[\"finalmethodedemo2是不能重新它的父类finalmethoddemo的final方法的\",{\"1\":{\"196\":1}}],[\"finalmethodedemo2\",{\"1\":{\"196\":1}}],[\"finalmethoddemo\",{\"1\":{\"196\":2}}],[\"finaltest\",{\"1\":{\"196\":2,\"199\":1}}],[\"final关键字的使用可以增加代码的可读性\",{\"1\":{\"196\":1}}],[\"final关键字的基本用法\",{\"0\":{\"196\":1}}],[\"final关键字可以用于修饰类\",{\"1\":{\"196\":1}}],[\"final关键字\",{\"1\":{\"196\":1}}],[\"final关键字详解\",{\"0\":{\"195\":1}}],[\"finally语句中没有使用return操作\",{\"1\":{\"199\":1}}],[\"finally语句在java中用于定义一段无论是否发生异常都会执行的代码块\",{\"1\":{\"199\":1}}],[\"finally语句块都将执行\",{\"1\":{\"199\":2}}],[\"finally语句将在try块执行完毕后立即执行\",{\"1\":{\"199\":1}}],[\"finally语句也不会被执行到\",{\"1\":{\"199\":1}}],[\"finally语句到底是在return之前还是之后执行\",{\"0\":{\"199\":1},\"1\":{\"199\":1}}],[\"finally或其他资源管理机制来确保资源的释放\",{\"1\":{\"198\":1}}],[\"finally是java中的关键字\",{\"1\":{\"198\":1}}],[\"finally代码块中的代码始终会执行\",{\"1\":{\"193\":1}}],[\"finally的用法\",{\"1\":{\"193\":1}}],[\"finally块中的代码也会在return语句执行后执行\",{\"1\":{\"199\":1}}],[\"finally块中的代码也会在方法返回之前执行\",{\"1\":{\"198\":1}}],[\"finally块中的代码将在return语句执行之后\",{\"1\":{\"199\":1}}],[\"finally块中的代码都会被执行\",{\"1\":{\"198\":1,\"199\":1}}],[\"finally块通常用于释放资源\",{\"1\":{\"198\":1}}],[\"finally块在try块或catch块执行完毕后执行\",{\"1\":{\"193\":1}}],[\"finally块用于定义无论是否发生异常都需要执行的代码\",{\"1\":{\"193\":1}}],[\"finally块\",{\"1\":{\"193\":2}}],[\"finally异常处理语句模板\",{\"1\":{\"193\":1}}],[\"finally\",{\"0\":{\"187\":1,\"198\":1},\"1\":{\"87\":2,\"193\":1,\"198\":2,\"199\":9}}],[\"final\",{\"1\":{\"76\":1,\"180\":1,\"196\":8,\"197\":2}}],[\"file=alertmanager\",{\"1\":{\"162\":1}}],[\"files定义recoding\",{\"1\":{\"172\":1}}],[\"filesystem\",{\"1\":{\"125\":1,\"133\":4,\"149\":1}}],[\"files是配置告警规则文件的路径\",{\"1\":{\"124\":1}}],[\"files\",{\"1\":{\"124\":1,\"164\":1,\"172\":1}}],[\"filewriter\",{\"1\":{\"87\":7}}],[\"filenotfoundexception\",{\"1\":{\"87\":1}}],[\"filepath=\",{\"1\":{\"87\":1}}],[\"filepath\",{\"1\":{\"87\":8}}],[\"file\",{\"1\":{\"85\":1,\"87\":8}}],[\"filereaderwriter=new\",{\"1\":{\"87\":1}}],[\"filereaderwriter\",{\"1\":{\"87\":5}}],[\"filereader\",{\"1\":{\"85\":3,\"87\":7}}],[\"foreach\",{\"1\":{\"174\":1}}],[\"forezp\",{\"1\":{\"80\":2,\"87\":1,\"92\":2,\"106\":5,\"154\":1,\"199\":1}}],[\"for\",{\"1\":{\"87\":2,\"106\":1,\"163\":5,\"164\":2,\"174\":4,\"175\":2,\"176\":4,\"192\":1}}],[\"foo\",{\"0\":{\"51\":1,\"55\":1,\"56\":1},\"1\":{\"57\":1}}],[\"block\",{\"1\":{\"199\":6}}],[\"blog\",{\"1\":{\"167\":2}}],[\"blue\",{\"1\":{\"180\":1}}],[\"been\",{\"1\":{\"163\":2,\"166\":1}}],[\"bean\",{\"1\":{\"154\":1}}],[\"before\",{\"1\":{\"110\":2,\"112\":2,\"163\":2}}],[\"bin\",{\"1\":{\"127\":1}}],[\"by\",{\"1\":{\"124\":1,\"141\":2,\"146\":4,\"150\":2,\"156\":2,\"162\":1,\"163\":3,\"169\":1,\"172\":1,\"193\":1}}],[\"bytes的差值\",{\"1\":{\"133\":1}}],[\"bytes\",{\"1\":{\"124\":12,\"125\":1,\"133\":2}}],[\"bytearrayinputstream\",{\"1\":{\"87\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"87\":4}}],[\"byte\",{\"1\":{\"87\":6,\"190\":9}}],[\"buildandstart\",{\"1\":{\"154\":1}}],[\"builder\",{\"1\":{\"154\":3}}],[\"bucket指标去统计\",{\"1\":{\"134\":1}}],[\"bucket\",{\"1\":{\"124\":1,\"134\":10,\"150\":13,\"154\":12,\"156\":1}}],[\"buck\",{\"1\":{\"124\":3}}],[\"bufferedwriter\",{\"1\":{\"87\":8}}],[\"bufferedreader\",{\"1\":{\"85\":2,\"87\":7}}],[\"bufferedreader和filereader都是使用到包装器模式\",{\"1\":{\"85\":1}}],[\"b\",{\"1\":{\"87\":3,\"150\":1,\"190\":2}}],[\"bob\",{\"1\":{\"175\":7,\"176\":10}}],[\"book\",{\"1\":{\"167\":1}}],[\"boolean\",{\"1\":{\"154\":1,\"174\":1,\"175\":1,\"176\":1,\"190\":1,\"191\":2}}],[\"boot<\",{\"1\":{\"153\":2}}],[\"boot\",{\"0\":{\"0\":1,\"153\":1},\"1\":{\"152\":1,\"153\":3}}],[\"bottomk\",{\"1\":{\"146\":1}}],[\"bout\",{\"1\":{\"87\":8}}],[\"banana\",{\"1\":{\"174\":2}}],[\"backlink\",{\"1\":{\"166\":1}}],[\"basiccontroller\",{\"1\":{\"153\":1}}],[\"basics\",{\"1\":{\"151\":1}}],[\"base64\",{\"1\":{\"87\":4}}],[\"baz\",{\"0\":{\"63\":1},\"1\":{\"50\":1,\"54\":1,\"62\":1}}],[\"bark\",{\"1\":{\"180\":1}}],[\"bar\",{\"0\":{\"50\":1,\"54\":1,\"60\":1},\"1\":{\"61\":1}}],[\"此篇文章不讲解这部分内容\",{\"1\":{\"127\":1}}],[\"此外\",{\"1\":{\"107\":1}}],[\"此种模式是不推荐的\",{\"1\":{\"79\":1}}],[\"此页面应当包含\",{\"1\":{\"45\":1}}],[\"此文字有脚注\",{\"1\":{\"24\":1}}],[\"徽章\",{\"1\":{\"44\":1}}],[\"徽章文字\",{\"1\":{\"44\":1}}],[\"pi\",{\"1\":{\"180\":1}}],[\"person=null\",{\"1\":{\"196\":1}}],[\"person=new\",{\"1\":{\"196\":1}}],[\"person\",{\"1\":{\"196\":5}}],[\"per\",{\"1\":{\"171\":4}}],[\"p\",{\"1\":{\"167\":1}}],[\"port\",{\"1\":{\"154\":1}}],[\"population\",{\"1\":{\"146\":2}}],[\"postmapping\",{\"1\":{\"166\":1}}],[\"post请求\",{\"1\":{\"161\":1}}],[\"posthandle\",{\"1\":{\"154\":1}}],[\"post\",{\"1\":{\"145\":6}}],[\"power\",{\"1\":{\"141\":1}}],[\"plcmt=topnav\",{\"1\":{\"127\":1}}],[\"plugin\",{\"1\":{\"18\":1}}],[\"pg=community\",{\"1\":{\"127\":1}}],[\"put\",{\"1\":{\"145\":1,\"176\":4}}],[\"push\",{\"1\":{\"119\":1}}],[\"publisher=new\",{\"1\":{\"106\":1}}],[\"publisherimpl\",{\"1\":{\"106\":2}}],[\"publisher接口的实现类publisherimpl\",{\"1\":{\"106\":1}}],[\"publisher\",{\"1\":{\"106\":6}}],[\"public和abstract\",{\"1\":{\"180\":1}}],[\"public\",{\"1\":{\"44\":1,\"74\":2,\"75\":2,\"76\":2,\"78\":2,\"79\":2,\"82\":9,\"87\":15,\"92\":12,\"97\":8,\"100\":7,\"103\":9,\"106\":10,\"110\":9,\"112\":6,\"113\":7,\"153\":2,\"154\":8,\"166\":20,\"174\":2,\"175\":2,\"176\":2,\"179\":11,\"180\":12,\"185\":3,\"191\":2,\"192\":1,\"193\":3,\"196\":13,\"197\":8,\"199\":9}}],[\"path\",{\"1\":{\"171\":15}}],[\"pattern\",{\"1\":{\"80\":1,\"95\":1,\"98\":1,\"101\":1,\"104\":1}}],[\"parti\",{\"1\":{\"167\":1}}],[\"parameter\",{\"1\":{\"146\":1}}],[\"page\",{\"1\":{\"164\":1}}],[\"pause\",{\"1\":{\"124\":1,\"135\":1}}],[\"package\",{\"1\":{\"92\":2,\"106\":5,\"154\":1,\"199\":1}}],[\"prefer\",{\"1\":{\"181\":1}}],[\"prehandle\",{\"1\":{\"154\":1}}],[\"predict\",{\"1\":{\"133\":1,\"149\":3}}],[\"protected\",{\"1\":{\"198\":1}}],[\"programming\",{\"1\":{\"183\":2}}],[\"procedural\",{\"1\":{\"183\":1}}],[\"process\",{\"1\":{\"87\":1}}],[\"properties中开启prometheus的暴露接口\",{\"1\":{\"153\":1}}],[\"profiling\",{\"1\":{\"124\":1}}],[\"promql提供了另外一个灵敏度更高的函数irate\",{\"1\":{\"148\":1}}],[\"promql提供了两个向量匹配符号\",{\"1\":{\"144\":1}}],[\"promql还支持常见的比较运算符\",{\"1\":{\"142\":1}}],[\"promql支持常见的逻辑和数学操作符\",{\"1\":{\"141\":1}}],[\"promql被广泛应用于指标视图的配置\",{\"1\":{\"136\":1}}],[\"promql是prometheus提供的数据查询语言\",{\"1\":{\"136\":1}}],[\"promql快速入门\",{\"0\":{\"136\":1}}],[\"promql非常的强大和灵活\",{\"1\":{\"118\":1}}],[\"prometheus会定时的根据拉取expr定时表达式的数据\",{\"1\":{\"169\":1}}],[\"prometheus支持两种规则表达式\",{\"1\":{\"168\":1}}],[\"prometheus预处理计算\",{\"0\":{\"168\":1}}],[\"prometheus作为存储端\",{\"1\":{\"157\":1}}],[\"prometheus作为采集端\",{\"1\":{\"157\":1}}],[\"prometheus作为一个采集组件\",{\"1\":{\"128\":1}}],[\"prometheus告警与alertmanager实战\",{\"0\":{\"157\":1}}],[\"prometheuslab\",{\"1\":{\"154\":1}}],[\"prometheus官方提供了java客户端\",{\"1\":{\"154\":1}}],[\"prometheus依赖是将micrometer的指标转换成prometheus格式的指标\",{\"1\":{\"153\":1}}],[\"prometheus<\",{\"1\":{\"153\":1,\"154\":3}}],[\"prometheus的告警分为两部分内容\",{\"1\":{\"157\":1}}],[\"prometheus的时间序列是通过指标名和一组标签来唯一定义\",{\"1\":{\"136\":1}}],[\"prometheus的数据模型\",{\"0\":{\"129\":1}}],[\"prometheus每发生一个请求\",{\"1\":{\"132\":1}}],[\"prometheus定义来四种类型的指标\",{\"1\":{\"131\":1}}],[\"prometheus可以通过调用\",{\"1\":{\"130\":1}}],[\"prometheus可以很好地记录任何纯粹的数字时间序列\",{\"1\":{\"121\":1}}],[\"prometheus配置文件热更新\",{\"0\":{\"126\":1}}],[\"prometheus配置文件讲解\",{\"0\":{\"124\":1}}],[\"prometheus环境搭建\",{\"0\":{\"122\":1}}],[\"prometheus是为可靠性而设计的\",{\"1\":{\"121\":1}}],[\"prometheus是一个开源的监控系统\",{\"1\":{\"117\":1}}],[\"prometheus适用的场景\",{\"0\":{\"121\":1}}],[\"prometheus发现到监控目标后\",{\"1\":{\"120\":1}}],[\"prometheus通过时间序列来存储所有的数据的\",{\"1\":{\"130\":1}}],[\"prometheus通过时序数据来收集和存储指标\",{\"1\":{\"117\":1}}],[\"prometheus通过pull的方式去周期性\",{\"1\":{\"120\":1}}],[\"prometheus生态包含了一系列组件\",{\"1\":{\"119\":1}}],[\"prometheus提供非常的多的聚合函数\",{\"1\":{\"146\":1}}],[\"prometheus提供了http接口的方式让外部第三方访问数据\",{\"1\":{\"120\":1}}],[\"prometheus提供一些关键的特性\",{\"1\":{\"118\":1}}],[\"prometheus提供的特性\",{\"0\":{\"118\":1}}],[\"prometheus让监控从传统的黑盒子监控提升到了白盒监控\",{\"1\":{\"118\":1}}],[\"prometheus和传统的监控系统相比\",{\"1\":{\"118\":1}}],[\"prometheus受启发于google的brogmon监控系统\",{\"1\":{\"117\":1}}],[\"prometheus概述\",{\"0\":{\"116\":1}}],[\"prometheus\",{\"1\":{\"115\":1,\"119\":1,\"120\":1,\"123\":4,\"124\":1,\"125\":3,\"126\":1,\"130\":10,\"131\":3,\"132\":2,\"134\":12,\"137\":7,\"138\":1,\"139\":4,\"141\":3,\"146\":6,\"148\":4,\"150\":22,\"151\":2,\"153\":1,\"154\":4,\"157\":1,\"162\":1,\"164\":1,\"166\":1,\"167\":3,\"172\":2}}],[\"prometheus教程介绍\",{\"0\":{\"115\":1}}],[\"proxy\",{\"1\":{\"112\":2,\"113\":2}}],[\"proxyhandler\",{\"1\":{\"112\":4}}],[\"proxy类和java\",{\"1\":{\"112\":1}}],[\"priorityqueue\",{\"1\":{\"173\":1}}],[\"printstacktrace\",{\"1\":{\"87\":7}}],[\"println\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"174\":10,\"175\":7,\"176\":9,\"179\":5,\"180\":5,\"185\":2,\"190\":3,\"193\":3,\"196\":3,\"197\":2,\"199\":8}}],[\"principle\",{\"1\":{\"70\":5}}],[\"private\",{\"1\":{\"74\":2,\"75\":2,\"76\":3,\"78\":2,\"79\":2,\"82\":1,\"87\":7,\"92\":1,\"106\":2,\"110\":1,\"112\":1,\"113\":1,\"180\":3,\"196\":5}}],[\"标签\",{\"1\":{\"141\":1}}],[\"标签为\",{\"1\":{\"43\":1}}],[\"标题和页面信息\",{\"1\":{\"45\":1}}],[\"标记\",{\"0\":{\"25\":1}}],[\"日\",{\"1\":{\"43\":1}}],[\"月\",{\"1\":{\"43\":1}}],[\"年\",{\"1\":{\"43\":1,\"138\":1}}],[\"↩︎\",{\"1\":{\"39\":1}}],[\"幻灯片\",{\"0\":{\"39\":1}}],[\"幻灯片页\",{\"0\":{\"3\":1}}],[\"交互演示\",{\"0\":{\"37\":1,\"38\":1}}],[\"捐赠一杯咖啡\",{\"1\":{\"36\":1}}],[\"向量匹配符号\",{\"0\":{\"144\":1}}],[\"向量里面的标签是左侧和右侧共同匹配的标签\",{\"1\":{\"141\":1}}],[\"向\",{\"1\":{\"36\":1}}],[\"样式化\",{\"0\":{\"36\":1}}],[\"导致不确定性\",{\"1\":{\"181\":1}}],[\"导致告警处理者漏处理一些告警消息\",{\"1\":{\"159\":1}}],[\"导致连接它的应用的几百个实例都出现异常\",{\"1\":{\"159\":1}}],[\"导致请求耗时的平均值远大于100ms\",{\"1\":{\"134\":1}}],[\"导致工厂类的代码会随着产品类型的增多而变得越来越复杂\",{\"1\":{\"97\":1}}],[\"导入成功后\",{\"1\":{\"127\":1}}],[\"导入文件\",{\"0\":{\"34\":1}}],[\"导航栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"−1\",{\"1\":{\"33\":1}}],[\"run2\",{\"1\":{\"197\":2}}],[\"run1\",{\"1\":{\"197\":2}}],[\"runtime\",{\"1\":{\"194\":1}}],[\"running\",{\"1\":{\"180\":1}}],[\"run\",{\"1\":{\"180\":1,\"197\":7}}],[\"rule规则文件的路径\",{\"1\":{\"172\":1}}],[\"rule产生的新的指标\",{\"1\":{\"171\":1}}],[\"rule的命令规范很重要\",{\"1\":{\"170\":1}}],[\"rule的最佳实践\",{\"0\":{\"170\":1}}],[\"rule的具体配置\",{\"1\":{\"169\":1}}],[\"rule的规则定义如下\",{\"1\":{\"169\":1}}],[\"rule类似\",{\"1\":{\"169\":1}}],[\"rule是预先计算成本较高的表达式\",{\"1\":{\"168\":1}}],[\"rules选项是recording\",{\"1\":{\"169\":1}}],[\"rules\",{\"0\":{\"169\":1},\"1\":{\"124\":2,\"162\":2,\"163\":3,\"164\":2,\"169\":1,\"172\":1}}],[\"rule\",{\"0\":{\"168\":1},\"1\":{\"124\":2,\"164\":4,\"167\":1,\"168\":1,\"169\":2,\"172\":5}}],[\"route配置\",{\"1\":{\"163\":1}}],[\"route\",{\"1\":{\"162\":2,\"163\":1}}],[\"right\",{\"1\":{\"145\":1}}],[\"radius\",{\"1\":{\"180\":6}}],[\"ratio\",{\"1\":{\"171\":4}}],[\"rate1m\",{\"1\":{\"172\":1}}],[\"rate\",{\"1\":{\"148\":1,\"150\":2,\"171\":2,\"172\":1}}],[\"rate5m\",{\"1\":{\"145\":12,\"171\":12}}],[\"range\",{\"0\":{\"138\":1},\"1\":{\"148\":1,\"149\":1}}],[\"ray\",{\"0\":{\"59\":1},\"1\":{\"51\":1,\"55\":1,\"58\":1}}],[\"rw\",{\"1\":{\"87\":2}}],[\"removing\",{\"1\":{\"174\":2,\"176\":2}}],[\"removeall\",{\"1\":{\"174\":1}}],[\"remove\",{\"1\":{\"174\":2,\"175\":1,\"176\":1}}],[\"reverse\",{\"1\":{\"174\":1}}],[\"recoding\",{\"1\":{\"172\":1}}],[\"record\",{\"1\":{\"169\":2,\"171\":5,\"172\":1}}],[\"recording的计算规则和alert的计算规则\",{\"1\":{\"169\":1}}],[\"recording\",{\"0\":{\"168\":1,\"170\":1},\"1\":{\"168\":1,\"170\":1,\"172\":1}}],[\"receiver可以集成邮箱\",{\"1\":{\"163\":1}}],[\"receivers配置\",{\"1\":{\"163\":1}}],[\"receivers\",{\"1\":{\"162\":2,\"163\":1}}],[\"receiver\",{\"1\":{\"162\":1,\"163\":1,\"166\":2}}],[\"region\",{\"1\":{\"164\":1,\"172\":1}}],[\"registry\",{\"1\":{\"153\":2,\"154\":2}}],[\"register\",{\"1\":{\"106\":4,\"154\":2}}],[\"repeat\",{\"1\":{\"162\":1,\"163\":2}}],[\"release\",{\"1\":{\"127\":1}}],[\"releases\",{\"1\":{\"125\":1}}],[\"reload\",{\"1\":{\"126\":1,\"161\":1}}],[\"reflect\",{\"1\":{\"112\":2}}],[\"realsubject\",{\"1\":{\"109\":1,\"110\":10,\"112\":4,\"113\":1}}],[\"readline\",{\"1\":{\"87\":1}}],[\"read\",{\"1\":{\"87\":9}}],[\"readerwriter的基本实现类是filereaderwriter\",{\"1\":{\"87\":1}}],[\"readerwriter\",{\"1\":{\"87\":21}}],[\"requestbody\",{\"1\":{\"166\":1}}],[\"requestparam\",{\"1\":{\"153\":1,\"154\":1}}],[\"requestmapping\",{\"1\":{\"153\":1,\"154\":1}}],[\"requests\",{\"1\":{\"130\":12,\"131\":4,\"132\":3,\"137\":8,\"138\":1,\"139\":4,\"141\":3,\"145\":5,\"146\":6,\"148\":5,\"153\":10,\"164\":1,\"169\":2,\"171\":10,\"172\":2}}],[\"request\",{\"1\":{\"91\":1,\"134\":13,\"141\":1,\"150\":13,\"154\":5,\"171\":8}}],[\"resolve\",{\"1\":{\"162\":1,\"163\":2}}],[\"response\",{\"1\":{\"154\":3}}],[\"responsebody\",{\"1\":{\"153\":1,\"154\":1}}],[\"responsibility\",{\"1\":{\"70\":1}}],[\"resulting\",{\"1\":{\"146\":1}}],[\"result\",{\"1\":{\"87\":8,\"193\":2,\"199\":2}}],[\"returnvalue\",{\"1\":{\"113\":2}}],[\"return\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"87\":9,\"92\":1,\"97\":3,\"100\":2,\"103\":3,\"112\":1,\"113\":2,\"153\":1,\"154\":3,\"166\":1,\"180\":1,\"191\":5,\"192\":1,\"193\":1,\"196\":2,\"199\":6}}],[\"r−i​\",{\"1\":{\"33\":1}}],[\"r−i+1\",{\"1\":{\"33\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"33\":1}}],[\"rgba\",{\"1\":{\"28\":1}}],[\"ωyω​\",{\"1\":{\"33\":2}}],[\"∂ωr∂r​\",{\"1\":{\"33\":1}}],[\"error也是throwable的一个子类\",{\"1\":{\"193\":1}}],[\"error是不可控制的严重问题的异常类\",{\"1\":{\"193\":1}}],[\"error\",{\"1\":{\"193\":1}}],[\"error和throwable是一个类层次结构中的相关类\",{\"1\":{\"193\":1}}],[\"errors\",{\"1\":{\"145\":7}}],[\"eating\",{\"1\":{\"180\":1}}],[\"eat\",{\"1\":{\"179\":8,\"180\":3}}],[\"empty\",{\"1\":{\"174\":2,\"175\":2,\"176\":2}}],[\"element\",{\"1\":{\"174\":2}}],[\"elements\",{\"1\":{\"146\":4}}],[\"else\",{\"1\":{\"92\":3,\"97\":1}}],[\"equal\",{\"1\":{\"142\":4,\"162\":1,\"163\":2}}],[\"equals\",{\"0\":{\"189\":1,\"191\":1,\"192\":1},\"1\":{\"97\":2,\"189\":1,\"191\":12}}],[\"even\",{\"1\":{\"124\":1}}],[\"evaluation\",{\"1\":{\"124\":2,\"169\":2}}],[\"executed\",{\"1\":{\"199\":6}}],[\"externalurl\",{\"1\":{\"166\":2}}],[\"extends\",{\"1\":{\"92\":3,\"97\":2,\"103\":1,\"154\":1,\"179\":2,\"180\":1,\"185\":2,\"196\":1}}],[\"ex\",{\"1\":{\"154\":1}}],[\"exceptionexample\",{\"1\":{\"193\":1}}],[\"exception又分为两种类型\",{\"1\":{\"193\":1}}],[\"exception是可控制的异常类\",{\"1\":{\"193\":1}}],[\"exception和error\",{\"1\":{\"193\":1}}],[\"exception\",{\"1\":{\"154\":4,\"193\":2,\"198\":1}}],[\"exception=\",{\"1\":{\"153\":3}}],[\"example\",{\"1\":{\"154\":4,\"169\":1}}],[\"exist\",{\"1\":{\"124\":1}}],[\"exit\",{\"1\":{\"87\":1,\"199\":2}}],[\"expr执行后生成新的指标的名称\",{\"1\":{\"169\":1}}],[\"expr\",{\"1\":{\"164\":2,\"169\":2,\"171\":5,\"172\":1}}],[\"expression>\",{\"1\":{\"146\":1}}],[\"exposure\",{\"1\":{\"153\":1}}],[\"exponentiation\",{\"1\":{\"141\":1}}],[\"expoter的指标时序\",{\"1\":{\"128\":1}}],[\"exporter暴露的端口指标\",{\"1\":{\"125\":1}}],[\"exporter的dashboard\",{\"1\":{\"127\":1}}],[\"exporter的面板\",{\"1\":{\"127\":1}}],[\"exporter的任务\",{\"1\":{\"125\":1}}],[\"exporter的端口为9100\",{\"1\":{\"125\":1}}],[\"exporter的指标了\",{\"1\":{\"125\":1}}],[\"exporter的指标\",{\"0\":{\"125\":1},\"1\":{\"122\":1,\"128\":1}}],[\"exporter是prometheus生态的一员\",{\"1\":{\"125\":1}}],[\"exporter采集的指标中\",{\"1\":{\"133\":1}}],[\"exporter采集的指标生产\",{\"1\":{\"127\":1}}],[\"exporter采集的指标\",{\"1\":{\"122\":1}}],[\"exporters是用来暴露或者导出被监控对象的指标的\",{\"1\":{\"119\":1}}],[\"exporter\",{\"1\":{\"115\":1,\"122\":1,\"125\":3,\"154\":2,\"157\":1}}],[\"expansiondockadapter并持有需要被适配的iusb接口\",{\"1\":{\"82\":1}}],[\"expansiondockadapter\",{\"1\":{\"82\":5}}],[\"entryset\",{\"1\":{\"176\":2}}],[\"entry<string\",{\"1\":{\"176\":2}}],[\"entry\",{\"1\":{\"176\":7}}],[\"entity\",{\"1\":{\"166\":1}}],[\"enterprise\",{\"1\":{\"127\":3}}],[\"env\",{\"1\":{\"164\":1}}],[\"environment\",{\"1\":{\"124\":1,\"194\":1}}],[\"endsat\",{\"1\":{\"166\":2}}],[\"endtime\",{\"1\":{\"154\":2}}],[\"endpoints\",{\"1\":{\"153\":1}}],[\"enable\",{\"1\":{\"126\":2}}],[\"en\",{\"1\":{\"113\":4}}],[\"encodetostring\",{\"1\":{\"87\":2}}],[\"encode\",{\"1\":{\"87\":2}}],[\"encryptionfilereaderwriter\",{\"1\":{\"87\":3}}],[\"encryptionfilereaderwriter是一个装饰器\",{\"1\":{\"87\":1}}],[\"enhancer\",{\"1\":{\"113\":2}}],[\"enhance\",{\"1\":{\"18\":1}}],[\"e\",{\"1\":{\"87\":14,\"166\":1,\"193\":2,\"198\":1,\"199\":2}}],[\"echarts\",{\"0\":{\"30\":1}}],[\"图中\",{\"1\":{\"81\":1,\"109\":1}}],[\"图表\",{\"0\":{\"29\":1}}],[\"图片增强\",{\"0\":{\"27\":1}}],[\"0即\",{\"1\":{\"190\":1}}],[\"025\",{\"1\":{\"154\":1}}],[\"01\",{\"1\":{\"154\":1}}],[\"0<\",{\"1\":{\"154\":3}}],[\"071374449\",{\"1\":{\"153\":1}}],[\"049234863\",{\"1\":{\"153\":1}}],[\"04\",{\"1\":{\"145\":2}}],[\"005\",{\"1\":{\"154\":1}}],[\"009242327\",{\"1\":{\"135\":1}}],[\"009608685\",{\"1\":{\"124\":1}}],[\"002707693\",{\"1\":{\"124\":1}}],[\"000421166\",{\"1\":{\"135\":1}}],[\"000194843\",{\"1\":{\"135\":1}}],[\"00013637\",{\"1\":{\"135\":1}}],[\"000123743\",{\"1\":{\"124\":1}}],[\"000251038\",{\"1\":{\"124\":1}}],[\"05\",{\"1\":{\"124\":2,\"135\":1,\"145\":3,\"154\":1}}],[\"0版本\",{\"1\":{\"117\":2,\"153\":1}}],[\"0\",{\"1\":{\"28\":1,\"87\":3,\"106\":1,\"124\":8,\"134\":5,\"135\":9,\"145\":6,\"146\":1,\"149\":1,\"150\":5,\"153\":9,\"154\":27,\"156\":1,\"162\":2,\"163\":2,\"164\":6,\"174\":1,\"191\":2,\"192\":3,\"193\":1,\"199\":4}}],[\"ss\",{\"1\":{\"196\":1}}],[\"s=\",{\"1\":{\"196\":1}}],[\"s3\",{\"1\":{\"196\":4}}],[\"s2=\",{\"1\":{\"196\":1}}],[\"s2\",{\"1\":{\"196\":2}}],[\"s1\",{\"1\":{\"196\":2}}],[\"s1=\",{\"1\":{\"196\":2}}],[\"sleeping\",{\"1\":{\"180\":1}}],[\"sleep\",{\"1\":{\"180\":3}}],[\"slack或者webhook等\",{\"1\":{\"162\":1}}],[\"slack配置等内容\",{\"1\":{\"162\":1}}],[\"short\",{\"1\":{\"190\":1}}],[\"showname\",{\"1\":{\"97\":2,\"100\":1,\"103\":3}}],[\"shape\",{\"1\":{\"180\":6}}],[\"sheep=new\",{\"1\":{\"179\":1}}],[\"sheep\",{\"1\":{\"179\":5}}],[\"sheep继承了animal父类\",{\"1\":{\"179\":1}}],[\"sdk\",{\"1\":{\"157\":1}}],[\"sdks\",{\"1\":{\"119\":1}}],[\"score\",{\"1\":{\"176\":8}}],[\"scores\",{\"1\":{\"176\":16}}],[\"scope>\",{\"1\":{\"153\":1}}],[\"scalar\",{\"1\":{\"149\":1,\"150\":1}}],[\"scrape\",{\"1\":{\"124\":4,\"125\":1,\"155\":1}}],[\"smallest\",{\"1\":{\"146\":1}}],[\"sam\",{\"1\":{\"196\":1}}],[\"same\",{\"1\":{\"146\":1,\"163\":1}}],[\"sample由三部分组成\",{\"1\":{\"130\":1}}],[\"sample\",{\"1\":{\"130\":1,\"146\":2}}],[\"super\",{\"1\":{\"180\":1,\"198\":1}}],[\"successfully\",{\"1\":{\"163\":1}}],[\"success\",{\"1\":{\"153\":3}}],[\"sum作为后缀\",{\"1\":{\"134\":1}}],[\"sum\",{\"1\":{\"124\":1,\"134\":1,\"135\":1,\"141\":1,\"146\":6,\"150\":2,\"153\":2,\"154\":1,\"156\":2,\"164\":1,\"169\":2,\"171\":4,\"172\":1}}],[\"summary在通过promql进行查询时有更好的性能表现\",{\"1\":{\"135\":1}}],[\"summary是在sdk侧已经计算好了分位数\",{\"1\":{\"135\":1}}],[\"summary和histogram类似\",{\"1\":{\"135\":1}}],[\"summary\",{\"0\":{\"135\":1},\"1\":{\"124\":2,\"131\":1,\"135\":2,\"153\":1,\"164\":1}}],[\"sublist\",{\"1\":{\"174\":1}}],[\"subtraction\",{\"1\":{\"141\":1}}],[\"subject\",{\"1\":{\"105\":1,\"109\":1,\"110\":3,\"112\":5,\"113\":5}}],[\"substitution\",{\"1\":{\"70\":1}}],[\"sort\",{\"1\":{\"174\":1}}],[\"so\",{\"1\":{\"171\":1}}],[\"source\",{\"1\":{\"162\":1,\"163\":2}}],[\"somthing\",{\"1\":{\"110\":2,\"112\":1,\"113\":1}}],[\"sofa=\",{\"1\":{\"103\":1}}],[\"sofa\",{\"1\":{\"96\":2,\"97\":17,\"99\":2,\"100\":7,\"103\":5}}],[\"sighup信号或者请求alertmanager\",{\"1\":{\"161\":1}}],[\"size\",{\"1\":{\"106\":1,\"174\":5,\"175\":5,\"176\":5}}],[\"simplefactory\",{\"1\":{\"97\":3}}],[\"simplesofafactory\",{\"1\":{\"96\":1,\"97\":1}}],[\"simple\",{\"1\":{\"95\":1}}],[\"sington\",{\"1\":{\"80\":1}}],[\"singleton=memory\",{\"1\":{\"75\":1}}],[\"single\",{\"1\":{\"70\":1}}],[\"search=\",{\"1\":{\"164\":1}}],[\"search=node+exporter+mac\",{\"1\":{\"127\":1}}],[\"sent\",{\"1\":{\"163\":2}}],[\"sending\",{\"1\":{\"163\":2}}],[\"send\",{\"1\":{\"163\":1}}],[\"select\",{\"1\":{\"146\":2}}],[\"selectors查询\",{\"1\":{\"138\":1}}],[\"selectors\",{\"0\":{\"137\":1,\"138\":1}}],[\"servlet\",{\"1\":{\"154\":4}}],[\"server中配置告警规则\",{\"1\":{\"157\":1}}],[\"server中配置alertmanager的地址\",{\"1\":{\"157\":1}}],[\"server中的告警规则\",{\"1\":{\"157\":1}}],[\"server进行计算的\",{\"1\":{\"135\":1}}],[\"server\",{\"1\":{\"127\":1,\"153\":10,\"154\":2,\"158\":1}}],[\"server是最核心的组件\",{\"1\":{\"119\":1}}],[\"series的形式存储在prometheus的level\",{\"1\":{\"131\":1}}],[\"series中每个点被称为一个样子\",{\"1\":{\"130\":1}}],[\"series\",{\"0\":{\"130\":1},\"1\":{\"130\":1}}],[\"seconds指标\",{\"1\":{\"135\":1}}],[\"seconds\",{\"1\":{\"124\":9,\"134\":13,\"135\":9,\"141\":1,\"150\":13,\"153\":10,\"154\":19,\"156\":1}}],[\"second\",{\"1\":{\"124\":1}}],[\"severity\",{\"1\":{\"162\":2,\"163\":4,\"164\":1}}],[\"sever\",{\"1\":{\"122\":1}}],[\"setname\",{\"1\":{\"196\":1}}],[\"setnextapproval\",{\"1\":{\"92\":3}}],[\"setage\",{\"1\":{\"196\":2}}],[\"setattribute\",{\"1\":{\"154\":1}}],[\"set和map接口\",{\"1\":{\"177\":1}}],[\"set<string>\",{\"1\":{\"175\":1}}],[\"setexample\",{\"1\":{\"175\":1}}],[\"set接口\",{\"0\":{\"175\":1}}],[\"set\",{\"1\":{\"173\":3,\"174\":2,\"175\":17}}],[\"setcallback\",{\"1\":{\"113\":1}}],[\"setsuperclass\",{\"1\":{\"113\":1}}],[\"segregation\",{\"1\":{\"70\":1}}],[\"sb\",{\"1\":{\"87\":3}}],[\"str3\",{\"1\":{\"190\":3}}],[\"str2\",{\"1\":{\"190\":3}}],[\"str1\",{\"1\":{\"190\":4}}],[\"string是线程安全的\",{\"1\":{\"182\":1}}],[\"string是不可变\",{\"1\":{\"182\":1}}],[\"stringbuffer是线程安全的\",{\"1\":{\"182\":1}}],[\"stringbuffer和stringbuilder是可变的\",{\"1\":{\"182\":1}}],[\"stringbuffer和stringbuilder是可变\",{\"1\":{\"182\":1}}],[\"stringbuffer和stringbuilder是用于处理字符串的类\",{\"1\":{\"182\":1}}],[\"stringbuilder的性能比stringbuffer性能更好\",{\"1\":{\"182\":1}}],[\"stringbuilder的区别是什么\",{\"0\":{\"182\":1}}],[\"stringbuilder是非线程安全的\",{\"1\":{\"182\":1}}],[\"stringbuilder\",{\"1\":{\"87\":2}}],[\"string和stringbuffer\",{\"0\":{\"182\":1}}],[\"string>\",{\"1\":{\"166\":5}}],[\"stringdata\",{\"1\":{\"87\":4}}],[\"string\",{\"1\":{\"82\":1,\"87\":24,\"92\":1,\"97\":5,\"100\":1,\"103\":3,\"106\":3,\"110\":1,\"112\":1,\"113\":1,\"153\":2,\"154\":3,\"166\":9,\"174\":5,\"175\":3,\"176\":3,\"179\":5,\"180\":5,\"182\":1,\"190\":4,\"191\":3,\"193\":1,\"196\":10,\"197\":3,\"199\":3}}],[\"stdvar\",{\"1\":{\"146\":1}}],[\"stddev\",{\"1\":{\"146\":1}}],[\"still\",{\"1\":{\"124\":1}}],[\"starsliao\",{\"1\":{\"167\":1}}],[\"startsat\",{\"1\":{\"166\":2}}],[\"starttime\",{\"1\":{\"154\":6}}],[\"starter\",{\"0\":{\"153\":1},\"1\":{\"152\":1,\"153\":3}}],[\"status\",{\"1\":{\"154\":2,\"166\":4}}],[\"status=\",{\"1\":{\"153\":3,\"154\":15}}],[\"staticproxy\",{\"1\":{\"109\":1,\"110\":7}}],[\"static\",{\"1\":{\"74\":2,\"75\":2,\"76\":3,\"78\":2,\"79\":2,\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":2,\"112\":2,\"113\":2,\"124\":2,\"125\":2,\"155\":1,\"164\":1,\"166\":1,\"174\":1,\"175\":1,\"176\":1,\"179\":2,\"180\":4,\"193\":2,\"196\":5,\"197\":1,\"199\":6}}],[\"standard\",{\"1\":{\"146\":2}}],[\"staff\",{\"1\":{\"92\":7}}],[\"sys\",{\"1\":{\"124\":3}}],[\"system\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"154\":2,\"174\":10,\"175\":7,\"176\":9,\"179\":5,\"180\":5,\"185\":2,\"190\":3,\"193\":3,\"196\":3,\"197\":2,\"199\":9}}],[\"synchronized\",{\"1\":{\"75\":1,\"79\":1}}],[\"src\",{\"1\":{\"80\":1}}],[\"srp\",{\"1\":{\"70\":1,\"97\":1}}],[\"s\",{\"1\":{\"70\":1,\"87\":3,\"138\":1,\"176\":2,\"196\":2}}],[\"svg\",{\"1\":{\"28\":1}}],[\"springboot\",{\"1\":{\"155\":1}}],[\"springboot已经有来micrometer的指标库\",{\"1\":{\"153\":1}}],[\"springframework\",{\"1\":{\"153\":2,\"154\":2}}],[\"spring事务等领域有着广泛的应用\",{\"1\":{\"108\":1}}],[\"spring\",{\"0\":{\"0\":3},\"1\":{\"108\":1}}],[\"legs\",{\"1\":{\"180\":2}}],[\"level\",{\"1\":{\"171\":4}}],[\"le\",{\"1\":{\"150\":2,\"156\":1}}],[\"left修改器进行查询\",{\"1\":{\"145\":1}}],[\"left\",{\"1\":{\"145\":2,\"171\":1}}],[\"less\",{\"1\":{\"142\":2}}],[\"le=\",{\"1\":{\"134\":12,\"150\":10,\"154\":12}}],[\"length\",{\"1\":{\"87\":2,\"191\":2,\"192\":2}}],[\"long\",{\"1\":{\"154\":4,\"163\":3,\"190\":1}}],[\"localhost\",{\"1\":{\"123\":1,\"124\":2,\"125\":4,\"126\":1,\"146\":1,\"150\":10,\"154\":1,\"155\":1,\"165\":1}}],[\"logger\",{\"1\":{\"166\":1}}],[\"logy\",{\"1\":{\"33\":2}}],[\"logo\",{\"1\":{\"28\":2}}],[\"lastindexof\",{\"1\":{\"174\":1}}],[\"latest\",{\"1\":{\"151\":1,\"166\":1}}],[\"largest\",{\"1\":{\"146\":1}}],[\"lang\",{\"1\":{\"112\":2}}],[\"lable\",{\"1\":{\"137\":1}}],[\"labelvalues\",{\"1\":{\"154\":2}}],[\"labelnames\",{\"1\":{\"154\":2}}],[\"label\",{\"1\":{\"137\":5}}],[\"labels\",{\"1\":{\"137\":4,\"141\":1,\"163\":1,\"164\":2,\"166\":2,\"169\":1,\"171\":1,\"172\":1}}],[\"lab\",{\"1\":{\"80\":1}}],[\"labs\",{\"1\":{\"80\":1}}],[\"lazyinstancesafe\",{\"1\":{\"79\":5}}],[\"lazyinstancenosafe\",{\"1\":{\"78\":5}}],[\"lazyinstance\",{\"1\":{\"75\":6}}],[\"lsp\",{\"1\":{\"70\":1}}],[\"l\",{\"1\":{\"70\":1}}],[\"linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据\",{\"1\":{\"149\":1}}],[\"linear函数对指标的数据变化趋势进行预测\",{\"1\":{\"133\":1}}],[\"linear\",{\"1\":{\"133\":1,\"149\":2}}],[\"linkedhashmap\",{\"1\":{\"176\":1}}],[\"linkedlist\",{\"1\":{\"173\":2}}],[\"link\",{\"1\":{\"28\":1}}],[\"lifecycle\",{\"1\":{\"126\":2}}],[\"libraries\",{\"1\":{\"119\":1}}],[\"library\",{\"1\":{\"113\":1}}],[\"lisi\",{\"1\":{\"179\":2}}],[\"list<string>\",{\"1\":{\"174\":1}}],[\"list<observer>\",{\"1\":{\"106\":1}}],[\"listexample\",{\"1\":{\"174\":1}}],[\"list>\",{\"1\":{\"146\":1}}],[\"list\",{\"0\":{\"174\":1},\"1\":{\"106\":5,\"173\":2,\"174\":18}}],[\"liskov\",{\"1\":{\"70\":1}}],[\"light\",{\"1\":{\"28\":1}}],[\"t\",{\"1\":{\"149\":1}}],[\"timeout对于prometheus的告警消息是不生效的\",{\"1\":{\"163\":1}}],[\"timeout\",{\"1\":{\"162\":1,\"163\":2}}],[\"timeseries格式如下\",{\"1\":{\"146\":1}}],[\"timestamp\",{\"1\":{\"130\":3}}],[\"time\",{\"1\":{\"130\":1}}],[\"title\",{\"1\":{\"28\":1}}],[\"task2\",{\"1\":{\"197\":1}}],[\"task1\",{\"1\":{\"197\":1}}],[\"taskname+\",{\"1\":{\"197\":1}}],[\"taskname=\",{\"1\":{\"197\":2}}],[\"taskname\",{\"1\":{\"197\":3}}],[\"task\",{\"1\":{\"197\":6}}],[\"tar\",{\"1\":{\"123\":2,\"127\":3}}],[\"targets\",{\"1\":{\"124\":2,\"125\":2,\"155\":1,\"164\":1}}],[\"target\",{\"1\":{\"113\":6,\"162\":1,\"163\":2}}],[\"table=\",{\"1\":{\"103\":1}}],[\"table\",{\"1\":{\"102\":1,\"103\":9,\"124\":1}}],[\"type\",{\"1\":{\"97\":3,\"124\":6,\"130\":1,\"131\":1,\"135\":1,\"153\":2,\"154\":2}}],[\"txt\",{\"1\":{\"87\":1}}],[\"test2\",{\"1\":{\"196\":1}}],[\"test<\",{\"1\":{\"153\":1}}],[\"testcglibproxy\",{\"1\":{\"113\":2}}],[\"testjdkproxy\",{\"1\":{\"112\":2}}],[\"teststatic\",{\"1\":{\"110\":2}}],[\"test\",{\"1\":{\"87\":1,\"164\":2,\"196\":4}}],[\"text\",{\"1\":{\"87\":2}}],[\"tex\",{\"0\":{\"33\":1}}],[\"together\",{\"1\":{\"163\":1}}],[\"topk\",{\"1\":{\"146\":2}}],[\"to\",{\"1\":{\"144\":3,\"145\":2,\"163\":8,\"166\":4,\"171\":1,\"199\":1}}],[\"total的后缀\",{\"1\":{\"171\":1}}],[\"total和http\",{\"1\":{\"154\":1}}],[\"total这个指标有4个标签\",{\"1\":{\"146\":1}}],[\"total指标的不同标签维度的所有指标\",{\"1\":{\"137\":1}}],[\"total都会累积1\",{\"1\":{\"132\":1}}],[\"total表示prometheus服务的http请求的数量\",{\"1\":{\"132\":1}}],[\"total结尾\",{\"1\":{\"132\":1}}],[\"total\",{\"1\":{\"124\":4,\"130\":11,\"131\":3,\"132\":1,\"137\":7,\"138\":1,\"139\":4,\"141\":3,\"146\":5,\"148\":5,\"154\":5,\"156\":1,\"164\":1,\"171\":4,\"172\":1}}],[\"tobytearray\",{\"1\":{\"87\":2}}],[\"tostring\",{\"1\":{\"87\":1,\"106\":1,\"166\":1}}],[\"toc\",{\"1\":{\"45\":1}}],[\"than\",{\"1\":{\"142\":2}}],[\"thanos\",{\"1\":{\"118\":1}}],[\"that\",{\"1\":{\"124\":1,\"163\":1,\"166\":1}}],[\"then\",{\"1\":{\"171\":1}}],[\"the\",{\"1\":{\"124\":3,\"135\":1,\"146\":4,\"163\":2,\"166\":5,\"171\":1,\"199\":1}}],[\"there\",{\"1\":{\"28\":2}}],[\"throwable有两个重要的子类\",{\"1\":{\"193\":1}}],[\"throwable是所有异常类的根类\",{\"1\":{\"193\":1}}],[\"throwable\",{\"1\":{\"112\":1,\"113\":1,\"193\":1,\"198\":1}}],[\"throws\",{\"1\":{\"112\":1,\"113\":1,\"154\":4,\"198\":1}}],[\"this\",{\"1\":{\"82\":1,\"87\":3,\"92\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":2,\"180\":2,\"191\":2,\"196\":3}}],[\"truncated\",{\"1\":{\"166\":1}}],[\"truncatedalerts\",{\"1\":{\"166\":2}}],[\"true\",{\"1\":{\"1\":1,\"2\":1,\"154\":1,\"174\":2,\"175\":2,\"176\":2,\"190\":5,\"191\":2}}],[\"try语句没有被执行到\",{\"1\":{\"199\":1}}],[\"try块用于包裹可能发生异常的代码片段\",{\"1\":{\"193\":1}}],[\"try块\",{\"1\":{\"193\":1}}],[\"try\",{\"1\":{\"87\":6,\"193\":1,\"198\":1,\"199\":3}}],[\"treemap\",{\"1\":{\"173\":1,\"176\":1}}],[\"treeset\",{\"1\":{\"173\":1}}],[\"tree\",{\"1\":{\"80\":1}}],[\"卡片\",{\"0\":{\"28\":1}}],[\"任务列表\",{\"0\":{\"26\":1}}],[\"脚注\",{\"0\":{\"24\":1}}],[\"的默认行为是使用对象的内存地址计算哈希码\",{\"1\":{\"192\":1}}],[\"的多次调用应始终返回相同的结果\",{\"1\":{\"191\":1}}],[\"的区别\",{\"0\":{\"189\":1}}],[\"的引用变量\",{\"1\":{\"185\":1}}],[\"的类\",{\"1\":{\"182\":2}}],[\"的实例对象\",{\"1\":{\"180\":1}}],[\"的大小和是否为空\",{\"1\":{\"176\":1}}],[\"的大小\",{\"1\":{\"176\":1}}],[\"的大小可以根据需要进行动态调整\",{\"1\":{\"174\":1}}],[\"的映射关系\",{\"1\":{\"176\":1}}],[\"的形式存储数据\",{\"1\":{\"173\":1}}],[\"的数据结构\",{\"1\":{\"173\":1}}],[\"的请求量\",{\"1\":{\"172\":1}}],[\"的指标情况\",{\"1\":{\"137\":2}}],[\"的所有的数据\",{\"1\":{\"137\":1}}],[\"的所有方法\",{\"1\":{\"109\":1}}],[\"的包含时间和值的流式数据\",{\"1\":{\"130\":1}}],[\"的项目\",{\"1\":{\"117\":1}}],[\"的代码如下\",{\"1\":{\"110\":1}}],[\"的抽象方法getname\",{\"1\":{\"97\":2}}],[\"的方法调用是基于运行时类型而不是编译时类型\",{\"1\":{\"185\":1}}],[\"的方法\",{\"1\":{\"73\":1,\"100\":1}}],[\"的静态对象和\",{\"1\":{\"73\":1}}],[\"的\",{\"1\":{\"23\":1,\"43\":1,\"161\":1,\"174\":1}}],[\"irate\",{\"1\":{\"148\":1}}],[\"irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率\",{\"1\":{\"148\":1}}],[\"irate同样用于计算区间向量的计算率\",{\"1\":{\"148\":1}}],[\"ir⋯\",{\"1\":{\"33\":1}}],[\"ignoring\",{\"1\":{\"144\":1,\"145\":2}}],[\"iin\",{\"1\":{\"87\":3}}],[\"i++\",{\"1\":{\"87\":2,\"106\":1,\"191\":1,\"192\":1}}],[\"immutable\",{\"1\":{\"182\":1}}],[\"img\",{\"1\":{\"121\":1}}],[\"import\",{\"1\":{\"106\":2,\"154\":6,\"174\":2,\"175\":2,\"176\":2}}],[\"implements\",{\"1\":{\"82\":2,\"87\":3,\"100\":2,\"103\":1,\"106\":2,\"110\":2,\"112\":1,\"113\":1,\"154\":1,\"180\":2}}],[\"image\",{\"1\":{\"65\":1,\"73\":1,\"86\":1,\"99\":1,\"105\":1,\"115\":1,\"123\":2,\"125\":1,\"127\":2,\"130\":1,\"137\":2,\"138\":1,\"156\":2,\"157\":1,\"164\":2,\"165\":1,\"172\":1}}],[\"iusb\",{\"1\":{\"82\":9}}],[\"io读写等\",{\"1\":{\"125\":1}}],[\"ioexception\",{\"1\":{\"87\":6,\"154\":1}}],[\"io\",{\"1\":{\"80\":1,\"92\":2,\"106\":5,\"123\":1,\"151\":1,\"154\":3,\"162\":1,\"166\":1,\"167\":1,\"199\":1}}],[\"ifurniturefactory\",{\"1\":{\"102\":1,\"103\":5}}],[\"ifactory的具体实现类americasofafactory\",{\"1\":{\"100\":1}}],[\"ifactory的具体实现类chinesesofafactory\",{\"1\":{\"100\":1}}],[\"ifactory\",{\"1\":{\"99\":1,\"100\":4}}],[\"if\",{\"1\":{\"75\":2,\"78\":1,\"79\":1,\"87\":4,\"92\":3,\"97\":2,\"124\":1,\"163\":1,\"191\":4,\"192\":1}}],[\"inheritance\",{\"1\":{\"181\":1}}],[\"inhibiting\",{\"1\":{\"163\":1}}],[\"inhibit\",{\"1\":{\"162\":2,\"163\":3}}],[\"indexof\",{\"1\":{\"174\":1}}],[\"inprogress\",{\"1\":{\"169\":2}}],[\"inputstream\",{\"1\":{\"87\":1}}],[\"initial\",{\"1\":{\"163\":2}}],[\"initially\",{\"1\":{\"163\":1}}],[\"ini文件下\",{\"1\":{\"127\":1}}],[\"instrumentation\",{\"1\":{\"154\":2,\"171\":1}}],[\"instant\",{\"0\":{\"137\":1},\"1\":{\"150\":1}}],[\"instanceof\",{\"1\":{\"191\":1}}],[\"instances\",{\"1\":{\"171\":1}}],[\"instance的标签值相等\",{\"1\":{\"163\":1}}],[\"instance=\",{\"1\":{\"146\":1,\"150\":10}}],[\"instance为被采集的实例\",{\"1\":{\"146\":1}}],[\"instance\",{\"1\":{\"73\":1,\"75\":5,\"76\":2,\"78\":4,\"79\":4,\"146\":2,\"162\":1,\"163\":2,\"171\":13,\"172\":2}}],[\"incoming\",{\"1\":{\"163\":1}}],[\"inc\",{\"1\":{\"154\":1}}],[\"include=prometheus\",{\"1\":{\"153\":1}}],[\"increase是promql中的一个函数\",{\"1\":{\"132\":1}}],[\"increase\",{\"1\":{\"132\":1,\"148\":2,\"156\":2,\"164\":1}}],[\"infinity\",{\"1\":{\"150\":1}}],[\"information\",{\"1\":{\"124\":1}}],[\"info\",{\"1\":{\"124\":3,\"166\":1}}],[\"inflaterinputstream\",{\"1\":{\"87\":2}}],[\"invoke\",{\"1\":{\"112\":6,\"113\":1}}],[\"invocationhandler\",{\"1\":{\"112\":1}}],[\"invocationhandler接口来实现动态代理\",{\"1\":{\"112\":1}}],[\"inversion\",{\"1\":{\"70\":1}}],[\"in\",{\"1\":{\"87\":3,\"124\":1,\"146\":2}}],[\"integer\",{\"1\":{\"184\":1}}],[\"integer>\",{\"1\":{\"176\":3}}],[\"intersection\",{\"1\":{\"143\":1}}],[\"interval是全局配置告警规则任务的计算\",{\"1\":{\"124\":1}}],[\"interval\",{\"1\":{\"124\":3,\"162\":2,\"163\":4,\"169\":3,\"172\":1}}],[\"interceptorregistry\",{\"1\":{\"154\":1}}],[\"intercept\",{\"1\":{\"113\":1}}],[\"interface的继承接口\",{\"1\":{\"173\":1}}],[\"interface\",{\"1\":{\"70\":1,\"82\":2,\"87\":1,\"100\":1,\"103\":1,\"106\":2,\"110\":1,\"173\":1,\"180\":2,\"181\":1}}],[\"int\",{\"1\":{\"82\":10,\"87\":3,\"92\":8,\"106\":1,\"166\":1,\"174\":1,\"175\":1,\"176\":4,\"180\":1,\"184\":1,\"190\":3,\"191\":2,\"192\":3,\"193\":4,\"196\":6,\"199\":8}}],[\"inner\",{\"1\":{\"76\":2}}],[\"innerclzsingleton\",{\"1\":{\"76\":5}}],[\"i\",{\"1\":{\"70\":1,\"87\":6,\"106\":3,\"184\":2,\"191\":3,\"192\":3}}],[\"isempty\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"isp\",{\"1\":{\"70\":1}}],[\"is\",{\"1\":{\"28\":2,\"174\":2,\"175\":2,\"176\":2,\"180\":3,\"199\":1}}],[\"idea提示\",{\"1\":{\"199\":1}}],[\"idea会提示错误\",{\"1\":{\"196\":1}}],[\"identify\",{\"1\":{\"166\":1}}],[\"identifying\",{\"1\":{\"166\":1}}],[\"identifies\",{\"1\":{\"166\":1}}],[\"id\",{\"1\":{\"23\":1}}],[\"itypec\",{\"1\":{\"82\":2}}],[\"it\",{\"1\":{\"16\":2,\"163\":1}}],[\"我们调用了divide方法并将结果存储在result变量中\",{\"1\":{\"193\":1}}],[\"我们使用try\",{\"1\":{\"193\":1}}],[\"我们使用父类\",{\"1\":{\"185\":1}}],[\"我们需要使用相同的属性来计算hashcode\",{\"1\":{\"192\":1}}],[\"我们需要有一些专注力\",{\"1\":{\"64\":1}}],[\"我们对对象内容的比较\",{\"1\":{\"191\":1}}],[\"我们都会选择使用histogram类型的指标去做分位数的统计\",{\"1\":{\"135\":1}}],[\"我们还可以通过histogram\",{\"1\":{\"134\":1}}],[\"我们可以实现代码的解耦和类之间的松耦合\",{\"1\":{\"180\":1}}],[\"我们可以根据指标的名称可以反推出指标的表达式\",{\"1\":{\"171\":1}}],[\"我们可以将一组相关的规则设置定义在一个group下\",{\"1\":{\"164\":1}}],[\"我们可以计算所有handler\",{\"1\":{\"146\":1}}],[\"我们可以使用offset关键字\",{\"1\":{\"139\":1}}],[\"我们可以使用求平均值来量化指标\",{\"1\":{\"134\":1}}],[\"我们可以直接输入指标名查询所有的这个指标名的时间序列\",{\"1\":{\"137\":1}}],[\"我们可以提前预测在未来什么时间节点上需要对资源进行扩容\",{\"1\":{\"121\":1}}],[\"我们可以看出代理模式有三个关键角色\",{\"1\":{\"109\":1}}],[\"我们可以看出适配器模式中包含三个关键角色\",{\"1\":{\"81\":1}}],[\"我们可以得出以下的一些结论\",{\"1\":{\"93\":1}}],[\"我们经常有一些审批流程\",{\"1\":{\"92\":1}}],[\"我们来思考一下\",{\"1\":{\"88\":1}}],[\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解\",{\"1\":{\"81\":1}}],[\"我们主要讲解最常用到的适配器模式\",{\"1\":{\"81\":1}}],[\"我们支持\",{\"1\":{\"57\":1,\"61\":1}}],[\"我觉得需要刻意练习\",{\"1\":{\"64\":1}}],[\"我在右对齐\",{\"1\":{\"22\":1}}],[\"我是居中的\",{\"1\":{\"22\":1}}],[\"highqps\",{\"1\":{\"164\":2}}],[\"histogram类型的http\",{\"1\":{\"154\":1}}],[\"histogram类型的指标可以使用histogram\",{\"1\":{\"150\":1}}],[\"histogram和summary的区别在于\",{\"1\":{\"135\":1}}],[\"histogram的指标\",{\"1\":{\"134\":1}}],[\"histogram直方图可以解决上面的问题\",{\"1\":{\"134\":1}}],[\"histogram直方图是用来统计和分析样本的分布情况\",{\"1\":{\"134\":1}}],[\"histogram直方图\",{\"0\":{\"134\":1}}],[\"histogram\",{\"1\":{\"131\":1,\"150\":3,\"154\":6,\"156\":1}}],[\"hello接口相关的指标\",{\"1\":{\"153\":1}}],[\"hello\",{\"1\":{\"153\":8,\"154\":19,\"179\":3}}],[\"help\",{\"1\":{\"124\":6,\"130\":1,\"131\":1,\"135\":1,\"153\":2,\"154\":4}}],[\"h\",{\"1\":{\"138\":1,\"192\":6}}],[\"have\",{\"1\":{\"166\":1}}],[\"has\",{\"1\":{\"163\":2}}],[\"hashcode\",{\"1\":{\"192\":3}}],[\"hashmap<>\",{\"1\":{\"176\":1}}],[\"hashmapexample\",{\"1\":{\"176\":1}}],[\"hashmap\",{\"1\":{\"173\":1,\"176\":15,\"192\":1}}],[\"hashset<>\",{\"1\":{\"175\":1}}],[\"hashset\",{\"1\":{\"173\":1,\"175\":1}}],[\"hash\",{\"1\":{\"124\":4,\"192\":2}}],[\"handle\",{\"1\":{\"92\":7}}],[\"handlerinterceptoradapter\",{\"1\":{\"154\":2}}],[\"handler=~\",{\"1\":{\"137\":2}}],[\"handler=\",{\"1\":{\"130\":6,\"131\":1,\"134\":12,\"137\":1,\"138\":1,\"141\":4,\"146\":1,\"148\":5,\"150\":12,\"164\":1,\"172\":1}}],[\"handler\",{\"1\":{\"112\":3,\"130\":1,\"137\":2,\"141\":2,\"146\":3,\"150\":2,\"154\":4,\"172\":2}}],[\"handlerc\",{\"1\":{\"91\":1}}],[\"handlerb\",{\"1\":{\"91\":1}}],[\"http\",{\"1\":{\"124\":1,\"125\":1,\"126\":1,\"130\":12,\"131\":4,\"132\":3,\"134\":13,\"137\":8,\"138\":1,\"139\":4,\"141\":4,\"145\":12,\"146\":6,\"148\":5,\"150\":13,\"153\":11,\"154\":23,\"156\":2,\"162\":1,\"163\":1,\"164\":3,\"165\":1,\"169\":2,\"172\":2}}],[\"httpservletresponse\",{\"1\":{\"154\":4}}],[\"httpservletrequest\",{\"1\":{\"154\":4}}],[\"httpserver\",{\"1\":{\"154\":3}}],[\"httpserver是用于导出指标的服务\",{\"1\":{\"154\":1}}],[\"httpserver<\",{\"1\":{\"154\":1}}],[\"https\",{\"1\":{\"28\":2,\"80\":1,\"125\":1,\"127\":2,\"151\":1,\"162\":1,\"166\":1,\"167\":4}}],[\"hugryinstance\",{\"1\":{\"74\":7}}],[\"how\",{\"1\":{\"163\":3,\"166\":1}}],[\"hook\",{\"1\":{\"162\":2,\"163\":2}}],[\"hope\",{\"1\":{\"28\":4,\"36\":1,\"43\":1}}],[\"home\",{\"1\":{\"1\":1,\"2\":1}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"上面的内容可能不会被面试官问到\",{\"1\":{\"177\":1}}],[\"上面的例子演示了如何创建\",{\"1\":{\"175\":1,\"176\":1}}],[\"上面的表达式rate\",{\"1\":{\"171\":1}}],[\"上面的表达式等价于\",{\"1\":{\"148\":1}}],[\"上面的语句等同于\",{\"1\":{\"137\":1}}],[\"上面的配置是采集prometheus自身的监控指标\",{\"1\":{\"124\":1}}],[\"上面的测试输出结果\",{\"1\":{\"100\":1}}],[\"上图是装饰器的uml图\",{\"1\":{\"86\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"上一篇\",{\"1\":{\"7\":1}}],[\"危险容器\",{\"1\":{\"19\":1}}],[\"提高代码的安全性\",{\"1\":{\"196\":1}}],[\"提高散列存储结构的性能\",{\"1\":{\"192\":1}}],[\"提高了系统的灵活性和可维护性\",{\"1\":{\"93\":1}}],[\"提升代码的可扩展性\",{\"1\":{\"93\":1}}],[\"提升代码的复用性\",{\"1\":{\"72\":1}}],[\"提供一些通用方法的实现\",{\"1\":{\"180\":1}}],[\"提供一个静态工厂方法用于创建不同的产品对象\",{\"1\":{\"96\":1}}],[\"提供一个全局的访问点\",{\"1\":{\"66\":1}}],[\"提供了一套完整的开发工具\",{\"1\":{\"194\":1}}],[\"提供了一种通用的规范\",{\"1\":{\"180\":1}}],[\"提供了访问基本类型数据的方法\",{\"1\":{\"184\":1}}],[\"提供了根据键快速查找对应值的方法\",{\"1\":{\"176\":1}}],[\"提供了高效的查找操作\",{\"1\":{\"175\":1}}],[\"提供了非常多的面板和插件\",{\"1\":{\"127\":1}}],[\"提供了单节点和分布式的数据存储方案\",{\"1\":{\"118\":1}}],[\"提供了数据查询的promql\",{\"1\":{\"118\":1}}],[\"提供了数据采集\",{\"1\":{\"117\":1}}],[\"提供更大的灵活性\",{\"1\":{\"113\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"18\":1}}],[\"提供整个责任链的可扩展性\",{\"1\":{\"93\":1}}],[\"提供统一的方法来访问内部子系统\",{\"1\":{\"67\":1}}],[\"提示\",{\"1\":{\"44\":1}}],[\"提示容器\",{\"1\":{\"19\":1}}],[\"=~\",{\"1\":{\"137\":2}}],[\"=>\",{\"1\":{\"130\":3}}],[\"=factory\",{\"1\":{\"100\":1}}],[\"==比较结果为\",{\"1\":{\"190\":1}}],[\"==\",{\"0\":{\"189\":1,\"190\":1},\"1\":{\"75\":2,\"78\":1,\"79\":1,\"142\":1,\"189\":1,\"190\":7,\"191\":4,\"192\":1}}],[\"=\",{\"1\":{\"19\":1,\"33\":1,\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"82\":3,\"85\":2,\"87\":36,\"92\":4,\"97\":5,\"103\":1,\"106\":3,\"110\":2,\"112\":4,\"113\":5,\"137\":4,\"142\":1,\"153\":2,\"154\":8,\"169\":1,\"174\":4,\"175\":3,\"176\":8,\"180\":4,\"184\":2,\"185\":2,\"190\":5,\"191\":7,\"192\":5,\"193\":1,\"196\":5,\"197\":2,\"199\":4}}],[\"a=3\",{\"1\":{\"199\":1}}],[\"a=2\",{\"1\":{\"199\":2}}],[\"a=1\",{\"1\":{\"199\":2}}],[\"assigned\",{\"1\":{\"199\":1}}],[\"as\",{\"1\":{\"171\":1}}],[\"age\",{\"1\":{\"196\":8}}],[\"aggregate\",{\"1\":{\"171\":1}}],[\"again\",{\"1\":{\"163\":1}}],[\"anotherstring\",{\"1\":{\"191\":3}}],[\"anobject\",{\"1\":{\"191\":4}}],[\"animal2\",{\"1\":{\"185\":3}}],[\"animal1\",{\"1\":{\"185\":3}}],[\"animaldemo\",{\"1\":{\"180\":1}}],[\"animal\",{\"1\":{\"179\":7,\"180\":7,\"185\":8}}],[\"annotations的内容在告警产生时会一同作为参数发送到alertmanager\",{\"1\":{\"164\":1}}],[\"annotations\",{\"1\":{\"164\":2,\"166\":2}}],[\"an\",{\"1\":{\"163\":3}}],[\"and\",{\"1\":{\"124\":1,\"143\":1,\"144\":1,\"171\":1}}],[\"actuator<\",{\"1\":{\"153\":1}}],[\"actuator的依赖包中\",{\"1\":{\"153\":1}}],[\"actuator\",{\"0\":{\"153\":1},\"1\":{\"152\":1,\"153\":1}}],[\"average\",{\"1\":{\"146\":1}}],[\"avg\",{\"1\":{\"146\":1}}],[\"avail\",{\"1\":{\"133\":3}}],[\"alicescore\",{\"1\":{\"176\":2}}],[\"alice\",{\"1\":{\"175\":3,\"176\":6}}],[\"already\",{\"1\":{\"163\":2}}],[\"allows\",{\"1\":{\"163\":1}}],[\"allocated\",{\"1\":{\"124\":2}}],[\"alloc\",{\"1\":{\"124\":6}}],[\"all\",{\"1\":{\"146\":1}}],[\"alert\",{\"1\":{\"163\":2,\"164\":2,\"166\":3,\"167\":2}}],[\"alerts\",{\"1\":{\"163\":5,\"164\":1,\"165\":1,\"166\":5}}],[\"alertname\",{\"1\":{\"162\":2,\"163\":3}}],[\"alerting\",{\"1\":{\"124\":2,\"164\":1,\"166\":1}}],[\"alertmanager收到告警消息后\",{\"1\":{\"166\":1}}],[\"alertmanager查看告警消息\",{\"0\":{\"165\":1}}],[\"alertmanager持续多长时间未接收到告警后标记告警状态为resolved\",{\"1\":{\"163\":1}}],[\"alertmanager会启动它的告警恢复逻辑\",{\"1\":{\"163\":1}}],[\"alertmanager安装\",{\"0\":{\"162\":1}}],[\"alertmanager则不会发送消息到下游\",{\"1\":{\"161\":1}}],[\"alertmanager处理来自客户端的告警消息\",{\"1\":{\"158\":1}}],[\"alertmanager介绍\",{\"0\":{\"158\":1}}],[\"alertmanager作为告警收敛的组件\",{\"1\":{\"157\":1}}],[\"alertmanager的主要功能包括告警消息的分组\",{\"1\":{\"157\":1}}],[\"alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",{\"1\":{\"124\":1}}],[\"alertmanagers是配置alertmanagers的地址的\",{\"1\":{\"124\":1}}],[\"alertmanagers\",{\"1\":{\"124\":1,\"164\":1}}],[\"alertmanager提供了对告警消息的管理\",{\"1\":{\"120\":1}}],[\"alertmanager是用来管理告警消息的\",{\"1\":{\"119\":1}}],[\"alertmanager\",{\"1\":{\"115\":1,\"124\":2,\"161\":2,\"162\":1,\"166\":1}}],[\"abc\",{\"1\":{\"190\":3}}],[\"about\",{\"1\":{\"124\":1,\"163\":1}}],[\"abstract\",{\"1\":{\"92\":2,\"97\":2,\"101\":1,\"103\":2,\"180\":4,\"185\":2,\"197\":2}}],[\"aftercompletion\",{\"1\":{\"154\":1}}],[\"after\",{\"1\":{\"110\":2,\"112\":2,\"174\":2,\"176\":2}}],[\"aop\",{\"1\":{\"108\":1,\"154\":1}}],[\"addall\",{\"1\":{\"174\":1}}],[\"added\",{\"1\":{\"163\":1}}],[\"addinterceptor\",{\"1\":{\"154\":1}}],[\"addinterceptors\",{\"1\":{\"154\":1}}],[\"addition\",{\"1\":{\"141\":1}}],[\"add\",{\"1\":{\"106\":1,\"174\":5,\"175\":4}}],[\"adapter\",{\"1\":{\"82\":2}}],[\"adaptee\",{\"1\":{\"81\":1}}],[\"arithmeticexception\",{\"1\":{\"193\":2,\"199\":6}}],[\"article\",{\"1\":{\"167\":1}}],[\"artifactid>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"arrays=null\",{\"1\":{\"196\":1}}],[\"arrays=new\",{\"1\":{\"196\":1}}],[\"arraylist<alert>\",{\"1\":{\"166\":1}}],[\"arraylist<>\",{\"1\":{\"106\":1,\"174\":1}}],[\"arraylist\",{\"1\":{\"106\":1,\"173\":1,\"174\":1}}],[\"arrive\",{\"1\":{\"163\":1}}],[\"are\",{\"1\":{\"146\":1,\"163\":2}}],[\"architecture\",{\"1\":{\"120\":1}}],[\"args\",{\"1\":{\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":3,\"113\":3,\"174\":1,\"175\":1,\"176\":1,\"179\":2,\"180\":2,\"193\":1,\"196\":1,\"197\":1,\"199\":3}}],[\"amd64\",{\"1\":{\"123\":2,\"127\":2}}],[\"america\",{\"1\":{\"97\":1}}],[\"americasofafactory\",{\"1\":{\"100\":1}}],[\"americasofa\",{\"1\":{\"97\":2,\"100\":1}}],[\"americasofa类实现了抽象产品类\",{\"1\":{\"97\":1}}],[\"amount<1000\",{\"1\":{\"92\":1}}],[\"amount\",{\"1\":{\"92\":12}}],[\"apple\",{\"1\":{\"174\":8}}],[\"append\",{\"1\":{\"87\":1}}],[\"apistatinterceptor\",{\"1\":{\"154\":2}}],[\"api\",{\"1\":{\"137\":4,\"141\":1}}],[\"aproval\",{\"1\":{\"92\":7}}],[\"attrs\",{\"0\":{\"23\":1}}],[\"a\",{\"1\":{\"19\":1,\"124\":1,\"130\":2,\"135\":1,\"163\":5,\"190\":2,\"199\":8}}],[\"circle=new\",{\"1\":{\"180\":1}}],[\"circle\",{\"1\":{\"180\":6}}],[\"c661e8050434\",{\"1\":{\"167\":1}}],[\"csdn\",{\"1\":{\"167\":1}}],[\"critical\",{\"1\":{\"162\":1,\"163\":2}}],[\"createhttpserver\",{\"1\":{\"154\":1}}],[\"create\",{\"1\":{\"113\":1}}],[\"createsofa\",{\"1\":{\"97\":1,\"100\":4}}],[\"createcoffee\",{\"1\":{\"97\":1}}],[\"caught\",{\"1\":{\"199\":4}}],[\"caused\",{\"1\":{\"166\":1}}],[\"cat\",{\"1\":{\"185\":6}}],[\"catch语句中使用\",{\"1\":{\"198\":1}}],[\"catch语句对可能发生异常的代码块进行了包裹\",{\"1\":{\"193\":1}}],[\"catch块可以捕获多个异常类型\",{\"1\":{\"193\":1}}],[\"catch块用于捕获并处理指定类型的异常\",{\"1\":{\"193\":1}}],[\"catch块\",{\"1\":{\"193\":1}}],[\"catch\",{\"1\":{\"87\":7,\"193\":4,\"198\":1,\"199\":2}}],[\"calculate\",{\"1\":{\"146\":5}}],[\"currenttimemillis\",{\"1\":{\"154\":2}}],[\"currently\",{\"1\":{\"124\":1}}],[\"curl\",{\"1\":{\"126\":1,\"127\":1}}],[\"cycles\",{\"1\":{\"124\":1,\"135\":1}}],[\"cd\",{\"1\":{\"123\":1}}],[\"cglib无法从代理对象中调用自身的方法\",{\"1\":{\"113\":1}}],[\"cglib无法代理final方法和final类\",{\"1\":{\"113\":1}}],[\"cglib能够代理普通类和接口类\",{\"1\":{\"113\":1}}],[\"cglib动态代理需要引入额外的库\",{\"1\":{\"113\":1}}],[\"cglib动态代理的缺点\",{\"1\":{\"113\":1}}],[\"cglib动态代理的优点\",{\"1\":{\"113\":1}}],[\"cglib动态代理可以代理没有实现任何接口的类\",{\"1\":{\"113\":1}}],[\"cglib动态代理通常能够提供更好的性能\",{\"1\":{\"113\":1}}],[\"cglib可以代理非接口类型的类\",{\"1\":{\"113\":1}}],[\"cglib\",{\"1\":{\"113\":1}}],[\"cglibproxyfactory\",{\"1\":{\"113\":3}}],[\"cglib代码模式需要实现methodinterceptor\",{\"1\":{\"113\":1}}],[\"cglib代码\",{\"0\":{\"113\":1}}],[\"cn\",{\"1\":{\"97\":2}}],[\"checked异常需要在代码中进行处理或声明\",{\"1\":{\"193\":1}}],[\"checked异常和unchecked异常\",{\"1\":{\"193\":1}}],[\"checked\",{\"1\":{\"193\":1}}],[\"character\",{\"1\":{\"184\":1}}],[\"char\",{\"1\":{\"184\":1,\"190\":1,\"191\":2,\"192\":1}}],[\"charlie\",{\"1\":{\"175\":3,\"176\":5}}],[\"chain\",{\"1\":{\"92\":2}}],[\"chu\",{\"1\":{\"167\":1}}],[\"china\",{\"1\":{\"97\":2,\"100\":1,\"103\":3}}],[\"chinesetable\",{\"1\":{\"102\":1,\"103\":3}}],[\"chinesesofafactory\",{\"1\":{\"99\":1,\"100\":2}}],[\"chinesesofa\",{\"1\":{\"97\":2,\"100\":1,\"103\":1}}],[\"chinesesofa类实现了抽象产品类\",{\"1\":{\"97\":1}}],[\"chinese\",{\"1\":{\"96\":1,\"99\":1}}],[\"cfo审批通过\",{\"1\":{\"92\":2}}],[\"cfo\",{\"1\":{\"92\":5}}],[\"cfo继承了aproval\",{\"1\":{\"92\":1}}],[\"cfo三个角色\",{\"1\":{\"92\":1}}],[\"ctorinstance\",{\"1\":{\"75\":1}}],[\"clear\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"client的数据\",{\"1\":{\"157\":1}}],[\"client\",{\"1\":{\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":1,\"119\":1}}],[\"class\",{\"1\":{\"74\":1,\"75\":2,\"76\":2,\"78\":1,\"79\":1,\"82\":3,\"87\":4,\"92\":5,\"97\":5,\"100\":3,\"103\":4,\"106\":3,\"110\":3,\"112\":2,\"113\":2,\"153\":1,\"154\":2,\"166\":2,\"174\":1,\"175\":1,\"176\":1,\"179\":5,\"180\":5,\"185\":3,\"193\":1,\"196\":5,\"197\":2,\"199\":3}}],[\"close\",{\"1\":{\"87\":9}}],[\"closed\",{\"1\":{\"70\":1}}],[\"cloud\",{\"0\":{\"0\":1}}],[\"core\",{\"1\":{\"154\":2}}],[\"core包是指标的关键包\",{\"1\":{\"154\":1}}],[\"core<\",{\"1\":{\"154\":1}}],[\"count作为后缀\",{\"1\":{\"134\":1}}],[\"counter类型的http\",{\"1\":{\"154\":1}}],[\"counter类型的指标和计数器一样\",{\"1\":{\"132\":1}}],[\"counter\",{\"0\":{\"132\":1},\"1\":{\"124\":1,\"130\":2,\"131\":3,\"154\":10}}],[\"count\",{\"1\":{\"124\":1,\"134\":1,\"135\":1,\"141\":1,\"146\":4,\"153\":2,\"154\":26,\"156\":2}}],[\"collect\",{\"1\":{\"163\":1}}],[\"collection的手写实现两个维度来讲解常见的集合类的具体实现\",{\"1\":{\"177\":1}}],[\"collection的实现还是经常被问到\",{\"1\":{\"177\":1}}],[\"collection概述\",{\"0\":{\"173\":1}}],[\"collection\",{\"1\":{\"124\":1,\"135\":1,\"173\":5,\"174\":1,\"175\":2}}],[\"color\",{\"1\":{\"28\":1,\"180\":6}}],[\"code的的请求总数\",{\"1\":{\"146\":1}}],[\"code=\",{\"1\":{\"130\":6,\"131\":1,\"145\":10,\"146\":1,\"148\":5}}],[\"code\",{\"1\":{\"87\":1,\"113\":1,\"130\":1,\"145\":9,\"146\":2,\"172\":2}}],[\"containskey\",{\"1\":{\"176\":3}}],[\"containsbob\",{\"1\":{\"175\":2}}],[\"contains\",{\"1\":{\"174\":3,\"175\":3,\"176\":2}}],[\"containsapple\",{\"1\":{\"174\":2}}],[\"controller\",{\"1\":{\"153\":1}}],[\"content\",{\"1\":{\"87\":7}}],[\"configs是配置采集任务的\",{\"1\":{\"124\":1}}],[\"configs\",{\"1\":{\"124\":3,\"125\":3,\"155\":2,\"162\":1,\"163\":1,\"164\":1}}],[\"configuration\",{\"1\":{\"124\":1,\"154\":1,\"166\":1}}],[\"config\",{\"1\":{\"124\":1,\"162\":1,\"166\":1}}],[\"consul\",{\"1\":{\"118\":1,\"124\":1}}],[\"const\",{\"1\":{\"19\":1}}],[\"concrete\",{\"1\":{\"105\":2}}],[\"connect\",{\"1\":{\"82\":6}}],[\"commonannotations\",{\"1\":{\"166\":2}}],[\"commonlabels\",{\"1\":{\"166\":2}}],[\"composition\",{\"1\":{\"181\":1}}],[\"componentimpl提供基本的实现方法\",{\"1\":{\"86\":1}}],[\"componentdecoratora\",{\"1\":{\"86\":1}}],[\"componentdecoratorb和componentdecoratora分别对componentimpl进行了增强\",{\"1\":{\"86\":1}}],[\"componentdecoratorb\",{\"1\":{\"86\":1}}],[\"complement\",{\"1\":{\"143\":1}}],[\"compress\",{\"1\":{\"87\":2}}],[\"compressionfilereaderwriter\",{\"1\":{\"87\":3}}],[\"compressionfilereaderwriter是一个装饰器\",{\"1\":{\"87\":1}}],[\"com\",{\"1\":{\"28\":2,\"80\":1,\"87\":3,\"106\":3,\"125\":1,\"127\":2,\"167\":2}}],[\"与java动态代理不同\",{\"1\":{\"113\":1}}],[\"与\",{\"1\":{\"19\":1}}],[\"信息容器\",{\"1\":{\"19\":1}}],[\"virtual\",{\"1\":{\"194\":2}}],[\"victoriametrics\",{\"1\":{\"118\":1}}],[\"victoriametrics系列\",{\"1\":{\"115\":1}}],[\"v2\",{\"1\":{\"191\":2}}],[\"v\",{\"1\":{\"148\":1,\"149\":1}}],[\"v1\",{\"1\":{\"137\":4,\"141\":1,\"191\":2}}],[\"vector\",{\"0\":{\"137\":1,\"138\":1,\"144\":1},\"1\":{\"138\":1,\"144\":2,\"146\":2,\"148\":1,\"149\":1,\"150\":1}}],[\"version\",{\"1\":{\"166\":2}}],[\"version=\",{\"1\":{\"124\":1}}],[\"version>\",{\"1\":{\"113\":1,\"153\":1,\"154\":3}}],[\"version>3\",{\"1\":{\"113\":1}}],[\"val\",{\"1\":{\"192\":2}}],[\"values\",{\"1\":{\"146\":2}}],[\"value1\",{\"1\":{\"137\":1}}],[\"value2\",{\"1\":{\"137\":1}}],[\"value\",{\"1\":{\"130\":3,\"137\":5,\"146\":3,\"173\":1,\"176\":1,\"191\":4,\"192\":3,\"199\":1}}],[\"value键值对\",{\"1\":{\"117\":1}}],[\"variance\",{\"1\":{\"146\":1}}],[\"variable\",{\"1\":{\"19\":1}}],[\"void\",{\"1\":{\"82\":5,\"87\":5,\"92\":6,\"97\":2,\"100\":1,\"103\":2,\"106\":7,\"110\":5,\"112\":2,\"113\":2,\"154\":3,\"174\":1,\"175\":1,\"176\":1,\"179\":6,\"180\":7,\"185\":3,\"193\":1,\"196\":6,\"197\":6,\"198\":1,\"199\":3}}],[\"volatile\",{\"1\":{\"75\":1}}],[\"vue\",{\"0\":{\"38\":1}}],[\"vuepress\",{\"0\":{\"17\":1},\"1\":{\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"18\":1,\"44\":1}}],[\"mutable\",{\"1\":{\"182\":1}}],[\"multiplication\",{\"1\":{\"141\":1}}],[\"micrometer<\",{\"1\":{\"153\":1}}],[\"minutes\",{\"1\":{\"163\":1}}],[\"minimum\",{\"1\":{\"146\":1}}],[\"min\",{\"1\":{\"146\":1}}],[\"mister\",{\"1\":{\"28\":2}}],[\"modelandview\",{\"1\":{\"154\":3}}],[\"modifiers\",{\"0\":{\"145\":1}}],[\"modulo\",{\"1\":{\"141\":1}}],[\"more\",{\"1\":{\"42\":1,\"163\":3}}],[\"m\",{\"1\":{\"138\":2}}],[\"mymethod\",{\"1\":{\"199\":6}}],[\"myjob\",{\"1\":{\"171\":9}}],[\"my\",{\"1\":{\"124\":1}}],[\"mysql等\",{\"1\":{\"119\":1}}],[\"mcclient\",{\"1\":{\"82\":1}}],[\"meow\",{\"1\":{\"185\":2}}],[\"memstats\",{\"1\":{\"124\":9}}],[\"memory=allocate\",{\"1\":{\"75\":1}}],[\"metric\",{\"1\":{\"130\":1,\"137\":1,\"171\":2}}],[\"metrics|\",{\"1\":{\"137\":2}}],[\"metrics接口耗时\",{\"1\":{\"134\":1}}],[\"metrics接口来获取自身的数据\",{\"1\":{\"130\":1}}],[\"metrics接口暴露\",{\"1\":{\"130\":1}}],[\"metrics\",{\"1\":{\"124\":1,\"125\":1,\"130\":9,\"131\":1,\"134\":12,\"137\":6,\"138\":1,\"141\":5,\"146\":1,\"148\":5,\"150\":13,\"154\":11,\"164\":1,\"172\":2}}],[\"method=\",{\"1\":{\"145\":14,\"153\":3}}],[\"methodproxy\",{\"1\":{\"113\":2}}],[\"methodinterceptor\",{\"1\":{\"113\":1}}],[\"method\",{\"1\":{\"98\":1,\"112\":5,\"113\":3,\"145\":12}}],[\"mermaid\",{\"0\":{\"32\":1}}],[\"ms\",{\"1\":{\"43\":1}}],[\"mr\",{\"1\":{\"28\":1,\"36\":1}}],[\"md\",{\"1\":{\"18\":1}}],[\"map接口\",{\"0\":{\"176\":1}}],[\"map\",{\"1\":{\"173\":1,\"176\":10}}],[\"map等\",{\"1\":{\"173\":1}}],[\"map<string\",{\"1\":{\"166\":5,\"176\":1}}],[\"maximum\",{\"1\":{\"146\":1}}],[\"max\",{\"1\":{\"146\":1,\"153\":4,\"166\":1}}],[\"mango\",{\"1\":{\"174\":4}}],[\"management\",{\"1\":{\"153\":1}}],[\"manager\",{\"1\":{\"92\":6}}],[\"manager继承了aproval\",{\"1\":{\"92\":1}}],[\"many的向量匹配\",{\"1\":{\"145\":1}}],[\"many\",{\"1\":{\"144\":1,\"166\":1}}],[\"math\",{\"1\":{\"180\":1}}],[\"match\",{\"1\":{\"162\":2,\"163\":4}}],[\"matches\",{\"1\":{\"144\":2}}],[\"matching\",{\"0\":{\"144\":1},\"1\":{\"144\":1}}],[\"matter\",{\"1\":{\"1\":1,\"2\":1}}],[\"machine\",{\"1\":{\"194\":2}}],[\"mac的版本\",{\"1\":{\"123\":1}}],[\"mac连接typec\",{\"1\":{\"82\":1}}],[\"makesound\",{\"1\":{\"180\":5,\"185\":9}}],[\"makesofa\",{\"1\":{\"103\":3}}],[\"maketable\",{\"1\":{\"103\":3}}],[\"main\",{\"1\":{\"80\":2,\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":1,\"174\":1,\"175\":1,\"176\":1,\"179\":2,\"180\":2,\"193\":1,\"196\":1,\"197\":1,\"199\":3}}],[\"markdown\",{\"0\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1},\"1\":{\"5\":1,\"13\":2,\"14\":3,\"15\":1,\"16\":3,\"17\":2,\"18\":1,\"19\":1,\"34\":1,\"43\":1,\"44\":2},\"2\":{\"41\":1}}],[\"主题实现类\",{\"1\":{\"109\":1,\"110\":1}}],[\"主题和观察者之间松耦合\",{\"1\":{\"107\":1}}],[\"主题包含了一个自定义徽章可以使用\",{\"1\":{\"44\":1}}],[\"主题扩展了更多\",{\"1\":{\"18\":1}}],[\"主题扩展\",{\"0\":{\"18\":1}}],[\"主要原因\",{\"1\":{\"88\":1}}],[\"主要从\",{\"1\":{\"13\":1}}],[\"主要功能与配置演示\",{\"0\":{\"4\":1}}],[\"请看下面的示例代码\",{\"1\":{\"199\":1}}],[\"请求状态码\",{\"1\":{\"154\":2}}],[\"请求路径\",{\"1\":{\"154\":2}}],[\"请求的最大耗时\",{\"1\":{\"153\":1}}],[\"请求的总耗时\",{\"1\":{\"153\":1}}],[\"请求的总次数\",{\"1\":{\"153\":1}}],[\"请求都是在100ms以内\",{\"1\":{\"134\":1}}],[\"请使用绝对链接\",{\"1\":{\"44\":1}}],[\"请阅读\",{\"1\":{\"17\":1}}],[\"请先阅读\",{\"1\":{\"14\":1}}],[\"语法\",{\"0\":{\"33\":1},\"1\":{\"18\":1}}],[\"语法进行了扩展\",{\"1\":{\"17\":1}}],[\"语法扩展\",{\"1\":{\"16\":1}}],[\"对异常进行合适的处理\",{\"1\":{\"193\":1}}],[\"对称性\",{\"1\":{\"191\":1}}],[\"对字符串进行操作时不需要创建新的对象\",{\"1\":{\"182\":1}}],[\"对性能会有一定的影响\",{\"1\":{\"182\":1}}],[\"对象中重写的\",{\"1\":{\"185\":1}}],[\"对象\",{\"1\":{\"174\":1,\"175\":2,\"176\":1,\"185\":2}}],[\"对象之间通过消息传递来进行通信和协作\",{\"1\":{\"183\":1}}],[\"对象之间关系也比较清晰\",{\"1\":{\"107\":1}}],[\"对象之间尽量少了解\",{\"1\":{\"70\":1}}],[\"对meric使用了rate操作将metric原来的名称去掉\",{\"1\":{\"171\":1}}],[\"对应的java实体如下\",{\"1\":{\"166\":1}}],[\"对处理者来说是一个灾难\",{\"1\":{\"159\":1}}],[\"对照分析\",{\"1\":{\"121\":1}}],[\"对监控指标进行长期趋势分析\",{\"1\":{\"121\":1}}],[\"对final方法和final类的限制\",{\"1\":{\"113\":1}}],[\"对原有功能的做扩展或者增强\",{\"1\":{\"108\":1}}],[\"对一些基础类无法修改\",{\"1\":{\"88\":1}}],[\"对读取的字符进行先解压再解密\",{\"1\":{\"87\":1}}],[\"对读取的字符进行解压\",{\"1\":{\"87\":2}}],[\"对读取的字符进行解密\",{\"1\":{\"87\":2}}],[\"对它进行功能的增强\",{\"1\":{\"87\":2}}],[\"对写入的字符进行先加密再压缩\",{\"1\":{\"87\":1}}],[\"对写入的字符进行压缩\",{\"1\":{\"87\":1}}],[\"对写入的字符进行加密\",{\"1\":{\"87\":1}}],[\"对写入字符进行压缩\",{\"1\":{\"87\":1}}],[\"对写入文件的字符的加密\",{\"1\":{\"87\":1}}],[\"对于被final修饰的局部变量\",{\"1\":{\"196\":1}}],[\"对于实例变量\",{\"1\":{\"196\":1}}],[\"对于任何非null的引用值x和y\",{\"1\":{\"191\":2}}],[\"对于任何非null的引用值x\",{\"1\":{\"191\":3}}],[\"对于基本数据类型的变量\",{\"1\":{\"190\":1}}],[\"对于包装类\",{\"1\":{\"184\":1}}],[\"对于请求数量在5分钟的时间窗口内\",{\"1\":{\"148\":1}}],[\"对于分位数的计算而言\",{\"1\":{\"135\":1}}],[\"对于标签值无约束\",{\"1\":{\"130\":1}}],[\"对于需要代理的类数量较多或变化频繁的情况下\",{\"1\":{\"109\":1}}],[\"对于修改是封闭的\",{\"1\":{\"70\":1}}],[\"对于扩展是开放的\",{\"1\":{\"70\":1}}],[\"对于\",{\"1\":{\"44\":1}}],[\"对\",{\"1\":{\"17\":1}}],[\"为例\",{\"1\":{\"190\":1}}],[\"为什么会这样呢\",{\"1\":{\"197\":1}}],[\"为什么会有人把equals方法当做是比较两个内容的比较呢\",{\"1\":{\"191\":1}}],[\"为什么内部类引用的外部变量必须用final修饰\",{\"0\":{\"197\":1}}],[\"为什么java不支持多继承\",{\"0\":{\"181\":1}}],[\"为什么要使用观察者模式\",{\"0\":{\"107\":1}}],[\"为什么要使用责任链模式\",{\"0\":{\"93\":1}}],[\"为什么要使用装饰器模式\",{\"0\":{\"88\":1},\"1\":{\"88\":1}}],[\"为了保持一致性\",{\"1\":{\"192\":1}}],[\"为了解决该问题\",{\"1\":{\"148\":1}}],[\"为了丰富文档写作\",{\"1\":{\"17\":1}}],[\"为目标对象生成代理对象\",{\"1\":{\"113\":1}}],[\"为每个\",{\"1\":{\"15\":1}}],[\"插件来实现\",{\"1\":{\"16\":1}}],[\"扩展\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"17\":1}}],[\"中是否包含某个键\",{\"1\":{\"176\":1}}],[\"中\",{\"1\":{\"176\":1,\"185\":1}}],[\"中间件有着广泛的应用\",{\"1\":{\"109\":1}}],[\"中介者对象封装了一组对象之间的交互\",{\"1\":{\"68\":1}}],[\"中介者模式\",{\"1\":{\"68\":1}}],[\"中使用\",{\"1\":{\"19\":1}}],[\"中的对象\",{\"1\":{\"189\":1}}],[\"中的多态\",{\"1\":{\"185\":1}}],[\"中的键值对\",{\"1\":{\"176\":1}}],[\"中的键值对没有固定的顺序\",{\"1\":{\"176\":1}}],[\"中的键是唯一的\",{\"1\":{\"176\":1}}],[\"中的元素是唯一的\",{\"1\":{\"175\":1}}],[\"中的元素没有固定的顺序\",{\"1\":{\"175\":2}}],[\"中的元素按照插入的顺序进行存储\",{\"1\":{\"174\":1}}],[\"中的创建对象的方法\",{\"1\":{\"103\":1}}],[\"中的\",{\"1\":{\"17\":1}}],[\"中很重要的一个概念\",{\"1\":{\"15\":1}}],[\"中设置页面信息\",{\"1\":{\"43\":1}}],[\"中设置\",{\"1\":{\"1\":1,\"2\":1}}],[\"是终止java虚拟机jvm的\",{\"1\":{\"199\":1}}],[\"是不可以被更改的\",{\"1\":{\"197\":1}}],[\"是不能改变原有的基础功能\",{\"1\":{\"86\":1}}],[\"是在目标机器上运行java应用程序所需的最小环境\",{\"1\":{\"194\":1}}],[\"是java平台的核心部分\",{\"1\":{\"194\":1}}],[\"是java虚拟机\",{\"1\":{\"194\":1}}],[\"是java运行时环境\",{\"1\":{\"194\":1}}],[\"是java开发工具包\",{\"1\":{\"194\":1}}],[\"是java语言中的两个重要概念\",{\"1\":{\"179\":1}}],[\"是程序的稳定性和健壮性的一种保护机制\",{\"1\":{\"193\":1}}],[\"是因为在string\",{\"1\":{\"191\":1}}],[\"是比较对象的内容\",{\"1\":{\"191\":1}}],[\"是两种不同的编程范式\",{\"1\":{\"183\":1}}],[\"是其子类\",{\"1\":{\"180\":1}}],[\"是应用于指标的操作函数列表\",{\"1\":{\"171\":1}}],[\"是和预聚合前的名称保存一致\",{\"1\":{\"171\":1}}],[\"是单调递增的\",{\"1\":{\"132\":1}}],[\"是全局配置默认采集时间间隔\",{\"1\":{\"124\":1}}],[\"是用来开发应用指标的工具包\",{\"1\":{\"119\":1}}],[\"是一个强大的高性能的代码生成库\",{\"1\":{\"113\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"104\":1}}],[\"是一种创建型设计模式\",{\"1\":{\"98\":1,\"101\":1}}],[\"是会经常使用到的一个设计模式\",{\"1\":{\"90\":1}}],[\"是为了保持简单性\",{\"1\":{\"83\":1}}],[\"是作为适配的中间类\",{\"1\":{\"81\":1}}],[\"是\",{\"1\":{\"15\":1,\"173\":1}}],[\"配置讲解\",{\"0\":{\"163\":1}}],[\"配置文件中包含了4个部分\",{\"1\":{\"162\":1}}],[\"配置和启动alertmanager\",{\"1\":{\"157\":1}}],[\"配置请求的p95耗时\",{\"1\":{\"156\":1}}],[\"配置的表达式如下\",{\"1\":{\"156\":2}}],[\"配置grafana视图\",{\"0\":{\"156\":1}}],[\"配置完成后\",{\"1\":{\"155\":1}}],[\"配置完成后保存\",{\"1\":{\"127\":1}}],[\"配置如下\",{\"1\":{\"155\":1}}],[\"配置prometheus采集\",{\"0\":{\"155\":1}}],[\"配置prometheus采集node\",{\"1\":{\"122\":1}}],[\"配置界面的路径和配置如下\",{\"1\":{\"127\":1}}],[\"配置信息如下\",{\"1\":{\"125\":1}}],[\"配置\",{\"0\":{\"15\":1},\"1\":{\"163\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"1\":1,\"2\":1}}],[\"演示了try\",{\"1\":{\"193\":1}}],[\"演示如何使用\",{\"1\":{\"175\":1}}],[\"演示\",{\"1\":{\"14\":1}}],[\"和java类库\",{\"1\":{\"194\":1}}],[\"和hashcode的关系\",{\"0\":{\"192\":1}}],[\"和handler不为\",{\"1\":{\"137\":1}}],[\"和handler为\",{\"1\":{\"137\":1}}],[\"和它的两个子类\",{\"1\":{\"185\":1}}],[\"和行为\",{\"1\":{\"183\":1}}],[\"和面向对象\",{\"1\":{\"183\":1}}],[\"和静态方法\",{\"1\":{\"180\":1}}],[\"和静态代理类似\",{\"1\":{\"112\":1}}],[\"和抽象方法\",{\"1\":{\"180\":1}}],[\"和私有方法\",{\"1\":{\"180\":1}}],[\"和重写\",{\"1\":{\"179\":1}}],[\"和alert\",{\"1\":{\"169\":1}}],[\"和status\",{\"1\":{\"154\":2}}],[\"和many\",{\"1\":{\"144\":1}}],[\"和maketable\",{\"1\":{\"103\":1}}],[\"和值的总和\",{\"1\":{\"134\":1}}],[\"和直方图类似\",{\"1\":{\"131\":1}}],[\"和一个具体方法showname\",{\"1\":{\"97\":1}}],[\"和持有一个aproval对象\",{\"1\":{\"92\":1}}],[\"和双重检查模式一样\",{\"1\":{\"76\":1}}],[\"和\",{\"0\":{\"189\":1},\"1\":{\"14\":1,\"43\":1,\"173\":5,\"176\":1,\"185\":4,\"189\":1,\"190\":2}}],[\"介绍\",{\"0\":{\"14\":1,\"57\":1,\"61\":1},\"1\":{\"14\":1,\"15\":1}}],[\"文章标题列表\",{\"1\":{\"45\":1}}],[\"文章加密\",{\"2\":{\"12\":1}}],[\"文件系统里剩余的磁盘字节数\",{\"1\":{\"125\":1}}],[\"文件夹的图片\",{\"1\":{\"44\":1}}],[\"文件放置在一起\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"13\":1}}],[\"文件生成页面\",{\"1\":{\"13\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"44\":1}}],[\"文字\",{\"1\":{\"10\":2}}],[\"文字段落\",{\"1\":{\"10\":24}}],[\"2^7\",{\"1\":{\"190\":2}}],[\"23\",{\"1\":{\"180\":1}}],[\"230\",{\"1\":{\"28\":1}}],[\"24\",{\"1\":{\"145\":3,\"149\":1}}],[\"296\",{\"1\":{\"135\":1}}],[\"2s\",{\"1\":{\"134\":1}}],[\"21\",{\"1\":{\"124\":1,\"145\":2}}],[\"25\",{\"1\":{\"124\":1,\"135\":1,\"154\":1}}],[\"253\",{\"1\":{\"28\":1}}],[\"20\",{\"1\":{\"134\":1,\"150\":1}}],[\"20ms的请求又多少个\",{\"1\":{\"134\":1}}],[\"200\",{\"1\":{\"130\":9,\"131\":1,\"146\":1,\"148\":5,\"153\":3}}],[\"2017年底发布了基于全新存储层的2\",{\"1\":{\"117\":1}}],[\"2016年5月继kubernetes之后成为第二个正式加入cncf\",{\"1\":{\"117\":1}}],[\"20230830224136440\",{\"1\":{\"115\":1}}],[\"20231023210926364\",{\"1\":{\"172\":1}}],[\"20231021174948512\",{\"1\":{\"165\":1}}],[\"20231021174854220\",{\"1\":{\"164\":1}}],[\"20231021174512876\",{\"1\":{\"164\":1}}],[\"20231021170507878\",{\"1\":{\"157\":1}}],[\"20231021115611700\",{\"1\":{\"156\":1}}],[\"20231021115719027\",{\"1\":{\"156\":1}}],[\"20231014211256244\",{\"1\":{\"138\":1}}],[\"20231014210912914\",{\"1\":{\"137\":1}}],[\"20231014210829763\",{\"1\":{\"137\":1}}],[\"20231012215203283\",{\"1\":{\"130\":1}}],[\"20231010201727866\",{\"1\":{\"127\":1}}],[\"20231009220040376\",{\"1\":{\"127\":1}}],[\"20231008231356066\",{\"1\":{\"125\":1}}],[\"20231008084050835\",{\"1\":{\"123\":1}}],[\"20231008083006727\",{\"1\":{\"123\":1}}],[\"20231030213851667\",{\"1\":{\"73\":1}}],[\"20231107230028268\",{\"1\":{\"105\":1}}],[\"20231105210628018\",{\"1\":{\"99\":1}}],[\"20231102232111957\",{\"1\":{\"86\":1}}],[\"20231112200737983\",{\"1\":{\"65\":1}}],[\"2020\",{\"1\":{\"43\":1}}],[\"2和3可能会发生重排序\",{\"1\":{\"75\":1}}],[\"2\",{\"1\":{\"10\":14,\"26\":1,\"75\":1,\"82\":1,\"113\":1,\"123\":2,\"124\":1,\"134\":2,\"150\":1,\"154\":4,\"174\":1,\"190\":2,\"196\":2,\"199\":3}}],[\"1m\",{\"1\":{\"150\":2,\"156\":2,\"164\":2,\"169\":1,\"172\":2}}],[\"175\",{\"1\":{\"145\":1}}],[\"171390910999984\",{\"1\":{\"134\":1}}],[\"1d\",{\"1\":{\"139\":1}}],[\"128\",{\"1\":{\"190\":1}}],[\"127\",{\"1\":{\"153\":3,\"154\":1,\"162\":1,\"163\":1,\"164\":3}}],[\"1255515\",{\"1\":{\"135\":1}}],[\"120665690\",{\"1\":{\"167\":1}}],[\"120\",{\"1\":{\"134\":1,\"145\":4,\"150\":1}}],[\"1205\",{\"1\":{\"130\":3,\"131\":1}}],[\"1s\",{\"1\":{\"134\":1}}],[\"1831\",{\"1\":{\"134\":7}}],[\"1830\",{\"1\":{\"134\":1}}],[\"1829\",{\"1\":{\"134\":1}}],[\"1828\",{\"1\":{\"134\":1}}],[\"1827\",{\"1\":{\"134\":1}}],[\"1h\",{\"1\":{\"133\":1,\"162\":1,\"163\":1}}],[\"11\",{\"1\":{\"153\":1}}],[\"1186\",{\"1\":{\"130\":2}}],[\"1194\",{\"1\":{\"130\":2}}],[\"1696984033\",{\"1\":{\"130\":2}}],[\"1696984153\",{\"1\":{\"130\":2}}],[\"1696984318\",{\"1\":{\"130\":2}}],[\"10s\",{\"1\":{\"163\":1}}],[\"10ms\",{\"1\":{\"134\":1}}],[\"10ms的请求有多少个\",{\"1\":{\"134\":1}}],[\"10\",{\"1\":{\"127\":2,\"154\":1,\"184\":1,\"193\":1,\"199\":2}}],[\"10000\",{\"1\":{\"92\":1}}],[\"1363728e+07\",{\"1\":{\"124\":1}}],[\"138\",{\"1\":{\"28\":1}}],[\"15s\",{\"1\":{\"124\":2}}],[\"15\",{\"1\":{\"28\":1,\"134\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"1\",{\"1\":{\"10\":12,\"19\":1,\"24\":1,\"26\":1,\"43\":2,\"75\":1,\"82\":1,\"87\":3,\"123\":2,\"124\":4,\"127\":2,\"134\":3,\"135\":1,\"146\":2,\"150\":2,\"153\":3,\"154\":4,\"162\":1,\"163\":1,\"164\":4,\"174\":1,\"190\":3,\"196\":2,\"199\":2}}],[\"段落\",{\"1\":{\"10\":2}}],[\"页脚\",{\"1\":{\"7\":1,\"45\":1}}],[\"页面的导入路径如下\",{\"1\":{\"127\":1}}],[\"页面结构\",{\"0\":{\"45\":1}}],[\"页面内容\",{\"0\":{\"44\":1}}],[\"页面配置\",{\"0\":{\"42\":1},\"1\":{\"43\":1},\"2\":{\"47\":1}}],[\"页面引入配置\",{\"1\":{\"15\":1}}],[\"页面信息\",{\"0\":{\"43\":1},\"1\":{\"7\":1}}],[\"页面展示如下\",{\"1\":{\"123\":1}}],[\"页面展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"链接\",{\"1\":{\"7\":1,\"19\":1}}],[\"贡献者\",{\"1\":{\"7\":1,\"45\":1}}],[\"侧边栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"展示prometheus数据\",{\"1\":{\"127\":1}}],[\"展示\",{\"0\":{\"13\":1},\"1\":{\"5\":1,\"34\":1}}],[\"项目主页配置\",{\"1\":{\"1\":1,\"2\":1}}],[\"你需要阅读\",{\"1\":{\"15\":1}}],[\"你需要在页面\",{\"1\":{\"1\":1,\"2\":1}}],[\"你应该创建和编写\",{\"1\":{\"13\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"45\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"7\":1}}],[\"你可以将图片和\",{\"1\":{\"44\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"44\":1}}],[\"你可以在\",{\"1\":{\"43\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"1\":1,\"2\":1}}],[\"你可以标记\",{\"1\":{\"25\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"13\":1}}],[\"想要使用此布局\",{\"1\":{\"1\":1,\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
