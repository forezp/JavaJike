const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":439,\"nextId\":439,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#更新计划\",\"2\":\"v-8daa1a0e#更新计划-1\",\"3\":\"v-2e3eac9e\",\"4\":\"v-71b3ae87\",\"5\":\"v-71b3ae87#功能亮点\",\"6\":\"v-71b3ae87#bar\",\"7\":\"v-71b3ae87#foo\",\"8\":\"v-9cffac66\",\"9\":\"v-9cffac66#设计模式有哪些类型\",\"10\":\"v-9cffac66#创建型模式\",\"11\":\"v-9cffac66#结构型模式\",\"12\":\"v-9cffac66#行为型模式\",\"13\":\"v-9cffac66#面试过程中常问的设计模式\",\"14\":\"v-9cffac66#设计模式的几种原则\",\"15\":\"v-1110218a\",\"16\":\"v-1110218a#什么是单例模式\",\"17\":\"v-1110218a#单例模式的实现\",\"18\":\"v-1110218a#饿汉模式-线程安全-推荐\",\"19\":\"v-1110218a#双重检查-线程安全-推荐\",\"20\":\"v-1110218a#使用内部类模式-线程安全-推荐\",\"21\":\"v-1110218a#其他\",\"22\":\"v-1110218a#懒汉模式-线程不安全-不推荐\",\"23\":\"v-1110218a#懒汉模式-线程不安全-不推荐-1\",\"24\":\"v-1110218a#源码下载\",\"25\":\"v-3be12559\",\"26\":\"v-3be12559#代码实现\",\"27\":\"v-3be12559#使用适配器模式有什么收益\",\"28\":\"v-3be12559#源码下载\",\"29\":\"v-4b45c2fc\",\"30\":\"v-4b45c2fc#uml图\",\"31\":\"v-4b45c2fc#使用案例\",\"32\":\"v-4b45c2fc#为什么要使用装饰器模式\",\"33\":\"v-4b45c2fc#源码下载\",\"34\":\"v-7f97107a\",\"35\":\"v-7f97107a#责任链模式的uml图\",\"36\":\"v-7f97107a#案例实战\",\"37\":\"v-7f97107a#为什么要使用责任链模式\",\"38\":\"v-9b0dc620\",\"39\":\"v-9b0dc620#简单工厂\",\"40\":\"v-9b0dc620#uml图\",\"41\":\"v-9b0dc620#代码实现\",\"42\":\"v-9b0dc620#工厂方法模式\",\"43\":\"v-9b0dc620#uml图-1\",\"44\":\"v-9b0dc620#代码实现-1\",\"45\":\"v-9b0dc620#抽象工厂\",\"46\":\"v-9b0dc620#uml图-2\",\"47\":\"v-9b0dc620#代码实现-2\",\"48\":\"v-63d3fd84\",\"49\":\"v-63d3fd84#观察者模式uml图\",\"50\":\"v-63d3fd84#案例实战\",\"51\":\"v-63d3fd84#为什么要使用观察者模式\",\"52\":\"v-a950132e\",\"53\":\"v-a950132e#静态代理\",\"54\":\"v-a950132e#代码实现\",\"55\":\"v-a950132e#动态代理\",\"56\":\"v-a950132e#java-动态代理\",\"57\":\"v-a950132e#cglib代码\",\"58\":\"v-7e340ee0\",\"59\":\"v-7e340ee0#prometheus教程介绍\",\"60\":\"v-69099ac7\",\"61\":\"v-69099ac7#什么是prometheus\",\"62\":\"v-69099ac7#prometheus提供的特性\",\"63\":\"v-69099ac7#组件\",\"64\":\"v-69099ac7#架构\",\"65\":\"v-69099ac7#prometheus适用的场景\",\"66\":\"v-300045a1\",\"67\":\"v-300045a1#安装prometheus\",\"68\":\"v-300045a1#prometheus配置文件讲解\",\"69\":\"v-300045a1#采集node-exporter的指标\",\"70\":\"v-300045a1#prometheus配置文件热更新\",\"71\":\"v-300045a1#grafana安装\",\"72\":\"v-300045a1#总结\",\"73\":\"v-0890d0c6\",\"74\":\"v-0890d0c6#什么是time-series\",\"75\":\"v-0890d0c6#指标的类型\",\"76\":\"v-0890d0c6#counter-累加器\",\"77\":\"v-0890d0c6#gauge仪表盘\",\"78\":\"v-0890d0c6#histogram直方图\",\"79\":\"v-0890d0c6#summary\",\"80\":\"v-40c62e56\",\"81\":\"v-40c62e56#瞬时向量查询-instant-vector-selectors\",\"82\":\"v-40c62e56#范围向量查询-range-vector-selectors\",\"83\":\"v-40c62e56#offset-时间位移操作\",\"84\":\"v-40c62e56#操作符\",\"85\":\"v-40c62e56#数学操作符\",\"86\":\"v-40c62e56#比较操作符\",\"87\":\"v-40c62e56#逻辑运算符\",\"88\":\"v-40c62e56#向量匹配符号-vector-matching\",\"89\":\"v-40c62e56#分组修改器-group-modifiers\",\"90\":\"v-40c62e56#聚合函数\",\"91\":\"v-40c62e56#其他常见的函数\",\"92\":\"v-40c62e56#计算counter的增长率\",\"93\":\"v-40c62e56#预测指标变化趋势\",\"94\":\"v-40c62e56#计算分位数\",\"95\":\"v-40c62e56#总结\",\"96\":\"v-a5f16108\",\"97\":\"v-a5f16108#方案一-使用spring-boot-starter-actuator\",\"98\":\"v-a5f16108#方案二-使用prometheus\",\"99\":\"v-a5f16108#配置prometheus采集\",\"100\":\"v-a5f16108#配置grafana视图\",\"101\":\"v-9930b448\",\"102\":\"v-9930b448#alertmanager介绍\",\"103\":\"v-9930b448#分组\",\"104\":\"v-9930b448#抑制\",\"105\":\"v-9930b448#静默\",\"106\":\"v-9930b448#alertmanager安装\",\"107\":\"v-9930b448#配置讲解\",\"108\":\"v-9930b448#在prometheus中配置告警规则\",\"109\":\"v-9930b448#alertmanager查看告警消息\",\"110\":\"v-9930b448#webhook\",\"111\":\"v-9930b448#参考文档\",\"112\":\"v-012ad836\",\"113\":\"v-012ad836#定义recoding-rules\",\"114\":\"v-012ad836#recording-rule的最佳实践\",\"115\":\"v-012ad836#命名规范\",\"116\":\"v-012ad836#实战\",\"117\":\"v-4271bd10\",\"118\":\"v-4271bd10#为什么会有可见性、原子性、有序性的问题\",\"119\":\"v-4271bd10#缓存导致的可见性问题\",\"120\":\"v-4271bd10#线程切换带来的原子问题\",\"121\":\"v-4271bd10#编译优化带来的有序性问题\",\"122\":\"v-4271bd10#总结\",\"123\":\"v-dfa7306e\",\"124\":\"v-dfa7306e#java内存模型\",\"125\":\"v-dfa7306e#编发编程的概念\",\"126\":\"v-dfa7306e#原子性\",\"127\":\"v-dfa7306e#可见性\",\"128\":\"v-dfa7306e#有序性\",\"129\":\"v-dfa7306e#volatile详解\",\"130\":\"v-dfa7306e#volatile关键字作用\",\"131\":\"v-dfa7306e#volatile能够保证可见性和防止指令重排\",\"132\":\"v-dfa7306e#volatile不能保证原子性\",\"133\":\"v-dfa7306e#volatile的使用场景\",\"134\":\"v-dfa7306e#状态标记\",\"135\":\"v-dfa7306e#防止指令重排\",\"136\":\"v-dfa7306e#happens-before-规则\",\"137\":\"v-dfa7306e#参考资料\",\"138\":\"v-ad9c5168\",\"139\":\"v-ad9c5168#java死锁示例\",\"140\":\"v-ad9c5168#死锁发生的条件\",\"141\":\"v-ad9c5168#如何避免死锁\",\"142\":\"v-ad9c5168#破坏占有且等待\",\"143\":\"v-ad9c5168#破坏循环等待条件\",\"144\":\"v-0c63cbe7\",\"145\":\"v-0c63cbe7#synchronized关键字的作用\",\"146\":\"v-0c63cbe7#使用示例\",\"147\":\"v-0c63cbe7#synchronized原理\",\"148\":\"v-0c63cbe7#synchronized优化\",\"149\":\"v-0c63cbe7#对象头\",\"150\":\"v-0c63cbe7#偏向锁\",\"151\":\"v-0c63cbe7#轻量级锁\",\"152\":\"v-0c63cbe7#重量级锁\",\"153\":\"v-0c63cbe7#synchronized的优化一览表\",\"154\":\"v-218427ee\",\"155\":\"v-218427ee#thread状态\",\"156\":\"v-218427ee#new-新建状态\",\"157\":\"v-218427ee#runnable\",\"158\":\"v-218427ee#blocked\",\"159\":\"v-218427ee#wait\",\"160\":\"v-218427ee#两个线程交替打印奇数和偶数\",\"161\":\"v-2ba52b9a\",\"162\":\"v-2ba52b9a#aqs简介\",\"163\":\"v-2ba52b9a#aqs核心思想\",\"164\":\"v-2ba52b9a#aqs-对资源的共享方式\",\"165\":\"v-2ba52b9a#aqs源码解析\",\"166\":\"v-2ba52b9a#类的继承关系\",\"167\":\"v-2ba52b9a#类的内部类\",\"168\":\"v-2ba52b9a#node类\",\"169\":\"v-2ba52b9a#conditionobject类\",\"170\":\"v-2ba52b9a#类的属性\",\"171\":\"v-2ba52b9a#类的构造函数\",\"172\":\"v-2ba52b9a#类的核心函数\",\"173\":\"v-2ba52b9a#acquire函数\",\"174\":\"v-2ba52b9a#release\",\"175\":\"v-2ba52b9a#手写一个aqs\",\"176\":\"v-2ba52b9a#参考资料\",\"177\":\"v-620122cd\",\"178\":\"v-620122cd#reentrantlock数据结构\",\"179\":\"v-620122cd#reentrantlock类继承关系\",\"180\":\"v-620122cd#类的属性\",\"181\":\"v-620122cd#类的构造函数\",\"182\":\"v-620122cd#类的内部类\",\"183\":\"v-620122cd#sync类\",\"184\":\"v-620122cd#nonfairsync类\",\"185\":\"v-620122cd#fairsyn类\",\"186\":\"v-620122cd#reentrantlock在dubbo中的使用\",\"187\":\"v-620122cd#reentrantlock使用示例\",\"188\":\"v-620122cd#reentrantlock的特点总结\",\"189\":\"v-1ed9a138\",\"190\":\"v-1ed9a138#countdownlatch简介\",\"191\":\"v-1ed9a138#countdownlatch使用示例\",\"192\":\"v-1ed9a138#countdownlatch源码解析\",\"193\":\"v-1ed9a138#countdownlatch数据结构\",\"194\":\"v-1ed9a138#类的继承关系\",\"195\":\"v-1ed9a138#类的属性\",\"196\":\"v-1ed9a138#类的构造函数\",\"197\":\"v-1ed9a138#类的内部类\",\"198\":\"v-1ed9a138#await函数\",\"199\":\"v-1ed9a138#countdown函数\",\"200\":\"v-1ed9a138#参考文档\",\"201\":\"v-6bf87dc7\",\"202\":\"v-6bf87dc7#cyclicbarrier简介\",\"203\":\"v-6bf87dc7#cyclicbarrier使用示例\",\"204\":\"v-6bf87dc7#cyclicbarrier源码解析\",\"205\":\"v-6bf87dc7#cyclicbarrier数据结构\",\"206\":\"v-6bf87dc7#类的继承关系\",\"207\":\"v-6bf87dc7#类的内部类\",\"208\":\"v-6bf87dc7#类的属性\",\"209\":\"v-6bf87dc7#类的构造函数\",\"210\":\"v-6bf87dc7#cyclicbarrier-int-runnable-型构造函数\",\"211\":\"v-6bf87dc7#cyclicbarrier-int-型构造函数\",\"212\":\"v-6bf87dc7#核心函数分析\",\"213\":\"v-6bf87dc7#dowait函数\",\"214\":\"v-6bf87dc7#nextgeneration函数\",\"215\":\"v-6bf87dc7#breakbarrier函数\",\"216\":\"v-6bf87dc7#参考\",\"217\":\"v-6ea84c4f\",\"218\":\"v-6ea84c4f#并发包的锁\",\"219\":\"v-6ea84c4f#reentrantlock\",\"220\":\"v-6ea84c4f#readwritelock\",\"221\":\"v-6ea84c4f#stampedlock\",\"222\":\"v-5c7e9d2b\",\"223\":\"v-5c7e9d2b#list\",\"224\":\"v-5c7e9d2b#map\",\"225\":\"v-5c7e9d2b#set\",\"226\":\"v-5c7e9d2b#queue\",\"227\":\"v-5c7e9d2b#总结\",\"228\":\"v-08dda278\",\"229\":\"v-08dda278#copyonwritearraylist介绍\",\"230\":\"v-08dda278#copyonwritearraylist使用示例\",\"231\":\"v-08dda278#copyonwritearraylist源码解析\",\"232\":\"v-08dda278#类的继承关系\",\"233\":\"v-08dda278#类的属性\",\"234\":\"v-08dda278#类的构造函数\",\"235\":\"v-08dda278#类的内部类\",\"236\":\"v-08dda278#核心函数分析\",\"237\":\"v-08dda278#copyof函数\",\"238\":\"v-08dda278#add函数\",\"239\":\"v-08dda278#addifabsent\",\"240\":\"v-08dda278#set函数\",\"241\":\"v-08dda278#remove函数\",\"242\":\"v-08dda278#总结\",\"243\":\"v-9d9dd8ee\",\"244\":\"v-9d9dd8ee#concurrenthashmap介绍\",\"245\":\"v-9d9dd8ee#java7-基于分段锁的concurrenthashmap\",\"246\":\"v-9d9dd8ee#java-8基于cas的concurrenthashmap\",\"247\":\"v-9d9dd8ee#concurrenthashmap使用示例\",\"248\":\"v-9d9dd8ee#concurrenthashmap源码解析\",\"249\":\"v-9d9dd8ee#类的继承关系\",\"250\":\"v-9d9dd8ee#类的内部类\",\"251\":\"v-9d9dd8ee#node类\",\"252\":\"v-9d9dd8ee#traverser类\",\"253\":\"v-9d9dd8ee#collectionview类\",\"254\":\"v-9d9dd8ee#segment类\",\"255\":\"v-9d9dd8ee#countercell\",\"256\":\"v-9d9dd8ee#类的属性\",\"257\":\"v-9d9dd8ee#类的构造函数\",\"258\":\"v-9d9dd8ee#核心函数分析\",\"259\":\"v-9d9dd8ee#putval函数\",\"260\":\"v-9d9dd8ee#get函数\",\"261\":\"v-9d9dd8ee#replacenode函数\",\"262\":\"v-9d9dd8ee#参考\",\"263\":\"v-301d6afa\",\"264\":\"v-301d6afa#什么是blockingqueue\",\"265\":\"v-301d6afa#blockingqueue接口定义\",\"266\":\"v-301d6afa#blockingqueue实现\",\"267\":\"v-301d6afa#arrayblockingqueue使用介绍\",\"268\":\"v-301d6afa#arrayblockingqueue源码实现\",\"269\":\"v-301d6afa#类的继承关系\",\"270\":\"v-301d6afa#类的属性\",\"271\":\"v-301d6afa#类的构造函数\",\"272\":\"v-301d6afa#核心函数分析\",\"273\":\"v-301d6afa#put函数\",\"274\":\"v-301d6afa#offer函数\",\"275\":\"v-301d6afa#take函数\",\"276\":\"v-301d6afa#poll函数\",\"277\":\"v-301d6afa#clear函数\",\"278\":\"v-301d6afa#参考\",\"279\":\"v-65337fdb\",\"280\":\"v-65337fdb#什么是threadlocal\",\"281\":\"v-65337fdb#threadlocal的使用示例\",\"282\":\"v-65337fdb#threadlocal原理分析\",\"283\":\"v-65337fdb#threadlocal的使用场景\",\"284\":\"v-65337fdb#threadlocal内存泄露\",\"285\":\"v-65337fdb#内存引用链路\",\"286\":\"v-65337fdb#java中的引用\",\"287\":\"v-65337fdb#泄露原因分析\",\"288\":\"v-65337fdb#inheritablethreadlocal-父子线程间的数据共享\",\"289\":\"v-65337fdb#参考\",\"290\":\"v-049841de\",\"291\":\"v-049841de#前言\",\"292\":\"v-049841de#threadpoolexecutor类图\",\"293\":\"v-049841de#threadpoolexecutor线程池的生命周期\",\"294\":\"v-049841de#threadpoolexecutor构造函数\",\"295\":\"v-049841de#corepoolsize\",\"296\":\"v-049841de#keepalivetime\",\"297\":\"v-049841de#workqueue\",\"298\":\"v-049841de#synchronousqueue\",\"299\":\"v-049841de#linkedblockingqueue\",\"300\":\"v-049841de#arrayblockingqueue\",\"301\":\"v-049841de#threadfactory\",\"302\":\"v-049841de#handler\",\"303\":\"v-049841de#线程池的工作流程\",\"304\":\"v-049841de#为什么线程池不允许使用executors去创建\",\"305\":\"v-049841de#推荐方式-1\",\"306\":\"v-049841de#推荐方式-2\",\"307\":\"v-049841de#threadpoolexecutor源码详解\",\"308\":\"v-049841de#几个关键属性\",\"309\":\"v-049841de#内部状态\",\"310\":\"v-049841de#任务的执行\",\"311\":\"v-049841de#execute-方法\",\"312\":\"v-049841de#addworker方法\",\"313\":\"v-049841de#worker类的runworker方法\",\"314\":\"v-049841de#gettask方法\",\"315\":\"v-049841de#任务的提交\",\"316\":\"v-049841de#submit方法\",\"317\":\"v-049841de#futuretask对象\",\"318\":\"v-049841de#run方法\",\"319\":\"v-049841de#任务的关闭\",\"320\":\"v-049841de#参考\",\"321\":\"v-fe3f8ca0\",\"322\":\"v-fe3f8ca0#什么是futuretask\",\"323\":\"v-fe3f8ca0#futuretask使用示例\",\"324\":\"v-fe3f8ca0#futuretask源码解析\",\"325\":\"v-fe3f8ca0#callable接口\",\"326\":\"v-fe3f8ca0#future接口\",\"327\":\"v-fe3f8ca0#futuretask\",\"328\":\"v-fe3f8ca0#核心属性\",\"329\":\"v-fe3f8ca0#run方法\",\"330\":\"v-fe3f8ca0#get方法\",\"331\":\"v-fe3f8ca0#awaitdone方法\",\"332\":\"v-fe3f8ca0#cancel方法\",\"333\":\"v-fe3f8ca0#finishcompletion方法\",\"334\":\"v-fe3f8ca0#参考\",\"335\":\"v-691e0ce0\",\"336\":\"v-691e0ce0#前言\",\"337\":\"v-691e0ce0#completablefuture介绍\",\"338\":\"v-691e0ce0#completablefuture使用示例\",\"339\":\"v-691e0ce0#completablefuture具有future的功能\",\"340\":\"v-691e0ce0#task异步完成后使用回调函数\",\"341\":\"v-691e0ce0#完成任意一个task就开始执行回调函数\",\"342\":\"v-691e0ce0#完成全部task就开始执行回调函数\",\"343\":\"v-691e0ce0#总结\",\"344\":\"v-ee339e7a\",\"345\":\"v-ee339e7a#简介\",\"346\":\"v-ee339e7a#核心模块\",\"347\":\"v-ee339e7a#forkjoinpool继承关系\",\"348\":\"v-ee339e7a#forkjointask继承关系\",\"349\":\"v-ee339e7a#使用示例\",\"350\":\"v-ee339e7a#参考\",\"351\":\"v-4d4f79fa\",\"352\":\"v-4d4f79fa#list-接口\",\"353\":\"v-4d4f79fa#set接口\",\"354\":\"v-4d4f79fa#map接口\",\"355\":\"v-4d4f79fa#总结\",\"356\":\"v-8631ab70\",\"357\":\"v-8631ab70#arraylist的类结构图\",\"358\":\"v-8631ab70#arraylist底层是如何实现的\",\"359\":\"v-8631ab70#arraylist的初始化\",\"360\":\"v-8631ab70#添加元素\",\"361\":\"v-8631ab70#扩容\",\"362\":\"v-8631ab70#删除元素\",\"363\":\"v-8631ab70#查找元素\",\"364\":\"v-8631ab70#迭代器源码解析\",\"365\":\"v-618535c6\",\"366\":\"v-618535c6#linkedlist的类结构图\",\"367\":\"v-618535c6#构造函数\",\"368\":\"v-618535c6#add-e-e-方法\",\"369\":\"v-618535c6#get-int-index-方法\",\"370\":\"v-618535c6#remove-int-index-方法\",\"371\":\"v-618535c6#总结\",\"372\":\"v-4e3cbe0a\",\"373\":\"v-4e3cbe0a#hashmap的类结构图\",\"374\":\"v-4e3cbe0a#hashmap的底层数据结构\",\"375\":\"v-4e3cbe0a#构造函数\",\"376\":\"v-4e3cbe0a#存储元素过程\",\"377\":\"v-4e3cbe0a#扩容\",\"378\":\"v-4e3cbe0a#获取元素\",\"379\":\"v-4e3cbe0a#总结\",\"380\":\"v-42225482\",\"381\":\"v-42225482#类结构图\",\"382\":\"v-42225482#底层数据结构\",\"383\":\"v-42225482#简单示例\",\"384\":\"v-42225482#源码解析\",\"385\":\"v-42225482#构造函数\",\"386\":\"v-42225482#添加元素\",\"387\":\"v-42225482#查找元素\",\"388\":\"v-42225482#删除元素\",\"389\":\"v-42225482#总结\",\"390\":\"v-4689cbba\",\"391\":\"v-4689cbba#类结构关系\",\"392\":\"v-4689cbba#bitset介绍\",\"393\":\"v-4689cbba#bitset的简单使用\",\"394\":\"v-4689cbba#使用场景\",\"395\":\"v-4689cbba#代码示例\",\"396\":\"v-4689cbba#参考\",\"397\":\"v-6ca18109\",\"398\":\"v-6ca18109#简介\",\"399\":\"v-6ca18109#io流基本类\",\"400\":\"v-6ca18109#java流类图结构\",\"401\":\"v-6ca18109#java-io流对象\",\"402\":\"v-518ce18e\",\"403\":\"v-518ce18e#简介\",\"404\":\"v-518ce18e#channel\",\"405\":\"v-518ce18e#filechannel\",\"406\":\"v-518ce18e#buffer\",\"407\":\"v-518ce18e#selector\",\"408\":\"v-518ce18e#总结\",\"409\":\"v-bb4bc3d6\",\"410\":\"v-bb4bc3d6#socketchannel介绍\",\"411\":\"v-bb4bc3d6#serversocketchannel介绍\",\"412\":\"v-bb4bc3d6#selector介绍\",\"413\":\"v-bb4bc3d6#案列介绍\",\"414\":\"v-bb4bc3d6#服务端代码\",\"415\":\"v-bb4bc3d6#客户端代码\",\"416\":\"v-bb4bc3d6#nio底层原理\",\"417\":\"v-879b283a\",\"418\":\"v-879b283a#重载与重写的区别\",\"419\":\"v-879b283a#抽象类和接口的区别\",\"420\":\"v-879b283a#为什么java不支持多继承\",\"421\":\"v-879b283a#string和stringbuffer、stringbuilder的区别是什么\",\"422\":\"v-879b283a#如何理解面向过程和面向对象\",\"423\":\"v-879b283a#java基本类型为什么需要包装类\",\"424\":\"v-879b283a#如何理解java中的多态\",\"425\":\"v-2f0fbf99\",\"426\":\"v-2f0fbf99#谈谈final、finally、finalize的区别\",\"427\":\"v-e4b894f2\",\"428\":\"v-e4b894f2#和-equals-的区别\",\"429\":\"v-e4b894f2#关系操作符号\",\"430\":\"v-e4b894f2#equals\",\"431\":\"v-e4b894f2#equals-和hashcode的关系\",\"432\":\"v-e4b894f2#java中的异常处理机制\",\"433\":\"v-e4b894f2#jdk、jre、jvm的区别和联系\",\"434\":\"v-9e8a134a\",\"435\":\"v-9e8a134a#final关键字的基本用法\",\"436\":\"v-9e8a134a#为什么内部类引用的外部变量必须用final修饰\",\"437\":\"v-9e8a134a#谈谈final、finally、finalize的区别\",\"438\":\"v-9e8a134a#finally语句到底是在return之前还是之后执行\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,12],\"2\":[1,12],\"3\":[1],\"4\":[1],\"5\":[1],\"6\":[1,2],\"7\":[1,2],\"8\":[1,35],\"9\":[2,8],\"10\":[1,21],\"11\":[1,19],\"12\":[1,43],\"13\":[1,21],\"14\":[1,62],\"15\":[1],\"16\":[1,22],\"17\":[1,12],\"18\":[4,29],\"19\":[4,59],\"20\":[4,28],\"21\":[1,4],\"22\":[4,17],\"23\":[4,20],\"24\":[1,15],\"25\":[1,34],\"26\":[1,49],\"27\":[1,31],\"28\":[1],\"29\":[1,17],\"30\":[1,32],\"31\":[1,155],\"32\":[2,24],\"33\":[1],\"34\":[1,8],\"35\":[1,13],\"36\":[1,88],\"37\":[1,41],\"38\":[1],\"39\":[1,10],\"40\":[1,14],\"41\":[1,65],\"42\":[1,10],\"43\":[1,19],\"44\":[1,49],\"45\":[1,15],\"46\":[1,18],\"47\":[1,64],\"48\":[1,8],\"49\":[1,29],\"50\":[1,71],\"51\":[1,33],\"52\":[1,18],\"53\":[1,27],\"54\":[1,43],\"55\":[1,4],\"56\":[2,91],\"57\":[1,108],\"58\":[1],\"59\":[1,14],\"60\":[1],\"61\":[1,22],\"62\":[1,29],\"63\":[1,23],\"64\":[1,30],\"65\":[1,41],\"66\":[1,12],\"67\":[1,37],\"68\":[1,125],\"69\":[2,52],\"70\":[1,17],\"71\":[1,65],\"72\":[1,10],\"73\":[1],\"74\":[2,79],\"75\":[1,41],\"76\":[2,23],\"77\":[1,25],\"78\":[1,66],\"79\":[1,47],\"80\":[1,15],\"81\":[5,55],\"82\":[5,37],\"83\":[2,18],\"84\":[1],\"85\":[1,53],\"86\":[1,20],\"87\":[1,16],\"88\":[3,21],\"89\":[3,46],\"90\":[1,88],\"91\":[1],\"92\":[1,46],\"93\":[1,23],\"94\":[1,51],\"95\":[1,13],\"96\":[1,7],\"97\":[5,106],\"98\":[2,172],\"99\":[1,15],\"100\":[1,22],\"101\":[1,37],\"102\":[1,10],\"103\":[1,16],\"104\":[1,7],\"105\":[1,15],\"106\":[1,66],\"107\":[1,145],\"108\":[1,78],\"109\":[1,8],\"110\":[1,84],\"111\":[1,27],\"112\":[3,9],\"113\":[2,56],\"114\":[2,5],\"115\":[1,69],\"116\":[1,46],\"117\":[3],\"118\":[3,69],\"119\":[1,87],\"120\":[1,60],\"121\":[1,66],\"122\":[1,12],\"123\":[1,13],\"124\":[1,59],\"125\":[1,5],\"126\":[1,24],\"127\":[1,24],\"128\":[1,17],\"129\":[1],\"130\":[1,12],\"131\":[1,47],\"132\":[1,72],\"133\":[1],\"134\":[1,13],\"135\":[1,17],\"136\":[3,56],\"137\":[1,13],\"138\":[1,7],\"139\":[1,84],\"140\":[1,42],\"141\":[1,36],\"142\":[1,108],\"143\":[1,87],\"144\":[2],\"145\":[1,39],\"146\":[1,61],\"147\":[1,125],\"148\":[1,18],\"149\":[1,26],\"150\":[1,21],\"151\":[1,23],\"152\":[1,64],\"153\":[1,88],\"154\":[2],\"155\":[1,39],\"156\":[3,27],\"157\":[1,54],\"158\":[1,50],\"159\":[1,59],\"160\":[1,76],\"161\":[1],\"162\":[1,11],\"163\":[1,58],\"164\":[2,35],\"165\":[1],\"166\":[1,42],\"167\":[1,4],\"168\":[1,87],\"169\":[1,49],\"170\":[1,66],\"171\":[1,5],\"172\":[1],\"173\":[1,394],\"174\":[1,38],\"175\":[1,183],\"176\":[1,19],\"177\":[1,3],\"178\":[1,5],\"179\":[1,30],\"180\":[1,25],\"181\":[1,16],\"182\":[1],\"183\":[1,129],\"184\":[1,48],\"185\":[1,103],\"186\":[1,74],\"187\":[1,77],\"188\":[1,21],\"189\":[1],\"190\":[1,26],\"191\":[1,112],\"192\":[1],\"193\":[1,10],\"194\":[1,7],\"195\":[1,12],\"196\":[1,20],\"197\":[1,55],\"198\":[1,135],\"199\":[1,93],\"200\":[1,8],\"201\":[1],\"202\":[1,31],\"203\":[1,84],\"204\":[1],\"205\":[1,7],\"206\":[1,8],\"207\":[1,15],\"208\":[1,50],\"209\":[1],\"210\":[4,26],\"211\":[3,11],\"212\":[1],\"213\":[1,118],\"214\":[1,147],\"215\":[1,21],\"216\":[1,8],\"217\":[1],\"218\":[1,46],\"219\":[1,47],\"220\":[1,54],\"221\":[1,100],\"222\":[1,34],\"223\":[1,43],\"224\":[1,24],\"225\":[1,18],\"226\":[1,59],\"227\":[1,11],\"228\":[1,11],\"229\":[1,37],\"230\":[1,40],\"231\":[1],\"232\":[1,14],\"233\":[1,55],\"234\":[1,71],\"235\":[1,108],\"236\":[1,4],\"237\":[1,47],\"238\":[1,55],\"239\":[1,108],\"240\":[1,51],\"241\":[1,71],\"242\":[1,13],\"243\":[1],\"244\":[1,7],\"245\":[2,26],\"246\":[2,23],\"247\":[1,49],\"248\":[1,5],\"249\":[1,16],\"250\":[1,9],\"251\":[1,6],\"252\":[1,11],\"253\":[1,8],\"254\":[1,7],\"255\":[1,2],\"256\":[1,243],\"257\":[1,4],\"258\":[1],\"259\":[1,335],\"260\":[1,56],\"261\":[1,93],\"262\":[1,16],\"263\":[1,3],\"264\":[1,33],\"265\":[1,85],\"266\":[1,44],\"267\":[1,93],\"268\":[1],\"269\":[1,18],\"270\":[1,46],\"271\":[1,75],\"272\":[1],\"273\":[1,64],\"274\":[1,42],\"275\":[1,66],\"276\":[1,33],\"277\":[1,52],\"278\":[1,8],\"279\":[1],\"280\":[1,19],\"281\":[1,60],\"282\":[1,66],\"283\":[1,36],\"284\":[1,4],\"285\":[1,19],\"286\":[1,22],\"287\":[1,41],\"288\":[2,123],\"289\":[1,8],\"290\":[2],\"291\":[1,53],\"292\":[1,15],\"293\":[1,67],\"294\":[1,57],\"295\":[1,60],\"296\":[1,21],\"297\":[1,33],\"298\":[1,17],\"299\":[1,8],\"300\":[1,21],\"301\":[1,10],\"302\":[1,29],\"303\":[1,35],\"304\":[2,15],\"305\":[2,20],\"306\":[2,38],\"307\":[1],\"308\":[1,38],\"309\":[1,62],\"310\":[1,20],\"311\":[2,148],\"312\":[1,105],\"313\":[1,126],\"314\":[1,84],\"315\":[1,60],\"316\":[1,37],\"317\":[1,105],\"318\":[1,65],\"319\":[1,80],\"320\":[1,20],\"321\":[1],\"322\":[1,42],\"323\":[1,138],\"324\":[1],\"325\":[1,17],\"326\":[1,56],\"327\":[1,5],\"328\":[1,76],\"329\":[1,120],\"330\":[1,41],\"331\":[1,132],\"332\":[1,58],\"333\":[1,52],\"334\":[1,9],\"335\":[1],\"336\":[1,102],\"337\":[1,60],\"338\":[1],\"339\":[1,55],\"340\":[1,78],\"341\":[1,77],\"342\":[1,76],\"343\":[1,39],\"344\":[2],\"345\":[1,16],\"346\":[1,28],\"347\":[1,75],\"348\":[1,31],\"349\":[1,114],\"350\":[1,11],\"351\":[2,58],\"352\":[2,122],\"353\":[1,89],\"354\":[1,113],\"355\":[1,13],\"356\":[1],\"357\":[1,33],\"358\":[2,73],\"359\":[1,51],\"360\":[1,46],\"361\":[1,95],\"362\":[1,60],\"363\":[1,50],\"364\":[1,103],\"365\":[1],\"366\":[1,53],\"367\":[1,18],\"368\":[4,54],\"369\":[4,66],\"370\":[4,82],\"371\":[1,24],\"372\":[1],\"373\":[1,16],\"374\":[1,31],\"375\":[1,47],\"376\":[1,110],\"377\":[1,108],\"378\":[1,85],\"379\":[1,19],\"380\":[1],\"381\":[1,17],\"382\":[1,37],\"383\":[1,21],\"384\":[1],\"385\":[1,42],\"386\":[1,52],\"387\":[1,45],\"388\":[1,48],\"389\":[1,13],\"390\":[1],\"391\":[1,16],\"392\":[1,61],\"393\":[1,85],\"394\":[1,9],\"395\":[1,123],\"396\":[1,8],\"397\":[2],\"398\":[1,15],\"399\":[1,66],\"400\":[1,3],\"401\":[2,236],\"402\":[2],\"403\":[1,91],\"404\":[1,48],\"405\":[1,79],\"406\":[1,152],\"407\":[1,67],\"408\":[1,7],\"409\":[2],\"410\":[1,77],\"411\":[1,86],\"412\":[1,93],\"413\":[1,5],\"414\":[1,170],\"415\":[1,119],\"416\":[1,47],\"417\":[1],\"418\":[1,94],\"419\":[1,185],\"420\":[1,34],\"421\":[2,46],\"422\":[1,35],\"423\":[1,67],\"424\":[1,77],\"425\":[1],\"426\":[3],\"427\":[1],\"428\":[5,8],\"429\":[3,81],\"430\":[2,78],\"431\":[3,78],\"432\":[1,122],\"433\":[3,48],\"434\":[1],\"435\":[1,99],\"436\":[1,52],\"437\":[3,55],\"438\":[2,95]},\"averageFieldLength\":[1.2300683371298422,48.28003045706732],\"storedFields\":{\"0\":{\"h\":\"个人生活文章\"},\"1\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"2\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"3\":{\"h\":\"幻灯片页\"},\"4\":{\"h\":\"指南\"},\"5\":{\"h\":\"功能亮点\"},\"6\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"7\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"8\":{\"h\":\"设计模式面试概述\",\"t\":[\"设计模式是软件开发的一种指导思想，它是为了解决具体的编码问题或者是解决某一类问题而产生的。这些年无论是生产环境遇到的事故，还是自己自己做的一些开源项目中，越来越体会到系统是运营出来的，代码质量是设计出来的。无论是在前期的需求分析、方案设计、代码编写，都需要良好的程序设计，这些都离不开设计模式的思想。所以设计模式是程序员的一项基本功。\",\"那么如何学习好设计模式呢，我觉得需要刻意练习，说的简单一点就是多写、多练、多应用。\",\"这些年技术层出不穷，新的框架、新的工具、新的软件开发模式，都会让程序员在技术的海洋里迷失。无论面对什么的环境，我们需要有一些专注力，刻意的去练习、要深挖技术背后的原因，要做到知其然并知其所以然。不能东一榔头西一棒槌，这样只会原地踏步走。\",\"那本系列教程将会讲述23种经典的设计模式，有两个目标：\",\"优先讲解面试过程中常见遇到的几种设计模式；剩下的设计模式会在写完Java面试系列文章之后做为补充。\",\"尽量以通俗易懂的语言和代码案例去讲述。\"]},\"9\":{\"h\":\"设计模式有哪些类型？\",\"t\":[\"设计模式可以分为三种类型，分别是创建性型设计模式、结构型设计模式和行为型设计模式。每种类型的设计模式又包含了多种设计模式，总共有23种设计模式，如图所示：\",\"image-20231112200737983\"]},\"10\":{\"h\":\"创建型模式\",\"t\":[\"创建型设计模式，用于解耦对象的实例化过程，用于对象的实例化，包含了5种设计模式，在实际的开发过程中是应用非常多的：\",\"单列模式：某个类在全局只有一个实例对象，提供一个全局的访问点。\",\"创建者模式：封装对象的创建过程，可以按照方法去构造对象。\",\"工厂方法模式：它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成\",\"抽象工厂模式：它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\",\"原型模式：通过复制原有的实例来创建新的实例。\"]},\"11\":{\"h\":\"结构型模式\",\"t\":[\"结构型设计模式是多个对象实例的结合或者组装，形成一个更大的对象。\",\"装饰器模式：装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能。\",\"代理模式：将对象的访问控制和代码运行位置转移到代理对象中。\",\"享元模式：通过共享对象池技术，共享对象。\",\"适配器模式：将类的接口转换为客户期望的另一个接口\",\"外观模式：提供统一的方法来访问内部子系统。\",\"桥接模式：将抽象部分和实现部分分离，使它们都可以独立\",\"组合模式：将对象组合成树形结构以表示整个部分的层次结构。\"]},\"12\":{\"h\":\"行为型模式\",\"t\":[\"类和对象如何交互，及划分责任和算法。\",\"策略模式：定义一系列算法，封装每个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化。\",\"模板模式：在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。\",\"命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。\",\"迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。\",\"观察者模式：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。\",\"中介者模式：中介者对象封装了一组对象之间的交互，这组对象会将它们的交互委托给中介者对象，而不是直接交互。\",\"备忘录模式：捕获并外部化对象的内部状态，以便以后可以恢复，所有这些都不会违反封装。\",\"解释器模式：给用于定义语言的语法规则表示，并提供解释器来处理句子中的语法。\",\"状态模式：状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",\"责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。\",\"访问者模式：访问者模式是以行为（某一个操作）作为扩展对象功能的出发点，在不改变已有类的功能的前提下进行批量扩展。\"]},\"13\":{\"h\":\"面试过程中常问的设计模式\",\"t\":[\"设计模式有23种，每种设计模式有非常多的应用，能够熟练使用设计模式，可以极大程度的提高我们写代码的质量。熟练使用23种设计模式是高阶程序员必须掌握的技能。\",\"在面试过程中，面试官不会考察每一种设计模式，笔者作为多年面试官，一般常见的考察的面试模式如下：\",\"单例模式\",\"工厂方法模式\",\"抽象工厂模式\",\"装饰器模式\",\"适配器模式\",\"责任链模式\",\"代理模式\",\"观察者模式\",\"掌握好以上的几种设计模式，应对面试应该是足够的，在接下来的文章中会逐步讲解这几种设计模式。\"]},\"14\":{\"h\":\"设计模式的几种原则\",\"t\":[\"面向对象有个SOLID原则，而设计模式是基于对象实例的，基本上也遵循SOLID 原则。这个原则在面试过程中会经常被问到。\",\"S（Single Responsibility Principle，简称 SRP）：单一职责原则，该类的职责是唯一的，这个职责是唯一引起该类变化的原因。\",\"O（Open–Closed Principle，简称 OCP）：开闭原则，对于扩展是开放的，对于修改是封闭的。\",\"L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。里氏代换原则是继承复用的基石，只有当子类可以替换基类，软件功能在不受影响时，基类功能可以被复用，而子类也能够在基类的基础上增加新的行为。\",\"I（Interface Segregation Principle，简称 ISP）：接口隔离原则，接口互相隔离，一个类对另一个类的依赖应该建立在最小的接口范围内。\",\"D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\",\"除了以上的SOLID 原则，面向对象还有以下的基本原则：\",\"迪米特法则：又被叫做最小知识原则，就是一个对象应该尽量对外少暴露，对象之间尽量少了解。\",\"组合优先原则：在复用代码时，要尽量先使用组合关系来实现，其次才考虑使用继承关系来实现。它和里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。\"]},\"15\":{\"h\":\"单例模式\"},\"16\":{\"h\":\"什么是单例模式\",\"t\":[\"单例模式在允许在全局中只存在一个实例，并提供一个方法，让其他的对象可以访问这个实例。单例模式可以解决一个全局的使用的实例，防止它频繁的被创建或者被销毁，从而提高整个系统的性能。单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的。\",\"在什么样的场景会使用到单列模式呢？\",\"需要表示全局唯一的对象，比如id生成器，比如工具类，或者访问资源配置文件的reader。这些对象一般只提供具体的方法、不提供全局的共享变量。在系统中只需要初始化一个实例，就能够提供给其他对象在各个地方使用。\",\"使用单例模式有什么好处呢？\",\"可以节约系统的资源，防止对象的频繁创建\",\"提升代码的复用性\",\"统一全局的访问点控制，方便统一管理和修改\"]},\"17\":{\"h\":\"单例模式的实现\",\"t\":[\"如下图的UML图，单例模式声明了一个名为 instance 的静态对象和 get­Instance() 的方法，静态对象用来存储对象自身的属性和方法，静态方法用来返回其所属类的一个相同实例。这里我们以单例模式经典的懒汉式初始化方式为例，其代码实现如下：\",\"image-20231030213851667\"]},\"18\":{\"h\":\"饿汉模式（线程安全，推荐）\",\"t\":[\"单例模式不需要对外提供构造方法，只允许通过getInstance()方法获取实例，在下面的案例中，会在程序的类的加载过程中，自动创建hugryInstance的静态实例，然后getInstance()去提供获取对象的服务。这种模式是在类加载的时候就完成了对象的实例化，类加载是加锁的，所以它是线程安全的。这种模式称为饿汉模式。\",\"饿汉模式类似于Spring框架初始化Bean实例，都是在程序启动之初创建。虽然可能会造成一定资源开销和浪费，但是由于简单、安全，所以还是比较推荐的。\",\"public class HugryInstance { private static HugryInstance hugryInstance = new HugryInstance(); private HugryInstance() { } public static HugryInstance getInstance() { return hugryInstance; } } \"]},\"19\":{\"h\":\"双重检查（线程安全，推荐）\",\"t\":[\"这种双重检查模式经常在面试中被考察，近几年由于八股文泛滥，可能问的少一些。\",\"public class LazyInstance { private static volatile LazyInstance instance; private LazyInstance() { } public static LazyInstance getInstance() { if (instance == null) { synchronized (LazyInstance.class) { if (instance == null) { instance = new LazyInstance(); } } } return instance; } } \",\"双重检查模式，它属于懒汉模式，只有第一次调用getSingleton()方法才会初始化实例instance。\",\"同时它是线程安全的，使用同步代码块来保证线程的安全。\",\"使用双重检查来判断实例是否初始化，减少同步创建实例的开销。\",\"那为什么要使用volatile关键字来修饰静态的instance对象呢？\",\"在java中创建一个对象，需要如下几步，伪代码如下：\",\"memory=allocate(); //1：分配内存空间 ctorInstance(); //2:初始化对象 singleton=memory; //3:设置singleton指向刚分配的内存空间 \",\"当线程1在执行上面伪代码时，2和3可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以JVM是允许的。如果此时伪代码发生重排序，步骤变为1->3->2，线程1执行到第3步时，线程2调用getsingleton方法，在判断singleton==null时不为null，则返回singleton。但此时singleton并还没初始化完毕，线程2访问的将是个还没初始化完毕的对象。这时程序会出错！\",\"当声明对象的引用为volatile后，伪代码的2、3的重排序在多线程中将被禁止!\"]},\"20\":{\"h\":\"使用内部类模式（线程安全，推荐）\",\"t\":[\"public class InnerClzSingleton { private InnerClzSingleton(){ } public static InnerClzSingleton getSingleton(){ return Inner.instance; } private static class Inner { private static final InnerClzSingleton instance = new InnerClzSingleton(); } } \",\"使用内部类的模式，有以下的优点在：\",\"延迟初始化，属于懒汉模式，需要第一次调用getSingleton()方法，才会初始化内部类。\",\"线程安全，Jvm在执行类的初始化的时候，会进行加锁初始化，在多线程的情况下，也不会频繁创建对象。\",\"所以它属于线程安全的懒汉模式，和双重检查模式一样，但是代码比双重检查模式简洁。\"]},\"21\":{\"h\":\"其他\",\"t\":[\"单例模式除了上面的写法，还有其他的写法，但是不太推荐。\"]},\"22\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是最简单的懒汉模式的单列模式，这种情况下在多线程下是不安全的，可能会同时存在多个实例的创建。\",\"public class LazyInstanceNoSafe { private static LazyInstanceNoSafe instance; private LazyInstanceNoSafe() { } public static LazyInstanceNoSafe getInstance() { if (instance == null) { instance = new LazyInstanceNoSafe(); } return instance; } } \"]},\"23\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是懒汉模式的线程安全的，但是在方法上加了锁，在访问的时候需要锁占用，会导致一定的资源开销和性能下降。此种模式是不推荐的。\",\"public class LazyInstanceSafe { private static LazyInstanceSafe instance; private LazyInstanceSafe() { } public static synchronized LazyInstanceSafe getInstance() { if (instance == null) { instance = new LazyInstanceSafe(); } return instance; } } \"]},\"24\":{\"h\":\"源码下载\",\"t\":[\"https://github.com/forezp/Java-Labs/tree/main/design-pattern-lab/src/main/java/io/github/forezp/java/design/sington\"]},\"25\":{\"h\":\"适配器模式\",\"t\":[\"今天这一讲，我们主要讲解最常用到的适配器模式。\",\"在程序中，经常需要新的项目中需要对老代码进行适配才能用。适配器模式就是将旧代码和新程序的中间的转换角色。举个现实例子，比如我们的MAC电脑需要连接USB接口的键盘，但是MAC电脑只有typec接口，这时我们需要一个拓展坞，需要把typec接口转换成USB接口，给键盘使用，如图所示：\",\"适配器模式的定义是：将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。\",\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解，它的UML图如下所示：\",\"从 UML 图中，我们可以看出适配器模式中包含三个关键角色：\",\"目标类Target， 适配器类即将要进行适配的抽象类或接口，比如TypeC接口；\",\"适配器类Adapter，是作为适配的中间类，它必须持有或者实现目标类和适配类的接口，比如拓展坞类实现了目标接口TypeC接口，持有适配者的类Keyboard；\",\"需要被适配器转换的对象 Adaptee, 比如图中的键盘（实现了USB接口）。\"]},\"26\":{\"h\":\"代码实现\",\"t\":[\"需要被适配的接口USB接口：\",\"public interface IUsb { void connect(int x, int y); } \",\"需要被适配的接口的实现类，比如案例中Keyboard：\",\"public class Keyboard implements IUsb{ @Override public void connect(int x, int y) { System.out.println(\\\"keyborad 连上了usb接口\\\"); } } \",\"目标接口ITypeC：\",\"public interface ITypeC { void connect(int x, int y,int z); } \",\"ExpansionDockAdapter（拓展坞适配器）实现了ITypeC的目标接口接口，ExpansionDockAdapter并持有需要被适配的IUsb接口，适配器只有同时实现或者持有目标接口和被适配的对象，才能进行适配工作：\",\"public class ExpansionDockAdapter implements ITypeC{ private IUsb iUsb; public ExpansionDockAdapter(IUsb iUsb) { this.iUsb = iUsb; } @Override public void connect(int x, int y, int z) { System.out.println(\\\"拓展坞将Typec接口转换成USB接口\\\"); iUsb.connect(x,y); } } \",\"最后，可以调用客户端对它们调用：\",\"public class McClient { public static void main(String[] args) { Keyboard keyboard = new Keyboard(); ExpansionDockAdapter adapter = new ExpansionDockAdapter(keyboard); System.out.println(\\\"mac连接typec\\\"); adapter.connect(1, 2, 3); } } \"]},\"27\":{\"h\":\"使用适配器模式有什么收益\",\"t\":[\"可能有很多人比较疑惑，如果在目标类中，新写一个方法就可以将需要适配的类进行转换。那么为什么还需要使用适配器模式呢？\",\"首先 ，是为了保持简单性，正如mac电脑一样，它只提供TypeC接口。由拓展坞去做USB或者是HDMI接口的转换。保证了MAC电脑对外接口的简单性。\",\"单一职责，不同的角色做不同的事，没有必要将多个事情给一个角色做完，这样代码会非常的臃肿，难以维护。\",\"可复用，将适配器这个角色进行高度抽象化，可以做到移植可复用\",\"使用适配器模式有以下的优点：\",\"将目标类和适配的类解耦，引入一个适配器类兼容现有目标类，拓展新的适配者类功能，很好的避免了现有类和适配者类的耦合。\",\"单一职责，目标类和适配者类各司其职，互不干扰。\",\"满足里氏替换原则。 目标类和适配者类是通过适配器进行交互的，适配器类只要不影响目标类的接口功能，适配者类无论出现什么新功能，都很方便替换。\"]},\"28\":{\"h\":\"源码下载\"},\"29\":{\"h\":\"装饰器模式\",\"t\":[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能，相当于对原有的类进行类一个包装，它又称为包装器模式。\",\"在Java的IO源码中，使用到了包装器模式，比如在以下的代码中，BufferedReader和FileReader都是使用到包装器模式，各种Reader一层套一层，进行数据的转换或者功能的增强。\",\" fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); \"]},\"30\":{\"h\":\"UML图\",\"t\":[\"image-20231102232111957\",\"上图是装饰器的UML图，在图中一共有三个角色：\",\"组件Component，它是目标接口，定义目标的方法\",\"组件实现类ComponentImpl，它实现了目标接口\",\"装饰器ComponentDecoratorB和ComponentDecoratorA \",\"ComponentDecoratorB，它实现了目标接口，并持有组件实现类ComponentImpl\",\"ComponentDecoratorA，它实现了目标接口，并持有装饰器ComponentDecoratorB\",\"ComponentImpl提供基本的实现方法，在不改变了ComponentImpl的情况下，ComponentDecoratorB和ComponentDecoratorA分别对ComponentImpl进行了增强。\",\"什么时候使用装饰器模式\",\"一般来讲，装饰模式不改变原有类的结构，是不能改变原有的基础功能，只能在原有的基础功能之上做进一步增强。一般情况下，装饰器模式经常使用到以下场景：\",\"一个组件可以有很多个装饰器，不同的装饰器有不同的功能，可以按照需要使用不同装饰器组合。在扩展性上，装饰器非常的灵活。\",\"原有的类不支持继承，比如使用类final关键字的类。\"]},\"31\":{\"h\":\"使用案例\",\"t\":[\"在案例模仿JavaIO的文件流的写入和读取功能，在文件流的基础之上使用装饰器模式，做下面的增强功能：\",\"加密装饰器：对写入文件的字符的加密，对读取的字符进行解密\",\"压缩解压装饰器：对写入字符进行压缩，对读取的字符进行解压\",\"可以通过顺序组合包装的方式来附加扩张功能，比如可以先使用加密装饰器，后使用压缩解压装饰器；也可以把他们的顺序对调。\",\"首先，定义一个目标接口ReaderWriter，它有读取和写入的功能：\",\"public interface ReaderWriter { String read(); void write(String content); } \",\"ReaderWriter的基本实现类是FileReaderWriter，它可以把字符写入到文件中，也可以读取文件的字符。\",\"public class FileReaderWriter implements ReaderWriter { private String filePath; public FileReaderWriter(String filePath) { this.filePath = filePath; } @Override public String read() { StringBuilder sb = new StringBuilder(); File file = new File(filePath); BufferedReader bufferedReader = null; FileReader fileReader = null; try { fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); String s; while ((s = bufferedReader.readLine()) != null) { sb.append(s); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } if (bufferedReader != null) { bufferedReader.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } @Override public void write(String content) { File file = new File(filePath); FileWriter fileWriter = null; BufferedWriter bufferedWriter = null; try { fileWriter = new FileWriter(file); bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(content); bufferedWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileWriter != null) { fileWriter.close(); } if (bufferedWriter != null) { bufferedWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"EncryptionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行加密\",\"在读取文件的字符之后 ，对读取的字符进行解密\",\"public class EncryptionFileReaderWriter implements ReaderWriter{ private ReaderWriter readerWriter; public EncryptionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decode(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(encode(content)); } private String encode(String data) { byte[] result = data.getBytes(); for (int i = 0; i < result.length; i++) { result[i] += (byte) 1; } return Base64.getEncoder().encodeToString(result); } private String decode(String data) { byte[] result = Base64.getDecoder().decode(data); for (int i = 0; i < result.length; i++) { result[i] -= (byte) 1; } return new String(result); } } \",\"CompressionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行压缩\",\"在读取文件的字符之后 ，对读取的字符进行解压\",\"public class CompressionFileReaderWriter implements ReaderWriter { private ReaderWriter readerWriter; public CompressionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decompress(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(compress(content)); } private String compress(String stringData) { byte[] data = stringData.getBytes(); try { ByteArrayOutputStream bout = new ByteArrayOutputStream(512); DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater()); dos.write(data); dos.close(); bout.close(); return Base64.getEncoder().encodeToString(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } private String decompress(String stringData) { byte[] data = Base64.getDecoder().decode(stringData); try { InputStream in = new ByteArrayInputStream(data); InflaterInputStream iin = new InflaterInputStream(in); ByteArrayOutputStream bout = new ByteArrayOutputStream(512); int b; while ((b = iin.read()) != -1) { bout.write(b); } in.close(); iin.close(); bout.close(); return new String(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } } \",\"写一个客户端测试类：\",\"定义一个写入的字符串text\",\"定义文件的写入或者读取的路径\",\"然后使用装饰器模式，嵌套了两个装饰器（加减密装饰器和压缩解缩的装饰器），对写入的字符进行先加密再压缩；对读取的字符进行先解压再解密。\",\"具体实现如下：\",\"public class Client { public static void main(String[] args) { String text = \\\"fangzhipeng.com\\\"; String filePath=\\\"/Users/forezp/Downloads//test.txt\\\"; System.out.println(\\\"原始内容：\\\"+text); ReaderWriter rw = new CompressionFileReaderWriter(new EncryptionFileReaderWriter(new FileReaderWriter(filePath))); rw.write(text); FileReaderWriter fileReaderWriter=new FileReaderWriter(filePath); // System.out.println(\\\"加密后、压缩后的内容为：\\\"+fileReaderWriter.read()); System.out.println(\\\"解密后、解缩后的内容为：\\\"+rw.read()); } } \",\"执行测试类，控制台打出的结果如下：\",\"原始内容：fangzhipeng.com 加密后、压缩后的内容为：Zkt5TVQ5eU1zOXNKTUZrT1Q6ZU17dDlHQkVFSENnOT4= 解密后、解缩后的内容为：fangzhipeng.com\",\"Process finished with exit code 0\"]},\"32\":{\"h\":\"为什么要使用装饰器模式？\",\"t\":[\"在讲解完具体案例后，我们来思考一下，为什么要使用装饰器模式，主要原因：\",\"能够快速的扩展现有类的功能，并能自由组合包装各种装饰器，达到不同的效果，也就是能够根据需求，快速的装载和卸载装饰器\",\"希望继承原有类的功能，但又不方便继承。\",\"使用装饰器模式有以下的优点：\",\"代码的可扩展性和可复用性非常的强，对一些基础类无法修改，需要扩展功能的时候，采用装饰器模式能够快速的扩展功能，同时有不会影响原有的公民\",\"满足单一职责的原则。基本功能实现类和不同的装饰器只实现自己的独一的功能，后面加一些功能，可以增加新的装饰器。\",\"可以快速装载和卸载增强功能\",\"可以快速组合，通过包装不同的装饰器组合来满足自己的业务需求\"]},\"33\":{\"h\":\"源码下载\"},\"34\":{\"h\":\"责任链模式\",\"t\":[\"责任链模式在软件开发中，是会经常使用到的一个设计模式，比如对某一次请求进行不同的规则的校验，这些规则的执行有先后顺序，组成了链式的执行顺序。\",\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理。这些在流水线的处理类对象构成了一个单项链表结构。\"]},\"35\":{\"h\":\"责任链模式的UML图\",\"t\":[\"从该UML中中，责任链模式有两个角色：\",\"处理类Handler，可以是一个接口，也可以是一个抽象类。它有一个核心的处理方法，比如handle_request();\",\"处理类的实现类HandlerA、HandlerB、HandlerC，这几个Handler构成了一个链式的处理顺序。\"]},\"36\":{\"h\":\"案例实战\",\"t\":[\"在工作中，我们经常有一些审批流程，现在使用责任链模式去模拟一个向公司借款的流程。在流程中有三个角色，分别是员工、经历、CFO三个角色，根据借款金额的不同，需要不同的审批角色。\",\"当借款金额小于1000元，只需要财务审批\",\"当借款金额大于1000元小于5000元，需要经理审批\",\"当借款金额大于5000元小于10000元，需要CFO审批\",\"当借款金额大于10000元，审批拒绝。\",\"首先创建一个审批抽象类Aproval，有一个核心的抽象处理方法handle(int amount)和持有一个Aproval对象。\",\"public abstract class Aproval { private Aproval nextApproval; public abstract void handle(int amount); public Aproval getNextApproval() { return nextApproval; } public void setNextApproval(Aproval nextApproval) { this.nextApproval = nextApproval; } } \",\"Staff（财务）继承了Aproval，并实现了handle(int amount)方法，里面有具体的处理逻辑，它只能审批1000元以下的借款。\",\"public class Staff extends Aproval { @Override public void handle(int amount) { if(amount<1000){ System.out.println(\\\"审批通过\\\"); }else { System.out.println(\\\"财物权限不够，需要经理审批\\\"); getNextApproval().handle(amount); } } } \",\"Manager继承了Aproval，并实现了handle(int amount)方法，它能审批5000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class Manager extends Aproval { @Override public void handle(int amount) { if (amount < 5000) { System.out.println(\\\"经理审批通过\\\"); } else { System.out.println(\\\"经理权限不够，需要总裁审批\\\"); getNextApproval().handle(amount); } } } \",\"CFO继承了Aproval，并实现了handle(int amount)方法，它能审批10000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class CFO extends Aproval { @Override public void handle(int amount) { if (amount < 10000) { System.out.println(\\\"cfo审批通过\\\"); } else { System.out.println(\\\"金额太大，审批不通过\\\"); } } } \",\"写一个测试类，将三个审批角色组成一个责任链模式的审批流，并向审批流的第一角色handle(9000)：\",\"public class Client { public static void main(String[] args) { Staff staff = new Staff(); Manager manager = new Manager(); CFO cfo = new CFO(); staff.setNextApproval(manager); manager.setNextApproval(cfo); staff.handle(9000); } } \",\"运行代码处理结果如下：\",\"财物权限不够，需要经理审批 经理权限不够，需要总裁审批 cfo审批通过\"]},\"37\":{\"h\":\"为什么要使用责任链模式\",\"t\":[\"从上面的使用场景，我们可以得出以下的一些结论，使用责任链的原因有：\",\"使用责任链模式可以将一个大而复杂的判断逻辑，分成多个小的逻辑单元，每个逻辑单元组成了链中的一环。每个逻辑单元的功能都是解藕的。\",\"可以动态的扩展责任链中的逻辑单元，当需要扩展新的功能，可以写一个Handler即可\",\"也可以根据需求快速的删除一些逻辑单元，并且可以根据需要快速的组合逻辑单元\",\"从上面的分析原因我们可以得出，使用责任链有以下的优点：\",\"降低逻辑单元之间的耦合度，不同的逻辑单元的处理逻辑不耦合，提高了系统的灵活性和可维护性。\",\"提升代码的可扩展性，可以快速的装载和卸载逻辑单元，提供整个责任链的可扩展性。可以根据不同的需求，制定不同的处理流程，而且不需要修改现有的代码\",\"符合开闭原则：责任链模式将处理逻辑放在链式的逻辑单元中处理，新增一个逻辑功能，并不需要改变原有的逻辑功能\",\"可以灵活的控制责任链中逻辑单元的处理顺序\",\"总之，责任链模式可以提供一种灵活、可扩展和可维护的链式处理的机制，使系统能够更好地应对变化和复杂性。但需要防止责任链模式有过多的处理逻辑单元，如果处理链路过长，系统出错，很难去排查，也有可能影响系统的性能。所以我们在实际的使用过程中，需要权衡一下利弊，根据实际的情况做设计和优化。\"]},\"38\":{\"h\":\"工厂模式\"},\"39\":{\"h\":\"简单工厂\",\"t\":[\"简单工厂模式（Simple Factory Pattern）也称为静态工厂方法模式，属于创建型设计模式的一种。简单工厂模式提供一个简单的工厂类，根据传入参数的不同，返回不同类的实例对象。\"]},\"40\":{\"h\":\"UML图\",\"t\":[\"简单工厂包含如下角色：\",\"工厂类（SimpleSofaFactory）:负责创建实例对象的类，提供一个静态工厂方法用于创建不同的产品对象。工厂类根据客户端传入的参数来创建相应的产品对象。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"41\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象产品类（Sofa），它有一个抽象方法getName()和一个具体方法showName()\",\"public abstract class Sofa { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" sofa\\\"); } } \",\"ChineseSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class ChineseSofa extends Sofa { @Override String getName() { return \\\"china\\\"; } } \",\"AmericaSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class AmericaSofa extends Sofa{ @Override String getName() { return \\\"america\\\"; } } \",\"工厂类（SimpleSofaFactory）根据客户端传入的参数来创建相应的产品对象Sofa。\",\"public class SimpleFactory { public Sofa createCoffee(String type) { Sofa sofa = null; if(\\\"us\\\".equals(type)) { sofa = new AmericaSofa(); } else if(\\\"cn\\\".equals(type)) { sofa = new ChineseSofa(); } return sofa; } } \",\"写一个客户端，测试类：\",\"public class Client { public static void main(String[] args) { SimpleFactory factory = new SimpleFactory(); Sofa sofa = factory.createSofa(\\\"cn\\\"); sofa.showName(); } } \",\"运行结果如下：\",\"china sofa\",\"简单工厂模式是一种常见的设计模式，它具有如下的优点：\",\"工厂类包含了必要的逻辑判断，可以根据客户端的需求，动态地实例化具体的产品类。\",\"系统扩展性好，如果需要增加新的产品类，只需要修改工厂类的逻辑判断即可。\",\"那它的缺点是：\",\"工厂类包含了所有产品对象的创建逻辑，导致工厂类的代码会随着产品类型的增多而变得越来越复杂。\",\"违反了单一职责原则（SRP），工厂类负责了两个职责：创建和业务逻辑判断。\"]},\"42\":{\"h\":\"工厂方法模式\",\"t\":[\"工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成。工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题。\"]},\"43\":{\"h\":\"UML图\",\"t\":[\"image-20231105210628018\",\"工厂方法模式包含以下角色：\",\"抽象工厂（IFactory）：定义了一个工厂方法makeSofa()，用于创建产品对象的接口。\",\"具体工厂（ChineseSofaFactory）：实现抽象工厂类中定义的工厂方法makeSofa，返回一个具体的产品对象Sofa。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"44\":{\"h\":\"代码实现\",\"t\":[\"定义一个接口IFactory，它有一个createSofa()的方法：\",\"public interface IFactory { Sofa createSofa(); } \",\"IFactory的具体实现类ChineseSofaFactory：\",\"public class ChineseSofaFactory implements IFactory { @Override public Sofa createSofa() { return new ChineseSofa(); } } \",\"IFactory的具体实现类AmericaSofaFactory：\",\"public class AmericaSofaFactory implements IFactory{ @Override public Sofa createSofa() { return new AmericaSofa(); } } \",\"写一个客户端用于测试：\",\"public class Client { public static void main(String[] args) { IFactory factory=new ChineseSofaFactory(); Sofa sofa =factory.createSofa(); sofa.showName(); } } \",\"上面的测试输出结果：\",\"china sofa\",\"使用工厂方法模式的好处是：\",\"客户端通过抽象工厂来创建产品对象，可以方便地创建出不同的产品对象，而不需要了解具体的实现类。\",\"不同的产品由不同的工厂创建，符合单一职责原则，相对于简单工厂，具体工厂类的代码更加简洁。\",\"具备良好的扩展性，增加新的产品和新的工厂非常容易，无需修改已有代码。\",\"使用工厂方法模式的缺点是：\",\"大量的类：每个具体产品都需要一个具体工厂类来创建，会导致类的数量增加，增加了系统的复杂度。\"]},\"45\":{\"h\":\"抽象工厂\",\"t\":[\"工厂方法模式中考虑的是一类产品的生产，比如sofa的生产，但现实生活中，有很多同类型的产品生产，比如家具厂除了生产沙发，还生产桌子、椅子。\",\"抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\"]},\"46\":{\"h\":\"UML图\",\"t\":[\"抽象工厂的UML图如下：\",\"抽象工厂模式包含以下角色：\",\"抽象工厂（IFurnitureFactory）：定义了一系列可以创建不同产品对象的方法，每个方法对应一个具体产品类的创建方法。\",\"具体工厂（FurnitureFactory ）：实现了抽象工厂接口，负责创建一族相关的具体产品对象。\",\"抽象产品类（Table）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（ChineseTable）：实现了抽象产品类的属性和方法。\"]},\"47\":{\"h\":\"代码实现\",\"t\":[\"抽象产品类（Table），代码如下：\",\"public abstract class Table { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" table\\\"); } } \",\"具体产品类（ChineseTable），代码如下：\",\"public class ChineseTable extends Table{ @Override String getName() { return \\\"china\\\"; } } \",\"抽象工厂（IFurnitureFactory），定义了makeSofa()和makeTable()方法，代码如下：\",\"public interface IFurnitureFactory { Sofa makeSofa(); Table makeTable(); } \",\"具体工厂（FurnitureFactory ）实现了抽象工厂（IFurnitureFactory）中的创建对象的方法：\",\"public class FurnitureFactory implements IFurnitureFactory { @Override public Sofa makeSofa() { return new ChineseSofa(); } @Override public Table makeTable() { return new ChineseTable(); } } \",\"写一个测试类，该类使用抽象工厂模式创建不同的产品对象，代码如下：\",\"public class Client { public static void main(String[] args) { IFurnitureFactory factory = new FurnitureFactory(); Sofa sofa= factory.makeSofa(); Table table= factory.makeTable(); sofa.showName(); table.showName(); } } \",\"运行上面的代码，输出如下：\",\"china sofa china table\",\"抽象工厂模式提供了一种创建一族相关对象的方法，能够实现不同产品族的兼容性和高度可扩展性，它具有以下的优点：\",\"可以创建一系列相关的产品对象，保证了这些对象之间的兼容性。\",\"客户端代码与具体产品的创建实现了解耦\",\"符合开闭原则，新增一族产品时，只需要增加相应的具体产品类和工厂类即可。\",\"同时它具有以下的缺点：\",\"新增产品族、比较困难，需要修改抽象工厂的接口和具体工厂类。\",\"增加系统的复杂性\"]},\"48\":{\"h\":\"观察者模式\",\"t\":[\"观察者模式（Observer Pattern）是一种行为型设计模式，用于对象之间的一对多的依赖关系，当对象发生改变时，所有依赖于它的对象都会收到通知。\"]},\"49\":{\"h\":\"观察者模式UML图\",\"t\":[\"UML图如下：\",\"image-20231107230028268\",\"从UML图上可以得出，在观察者模式中，有以下的角色：\",\"发布者Publisher：或者被称为被观察者，它维护了一个观察者的列表，并可以动态添加观察者或者删除观察者。\",\"观察者Observer：定义了一个接收发布者消息的方法，当发布者发布消息，观察者会执行该方法。\",\"具体主题（Concrete Subject）：具体主题是主题的具体实现，它维护了一个状态，并在状态改变时通知观察者。\",\"具体观察者（Concrete Observer）：具体观察者是观察者的具体实现，它实现了观察者的更新接口，并定义了观察者接收到通知后的具体行为。\",\"观察者模式在软件开发中有非常多的应用，在GUI中应用的比较多，在消息队列的场景有广泛的应用。\"]},\"50\":{\"h\":\"案例实战\",\"t\":[\"写一个观察者接口Observer，它有一个接收通知对象的方法 notify (Object obj);\",\"package io.github.forezp.java.design.obeserver2; public interface Observer { void notify (Object obj); } \",\"Observer接口的实现类ObserverImpl的代码如下：\",\"package io.github.forezp.java.design.obeserver2; public class ObserverImpl implements Observer { private String name; public ObserverImpl(String name) { this.name = name; } @Override public void notify(Object obj) { System.out.println(name+\\\":\\\"+obj.toString()); } } \",\"消息发布者Publisher接口，可以向它注册观察者对象，也可以用它来向观察者发送消息：\",\"package io.github.forezp.java.design.obeserver2; public interface Publisher { void register(Observer observer); void notify(Object o); } \",\"Publisher接口的实现类PublisherImpl，代码如下：\",\"package io.github.forezp.java.design.obeserver2; import java.util.ArrayList; import java.util.List; public class PublisherImpl implements Publisher { private List<Observer> list = new ArrayList<>(); @Override public void register(Observer observer) { list.add(observer); } @Override public void notify(Object o) { for (int i = 0; i < list.size(); i++) { list.get(i).notify(o); } } } \",\"写一个客户端测试类：\",\"package io.github.forezp.java.design.obeserver2; public class Client { public static void main(String[] args) { Publisher publisher=new PublisherImpl(); publisher.register(new ObserverImpl(\\\"observer1\\\")); publisher.register(new ObserverImpl(\\\"observer2\\\")); publisher.notify(\\\"fangzhipeng.com\\\"); } } \",\"运行结果如下：\",\"observer1:fangzhipeng.com observer2:fangzhipeng.com\"]},\"51\":{\"h\":\"为什么要使用观察者模式\",\"t\":[\"观察者模式的核心思想是将观察者对象注册到发布者对象中，发布者对象可以对所有的观察者发送消息，观察者收到消息后可以做出响应。\",\"使用观察者模式有以下的收益：\",\"主题和观察者之间松耦合，使得发布者和观察者互不影响。对象之间关系也比较清晰。可以利用发布者向所有的观察者发送消息。\",\"可扩展性很强，可以动态地添加和删除观察者，灵活性非常高。如果不使用观察者模式来捕获一个被观察对象的属性变化，那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑，这样不仅增加了代码的耦合性，也让代码扩展变得非常困难。\",\"观察者模式符合开闭原则，增加新的观察者，不需要修改已有的代码。\",\"同时，观察者模式也有一些缺点，比如发布者维护的观察者对象是无顺序的，并且发布者发布消息也是无顺序的，如果需要把证消息发送的顺序，需要做更多的工作。此外，过多的观察者会影响性能，需要做性能测试。\",\"综上所述，观察者模式是一种实用并且简单的设计模式，它能够提高系统的可扩展性和灵活性。但是在使用它的时候需要注意它带来的一些缺点，要做一些优化工作。\"]},\"52\":{\"h\":\"代理模式\",\"t\":[\"代理模式和装饰器模式类似，都是在不改变同一个接口功能的前提下，对原有功能的做扩展或者增强。代理模式并没有做类似于装饰器模式多层嵌套，而是采用灵活的单一结构。在Java语言中并支持动态代理，在很多RPC框架、Spring AOP、Spring事务等领域有着广泛的应用。\",\"代理模式是一种结构性模式，它允许将对象的访问控制和代码运行位置转移到代理对象中。类似于中介，代理对象可以控制客户端对真实对象的访问。代理模式常用于对已有功能的增强，比如访问控制、远程调用。\"]},\"53\":{\"h\":\"静态代理\",\"t\":[\"代理模式分为静态代理和动态代码，一般静态代理使用的比较少，而动态代理在各种框架、中间件有着广泛的应用。\",\"静态代理需要手动创建一个代理类，实现被代理对象的接口，并将实际对象的方法调用转发给它。静态代理的优点是简单易懂，但缺点是需要手动创建代理类，对于需要代理的类数量较多或变化频繁的情况下，代码会变得臃肿难以维护。\",\"从上面的 UML 图中，我们可以看出代理模式有三个关键角色：\",\"抽象主题接口类（Subject）：它定义了一些方法。\",\"主题实现类（RealSubject）：实现了抽象接口类（的所有方法\",\"代理类（StaticProxy）：实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。\"]},\"54\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象主题类：\",\"public interface Subject { void operation(); } \",\"主题实现类（RealSubject）的代码如下：\",\"public class RealSubject implements Subject{ @Override public void operation() { System.out.println(\\\"do somthing\\\"); } } \",\"代理类（StaticProxy）实现了抽象主题类，并持有主题实现类的对象，并在主题实现类的对象的operation()方法之前和之后做了功能的增强，具体代码如下：\",\"public class StaticProxy implements Subject{ private RealSubject realSubject; public StaticProxy(RealSubject realSubject) { this.realSubject = realSubject; } @Override public void operation() { System.out.println(\\\"before operation...\\\"); realSubject.operation(); System.out.println(\\\"after operation...\\\"); } } \",\"写一个客户端实现类，代码如下：\",\"public class Client { public static void main(String[] args) { testStatic(); } public static void testStatic() { StaticProxy staticProxy = new StaticProxy(new RealSubject()); staticProxy.operation(); } } \",\"运行代码，输出如下：\",\"before operation... do somthing after operation...\"]},\"55\":{\"h\":\"动态代理\",\"t\":[\"动态代理可以使用 Java 动态代理机制和CGLIB动态代理。\"]},\"56\":{\"h\":\"Java 动态代理\",\"t\":[\"Java 动态代理是在运行时自动生成代理类并将方法调用转发到实际对象。 Java 动态代理的优点是避免了手动创建代理类的麻烦，但缺点是对于一些无法实现接口的类，无法使用动态代理。\",\"Java 动态代理是使用Java的反射机制来实现动态代理。Java提供了java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。\",\"具体使用Java 动态代理的步骤是先实现InvocationHandler接口。和静态代理类似：在这个接口中，需要对真实的代理对象的功能需要做一下加强，它是实现动态代理的关键，代码如下：\",\"public class ProxyHandler implements InvocationHandler { private Object object; public ProxyHandler(Object object){ this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"Before invoke \\\" + method.getName()); method.invoke(object, args); System.out.println(\\\"After invoke \\\" + method.getName()); return null; } } \",\"实现代理如下：\",\"public class Client { /** * jdk动态代理 */ public static void testJdkProxy() { Subject realSubject = new RealSubject(); ProxyHandler handler = new ProxyHandler(realSubject); Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.operation(); } public static void main(String[] args) { testJdkProxy(); } } \",\"运行代码输出：\",\"Before invoke operation do somthing After invoke operation\",\"Java动态代理是基于反射生产的一个代理类，这个代理类本身已经继承了jdk包中的Proxy对象，而Java是不允许多继承的，所以只能实现接口的方式进行代理。\",\"它的优点如下：\",\"Java动态代理不需要任何依赖\",\"灵活性：动态代理可以在运行时动态生成代理类，\",\"可拓展性：可以通过动态代理实现一些横切关注点，比如日志记录、性能监控等，而无需修改原有的代码。\",\"缺点：\",\"性能开销：由于动态代理是在运行时动态生成代理类，相比直接调用实现类的方法，会带来一定的性能开销\",\"功能限制：动态代理只能对接口进行代理，在某些情况下，无法代理实现类的方法。\"]},\"57\":{\"h\":\"CGLIB代码\",\"t\":[\"在pom文件中引入cglib包，代码如下：\",\" <dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> version>3.2.5</version> </dependency> \",\"CGlib代码模式需要实现MethodInterceptor，并在intercept方法中实现真实对象的功能增强，代码如下：\",\"public class CglibProxyFactory implements MethodInterceptor { private Object target;//维护一个目标对象 public CglibProxyFactory(Object target) { this.target = target; } //为目标对象生成代理对象 public Object getProxyInstance() { //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象代理 return en.create(); } @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"开始cglib拦截\\\"); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\\\"结束cglib拦截\\\"); return returnValue; } } \",\"写一个测试类：\",\"public class Client { public static void main(String[] args) { testCglibProxy(); } /** * 测试cglib */ public static void testCglibProxy() { Subject subject = new RealSubject(); Subject proxy = (Subject) new CglibProxyFactory(subject).getProxyInstance(); proxy.operation(); } } \",\"执行结果如下：\",\"开始cglib拦截 do somthing 结束cglib拦截\",\"CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，用于在运行时扩展Java类和实现动态代理。与Java动态代理不同，CGLIB可以代理非接口类型的类。\",\"CGLIB动态代理的优点:\",\"性能高：相比Java动态代理，CGLIB动态代理通常能够提供更好的性能，因为它是通过生成子类来代理目标类，而不是通过实现接口。\",\"功能强大：CGLIB能够代理普通类和接口类，更灵活地满足额外需求，例如代理私有方法、拦截静态方法等。\",\"无需依赖接口：CGLIB动态代理可以代理没有实现任何接口的类，这使得它可以代理更多类型的类，提供更大的灵活性。\",\"CGLIB动态代理的缺点:\",\"需要额外依赖：CGLIB动态代理需要引入额外的库，增加项目的依赖，相比Java动态代理而言更为复杂。\",\"对final方法和final类的限制：CGLIB无法代理final方法和final类。\",\"不支持自身方法调用：CGLIB无法从代理对象中调用自身的方法，这可能会引起无限循环或抛出异常。\"]},\"58\":{\"h\":\"概览\"},\"59\":{\"h\":\"Prometheus教程介绍\",\"t\":[\"本篇文章为系列教程，旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统。所用到开源组件如下：\",\"Prometheus\",\"Grafana\",\"VictoriaMetrics系列\",\"Node-exporter\",\"Alertmanager\",\"Kafka\",\"Flink\",\"最终的技术架构如下：\",\"image-20230830224136440\"]},\"60\":{\"h\":\"Prometheus概述\"},\"61\":{\"h\":\"什么是Prometheus\",\"t\":[\"Prometheus是一个开源的监控系统，提供了数据采集、告警计算、告警管理等一系列工具包，周边生态非常的丰富。\",\"Prometheus受启发于Google的Brogmon监控系统（类似于Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师以开源软件的形式进行研发，并且于2015年对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF(云原生计算基金会)的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。\",\"Prometheus通过时序数据来收集和存储指标。一个时序数据包含了一个时间戳、值和一个或者是多个key-value键值对。\"]},\"62\":{\"h\":\"Prometheus提供的特性\",\"t\":[\"作为新一代的监控系统，Prometheus和传统的监控系统相比，有着非常大的创新。Prometheus让监控从传统的黑盒子监控提升到了白盒监控；不仅可以监控系统的一些状态，也可以深入到进程内部关键点的监控（白盒监控）。\",\"Prometheus提供一些关键的特性：\",\"多维的数据结构，这个数据结构包括一个指标名和一系列的键值对（指标）。\",\"提供了数据查询的Promql，Promql非常的强大和灵活。\",\"提供了单节点和分布式的数据存储方案。也可以使用第三方时序数据去存储，比如influxdb、thanos、victoriaMetrics\",\"时序数据使用http协议采集，通常是pull模式，也可以使用push模式（通过中间层push_gateway）\",\"采集目标可以使用服务发现的方式（比如k8s系统、consul），也可以通过静态的配置去发现采集目标。\",\"可以和开源组件grafana无缝对接。\"]},\"63\":{\"h\":\"组件\",\"t\":[\"Prometheus生态包含了一系列组件，除了Prometheus很多组件是可选的：\",\"Prometheus server是最核心的组件，用来抓取和存储时序数据的。\",\"Client-libraries（sdks）是用来开发应用指标的工具包\",\"Push_gateway是用来短暂存储push类型指标的\",\"exporters是用来暴露或者导出被监控对象的指标的，比如虚拟机、nginx、mysql等\",\"alertmanager是用来管理告警消息的，比如对消息的去重、静默、恢复等管理\",\"还有一系列其他的组件\",\"大多数Prometheus组件都是使用go语言写的，非常容易的打包和部署。\"]},\"64\":{\"h\":\"架构\",\"t\":[\"下图是Prometheus和它周边生态组件的架构图，这些组件构成了一个完整的监控系统：\",\"Prometheus architecture\",\"Prometheus通过pull的方式去周期性（通常15-30s）采集监控对象的指标，健康对象包含： \",\"直接采集的jobs和exporters\",\"也可以是短生命周期的任务推送到pushgateway的指标\",\"监控对象的发现 \",\"可以是k8s的集群的服务发现\",\"也可以是consul\",\"或者静态的配置文件\",\"prometheus发现到监控目标后，会周期性的去采集指标，并将指标存储在主机的磁盘中\",\"通过了内置的告警规则计算，并将告警消息发送给alertmanager\",\"alertmanager提供了对告警消息的管理、去重、静默、分发，可以配置多种分发方式： \",\"比如email\",\"webhook\",\"prometheus提供了http接口的方式让外部第三方访问数据，比如可以将指标数据展示在grafana上。\"]},\"65\":{\"h\":\"prometheus适用的场景\",\"t\":[\"prometheus可以很好地记录任何纯粹的数字时间序列。它既适合以机器为中心的监视，也适合高度动态的面向服务的体系结构的监视。\",\"在微服务的世界里，它对多维数据收集和查询的支持是一个特别的优势。\",\"Prometheus是为可靠性而设计的。每个Prometheus都是单节点设计的，使用多个节点去采集相通的监控对象可以做到高可用。通过Prometheus建立完善的监控体系，从而达到以下目的：\",\"长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。\",\"对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。\",\"告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。\",\"故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题。\",\"数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息\",\"img\",\"那prometheus不适合什么？\",\"由于prometheus是使用周期性的采集数据，它并不能保证数据的及时性和绝对正确性，如果是想做与money相关的业务，使用prometheus明显是不合适的。\"]},\"66\":{\"h\":\"Prometheus环境搭建\",\"t\":[\"本文是Prometheus环境的搭建和安装，包括prometheus-sever、node-exporter、grafna的安装。安装成功后，配置prometheus采集node-exporter的指标，然后在grafana展示node-exporter采集的指标。\"]},\"67\":{\"h\":\"安装prometheus\",\"t\":[\"去prometheus官网下载prometheus，下载地址为https://prometheus.io/download/ ，目前提供了Linux\\\\windows\\\\mac的版本，笔者这里下载mac版本的。\",\"image-20231008083006727\",\"下载完成后，执行解压：\",\"tar -zxvf prometheus-2.47.1.darwin-amd64.tar.gz cd prometheus-2.47.1.darwin-amd64 \",\"执行启动命令：\",\"./prometheus \",\"笔者是mac电脑，运行时会被系统拒绝运行，需要打开系统偏好设置-安全与隐私，允许prometheus运行。\",\"其他操作系统应该没有这个问题。\",\"启动成功后，访问http://localhost:9090 ，就可以访问prometheus页面了，这个页面提供了对prometheus数据的查询和告警信息的查询，页面展示如下：\",\"image-20231008084050835\"]},\"68\":{\"h\":\"prometheus配置文件讲解\",\"t\":[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus.yml，这个配置文件是prometheus启动的时候会读取的配置。具体如下：\",\"# my global config global: scrape_interval: 15s evaluation_interval: 15s # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] \",\"具体的配置介绍如下：\",\"global.scrape_interval 是全局配置默认采集时间间隔（周期性采集监控目标）\",\"global.evaluation_interval是全局配置告警规则任务的计算\",\"alerting.alertmanagers是配置alertmanagers的地址的，alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",\"rule_files是配置告警规则文件的路径，可以使用通配符\",\"scrape_configs是配置采集任务的，支持多种类型的采集，比如从k8s、consul、也可以配置静态采集任务。上面的配置是采集prometheus自身的监控指标。可以访问prometheus自身的监控指标的暴露端点：http://localhost:9090/metrics，可以得到prometheus的监控指标，内容如下：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 4.5782e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 7.745e-05 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000123743 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000251038 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.002707693 go_gc_duration_seconds_sum 0.009608685 go_gc_duration_seconds_count 35 # HELP go_goroutines Number of goroutines that currently exist. # TYPE go_goroutines gauge go_goroutines 32 # HELP go_info Information about the Go environment. # TYPE go_info gauge go_info{version=\\\"go1.21.1\\\"} 1 # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use. # TYPE go_memstats_alloc_bytes gauge go_memstats_alloc_bytes 2.1363728e+07 # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed. # TYPE go_memstats_alloc_bytes_total counter go_memstats_alloc_bytes_total 3.82033736e+08 # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table. # TYPE go_memstats_buck_hash_sys_bytes gauge go_memstats_buck_hash_sys_bytes 1.489234e+06 ... \"]},\"69\":{\"h\":\"采集Node Exporter的指标\",\"t\":[\"Node Exporter是Prometheus生态的一员，它为主机暴露了硬件和内核相关的指标，比如主机的cpu、内存、磁盘、io读写等。目前支持linux系统、windows系统和mac系统，下载地址为：\",\"https://github.com/prometheus/node_exporter/releases \",\"下载完成后，启动node_exporter，node_exporter的端口为9100，访问http://localhost:9100/metrics，就可以查看node_exporter暴露的端口指标。\",\"在prometheus的配置文prometheus.yml中，增加采集Node Exporter的任务，配置信息如下：\",\"scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] - job_name: \\\"node_exporter\\\" static_configs: - targets: [\\\"localhost:9100\\\"] \",\"重新启动prometheus的程序，prometheus 就可以采集Node_Exporter的指标了。\",\"访问prometheus的网页，http://localhost:9090/graph，在查询框里输入node_filesystem_free_bytes（文件系统里剩余的磁盘字节数），就可以看到各个目录的磁盘剩余字节数了。\",\"image-20231008231356066\"]},\"70\":{\"h\":\"prometheus配置文件热更新\",\"t\":[\"在prometheus启动的时候加上启动参数--web.enable-lifecycle，具体命令如下：\",\"prometheus --web.enable-lifecycle \",\"在更改完配置以后，就可以进行配置的热更新，通过拉prometheus的配置热更新接口，接口如戏：\",\"curl -XPOST http://localhost:9090/-/reload \"]},\"71\":{\"h\":\"grafana安装\",\"t\":[\"Grafana是一个开源的、流行的、炫酷的展示数据的可视化仪表盘，它支持多种类型的数据库，提供了非常多的面板和插件，可以让开发者轻松的实现监控大盘。\",\"grafana可以完美的和prometheus结合，展示prometheus数据。\",\"进入grafana官网下载安装包，笔者是mac，所以下载的是mac版本的，下载命令如下：\",\"curl -O https://dl.grafana.com/enterprise/release/grafana-enterprise-10.1.4.darwin-amd64.tar.gz tar -zxvf grafana-enterprise-10.1.4.darwin-amd64.tar.gz \",\"下载并解压成功后，进入到grafana的安装目录，启动grafana，启动命令如下：\",\"./bin/grafana-server \",\"grafana有很多配置项在conf目录下default.ini文件下，此篇文章不讲解这部分内容。\",\"启动成功后，进入grafana的页面，地址为localhost:3030 ，grafana的默认登陆用户名admin、密码为admin\",\"登陆成功后，需要为grafana配置prometheus的数据源，配置界面的路径和配置如下：\",\"配置完成后保存。\",\"然后去grafana官方网站的dashboard社区找一个node exporter的面板，搜索地址：https://grafana.com/grafana/dashboards/?pg=community&plcmt=topnav&search=node+exporter+mac\",\"搜索成功后，在本地部署的grafana页面导入node exporter的dashboard，页面的导入路径如下：\",\"image-20231010201727866\",\"导入成功后，就可以看到本机的资源dashboard（由node exporter采集的指标生产）\",\"image-20231009220040376\"]},\"72\":{\"h\":\"总结\",\"t\":[\"prometheus作为一个采集组件，采集了node-exporter的指标\",\"同时prometheus作为一个时序数据库，存储了node-expoter的指标时序\",\"grafana作为数据展示前端，读取prometheus的指标时序，并展示在监控大盘上。\"]},\"73\":{\"h\":\"Prometheus的数据模型\"},\"74\":{\"h\":\"什么是time-series\",\"t\":[\"Prometheus通过时间序列来存储所有的数据的。时间序列是指标（有相同指标名和标签构成的）的包含时间和值的流式数据。采用的数据模型是单值模型，且只支持浮点数指标。举个例子：\",\"在前面的文章介绍过如下Prometheus自身的监控，通过/metrics接口暴露，Prometheus可以通过调用/metrics接口来获取自身的数据。指标定义如下：\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \",\"指标是单值模型，即一个指标代表一种含义，如下表示prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 指标在不同时间下的值。\",\"指标名称(name)\",\"code\",\"handler\",\"Timestamp\",\"Value\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984318.82\",\"1205\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984153.822\",\"1194\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984033.817\",\"1186\",\"指标在不同时间有不同的值，被称为time-series（时间序列），time-series中每个点被称为一个样子（sample)，sample由三部分组成：\",\"指标：指标是由指标名和标签组成，它们共同组成描述当前指标的特征 \",\"指标名和标签名的命名需要满足[a-zA-Z_:][a-zA-Z0-9_:]*\",\"对于标签值无约束，但是需要对值的控制字符进行转义\",\"时间戳(timestamp)：时间戳精度为毫秒\",\"值(value)： float64类型的值。\",\"<--------------- metric -------------------------------------><-timestamp -><-value-> prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984318.82 => 1205 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984153.822 => 1194 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984033.817 => 1186 \",\"在grafana上查询指标：prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}；\",\"image-20231012215203283\"]},\"75\":{\"h\":\"指标的类型\",\"t\":[\"Prometheus定义来四种类型的指标：\",\"Counter（累加器），初始值为0，只增不减，或者重启的进程的时候重置为0\",\"Gauge（仪表盘），状态值，可增可减。\",\"Histogram（直方图），用于求分位数，比如p99\",\"Summary（摘要），和直方图类似\",\"但是对于Prometheus的底层数据来说，这些类型的指标在存储的时候，并没有差别，都是以time-series的形式存储在Prometheus的level-db中。而在样本数据采集的时候，在注释中包含了指标的类型，其实在存储的时候是并没有存储的。\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \"]},\"76\":{\"h\":\"Counter 累加器\",\"t\":[\"Counter类型的指标和计数器一样，初始值为零，是单调递增的，除非进程重启重置。一般Counter类型的指标建议以_total结尾。例如prometheus_http_requests_total表示prometheus服务的http请求的数量，prometheus每发生一个请求，prometheus_http_requests_total都会累积1。\",\"使用counter类型的指标，可以很容易一段时间的增量数据，比如求最近5分钟prometheus发生了多少次请求：\",\"increase(prometheus_http_requests_total[5m]) \",\"increase是promql中的一个函数，函数的内容，在下一篇文章将会讲解。\"]},\"77\":{\"h\":\"Gauge仪表盘\",\"t\":[\"Gauge类型的指标主要反映的是当前的状态，它是可增可减的，比如node exporter采集的指标中：node_filesystem_avail_bytes，表示的是当前系统文件系统中磁盘可用的字节数，可用通过prometheus的内置函数计算最近5分钟node_filesystem_avail_bytes的差值。\",\"delta(node_filesystem_avail_bytes{}[5m]) \",\"还可以使用predict_linear函数对指标的数据变化趋势进行预测。例如，预测系统磁盘在6个小时之后的剩余情况：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[1h], 6* 3600) \"]},\"78\":{\"h\":\"Histogram直方图\",\"t\":[\"Histogram直方图是用来统计和分析样本的分布情况。\",\"在很多场景下，我们可以使用求平均值来量化指标。比如我们求某个请求耗时的平均值，但是在大多数情况下，请求都是在100ms以内，而个别情况可能导致请求耗时超过了5s，导致请求耗时的平均值远大于100ms，这个平均值是不能反应的请求的真实状态。\",\"Histogram直方图可以解决上面的问题，例如0-10ms的请求有多少个，10ms-20ms的请求又多少个。例如prometheus的服务的/metrics接口耗时，使用了prometheus_http_request_duration_seconds_bucket指标去统计。\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.1\\\"} 1827 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.2\\\"} 1828 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.4\\\"} 1829 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"1\\\"} 1830 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"3\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"8\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"20\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"60\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"120\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"+Inf\\\"} 1831 \",\"在上面的示例中，使用le标签表示小于的意思。\",\"le=\\\"0.1\\\" 表示小于0.1s，有1827个请求\",\"le=\\\"0.2\\\"表示小于0.2s，有1828个请求\",\"通过这种直方图可以很方便的统计请求耗时分布的真实状态。另外，会统计当前指标的记录总数(以_count作为后缀)和值的总和（以_sum作为后缀），例如：\",\"prometheus_http_request_duration_seconds_sum{handler=\\\"/metrics\\\"} 15.171390910999984 prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"} 1831 \",\"Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。\"]},\"79\":{\"h\":\"summary\",\"t\":[\"summary和Histogram类似，只不过summary是已经在客户端已经计算好的数据，例如go_gc_duration_seconds指标：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 6.3884e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 0.00013637 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000194843 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000421166 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.009242327 go_gc_duration_seconds_sum 0.1255515 go_gc_duration_seconds_count 296 \",\"Histogram和summary的区别在于，summary是在sdk侧已经计算好了分位数，而Histogram是通过histogram_quantile函数在prometheus-server进行计算的。对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多服务端的的资源。\",\"通常情况下，我们都会选择使用Histogram类型的指标去做分位数的统计，而不是使用summary。\"]},\"80\":{\"h\":\"Promql快速入门\",\"t\":[\"prometheus的时间序列是通过指标名和一组标签来唯一定义。指标的名称是监控样本的标识，而标签组是监控样本的多个维度特征的反应，所以可以通过标签进行对指标的筛选、过滤、聚合、转换等计算，计算的结果会产生一条新的时间序列。\",\"promql是Prometheus提供的数据查询语言，可以对时间序列提供丰富的查询。promql被广泛应用于指标视图的配置、告警语句的配置，它是一个基础能力，类似于mysql的sql查询语句。\"]},\"81\":{\"h\":\"瞬时向量查询（Instant vector selectors）\",\"t\":[\"我们可以直接输入指标名查询所有的这个指标名的时间序列，比如：\",\"prometheus_http_requests_total \",\"上面的语句等同于：\",\"prometheus_http_requests_total \",\"可以在grafana上查询，获取了prometheus_http_requests_total指标的不同标签维度的所有指标，一共有53个。\",\"image-20231014210829763\",\"可以筛选出handler=“/metrics\\\"接口的数据，在grafana执行：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"} \",\"image-20231014210912914\",\"另外也可以筛选出handler!=“/metrics\\\"的所有的数据，查询语句为：\",\"prometheus_http_requests_total{handler!=\\\"/metrics\\\"} \",\"也可以使用多个标签值进行进行查询，比如查询handler为\\\"/metrics“和handler为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler=~\\\"/metrics|/api/v1/labels\\\"} \",\"同理，也查询handler不为\\\"/metrics“和handler不为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler!~\\\"/metrics|/api/v1/labels\\\"} \",\"也可以使用.*通配符进行模糊匹配查询：\",\"prometheus_http_requests_total{handler=~\\\"/metric.*\\\"} \",\"小结：\",\"使用标签筛选数据的使用，可以使用完全匹配：\",\"label = value\",\"lable =~ value | value2\",\"也可以进行模糊匹配：\",\"label =~ value.*\",\"取反操作\",\"label != value\",\"Label !~ value1 |value2\",\"Label !~ value.*\"]},\"82\":{\"h\":\"范围向量查询（Range Vector Selectors）\",\"t\":[\"通过Instant vector selectors查询，返回值只会包含该时间序列的最新值的一个样本，它是一个瞬时向量结果。如果我们想查询一个时间区间的样本，可以使用范围矢量查询。范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}[5m] \",\"image-20231014211256244\",\"时间范围除了支持分钟（m)外，还还支持\",\"秒（s)\",\"分钟（m）\",\"小时（h）\",\"天（d）\",\"周（w）\",\"年（y）\"]},\"83\":{\"h\":\"offset 时间位移操作\",\"t\":[\"瞬时向量查询和范围向量查询的表达式中，都是以当前时间为基准的，比如：\",\"prometheus_http_requests_total{}，查询当前时间的最新值\",\"prometheus_http_requests_total{}[5m]，查询的是当前时间的过去五分钟的数据。\",\"如果想查询五分钟前的数据，获取昨天的当前时间同一时刻的五分钟的数据，怎么查询呢，我们可以使用offset关键字：\",\"prometheus_http_requests_total{} offset 5m，查询五分钟前的最新值\",\"prometheus_http_requests_total{}[5m] offset 1d，查询的是昨天的当前时间同一时刻的五分钟的数据\"]},\"84\":{\"h\":\"操作符\"},\"85\":{\"h\":\"数学操作符\",\"t\":[\"Promql支持常见的逻辑和数学操作符，这些操作符使用于瞬时向量的查询，常见的逻辑运算符如下\",\"+ (addition) 加\",\"- (subtraction) 减\",\"* (multiplication) 乘\",\"/ (division) 除\",\"% (modulo) 取模\",\"^ (power/exponentiation) 幂运算\",\"在作用于两个瞬时向量之间，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。如果匹配到了，会将计算结果输出到新的向量上，向量里面的标签是左侧和右侧共同匹配的标签，指标名将会被删除。\",\"例如下面的查询语句不会输出任何结果，因为两个handler标签值不一样。\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}+prometheus_http_requests_total{handler=\\\"/api/v1/labels\\\"} \",\"再比如下面的查询语句的可以输出结果，因为左侧的表达式有一个handler=\\\"/metrics\\\"，右侧的表达式也有一个handler=\\\"/metrics\\\"标签，完全匹配，所以能够输出：\",\"sum(prometheus_http_requests_total{handler=\\\"/metrics\\\"})by(handler)+sum(prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"})by(handler) \"]},\"86\":{\"h\":\"比较操作符\",\"t\":[\"promql还支持常见的比较运算符，比如：\",\"== (equal)\",\"!= (not-equal)\",\"> (greater-than)\",\"< (less-than)\",\">= (greater-or-equal)\",\"<= (less-or-equal)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"87\":{\"h\":\"逻辑运算符\",\"t\":[\"逻辑运算符作用于两个瞬时向量之间，支持的逻辑运算符如下：\",\"and (intersection) 求交集\",\"or (union) 求并集\",\"unless (complement)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"88\":{\"h\":\"向量匹配符号 Vector matching\",\"t\":[\"在上面讲解的操作符，比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算。在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算，promql提供了两个向量匹配符号\",\"on （匹配）\",\"Ignoring （忽略）\",\"使用上面的Vector matching，可以应用于One-to-one vector matches（一对一）和Many-to-one and one-to-many vector matches（一对多或者多对一）\"]},\"89\":{\"h\":\"分组修改器 Group modifiers\",\"t\":[\"分组修改器可以实现many-to-one/one-to-many的向量匹配，通常使用以下的关键字：\",\"group_left\",\"group_right\",\"分组修改器可以一边的标签组赋值给另一边的查询结构。\",\"举例子讲解\",\"比如有以下的时间序列的样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用以下的查询：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"如果不用ignoring修改器，将得不到任何结果。\",\"使用group_left修改器进行查询：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \"]},\"90\":{\"h\":\"聚合函数\",\"t\":[\"Prometheus提供非常的多的聚合函数，可以用来聚合耽搁瞬时向量，聚合完后的结果会生成根据聚合标签生成一个新的序列：\",\"sum (calculate sum over dimensions)\",\"min (select minimum over dimensions)\",\"max (select maximum over dimensions)\",\"avg (calculate the average over dimensions)\",\"group (all values in the resulting vector are 1)\",\"stddev (calculate population standard deviation over dimensions)\",\"stdvar (calculate population standard variance over dimensions)\",\"count (count number of elements in the vector)\",\"count_values (count number of elements with the same value)\",\"bottomk (smallest k elements by sample value)\",\"topk (largest k elements by sample value)\",\"quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\",\"基本查询格式是：\",\"<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>) \",\"比如prometheus_http_requests_total这个指标有4个标签，分别是code、handler、instance、job（其中job为采集任务、instance为被采集的实例，这两个标签对于同一个实例来说基本不变）， timeseries格式如下：\",\"prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} \",\"我们可以计算所有handler、code的的请求总数：\",\"sum by (handler, code) (prometheus_http_requests_total) \",\"它同等于：\",\"sum without (instance, job) (prometheus_http_requests_total) \",\"如果想计算所有的请求的总数：\",\"sum(prometheus_http_requests_total) \",\"获取请求次数最多的5个请求，可以用topk函数：\",\"topk(5,sum by (handler, code) (prometheus_http_requests_total)) \"]},\"91\":{\"h\":\"其他常见的函数\"},\"92\":{\"h\":\"计算counter的增长率\",\"t\":[\"可以使用increase函数计算增量数据，比如计算最近5分钟的请求次数：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"这里使用prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]获取最近五分钟的样本，用increase函数算出五分钟的增量。\",\"那么每秒的增量率，可以将上面的结果除以300，可以使用以下的表达式进行计算：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m])/(60*5) \",\"除了使用increase函数计算增量外，可以使用rate函数计算速率，上面的表达式等价于：\",\"rate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于请求数量在5分钟的时间窗口内，可能在某一时刻访问量突增，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。\",\"为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。\",\"irate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \"]},\"93\":{\"h\":\"预测指标变化趋势\",\"t\":[\"predict_linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据，函数的格式如下：\",\"predict_linear(v range-vector, t scalar) \",\"例如，基于5小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[5h], 24 * 3600) < 0 \"]},\"94\":{\"h\":\"计算分位数\",\"t\":[\"Histogram类型的指标可以使用histogram_quantile函数进行计算，函数格式为：\",\"histogram_quantile(φ scalar, b instant-vector) \",\"例如有以下的指标prometheus_http_request_duration_seconds_bucket\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\", job=\\\"prometheus\\\", le=\\\"0.1\\\"} 3767 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.2\\\"} 3769 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.4\\\"} 3773 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"1\\\"} 3775 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"3\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"8\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"20\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"60\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"120\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"Infinity\\\"} 3776 \",\"计算handler=\\\"/metrics\\\"接口的p90耗时：\",\"histogram_quantile(0.9, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \",\"计算p99耗时的表达式如下：\",\"histogram_quantile(0.99, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \"]},\"95\":{\"h\":\"总结\",\"t\":[\"本文快速的讲解了promql的查询、操作符、函数，并通过案例进行了实战。详细内容可以查看官方网站：https://prometheus.io/docs/prometheus/latest/querying/basics/\"]},\"96\":{\"h\":\"在SpringBoot项目中使用Prometheus监控\",\"t\":[\"本篇文章主要讲解如何在SpringBoot项目中使用Prometheus监控，实现方式有两种，一种是使用Springboot自带的spring-boot-starter-actuator；另一种是使用Prometheus的Java客户端\"]},\"97\":{\"h\":\"方案一：使用spring-boot-starter-actuator\",\"t\":[\"SpringBoot已经有来Micrometer的指标库，它默认集成在spring-boot-starter-actuator的依赖包中（要求SpringBoot>=2.0版本）。\",\"新建一个SpringBoot项目，在项目中引入以下的依赖：\",\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <version>1.11.4</version> </dependency> \",\"其中micrometer-registry-prometheus依赖是将Micrometer的指标转换成prometheus格式的指标。\",\"然后在springboot的配置文件application.properties中开启prometheus的暴露接口：\",\"management.endpoints.web.exposure.include=prometheus \",\"在SpringBoot项目创建一个测试接口：\",\"@Controller public class BasicController { // http://127.0.0.1:8080/hello?name=lisi @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后，在浏览器上请求http://127.0.0.1:8080/actuator/prometheus\",\"可以得到/hello接口相关的指标，当然actuator有很多内置的指标，在这里就不展开讲解了 。\",\"# HELP http_server_requests_seconds # TYPE http_server_requests_seconds summary http_server_requests_seconds_count{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 7.0 http_server_requests_seconds_sum{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.071374449 # HELP http_server_requests_seconds_max # TYPE http_server_requests_seconds_max gauge http_server_requests_seconds_max{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.049234863 \",\"在这里有三个指标，分别为\",\"http_server_requests_seconds_count 请求的总次数\",\"http_server_requests_seconds_sum 请求的总耗时\",\"http_server_requests_seconds_max 请求的最大耗时\",\"这个内置指标对请求耗时统计不是做的很好，只能求到最大的耗时和平均耗时，如果要求分位耗时，其实是做不到。而使用Prometheus的Java客户端是可以做到分位耗时的。\"]},\"98\":{\"h\":\"方案二：使用Prometheus\",\"t\":[\"Prometheus官方提供了Java客户端，用于Java程序的指标暴露。在SpringBoot项目中的pom文件引入以下的依赖：\",\" <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-instrumentation-jvm</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-exporter-httpserver</artifactId> <version>1.0.0</version> </dependency> \",\"其中prometheus-metrics-core包是指标的关键包；prometheus-metrics-instrumentation-jvm是用于暴露JVM相关的指标（可选）；prometheus-metrics-exporter-httpserver是用于导出指标的服务（可选）；\",\"同样的，在项目中有一个测试接口，如下：\",\" @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } \",\"然后，需要创建两个指标，如下：\",\"Counter类型的http_count_total，用于统计请求的数量，包括两个标签uri（请求路径）和status（请求状态码）\",\"Histogram类型的http_count_seconds，用于统计请求的耗时，包括两个标签uri（请求路径）和status（请求状态码）\",\"然后创建一个HandlerInterceptorAdapter的拦截器，用于指标数据的统计：\",\"在preHandle方法中记录请求的开始时间startTime\",\"在afterCompletion方法中，统计请求的次数和请求耗时，\",\"完整的代码如下：\",\"package io.github.forezp.prometheuslab.aop; import io.prometheus.metrics.core.metrics.Counter; import io.prometheus.metrics.core.metrics.Histogram; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ApiStatInterceptor extends HandlerInterceptorAdapter { Counter counter = Counter.builder() .name(\\\"http_count_total\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); Histogram histogram = Histogram.builder() .name(\\\"http_count_seconds\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); request.setAttribute(\\\"startTime\\\", startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { long startTime = (Long) request.getAttribute(\\\"startTime\\\"); long endTime = System.currentTimeMillis(); String uri=request.getRequestURI(); counter.labelValues(uri,\\\"ok\\\").inc(); histogram.labelValues(uri,\\\"ok\\\").observe(endTime-startTime); } } \",\"然后将ApiStatInterceptor注册到WebMvcConfigurer中：\",\"@Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new ApiStatInterceptor()); } } \",\"开启HTTPServer，并已bean的形式注册：\",\" @Bean public HTTPServer createHttpServer() throws IOException { HTTPServer server = HTTPServer.builder() .port(9400) .buildAndStart(); return server; } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后在浏览器上访问http://localhost:9400/metrics，可以看到有两个指标http_count_total和http_count_seconds，指标数据如下：\",\"# HELP http_count_total example counter # TYPE http_count_total counter http_count_total{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2.0 # HELP http_count_seconds example counter # TYPE http_count_seconds histogram http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.005\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.01\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.025\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.05\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.1\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.25\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"1.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"2.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"5.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"10.0\\\"} 1 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"+Inf\\\"} 2 http_count_seconds_count{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2 http_count_seconds_sum{status=\\\"ok\\\",uri=\\\"/hello\\\"} 44.0 \"]},\"99\":{\"h\":\"配置Prometheus采集\",\"t\":[\"在Springboot的项目中增加springboot指标的采集，配置如下：\",\"scrape_configs: - job_name: \\\"springboot\\\" static_configs: - targets: [\\\"localhost:9400\\\"] \",\"配置完成后，重新启动prometheus或者热加载，重新加载一下配置。\"]},\"100\":{\"h\":\"配置grafana视图\",\"t\":[\"在grafana中为Springboot项目配置试图，比如配置每分钟的请求量，配置的表达式如下：\",\"sum(increase(http_count_total{}[1m]))by (uri) \",\"image-20231021115719027\",\"配置请求的p95耗时，配置的表达式如下：\",\"histogram_quantile(0.95,sum(increase(http_count_seconds_bucket{}[1m]))by(uri,le)) \",\"image-20231021115611700\"]},\"101\":{\"h\":\"Prometheus告警与Alertmanager实战\",\"t\":[\"Prometheus的告警分为两部分内容：\",\"Prometheus server中的告警规则、告警发送。\",\"告警消息的处理程序Alertmanager，Alertmanager的主要功能包括告警消息的分组、路由分发、抑制和静默等核心功能\",\"工作流程包括：\",\"配置和启动Alertmanager\",\"在Prometheus server中配置Alertmanager的地址，用于向Alertmanager发送告警消息\",\"在Prometheus server中配置告警规则\",\"一个简单版的Prometheus的架构图如下：\",\"image-20231021170507878\",\"Prometheus作为采集端，采集Node-exporter、sdk client的数据\",\"Prometheus作为存储端，起到了时序数据库的作用，存储采集到的数据\",\"同时Prometheus读取告警规则文件，在进程内部计算告警规则，如果有告警发生，则向Alertmanager发送告警消息\",\"Alertmanager作为告警收敛的组件，在它内部进行告警消息的管理，最终将消息发送给第三方组件，通常是webhook\",\"最后webhook发送给告警平台。\",\"在前面的文章已经讲解过Prometheus采集数据和查询数据，在本篇文章中将会讲述Prometheus告警与Alertmanager实战。\"]},\"102\":{\"h\":\"Alertmanager介绍\",\"t\":[\"Alertmanager处理来自客户端的告警消息，例如Prometheus server，包括消息的去重、分组、路由、抑制和静默等核心功能。先了解这些核心概念，然后通过配置文件的形式来具体讲解。\"]},\"103\":{\"h\":\"分组\",\"t\":[\"分组是将同一组多个的相同的告警消息合并成一个高级消息。这在系统出现大量故障的时候非常有用，如果系统发出成千上万条相同的告警消息，对处理者来说是一个灾难。\",\"比如，某个数据库出现网络故障，导致连接它的应用的几百个实例都出现异常，如果不进行分组合并，则会出现几百上千的告警消息，很可能淹没掉一些其他的告警消息，导致告警处理者漏处理一些告警消息，从而导致一些系统问题。\",\"分组是\",\"告警分组，告警时间间隔，以及告警的接受方式可以通过Alertmanager的配置文件进行配置\"]},\"104\":{\"h\":\"抑制\",\"t\":[\"抑制是当某一告警已经发出，可以停止重复发送由此告警引发的其它告警的机制。\",\"例如，当集群不可用访问出发了告警，通过Alertmanager的配置可以忽略与该集群有关的其它告警功能。这样可以避免接受一些与实际问题相关的告警。\"]},\"105\":{\"h\":\"静默\",\"t\":[\"静默提供了一个标签匹配的设置，如果告警消息符合匹配，Alertmanager则不会发送消息到下游。\",\"Alertmanager 通过配置文件去配置一些配置，然后通过命令行的方式的启动它。Alertmanager 可以在运行时重新加载其配置，通过向Alertmanager 进程发送 SIGHUP信号或者请求Alertmanager 的 /-/reload 接口（POST请求）。\"]},\"106\":{\"h\":\"Alertmanager安装\",\"t\":[\"下载地址：https://prometheus.io/download/\",\"启动alertmanager可以使用以下命令：\",\"./alertmanager --config.file=alertmanager.yml \",\"在启动之前，需要修改alertmanager的配置文件，默认的配置文件如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 30s group_interval: 5m repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"配置文件中包含了4个部分，分别是：\",\"全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容； 告警路由（route）：根据标签匹配，确定当前告警应该如何处理； 接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用； 抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生\"]},\"107\":{\"h\":\"配置讲解\",\"t\":[\"每个部分包含的可配置的参数很多，参数的配置会在以后的文章中讲解，在此篇文章只讲解最基础的和几个重要的配置：\",\"gloabl配置\",\"resolve_timeout\",\"当告警消息没有endTs这个时间戳参数时，Alertmanager会启动它的告警恢复逻辑。当启动告警恢复逻辑时，Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）。这个对于prometheus的告警消息来说，它会含有endTs这个时间戳参数，所以这个resolve_timeout对于prometheus的告警消息是不生效的。\",\"route配置\",\"group_by 默认alertname\",\"The labels by which incoming alerts are grouped together.\",\"将告警消息按照某个标签分组，比如按照alertname\",\"group_wait（default: 30s）\",\"How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) 一组告警第一次发送之前等待的时间。用于等待抑制告警，或等待同一组告警采集更多初始告警后一起发送。（一般设置为0秒 ~ 几分钟\",\"group_interval（default: 5m）\",\"How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) 一组已发送初始通知的告警接收到新告警后，再次发送通知前等待的时间（一般设置为5分钟或更多）\",\"repeat_interval（default: 4h）\",\"How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). 一条成功发送的告警，在再次发送通知之前等待的时间。 （通常设置为3小时或更长时间）。\",\"receivers配置\",\"Receiver可以集成邮箱、微信、邮箱等，本文使用webHook的方式，即Alertmanager通过http接口调用来发送告警消息。\",\"inhibit_rules 配置\",\"抑制允许根据另一组警报的存在来静音一组警报。这允许在系统或服务之间建立依赖关系，以便在中断期间仅发送一组互连警报中最相关的警报。\",\"当存在与另一组匹配器匹配的警报（源）时，禁止规则会静音与一组匹配器匹配的警报（目标）。目标警报和源警报在相等列表中的标签名称必须具有相同的标签值。\",\"inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"比如当发生severity=critical的告警时，会屏蔽掉severity=warning的告警，前提条件是两个告警的alertname、dev、instance的标签值相等。\",\"根据实际情况，最终我的配置修改成如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 10s group_interval: 30s repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:8080/webhook' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"重新启动alertmanager，获取通过热加载的方式重新加载配置文件。\",\"在浏览器中访问localhost:9093，可以看到alertmanager的界面。\"]},\"108\":{\"h\":\"在prometheus中配置告警规则\",\"t\":[\"在prometheus的启动程序的同级目录下面，建一个first_rule.yml的文件，这个文件是告警规则计算的配置，内容如下：\",\"groups: - name: test rules: - alert: HighQps expr: sum(increase(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m])) > 1 for: 1m labels: severity: page env: test region: wuhan annotations: summary: HighQps description: '{{ $value }}' \",\"在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：\",\"alert：告警规则的名称。\",\"expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。\",\"for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。\",\"labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。\",\"annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。\",\"在Prometheus的配置文件中，增加告警规则的配置：\",\"alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:909 rule_files: - ./first_rule.yml \",\"最好创建一个目录专门存储告警规则文件，然后用*.yml去配置所有的告警规则文件。\",\"访问Prometheus的规则文件界面（http://127.0.0.1:9090/rules），可以看到的规则状态如下：\",\"image-20231021174512876\",\"等待1分钟，访问Prometheus的告警页面界面（http://127.0.0.1:9090/alerts?search=），可以看到已经有一条告警消息已经发送给Alertmanager\",\"image-20231021174854220\"]},\"109\":{\"h\":\"Alertmanager查看告警消息\",\"t\":[\"访问alertmanager的界面（http://localhost:9093/#/alerts），显示告警消息已经收到：\",\"image-20231021174948512\"]},\"110\":{\"h\":\"webhook\",\"t\":[\"Alertmanager收到告警消息后，如果判断需要发送消息给下游的Webhook程序，将通过POST的http请求发送下游程序，发送的告警消息的JSON格式如下：\",\"https://prometheus.io/docs/alerting/latest/configuration/#webhook_config\",\"{ \\\"version\\\": \\\"4\\\", \\\"groupKey\\\": <string>, // key identifying the group of alerts (e.g. to deduplicate) \\\"truncatedAlerts\\\": <int>, // how many alerts have been truncated due to \\\"max_alerts\\\" \\\"status\\\": \\\"<resolved|firing>\\\", \\\"receiver\\\": <string>, \\\"groupLabels\\\": <object>, \\\"commonLabels\\\": <object>, \\\"commonAnnotations\\\": <object>, \\\"externalURL\\\": <string>, // backlink to the Alertmanager. \\\"alerts\\\": [ { \\\"status\\\": \\\"<resolved|firing>\\\", \\\"labels\\\": <object>, \\\"annotations\\\": <object>, \\\"startsAt\\\": \\\"<rfc3339>\\\", \\\"endsAt\\\": \\\"<rfc3339>\\\", \\\"generatorURL\\\": <string>, // identifies the entity that caused the alert \\\"fingerprint\\\": <string> // fingerprint to identify the alert }, ... ] } \",\"对应的Java实体如下：\",\" public class Webhook { public String receiver; public String status; public ArrayList<Alert> alerts; public Map<String,String> groupLabels; public Map<String,String> commonLabels; public Map<String,String> commonAnnotations; public String externalURL; public String version; public String groupKey; public int truncatedAlerts public static class Alert { public String status; public Map<String,String> labels; public Map<String,String> annotations; public Date startsAt; public Date endsAt; public String generatorURL; public String fingerprint; } } \",\"在Springboot项目中，写一个接口如下：\",\" @PostMapping(\\\"/webhook\\\") public String webhook(@RequestBody Webhook webhook) { logger.info(webhook.toString()); return \\\"ok\\\"; } \",\"这样webhook的程序收到告警消息后，就可以具体的执行告警逻辑，比如将告警消息发送给运维人员的邮箱。\"]},\"111\":{\"h\":\"参考文档\",\"t\":[\"https://blog.csdn.net/qq_37843943/article/details/120665690\",\"https://www.jianshu.com/p/c661e8050434\",\"https://blog.51cto.com/starsliao/5763175\",\"https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/prometheus-alert-rule\"]},\"112\":{\"h\":\"Prometheus预处理计算-Recording Rule\",\"t\":[\"prometheus支持两种规则表达式，一种是告警告警规则表达式，另外一种是预计算规则recording rule。recording rule是预先计算成本较高的表达式，并将计算结果保存在一组新的时间序列上。预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多。\"]},\"113\":{\"h\":\"定义Recoding rules\",\"t\":[\"Prometheus会定时的根据拉取expr定时表达式的数据，并将数据的结果存储在新的时间序列中，新的序列名称为record中的值。如果expr表达式的计算结果包含标签，则会把标签添加到新的序列中，如果labels配置中含有额外的标签也会放到新的timeseries中。\",\"和alert rule类似，每个Recording rule的规则定义如下：\",\"groups: - name: example rules: - record: job:http_inprogress_requests:sum expr: sum(http_inprogress_requests) by (job) \",\"rule_group可以配置两个参数：\",\"name，group的名称，需要全局唯一\",\"interval, rule_group执行的时间间隔，如果没有配置，则默认是global.evaluation_interval\",\"Groups.rules选项是recording-rule的具体配置，可以有以下几个配置项：\",\"record ： expr执行后生成新的指标的名称，指标名称的定义可以参考下面一小节\",\"expr：具体预处理生成指标的表达式。\",\"labels：可以在新生成的指标上额外加一些标签。\",\"记录和告警规则存在于规则组中。组内的规则以固定的时间间隔按顺序运行，评估时间相同。记录规则的名称必须是有效的指标名称。警报规则的名称必须是有效的标签值。\",\"另外如果没有配置groups的interval配置，recording的计算规则和alert的计算规则，都可以通过以下配置，进行全局的计算频次的设置：\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"114\":{\"h\":\"recording rule的最佳实践\",\"t\":[\"recording rule的命令规范很重要，一个好的命名规范可以一目了然的知道规则的含义，避免出现一些无意义的计算。\"]},\"115\":{\"h\":\"命名规范\",\"t\":[\"通过recording rule产生的新的指标，应该遵循通用的方式：level:metric:operations\",\"level 表示聚合的级别和规则标签的输出\",\"metric 是和预聚合前的名称保存一致\",\"Operations 是应用于指标的操作函数列表，最新的操作函数在前。\",\"当对counter类型使用rate或者是irate操作，去掉_total的后缀\",\"当对指标用作除法,并且是求百分数，可以使用_per_\",\"例如：\",\"- record: instance_path:requests:rate5m expr: rate(requests_total{job=\\\"myjob\\\"}[5m]) \",\"上面的表达式rate(requests_total{job=\\\"myjob\\\"}[5m])，有两个标签分别是instance和path，所以它的level可以命名为instance_path；对meric使用了rate操作将metric原来的名称去掉_total；最后使用是rate操作\",\"最终根据上面的表达式得到的指标的名称是instance_path:requests:rate5m；我们可以根据指标的名称可以反推出指标的表达式，这样真的一目了然。\",\"其他例子：\",\"- record: instance_path:request_failures:rate5m expr: rate(request_failures_total{job=\\\"myjob\\\"}[5m]) - record: instance_path:request_failures_per_requests:ratio_rate5m expr: |2 instance_path:request_failures:rate5m{job=\\\"myjob\\\"} / instance_path:requests:rate5m{job=\\\"myjob\\\"} # Aggregate up numerator and denominator, then divide to get path-level ratio. - record: path:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) # No labels left from instrumentation or distinguishing instances, # so we use 'job' as the level. - record: job:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance, path)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance, path)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) \"]},\"116\":{\"h\":\"实战\",\"t\":[\"新建一个recoding_rule.yml的文件，在文件中写一个指标聚合的表达式，该表达式的计算时间间隔为1分钟，表达式的含义是计算每分钟handler=\\\"/metrics\\\"的请求量，另外在新生成的指标上添加一个新的标签region，具体表达式格式如下：\",\"groups: - name: recording_rule interval: 1m rules: - record: instance_handler_code:prometheus_http_requests:rate1m expr: sum(rate(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m]) )by(instance,handler,code) labels: region: wuhan \",\"在Prometheus的yaml配置文件中，通过rule_files定义recoding rule规则文件的路径。\",\"rule_files: - ./first_rule.yml - ./recoding_rule.yml \",\"重新启动Prometheus，在Prometheus的页面上可以查看新指标的数据，如下：\",\"image-20231023210926364\"]},\"117\":{\"h\":\"理解可见性、原子性、有序性\"},\"118\":{\"h\":\"为什么会有可见性、原子性、有序性的问题\",\"t\":[\"再回答这个问题之前，我们先看看计算机系统的基本组成部分：CPU、内存和I/O 设备。\",\"CPU（中央处理器）是计算机中的核心部件，负责执行指令、进行数学运算和控制数据流。CPU是整个计算机系统的\\\"大脑\\\"，决定了系统的性能和处理能力。\",\"内存（RAM）是计算机用来临时存储数据和程序的地方，它与CPU之间通过总线进行通信。内存的大小直接影响系统的运行速度和能够同时执行的任务数量。\",\"I/O 设备（输入/输出设备）包括磁盘、显示器、硬盘驱动器、网络适配器等。这些设备负责将数据从计算机系统的内存传输到外部世界，或者将外部数据传输到系统内存中。\",\"CPU、内存、I/O 设备三者相互协作，但是它们之间有一个核心矛盾，就是这三者的处理速度差异非常大。\",\"CPU 可以在纳秒级别完成一条指令的处理，具有非常高的计算能力和响应速度。\",\"内存的访问时间通常在纳秒数量级，比起 CPU 的处理速度，仍然是一个瓶颈。\",\"许多 I/O 设备的响应时间（例如硬盘读取时间）可以达到毫秒甚至更长的时间，这与 CPU 和内存的速度相比慢了很多。\",\"为了充分利用CPU的高性能，最大程度地提高计算机系统的整体性能，会采取一些优化策略：\",\"CPU增加了缓存，以减轻与内存的速度差异。缓存能够存储经常使用的数据与指令，从而减少对内存的频繁访问，提高了CPU的工作效率。\",\"操作系统增加了进程与线程，以分时复用CPU，从而平衡CPU与I/O设备的速度差异。操作系统能够合理地分配CPU资源，同时处理I/O设备的输入输出请求，充分利用CPU的处理能力。\",\"编译程序优化指令执行次序，以更好地利用缓存。通过合理安排指令执行的顺序，可以减少缓存未命中的次数，提高程序的运行效率。\",\"虽然这些改进使得大多数程序能够在现代计算机系统上获得较好的性能，但并发程序仍会面临一些挑战，需要特别注意并发编程中的可见性、原子性和有序性问题，以确保程序的正确性和稳定性。\"]},\"119\":{\"h\":\"缓存导致的可见性问题\",\"t\":[\"可见性（Visibility）：指的是当一个线程修改了共享变量的值时，其他线程能否立即看到这个修改。如果不同线程对同一变量的操作不是可见的，就可能导致数据不一致，从而引发Bug。\",\"image-20231209115348572\",\"举个可见性导致程序bug的例子。定义了一个静态整型变量a。在main方法中，创建了两个线程t1和t2，它们分别对变量a进行5000次自增操作。随后分别启动这两个线程，然后使用join()方法等待它们执行结束。最后输出变量a的值。代码如下：\",\"package io.github.forezp.concurrentlab.basic; public class IPlusDemo { static int a; public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 5000; i++) { a++; } } }); Thread t2=new Thread(new Runnable() { @Override public void run() { for (int i = 0; i < 5000; i++) { a++; } } }); t1.start(); t2.start(); t1.join(); //主线程阻塞，直到t1执行完 t2.join(); //主线程阻塞，直到t2执行完 System.out.println(\\\"a=\\\"+a); } } \",\"如果我们没有搞清楚并发编程的原理，直觉会告诉我们程序的执行结果是10000。运行程序，程序输出：\",\"a=7128\",\"为什么我们的预期和程序时机的输出会有差异呢，这是因为t1和t2线程共同对变量a进行自增操作，存在并发访问的情况。这样做可能导致竞态条件（Race Condition）的发生，即多个线程并发访问共享的资源（此处是变量a），从而导致程序的输出不确定。\",\"在这个特定的例子中，由于a++操作实际上包含了读取a的当前值、增加1和写回a的新值这三个步骤，两个线程同时执行这个操作可能会产生不确定的结果，因为线程之间的执行顺序不确定，线程对共享变量的操作是不可见的。这就是缓存可见性的问题。\"]},\"120\":{\"h\":\"线程切换带来的原子问题\",\"t\":[\"线程切换是指操作系统在多任务环境下，将当前正在执行的线程暂停下来，然后将另一个处于就绪状态的线程恢复执行的过程。在多核处理器系统中，线程切换还可能涉及将线程从一个处理器核心迁移到另一个核心。线程切换的目的是实现多任务并发执行，让多个任务看上去同时在运行，从而充分利用系统资源并提高系统的整体吞吐量。\",\"线程切换的过程可能包括保存当前线程的上下文信息（如寄存器状态、程序计数器等）、恢复另一个线程的上下文信息、更新调度相关的数据结构等操作。这些操作需要消耗一定的系统资源，因此过多的线程切换可能导致系统性能下降。因此，在编写并发程序时，需要注意尽量减少不必要的线程切换，从而提高系统的效率。\",\"线程切换也可能带来原子性问题。\",\"原子性（Atomicity）：指的是对共享变量的操作是不可分割的，要么全部执行成功，要么全部不执行。如果一个操作不是原子的，那么在多线程环境下就可能发生竞态条件，导致数据错误。\",\"在高级语言中，一条简单的语句可能会被编译成多条底层的CPU指令来执行。例如，对于语句a += 1，在底层执行时至少会包括三个步骤：\",\"首先，需要将变量count从内存加载到CPU的寄存器；\",\"然后，在寄存器中执行加1的操作；\",\"最后，将结果写回到内存（可能通过CPU缓存而不是直接写入内存）。\",\"如下图所示，当我们在多线程环境下对共享变量a进行a+=1操作时，有可能发生线程切换：\",\"image-20231209160829989\",\"两个线程分别对共享变量进行a+=1操作，我们期望的最终a的结果是2，但发生上图线程切换的时候，最终的结果是1。这就是线程切换带来的原子性的问题。\",\"在并发编程中，**CPU能够保证的原子操作是CPU指令级别的，而不是高级语言中的操作符。**这意味着在多核CPU上，即使某个操作在高级语言层面看起来是单个操作，底层实际上可能会被拆分成多条指令，在多线程并发执行时可能会发生竞态条件等问题。\"]},\"121\":{\"h\":\"编译优化带来的有序性问题\",\"t\":[\"有序性指的是程序按照代码的先后顺序执行。然而，编译器为了优化性能，有时会重新排列代码中语句的执行顺序。例如，程序中的\\\"a=1; b=2;\\\"在编译优化后可能会变成\\\"b=2; a=1;\\\"，尽管语句的顺序发生变化，但最终结果并不受影响。然而，编译器和解释器的优化有时可能会导致意想不到的错误。\",\"例如，在之前的设计模式的单例模式中，双重检查的单例模式，代码如下：\",\"public class LazyInstance { private static volatile LazyInstance instance; private LazyInstance() { } public static LazyInstance getInstance() { if (instance == null) { synchronized (LazyInstance.class) { if (instance == null) { instance = new LazyInstance(); } } } return instance; } } \",\"在上面的代码中，为什么要使用volatile关键字来修饰静态的instance对象呢？\",\"这是因为防止编译器进行编译优化，从而导致程序的有序性问题。\",\"在java中创建一个对象，需要如下几步，伪代码如下：\",\"memory=allocate(); //1：分配内存空间 ctorInstance(); //2:初始化对象 singleton=memory; //3:设置singleton指向刚分配的内存空间 \",\"当线程1在执行上面伪代码时，2和3可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以JVM是允许的。如果此时伪代码发生重排序，步骤变为1->3->2，线程1执行到第3步时，线程2调用getsingleton方法，在判断singleton==null时不为null，则返回singleton。但此时singleton并还没初始化完毕，线程2访问的将是个还没初始化完毕的对象。这时程序会出错！\",\"当声明对象的引用为volatile后，伪代码的2、3的重排序在多线程中将被禁止!\"]},\"122\":{\"h\":\"总结\",\"t\":[\"要写出高质量的并发程序，首先需要深刻理解并发程序可能出现的问题，并有针对性地解决这些问题。只有明确了问题的本质，才能够找到解决方案。\",\"并发编程中经常出现的令人难以理解的问题，实际上都源于对可见性、原子性和有序性的理解出现偏差。只有理解这些原则在并发场景下的应用，才能够理解并诊断许多并发 Bug。\"]},\"123\":{\"h\":\"Java内存模式以及volatile详解\",\"t\":[\"在并发编程中，可见性、原子性和有序性的问题常常让我们感到困惑，因为这些问题容易成为 Bug 的源头。早在诞生之初，Java就在多线程方面处于领先地位，并提供了针对这些问题的技术方案。\",\"今天先聊聊Java如何解决多线程下解决可见性和有序性问题。在此之前，先聊聊Java内存模型。\"]},\"124\":{\"h\":\"Java内存模型\",\"t\":[\"随着计算机CPU运算能力的迅速增长，CPU已经远远超越了主内存读取数据的速度。为了解决这个问题，CPU厂商引入了高速缓存，使得CPU能够直接从高速缓存中读取数据，从而达到更高的性能。然而，在多核CPU中，每个处理器都有自己的缓存，这引发了数据一致性的问题。为了确保多核处理器的数据一致性，需要引入多处理器数据一致性协议，例如MOSI、Synapse、Firely、DragonProtocol等。这些协议帮助确保处理器之间的数据一致性，以避免出现意外的错误和不一致的状态。\",\"JMM内存模型.png\",\"在JVM执行多线程任务时，共享数据存储在主内存中，而每个线程（在不同的处理器上执行）都拥有自己的高速缓存。当线程对共享数据进行修改时，首先会将数据从主内存复制到线程的高速缓存中，进行修改操作后再将结果从高速缓存复制回主内存。然而，当多个线程同时进行这样的操作时，可能会导致共享数据出现意外的错误。\",\"举个例子，比如执行i++操作，线程首先从主内存读取i的值，比如i=0，然后复制到自己的高速缓存区，进行i++操作，最后将结果再次从高速缓存区复制回主内存。如果有两个线程同时对i进行i++操作，预期的结果应该是2。然而实际上可能并非如此。线程1读取主内存的i=0后，线程2也读取i=0进行i++操作，最终导致结果为1而不是2。\",\"为了解决缓存不一致的问题，有两种解决方案：\",\"在总线上加锁，即只允许一个线程执行对共享数据的操作（包括读取和修改）。\",\"使用缓存一致性协议，如Intel的MESI协议。该协议的核心思想是，当某个处理器写入变量数据时，如果其他处理器也包含该变量，会发出信号通知其他处理器将高速缓存中的该数据设置为无效状态。这样其他处理器在需要读取该变量时，会重新从主内存中读取，然后再次复制到高速缓存区。\",\"这样就可以确保多线程在共享数据时不会出现意外的错误。\"]},\"125\":{\"h\":\"编发编程的概念\",\"t\":[\"再简单回顾一些上一篇文章讲解的并发编程的有三个概念，包括原子性、可见性、有序性。\"]},\"126\":{\"h\":\"原子性\",\"t\":[\"原子性是指，操作为原子性的，要么成功，要么失败，不存在第三种情况。比如：\",\"String s=\\\"abc\\\"; \",\"这个复杂操作是原子性的。再比如：\",\"int i=0; i++; \",\"i=0这是一个赋值操作，这一步是原子性操作；那么i++是原子性操作吗？当然不是，首先它需要读取i=0，然后需要执行运算，写入i的新值1，它包含了读取和写入两个步骤，所以不是原子性操作。\"]},\"127\":{\"h\":\"可见性\",\"t\":[\"可见性是指共享数据的时候，一个线程修改了数据，其他线程知道数据被修改，会重新读取最新的主存的数据。 举个例子：\",\"i=0;//主内存 i++;//线程1 j=i;//线程2 \",\"线程1修改了i值，但是没有将i值复制到主内存中，线程2读取i的值，并将i的值赋值给j,我们期望j=1,但是由于线程1修改了，没有来得及复制到主内存中，线程2读取了i,并赋值给j，这时j的值为0。 也就是线程i值被修改，其他线程并不知道。\"]},\"128\":{\"h\":\"有序性\",\"t\":[\"是指代码执行的有序性，因为代码有可能发生指令重排序（Instruction Reorder）。\",\"Java 语言提供了 volatile 和 synchronized 两个关键字来线程代码操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 在单线程中执行代码，无论指令是否重排，最终的执行结果是一致的。\"]},\"129\":{\"h\":\"volatile详解\"},\"130\":{\"h\":\"volatile关键字作用\",\"t\":[\"被volatile关键字修饰变量，起到了2个作用：\",\"1.某个线程修改了被volatile关键字修饰变量是，根据数据一致性的协议，通过信号量，更改其他线程的高速缓存中volatile关键字修饰变量状态为无效状态，其他线程如果需要重写读取该变量会再次从主内存中读取，而不是读取自己的高速缓存中的。\",\"2.被volatile关键字修饰变量不会指令重排序。\"]},\"131\":{\"h\":\"volatile能够保证可见性和防止指令重排\",\"t\":[\"在Java并发编程实战一书中有这样\",\"public class NoVisibility { private static boolean ready; private static int a; public static void main(String[] args) throws InterruptedException { new ReadThread().start(); Thread.sleep(100); a = 32; ready = true; } private static class ReadThread extends Thread { @Override public void run() { while (!ready) { Thread.yield(); } System.out.println(a); } } } \",\"在上述代码中，有可能（概率非常小，但是有这种可能性）永远不会打印a的值，因为线程ReadThread读取了主内存的ready为false,主线程虽然更新了ready，但是ReadThread的高速缓存中并没有更新。 另外：\",\"a = 32;\",\"ready = true;\",\"这两行代码有可能发生指令重排。也就是可以打印出a的值为0。\",\"如果在变量加上volatile关键字，可以防止上述两种不正常的情况的发生。\"]},\"132\":{\"h\":\"volatile不能保证原子性\",\"t\":[\"首先用一段代码测试下，开起了10个线程，这10个线程共享一个变量inc（被volatile修饰），并在每个线程循环1000次对inc进行inc++操作。我们预期的结果是10000.\",\"public class VolatileTest { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) throws InterruptedException { final VolatileTest test = new VolatileTest(); for (int i = 0; i < 10; i++) { new Thread(() -> { for (int j = 0; j < 1000; j++) test.increase(); }).start(); } //保证前面的线程都执行完 Thread.sleep(3000); System.out.println(test.inc); } } \",\"多次运行main函数，你会发现结果永远都不会为10000，都是小于10000。可能有这样的疑问，volatile保证了共享数据的可见性，线程1修改了inc变量线程2会重新从主内存中重新读，这样就能保证inc++的正确性了啊，可为什么没有得到我们预期的结果呢？\",\"在之前已经讲述过inc++这样的操作不是一个原子性操作，它分为读、加加、写。一种情况，当线程1读取了inc的值，还没有修改，线程2也读取了，线程1修改完了，通知线程2将线程的缓存的 inc的值无效需要重读，可这时它不需要读取inc ，它仍执行写操作，然后赋值给主线程，这时数据就会出现问题。\",\"所以volatile不能保证原子性 。这时需要用锁来保证,在increase方法加上synchronized，重新运行打印的结果为10000 。\",\" public synchronized void increase() { inc++; } \"]},\"133\":{\"h\":\"volatile的使用场景\"},\"134\":{\"h\":\"状态标记\",\"t\":[\"volatile最常见的使用场景是状态标记，如下：\",\"private volatile boolean asheep ; //线程1 while(!asleep){ countSheep(); } //线程2 asheep=true; \"]},\"135\":{\"h\":\"防止指令重排\",\"t\":[\"volatile boolean inited = false; //线程1: context = loadContext(); inited = true; //上面两行代码如果不用volatile修饰，可能会发生指令重排，导致报错 //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context); \"]},\"136\":{\"h\":\"Happens-Before 规则\",\"t\":[\"“Happens-Before” 是 Java 内存模型中定义的一个重要概念，用于描述多线程环境中内存操作的顺序和可见性。在多线程编程中，Happens-Before 规则的关键在于确保并发操作的顺序性和可见性。同时，Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。\",\"具体来说，Happens-Before 规则规定了以下几种情况，需要程序员重点掌握：\",\"程序次序规则：一个线程内的每一个操作，Happens-Before 于该线程内的后续操作。\",\"监视器锁规则：对一个锁的解锁操作，Happens-Before 于随后对这个锁的加锁操作。\",\"volatile 变量规则：对一个 volatile 变量的写操作，Happens-Before 于随后对这个变量的读操作。\",\"传递性：如果 A Happens-Before B，且 B Happens-Before C，则 A Happens-Before C。\",\"除了之前提到的基本规则之外，Happens-Before 还涉及到一些具体的应用场景和含义：\",\"线程启动规则：一个线程 A 启动另一个线程 B，A 线程启动操作的 Happens-Before 关系于 B 线程的任意操作。\",\"线程中断规则：对线程 interrupt() 方法的调用 Happens-Before 于被中断线程中的任意操作。\",\"终结器规则：对象的构造函数执行 Happens-Before 于该对象的 finalize() 方法。\",\"线程终结规则：所有的线程中的操作 Happens-Before 于该线程的终结。\"]},\"137\":{\"h\":\"参考资料\",\"t\":[\"《Java 并发编程实战》\",\"《深入理解JVM》\",\"海子的博客：http://www.cnblogs.com/dolphin0520/p/3920373.html\"]},\"138\":{\"h\":\"Java死锁详解\",\"t\":[\"死锁是指两个或多个线程互相等待对方释放资源而无法继续执行的情况。在 Java 中，死锁通常发生在多个线程同时持有多个锁的情况下，导致彼此相互等待对方释放锁。\"]},\"139\":{\"h\":\"Java死锁示例\",\"t\":[\"以下是一个简单的 Java 死锁示例：\",\"package io.github.forezp.concurrentlab.deadlock; public class DeadLock1 { public static void main(String[] args) throws InterruptedException { Account a1 = new Account(100); Account a2 = new Account(100); Thread t1 = new Thread(new Runnable() { @Override public void run() { a1.fundTransfer(a2, 10); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { a2.fundTransfer(a1, 10); } }); t1.start(); t2.start(); t1.join(); t2.join(); } static class Account { private int fund; public Account(int fund) { this.fund = fund; } void fundTransfer(Account account, int transferMoney) { synchronized (this) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (account) { this.fund = this.fund + transferMoney; account.fund = account.fund - transferMoney; } } } } } \",\"死锁示例图\",\"上面的代码展示了一个典型的死锁情况。在DeadLock1类中，我们有两个Account对象：a1和a2，每个对象都有一定数量的资金。Account类包含一个方法fundTransfer，用于从一个账户向另一个账户转移一定金额的资金。\",\"在main方法中，我们创建了两个线程（t1和t2），分别执行两个账户之间的资金转移。t1线程调用a1.fundTransfer(a2, 10)，而t2线程调用a2.fundTransfer(a1, 10)。在fundTransfer方法中，我们可以看到以下代码块：\",\"synchronized (this) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (account) { this.fund = this.fund + transferMoney; account.fund = account.fund - transferMoney; } } \",\"在这段代码中，我们使用synchronized关键字来同步代码块。线程先获取当前对象（this）的锁，然后在休眠100毫秒后，试图获取account对象的锁。在main方法中，t1线程获取了a1对象的锁，而t2线程获取了a2对象的锁。但是，每个线程在进行资金转移时都试图获取对方对象（即a2和a1）的锁。\",\"这种情况下可能会发生死锁。因为线程t1持有a1对象的锁，正在等待获取a2对象的锁，而线程t2持有a2对象的锁，正在等待获取a1对象的锁。这样就形成了循环等待的死锁情况，两个线程都无法继续执行，程序会停止响应。\"]},\"140\":{\"h\":\"死锁发生的条件\",\"t\":[\"死锁是指在并发程序中，两个或多个线程因竞争资源而陷入无限等待的状态。死锁发生一般需要满足四个条件，即下面所述的死锁发生条件：\",\"互斥条件（Mutual Exclusion）：共享资源 X 和 Y 只能被一个线程占用；\",\"占有且等待（Hold and Wait）：线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；\",\"不可抢占（No Preemption）：其他线程不能强行抢占线程 T1 占有的资源；\",\"循环等待条件（Circular Wait）：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。\",\"当以上四个条件同时满足时，就有可能发生死锁。只要避免其中一个条件，就能够预防死锁的发生。在编程中，要解决或避免死锁，需要合理地设计资源分配策略、锁使用策略，并充分考虑线程之间的依赖关系和顺序。\"]},\"141\":{\"h\":\"如何避免死锁\",\"t\":[\"在上面死锁发生的四个条件中，\",\"确实，我们可以通过破坏死锁发生条件中的三个条件来避免死锁的发生。下面是对这三个条件的反向分析，并提供解决方法：\",\"破坏占有且等待（Hold and Wait）：一种方法是使用资源分配策略，即一次性申请所有所需的资源。这意味着在开始执行之前，线程必须成功地获取所有需要的资源，不允许等待。另一种方法是资源预分配，即在开始执行之前，线程一次性获取它所需的所有资源，并且不会释放这些资源直到线程完成任务。\",\"破坏不可抢占（No Preemption）：在某些情况下，资源可以被强制剥夺并重新分配给其他线程。这可以通过引入资源的优先级和超时机制来实现。当其他线程请求被当前线程持有的资源时，如果当前线程在一定时间内没有完成任务，资源可以被剥夺并分配给等待的线程。\",\"破坏循环等待条件（Circular Wait）：通过为资源定义线性顺序，可以避免循环等待。线程在申请资源时必须按照相同的顺序申请，即先申请资源序号较小的，再申请资源序号较大的。这样可以避免线程之间的循环等待。\"]},\"142\":{\"h\":\"破坏占有且等待\",\"t\":[\"把死锁转账的例子进行改造：\",\"package io.github.forezp.concurrentlab.deadlock; import java.util.ArrayList; import java.util.List; public class DeadLockDemo2 { public static void main(String[] args) throws InterruptedException { ResManager resManager = new ResManager(); Account a1 = new Account(resManager, 100); Account a2 = new Account(resManager, 100); Thread t1 = new Thread(new Runnable() { @Override public void run() { a1.fundTransfer(a2, 10); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { a2.fundTransfer(a1, 10); } }); t1.start(); t2.start(); t1.join(); t2.join(); } static class ResManager { private List<Account> list = new ArrayList<>(); synchronized boolean apply(Account res1, Account res2) { if (list.contains(res1) || list.contains(res2)) { return false; } else { list.add(res1); list.add(res2); } return true; } synchronized void release(Account res1, Account res2) { list.remove(res1); list.remove(res2); } } static class Account { ResManager resManager; private int fund; public Account(ResManager resManager, int fund) { this.resManager = resManager; this.fund = fund; } void fundTransfer(Account account, int transferMoney) { while (!resManager.apply(this, account)) { } try { synchronized (this) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (account) { this.fund = this.fund + transferMoney; account.fund = account.fund - transferMoney; System.out.println(\\\"fundTransfer success\\\"); } } } finally { resManager.release(this, account); } } } } \",\"上面的代码展示了一个使用资源管理器（ResManager）来避免死锁的例子。在DeadLockDemo2类中，我们有两个Account对象（a1和a2），每个对象都有一定数量的资金。在这里，我们引入了ResManager类来管理资源的申请和释放。\",\"在main方法中，创建了两个线程（t1和t2），分别执行两个账户之间的资金转移。在ResManager类中，apply方法用于申请资源，release方法用于释放资源。在Account类的fundTransfer方法中，使用ResManager来避免死锁。具体来说：\",\"在fundTransfer方法中，通过resManager.apply(this, account)来申请资源，如果资源申请不成功，即返回false，线程会一直循环等待直到资源可用。这里一次性申请性申请了所有的资源，破换了占有且等待条件\",\"在执行资金转移操作时，先获取ResManager的锁，然后再获取账户之间资金转移所需的锁。在转移完成后，释放资源。\"]},\"143\":{\"h\":\"破坏循环等待条件\",\"t\":[\"再看一下破坏循环等待条件的例子：\",\" public class DeadLockDemo3 { public static void main(String[] args) throws InterruptedException { Account a1 = new Account(100, 1); Account a2 = new Account(100, 3); Thread t1 = new Thread(new Runnable() { @Override public void run() { a1.fundTransfer(a2, 10); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { a2.fundTransfer(a1, 10); } }); t1.start(); t2.start(); t1.join(); t2.join(); } private static class Account { private int fund; private int id; public Account(int fund, int id) { this.fund = fund; this.id = id; } void fundTransfer(Account account, int transferMoney) { Account account1; Account account2; if (this.id < account.id) { account1 = this; account2 = account; } else { account1 = account; account2 = this; } synchronized (account1) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (account2) { this.fund = this.fund + transferMoney; account.fund = account.fund - transferMoney; System.out.println(\\\"fundTransfer success\\\"); } } } } } \",\"上面的代码展示了另一种避免死锁的方式。在DeadLockDemo3类中，我们依然有两个Account对象（a1和a2），每个对象都有一定数量的资金。在Account类中，我们通过比较id字段的大小，决定获取锁的顺序。具体来说：\",\"在main方法中，创建了两个线程（t1和t2），分别执行两个账户之间的资金转移。\",\"在fundTransfer方法中，通过比较当前账户和目标账户的id字段，决定获取锁的顺序。如果当前账户的id小于目标账户的id，先获取当前账户的锁，再获取目标账户的锁；反之，顺序相反。\",\"在完成资源获取后，执行资金转移操作，并释放锁。\",\"通过这种方式，我们通过线性化的方式来获取锁，避免了遇到不同顺序而导致的循环等待，从而避免了死锁的发生。\",\"需要注意的是，这种方式假设每个账户具有唯一的id，且id是确定的、不会发生变化的。否则，可能会导致获取锁的顺序不一致，无法成功避免死锁。\"]},\"144\":{\"h\":\"Java synchronized关键字详解\"},\"145\":{\"h\":\"synchronized关键字的作用\",\"t\":[\"synchronized 是 Java 中用于实现线程互斥和同步的关键字。它可以应用于方法或代码块，用于保护共享资源，以避免并发访问导致的数据不一致性。\",\"具体而言，synchronized 的作用有以下几个方面：\",\"互斥性：使用 synchronized 关键字可以确保在同一时间只有一个线程可以执行被 synchronized 修饰的方法或代码块，从而避免多个线程同时访问临界资源导致的数据竞争。保证了原子性。\",\"可见性：synchronized 不仅提供了互斥性，还提供了可见性。当一个线程进入 synchronized 块时，它将会获取锁，并且在释放锁之前，它会将对共享变量的修改刷新到主内存中，从而保证其他线程读取到最新的值。\",\"内存屏障效果：synchronized 还会在进入和退出 synchronized 块时，自动插入内存屏障（Memory Barrier），这个内存屏障具有特殊的作用，可以禁止在 synchronized 块内部和外部的指令重排序，保证了代码的顺序性。保证了有序性。\",\"synchronized 关键字的作用是确保多线程环境下共享资源的正确访问和数据的一致性。它解决了线程安全问题，并提供了互斥性、可见性和顺序性保证。\"]},\"146\":{\"h\":\"使用示例\",\"t\":[\"当使用 synchronized 关键字时，可以通过以下两种方式来实现线程同步：\",\"同步方法（Synchronized Methods）： 在方法声明时使用 synchronized 关键字，这将使整个方法成为一个临界区，只有一个线程可以进入执行方法，其他线程需要等待该线程执行完毕后才能继续执行。\",\"public synchronized void methodName() { // 这里是需要线程同步的代码块 } \",\"同步代码块（Synchronized Blocks）： 在代码块内部使用 synchronized 关键字，只对特定的代码块进行同步，而非整个方法。这样可以减少同步的范围，提高多线程程序的性能。\",\"public void methodName() { // 非同步的代码块 synchronized (object) { // 这里是需要线程同步的代码块 } // 非同步的代码块 } \",\"无论是同步方法还是同步代码块，都需要一个共享的对象作为锁。这个对象可以是任何 Java 对象，如类的实例变量、类的静态变量或者常量。只有当线程获取到锁时，才能执行同步代码块内部的操作。其他线程需要等待锁的释放。\",\"以下是一个示例，演示了如何使用 synchronized 来实现线程同步：\",\"public class SynchronizedExample { private int count = 0; private Object lock = new Object(); public synchronized void increment() { count++; } public void doWork() { // 非同步的代码块 synchronized (lock) { // 需要线程同步的代码块 increment(); } // 非同步的代码块 } } \",\"在上面的示例中，通过 synchronized 关键字保证了 increment() 方法的原子性操作，以及同步代码块内的操作。这样就能确保多个线程对 count 变量的访问是安全的，不会出现数据不一致的情况。\"]},\"147\":{\"h\":\"Synchronized原理\",\"t\":[\"临界区是指一个需要互斥执行的代码段，只允许一个线程进入临界区执行。为了确保线程安全，需要使用锁机制来保护临界区。\",\"当线程想要进入临界区时，首先会尝试获取锁（通过调用lock()方法）。如果当前没有其他线程持有锁，则该线程成功获取锁并进入临界区，此时称为该线程持有锁。如果锁已经被其他线程持有，则该线程将进入等待状态，直到持有锁的线程解锁。\",\"synchronized关键字并没有显示的为临界区执行加锁和解锁的步骤。\",\"Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样有助于避免忘记解锁而导致的问题。这种自动处理的方式简化了代码编写，同时减少了潜在的错误。\",\"我们先来了解Synchronized的原理，我们先通过反编译下面的代码来看看Synchronized是如何实现对代码块进行同步的。\",\"package io.github.forezp.concurrentlab.synchro; public class SynchronizedDemo { public void method() { synchronized (this) { System.out.println(\\\"Method 1 start\\\"); } } } \",\"先执行javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class，我们就可以看到上面类的字节码信息：\",\"image-20231210110738038\",\"其中我们需要关注monitorenter和monitorexit的指令含义，直接参考JVM规范中描述：\",\"monitorenter ：\",\"每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：\",\"1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\",\"2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\",\"3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\",\"monitorexit：\",\"执行monitorexit的线程必须是objectref所对应的monitor的所有者。\",\"指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。\",\"通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。\",\"再来看一下同步方法：\",\" public class SynchronizedMethod { public synchronized void method() { System.out.println(\\\"Hello World!\\\"); ] } } \",\"反编译查看字节码如下：\",\"img\",\"从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。\"]},\"148\":{\"h\":\"synchronized优化\",\"t\":[\"Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。\",\"当线程不能获取锁的时候，就会阻塞，这时会有线程切换的开销，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。\",\"因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。\"]},\"149\":{\"h\":\"对象头\",\"t\":[\"对象头的内容非常多这里我们只做简单介绍以引出后文。在 JVM 中对象布局分为三块区域：\",\"对象头\",\"实例数据\",\"对齐填充\",\"img\",\"当线程访问同步块时首先需要获得锁并把相关信息存储在对象头中。对象头的Mark Word：存储自身的运行时数据，例如 HashCode、GC 年龄、锁相关信息等内容，如下：\",\"从JDK6开始，对synchronized的实现机制进行了较大调整，包括引入了CAS自旋、自适应的CAS自旋、锁消除、锁粗化、偏向锁和轻量级锁等一系列优化策略。\",\"总体上来说锁状态升级流程如下：\",\"img\"]},\"150\":{\"h\":\"偏向锁\",\"t\":[\"偏向锁是一种用于减少同步操作的开销的优化技术。它的设计思想是假定大多数情况下，锁总是由同一线程多次获得，因此在该线程第一次获得锁后，JVM会将这个锁标记为偏向锁。\",\"之后，当该线程再次请求这个锁时，无需进行同步操作，因为JVM已经假定该线程会继续拥有锁。\",\"只有当其他线程请求锁时，偏向锁才会撤销，改为轻量级锁等其他形式的锁。\",\"通过偏向锁，JVM避免了每次加锁和解锁时都需要竞争的情况，从而减少了不必要的开销，提高了程序的性能。这项优化特别适用于线程独占锁的场景，例如在GUI应用程序中，通常只有一个事件调度线程会访问某些部件，因此偏向锁能够有效地减少竞争和加锁解锁操作。\"]},\"151\":{\"h\":\"轻量级锁\",\"t\":[\"在使用轻量级锁的情况下，当一个线程请求锁时，不会立即阻塞，而是判断该锁对象是否被其他线程持有。\",\"如果没有其他线程持有该锁对象，当前线程会将锁的对象头记录下来，并将对象头的标记设置为轻量级锁。这样，该线程就可以在接下来的操作中直接操作被锁定的对象，而无需进行互斥同步。\",\"如果在这个过程中发现有其他线程竞争锁对象，当前线程会尝试通过自旋来获取锁，而不是进行线程阻塞，从而减少了不必要的上下文切换和线程阻塞时间。\",\"轻量级锁的优化策略适用于短期的同步操作，当竞争不激烈时，可以大幅度提高性能。但是当竞争激烈时，自旋操作可能会导致额外的开销，因此在这种情况下，轻量级锁会自动膨胀成重量级锁，使用传统的互斥同步方式。\"]},\"152\":{\"h\":\"重量级锁\",\"t\":[\"重量级锁是一种传统的同步机制，用于实现多线程对共享资源的互斥访问。当多个线程竞争同一个锁对象时，只能有一个线程获取到锁，其他线程需要等待，直到锁被释放。\",\"在使用重量级锁的情况下，当一个线程请求锁时，如果发现锁对象已被其他线程持有，则当前线程会被阻塞，进入等待状态，直到锁被释放。这种阻塞的机制会导致线程的上下文切换，增加了线程的延迟和系统开销，因此重量级锁在竞争激烈的情况下可能会影响性能。\",\"重量级锁的实现通常需要依赖底层的操作系统特性，如互斥量、信号量等，以保证对共享资源的互斥访问。在JVM中，重量级锁是通过监视器（monitor）实现的，每个对象都会有一个对应的监视器，用于管理对该对象的同步访问。\",\"尽管重量级锁在竞争激烈的情况下可能会带来性能开销，但它具有较强的功能和稳定性，适用于高并发场景中对资源访问的严格控制和保护。为了避免性能问题，使用重量级锁时应尽量减少锁的持有时间，避免不必要的阻塞。此外，Java中提供了一些其他的同步机制，如读写锁、可重入锁等，可以根据具体需求选择合适的锁机制来优化性能。\",\"重量级锁、轻量级锁和偏向锁之间转换\",\"img\",\"该图主要是对上述内容的总结，如果对上述内容有较好的了解的话，该图应该很容易看懂。\",\"锁\",\"优点\",\"缺点\",\"适用场景\",\"偏向锁\",\"加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。\",\"如果线程间存在锁竞争，会带来额外的锁撤销的消耗。\",\"适用于只有一个线程访问同步块场景。\",\"轻量级锁\",\"竞争的线程不会阻塞，提高了程序的响应速度。\",\"如果始终得不到锁竞争的线程使用自旋会消耗CPU。\",\"追求响应时间。\",\"同步块执行速度非常快。\",\"重量级锁\",\"线程竞争不使用自旋，不会消耗CPU。\",\"线程阻塞，响应时间缓慢。\",\"追求吞吐量。\",\"同步块执行速度较长。\"]},\"153\":{\"h\":\"synchronized的优化一览表\",\"t\":[\"锁的细粒度控制：可以尽量缩小 synchronized 关键字的范围，只对必要的代码块进行同步，这样可以减少线程间的竞争，提高并发性能。\",\"使用局部变量：如果在 synchronized 代码块内部使用局部变量而不是共享变量，可以减少对共享资源的访问次数，从而减少锁的竞争。\",\"使用同步块而不是同步方法：在某些情况下，使用同步块而不是同步方法可以提高性能。同步方法会对整个方法进行同步，而同步块可以控制同步范围更加细致。\",\"使用读写锁：如果共享资源在读操作上存在更多的并发访问，可以考虑使用读写锁来替代传统的 synchronized 锁，以提高并发读取的性能。\",\"使用 volatile 替代 synchronized：如果只需要保证可见性，而不需要互斥性，可以考虑使用 volatile 关键字来代替 synchronized，因为 volatile 有较低的开销。\",\"使用自旋锁：如果对共享资源的争用时间很短，可以考虑使用自旋锁来减少线程阻塞和切换的开销。自旋锁会让线程在一个循环内忙等待，直到获取到锁或达到一定的等待时间。\",\"适应性自旋（Adaptive Spinning）：JDK 6 引入了适应性自旋的机制。当一个线程尝试获取锁时，如果发现该锁被其他线程持有，它会进行一段短暂的自旋（忙等待），而不是立即阻塞和切换线程。适应性自旋的时间会根据当前环境的运行态势自动调整。这种方式可以减少线程阻塞和切换的开销，适用于短暂的锁竞争。\",\"锁粗化（Lock Coarsening）：JVM 可以将多个连续的加锁与解锁操作合并成一个更大的同步代码块，从而减少锁竞争的次数。这种优化技术可以避免频繁的锁释放和获取操作带来的开销。\",\"锁消除（Lock Elimination）：JVM 对代码进行静态分析，发现某些对象不可能被其他线程访问到时，会进行锁消除的优化。这意味着可以将不必要的同步操作消除，从而减少了不必要的锁竞争。\",\"偏向锁（Biased Locking）：JDK 5 引入了偏向锁的概念，它可以提升无竞争情况下的性能。偏向锁会在第一个线程获得锁后，将对象头中的标志位设置为偏向模式，并在之后的加锁解锁操作中免去互斥操作。这对于大多数情况下只有一个线程访问对象的场景非常有效。\",\"轻量级锁（Lightweight Locking）：JDK 6 引入了轻量级锁机制，用于优化对同步块的访问。轻量级锁使用 CAS（比较并交换）指令来进行加锁和解锁操作，避免了线程阻塞和内核切换的开销。\",\"这些优化技术在 JDK 中的实现使得 synchronized 关键字的性能有了较大的提升，使其成为高效的线程同步机制之一。\"]},\"154\":{\"h\":\"Thread状态、使用详解\"},\"155\":{\"h\":\"Thread状态\",\"t\":[\"Java的线程状态总共有六种，在Thread类的枚举类State中，总共有6种状态，代码如下：\",\" public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } \",\"每种状态代表的含义如下表所示：\",\"线程状态\",\"解释\",\"NEW\",\"尚未启动的线程状态，即线程创建，还未调用start方法\",\"RUNNABLE\",\"就绪状态（调用start，等待调度）+正在运行\",\"BLOCKED\",\"等待监视器锁时，陷入阻塞状态\",\"WAITING\",\"等待状态的线程正在等待另一线程执行特定的操作（如notify）\",\"TIMED_WAITING\",\"具有指定等待时间的等待状态\",\"TERMINATED\",\"线程完成执行，终止状态\",\"上面的六种状态代码了一个线程从创建、运行、阻塞、终止的各个状态，代表了线程的生命周期。每种状态都是可以扭转的，状态的扭转如下图所示：\",\"image-20231211225833220\"]},\"156\":{\"h\":\"New（新建状态）\",\"t\":[\"用new关键字新建一个线程，这个线程就处于新建状态。\",\" public static void main(String[] args) { Thread newThread=new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }); System.out.println(\\\"newThread state:\\\"+newThread.getState()); } \",\"执行上面代码，代码输出的线程状态为NEW，代码如下：\",\"newThread state:NEW\"]},\"157\":{\"h\":\"Runnable\",\"t\":[\"在操作系统中，线程的就绪和运行是两种不同的状态。在Java中，这两种状态都被统称为RUNNABLE。\",\"当线程调用start()方法时，新建状态的线程会转换为就绪状态。\",\"当线程调用sleep(long)方法并等待指定的时间到期后，等待状态的线程会转换为就绪状态。\",\"当阻塞式IO操作的结果返回时，阻塞状态的线程会转换为就绪状态。这\",\"当其他线程调用某个线程的join()方法，并且该线程执行完毕后，被等待的线程会转换为就绪状态。\",\"当线程拥有对象的锁时，等待获取该锁的其他线程会转换为就绪状态。\",\"在Java中，线程状态会受到操作系统的调度和资源限制。一旦线程处于就绪状态，它可以被操作系统调度为运行状态。然而，并非所有就绪状态的线程都会立即获得CPU时间片。\",\"运行状态的线程则表示正在CPU上执行计算任务。\",\" public static void main(String[] args) { Thread t=new Thread(new Runnable() { @Override public void run() { System.out.println(Thread.currentThread().getName()); } }); t.start(); System.out.println(\\\"newThread started, state=\\\"+t.getState()); } \",\"执行上面的代码，运行的结果如下：\",\"Thread-0 newThread started, state=RUNNABLE\"]},\"158\":{\"h\":\"blocked\",\"t\":[\"阻塞状态（Blocked）：用于处理资源竞争情况下的线程等待，等待获取对象的锁以继续执行。\",\"线程执行synchronized同步方法或者synchronized同步代码块时，如果没有获取到锁，将会被阻塞。\",\"public class ThreadStateTest2 { public static void main(String[] args) { Thread thread=new Thread(new Runnable() { @Override public void run() { synchronized (ThreadStateTest2.class){ System.out.println(Thread.currentThread().getName()); } } }); thread.start(); synchronized (ThreadStateTest2.class){ try { Thread.sleep(50); System.out.println(\\\"thread state =\\\"+thread.getState()); } catch (InterruptedException e) { e.printStackTrace(); } } } } \",\"在上面的示例中，主线程启动子线程之后，立刻执行了同步代码块代码 ，获取了锁；而子线程的由于没有获取锁，处于阻塞状态。这时获取子线程的状态为BLOCKED状态，输出如下：\",\"thread state =BLOCKED Thread-0\"]},\"159\":{\"h\":\"wait\",\"t\":[\"程在等待某个特定条件的发生，需要其他线程通过唤醒操作才能继续执行，用于线程间的异步通信和协作，等待某个条件的发生。\",\"线程执行了特定的等待操作（如wait()、join()等），使线程处于等待状态。\",\"需要其他线程显式地调用相应的唤醒操作（如notify()、notifyAll()）才能将等待状态的线程转换为就绪状态。\",\"package io.github.forezp.concurrentlab.thread; public class ThreadStateTest3 { public static void main(String[] args) { final Object lock = new Object(); Thread thread = new Thread(new Runnable() { @Override public void run() { synchronized (lock) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()); } } }); thread.start(); try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lock) { System.out.println(\\\"thread state =\\\" + thread.getState()); lock.notify(); } try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } \",\"执行上面代码，输出如下：\",\"thread state =WAITING Thread-0\"]},\"160\":{\"h\":\"两个线程交替打印奇数和偶数\",\"t\":[\"\\\"两个线程交替打印奇数和偶数\\\"，这时一个非常常见的面试题：\",\"package io.github.forezp.concurrentlab.thread; public class ThreadDemo4 { static int i = 0; public static void main(String[] args) { Object lock = new Object(); Thread t1 = new Thread( new Runnable() { @Override public void run() { while (true) { synchronized (lock) { if (i % 2 == 0) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\" i=\\\" + i); i++; lock.notifyAll(); } } } } ); Thread t2 = new Thread( new Runnable() { @Override public void run() { while (true) { synchronized (lock) { if (i % 2 == 1) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\" i=\\\" + i); i++; lock.notifyAll(); } } } } ); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } } } \",\"创建了两个线程t1和t2，它们通过共享的锁对象lock来实现交替打印奇数和偶数。\",\"具体来说，每个线程执行如下操作：\",\"进入一个无限循环，在循环内部使用synchronized (lock)来获取对共享锁对象lock的独占锁定。\",\"判断当前的计数i是偶数还是奇数，根据结果决定是否等待或执行打印操作，并将i的值递增。\",\"在打印完成后，调用lock.notifyAll()来唤醒其他因等待相同锁而处于暂停状态的线程，并释放锁。\",\"然后线程继续循环执行以上步骤。\",\"这是考察线程同步的例子，通过共享锁对象的wait()与notifyAll()方法来协调两个线程的执行顺序。从而达到交替打印奇偶输的目的。\"]},\"161\":{\"h\":\"Java并发技术AQS详解\"},\"162\":{\"h\":\"AQS简介\",\"t\":[\"AQS（AbstractQueuedSynchronizer）是一个用于构建锁和同步器的框架，它提供了一种基于FIFO等待队列的机制。AQS的设计使得开发者能够相对轻松地实现自定义的同步器，同时也为Java标准库中的诸如ReentrantLock、Semaphore、ReentrantReadWriteLock、SynchronousQueue、FutureTask等同步器提供了基础支持。\"]},\"163\":{\"h\":\"AQS核心思想\",\"t\":[\"AQS（AbstractQueuedSynchronizer）的核心思想是基于一个先进先出（FIFO）的等待队列来管理线程的争用，并通过内置的状态变量和原子操作来实现对共享资源的安全访问和控制。\",\"等待队列：AQS 使用一个先进先出的等待队列来管理等待获取同步器的线程。当某个线程无法获取到同步器时（如锁已被其他线程持有），它会被放入等待队列中，直到它能够获得同步器或者被中断。\",\"image-20231217171236598\",\"内置状态变量：AQS 内部维护了一个状态变量，用于表示同步器的状态。这个状态可以是自定义的，根据具体需求来决定如何利用这个状态来控制并发访问。\",\"private volatile int state;//共享变量，使用volatile修饰保证线程可见性 \",\"状态信息通过procted类型的getState，setState，compareAndSetState进行操作:\",\"//返回同步状态的当前值 protected final int getState() { return state; } // 设置同步状态的值 protected final void setState(int newState) { state = newState; } //原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值) protected final boolean compareAndSetState(int expect, int update) { return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } \",\"image-20231217172210727\",\"状态变迁与线程调度：AQS 负责管理线程的状态变迁，从而实现线程的调度和协作。当一个线程释放同步器时，AQS 会从等待队列中选取一个线程唤醒，使其进入就绪状态，然后与其他就绪状态的线程竞争执行权。\"]},\"164\":{\"h\":\"AQS 对资源的共享方式\",\"t\":[\"AQS定义两种资源共享方式\",\"Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： \",\"公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\",\"非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\",\"Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\",\"ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。\",\"不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。\"]},\"165\":{\"h\":\"AQS源码解析\"},\"166\":{\"h\":\"类的继承关系\",\"t\":[\"public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable \",\"说明：从类继承关系可知，AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。而AbstractOwnableSynchronizer抽象类的源码如下\",\"public abstract class AbstractOwnableSynchronizer implements java.io.Serializable { // 版本序列号 private static final long serialVersionUID = 3737899427754241961L; // 构造函数 protected AbstractOwnableSynchronizer() { } // 独占模式下的线程 private transient Thread exclusiveOwnerThread; // 设置独占线程 protected final void setExclusiveOwnerThread(Thread thread) { exclusiveOwnerThread = thread; } // 获取独占线程 protected final Thread getExclusiveOwnerThread() { return exclusiveOwnerThread; } } \",\"AbstractOwnableSynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。\"]},\"167\":{\"h\":\"类的内部类\",\"t\":[\"AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类。下面分别做介绍。\"]},\"168\":{\"h\":\"Node类\",\"t\":[\"static final class Node { // 模式，分为共享与独占 // 共享模式 static final Node SHARED = new Node(); // 独占模式 static final Node EXCLUSIVE = null; // 结点状态 // CANCELLED，值为1，表示当前的线程被取消 // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中 // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行 // 值为0，表示当前节点在sync队列中，等待着获取锁 static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; // 结点状态 volatile int waitStatus; // 前驱结点 volatile Node prev; // 后继结点 volatile Node next; // 结点所对应的线程 volatile Thread thread; // 下一个等待者 Node nextWaiter; // 结点是否在共享模式下等待 final boolean isShared() { return nextWaiter == SHARED; } // 获取前驱结点，若前驱结点为空，抛出异常 final Node predecessor() throws NullPointerException { // 保存前驱结点 Node p = prev; if (p == null) // 前驱结点为空，抛出异常 throw new NullPointerException(); else // 前驱结点不为空，返回 return p; } // 无参构造函数 Node() { // Used to establish initial head or SHARED marker } // 构造函数 Node(Thread thread, Node mode) { // Used by addWaiter this.nextWaiter = mode; this.thread = thread; } // 构造函数 Node(Thread thread, int waitStatus) { // Used by Condition this.waitStatus = waitStatus; this.thread = thread; } } \",\"每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下。\",\"CANCELLED，值为1，表示当前的线程被取消。\",\"SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。\",\"CONDITION，值为-2，表示当前节点在等待condition，也就是在condition queue中。\",\"PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行。\",\"值为0，表示当前节点在sync queue中，等待着获取锁。\"]},\"169\":{\"h\":\"ConditionObject类\",\"t\":[\"此类实现了Condition接口，Condition接口定义了条件操作规范，具体如下：\",\"public interface Condition { // 等待，当前线程在接到信号或被中断之前一直处于等待状态 void await() throws InterruptedException; // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断 void awaitUninterruptibly(); //等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 long awaitNanos(long nanosTimeout) throws InterruptedException; // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于：awaitNanos(unit.toNanos(time)) > 0 boolean await(long time, TimeUnit unit) throws InterruptedException; // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态 boolean awaitUntil(Date deadline) throws InterruptedException; // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。 void signal(); // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。 void signalAll(); } \",\"Condition接口中定义了await、signal函数，用来等待条件、释放条件。之后会详细分析CondtionObject的源码。\"]},\"170\":{\"h\":\"类的属性\",\"t\":[\"public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable { // 版本号 private static final long serialVersionUID = 7373984972572414691L; // 头结点 private transient volatile Node head; // 尾结点 private transient volatile Node tail; // 状态 private volatile int state; // 自旋时间 static final long spinForTimeoutThreshold = 1000L; // Unsafe类实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // state内存偏移地址 private static final long stateOffset; // head内存偏移地址 private static final long headOffset; // state内存偏移地址 private static final long tailOffset; // tail内存偏移地址 private static final long waitStatusOffset; // next内存偏移地址 private static final long nextOffset; // 静态初始化块 static { try { stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\\\"state\\\")); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\\\"head\\\")); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(\\\"tail\\\")); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\\\"waitStatus\\\")); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(\\\"next\\\")); } catch (Exception ex) { throw new Error(ex); } } } \",\"属性中包含了头结点head，尾结点tail，状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址。\"]},\"171\":{\"h\":\"类的构造函数\",\"t\":[\"protected AbstractQueuedSynchronizer() { } \",\"此类构造函数为从抽象构造函数，供子类调用。\"]},\"172\":{\"h\":\"类的核心函数\"},\"173\":{\"h\":\"acquire函数\",\"t\":[\"该函数以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下\",\"public final void acquire(int arg) { if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } \",\"由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下。\",\"img\",\"首先调用tryAcquire函数，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此函数完成自己的逻辑。之后会进行分析。\",\"若tryAcquire失败，则调用addWaiter函数，addWaiter函数完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。\",\"调用acquireQueued函数，此函数完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。\",\"由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。\",\"首先分析addWaiter函数\",\"// 添加等待者 private Node addWaiter(Node mode) { // 新生成一个结点，默认为独占模式 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 保存尾结点 Node pred = tail; if (pred != null) { // 尾结点不为空，即已经被初始化 // 将node结点的prev域连接到尾结点 node.prev = pred; if (compareAndSetTail(pred, node)) { // 比较pred是否为尾结点，是则将尾结点设置为node // 设置尾结点的next域为node pred.next = node; return node; // 返回新生成的结点 } } enq(node); // 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列 return node; } \",\"addWaiter函数使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下\",\"// 入队列 private Node enq(final Node node) { for (;;) { // 无限循环，确保结点能够成功入队列 // 保存尾结点 Node t = tail; if (t == null) { // 尾结点为空，即还没被初始化 if (compareAndSetHead(new Node())) // 头结点为空，并设置头结点为新生成的结点 tail = head; // 头结点与尾结点都指向同一个新生结点 } else { // 尾结点不为空，即已经被初始化过 // 将node结点的prev域连接到尾结点 node.prev = t; if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node // 设置尾结点的next域为node t.next = node; return t; // 返回尾结点 } } } } \",\"enq函数会使用无限循环来确保节点的成功插入。\",\"现在，分析acquireQueue函数。其源码如下\",\" // sync队列中的结点在独占且忽略中断的模式下获取(资源) final boolean acquireQueued(final Node node, int arg) { // 标志 boolean failed = true; try { // 中断标志 boolean interrupted = false; for (;;) { // 无限循环 // 获取node节点的前驱结点 final Node p = node.predecessor(); if (p == head && tryAcquire(arg)) { // 前驱为头结点并且成功获得锁 setHead(node); // 设置头结点 p.next = null; // help GC failed = false; // 设置标志 return interrupted; } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } \",\"首先获取当前节点的前驱节点，如果前驱节点是头结点并且能够获取(资源)，代表该当前节点能够占有锁，设置头结点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt函数，首先，我们看shouldParkAfterFailedAcquire函数，代码如下\",\"// 当获取(资源)失败后，检查并且更新结点状态 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { // 获取前驱结点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 状态为SIGNAL，为-1 /* * This node has already set status asking a release * to signal it, so it can safely park. */ // 可以进行park操作 return true; if (ws > 0) { // 表示状态为CANCELLED，为1 /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); // 找到pred结点前面最近的一个状态不为CANCELLED的结点 // 赋值pred结点的next域 pred.next = node; } else { // 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 比较并设置前驱结点的状态为SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } // 不能进行park操作 return false; } \",\"只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt函数，源码如下\",\"// 进行park操作并且返回该线程是否被中断 private final boolean parkAndCheckInterrupt() { // 在许可可用之前禁用当前线程，并且设置了blocker LockSupport.park(this); return Thread.interrupted(); // 当前线程是否已被中断，并清除中断标记位 } \",\"parkAndCheckInterrupt函数里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire函数，其源码如下\",\"// 取消继续获取(资源) private void cancelAcquire(Node node) { // Ignore if node doesn't exist // node为空，返回 if (node == null) return; // 设置node结点的thread为空 node.thread = null; // Skip cancelled predecessors // 保存node的前驱结点 Node pred = node.prev; while (pred.waitStatus > 0) // 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点 node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. // 获取pred结点的下一个结点 Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. // 设置node结点的状态为CANCELLED node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail && compareAndSetTail(node, pred)) { // node结点为尾结点，则设置尾结点为pred结点 // 比较并设置pred结点的next节点为null compareAndSetNext(pred, predNext, null); } else { // node结点不为尾结点，或者比较设置不成功 // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head && ((ws = pred.waitStatus) == Node.SIGNAL || (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) && pred.thread != null) { // （pred结点不为头结点，并且pred结点的状态为SIGNAL）或者 // pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空 // 保存结点的后继 Node next = node.next; if (next != null && next.waitStatus <= 0) // 后继不为空并且后继的状态小于等于0 compareAndSetNext(pred, predNext, next); // 比较并设置pred.next = next; } else { unparkSuccessor(node); // 释放node的前一个结点 } node.next = node; // help GC } } \",\"该函数完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor函数，源码如下\",\"// 释放后继结点 private void unparkSuccessor(Node node) { /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ // 获取node结点的等待状态 int ws = node.waitStatus; if (ws < 0) // 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3 // 比较并且设置结点等待状态，设置为0 compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 获取node节点的下一个结点 Node s = node.next; if (s == null || s.waitStatus > 0) { // 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED // s赋值为空 s = null; // 从尾结点开始从后往前开始遍历 for (Node t = tail; t != null && t != node; t = t.prev) if (t.waitStatus <= 0) // 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点 // 保存结点 s = t; } if (s != null) // 该结点不为为空，释放许可 LockSupport.unpark(s.thread); } \",\"该函数的作用就是为了释放node节点的后继结点。\",\"对于cancelAcquire与unparkSuccessor函数，如下示意图可以清晰的表示。\",\"img\",\"其中node为参数，在执行完cancelAcquire函数后的效果就是unpark了s结点所包含的t4线程。\",\"现在，再来看acquireQueued函数的整个的逻辑。逻辑如下\",\"① 判断结点的前驱是否为head并且是否成功获取(资源)。\",\"② 若步骤①均满足，则设置结点为head，之后会判断是否finally模块，然后返回。\",\"③ 若步骤①不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。\",\"④ 若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。\"]},\"174\":{\"h\":\"release\",\"t\":[\"以独占模式释放对象，其源码如下\",\"public final boolean release(int arg) { if (tryRelease(arg)) { // 释放成功 // 保存头结点 Node h = head; if (h != null && h.waitStatus != 0) // 头结点不为空并且头结点状态不为0 unparkSuccessor(h); //释放头结点的后继结点 return true; } return false; } \",\"说明：其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头结点不为空并且头结点的状态不为0，则释放头结点的后继结点，unparkSuccessor函数已经分析过，不再累赘。\",\"对于其他函数我们也可以分析，与前面分析的函数大同小异，所以，不再累赘。\"]},\"175\":{\"h\":\"手写一个AQS\",\"t\":[\"根据AQS的源码，我们手写一个简单的AQS，代码如下：\",\"package io.github.forezp.concurrentlab.aqs; import sun.misc.Unsafe; import java.lang.reflect.Field; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.locks.LockSupport; public class AQS { //用来记录当前加锁状态，记录加锁次数， //值为0/1，为1时表示已经有一个线程持有了锁 private volatile int state = 0; //表示当前只有锁的对象 private Thread localHolder; //定义一个线程安全(底层是使用CAS算法保证线程安全的)的队列，用于保存此时没有获取到锁的线程 private ConcurrentLinkedQueue<Thread> waiters = new ConcurrentLinkedQueue<>(); public int getState() { return state; } public void setState(int state) { this.state = state; } public Thread getLocalHolder() { return localHolder; } public void setLocalHolder(Thread localHolder) { this.localHolder = localHolder; } //尝试进行加锁的算法 public boolean acquire() { //CAS比较与交换算法，保证任意时刻只有一个线程可以拿到 //当前线程 Thread current = Thread.currentThread(); //获取到当前state初始值 int c = getState(); if (c == 0) { //目前锁还没有被持有 //如果等待队列中没有进程（实现公平锁）或者当前线程是等待队列中第一个线程，并且此线程修改成功了(加锁成功)，则设置持有锁的线程为本线程; if ((waiters.size() == 0 || current == waiters.peek()) && compareAndSwapState(0, 1)) { setLocalHolder(current); return true; } } return false; } //加锁 public void lock(){ //如果加锁成功 if(acquire()){ return; } //当前线程 Thread current = Thread.currentThread(); //没有获取成功，将线程放入等待队列中 waiters.add(current); //如果没有加锁成功，则使此线程一直自旋在本方法 for (;;){ //让步出线程 //1：Thread.yield();但是循环之后还是在占用cpu，不推荐 //2：Thread.sleep(1000);不推荐，原因如下 //（1）：设置时常大之后，其他线程已经释放锁，本线程还在睡眠，浪费时间 //（2）：设置时常小之后，导致不停的睡眠启动线程，系统开销大 //3：Thread.wait();不推荐，因为在唤醒线程的时候，无法准确指定唤醒那一个线程； //4：使用Unsafe类中的park()和unpark()方法，进行手动的释放和开启线程（此两种方法已经重写在了jdk的LockSupport类中） /* //jdk中的方法体 public static void park(Object blocker) { Thread t = Thread.currentThread(); setBlocker(t, blocker); U.park(false, 0L); setBlocker(t, (Object)null); } */ //判断当前线程是否是第一个等待的线程（保证公平），如果是则继续循环获取锁，获取成功跳出循环 if((current==waiters.peek()) && acquire()){ //第一个线程获取到锁之后，将它从等待队列中移除 waiters.poll(); return; } //阻塞当前线程（将此线程的所有数据放入内存中的运行时数据区） LockSupport.park(current); } } //解锁方法 public void unLock(){ //判断当前对象是不是之前拿到锁的对象 if(Thread.currentThread()!=localHolder){ throw new RuntimeException(\\\"LocalHolder is not current thread\\\"); } //将state和LocalHolder都置为空，表示当前锁空闲 int state = getState(); if(compareAndSwapState(state,0)){ setLocalHolder(null); //当前锁空闲后，如果等待队列中有线程，则唤醒此线程 Thread first = waiters.peek(); if(first!=null){ LockSupport.unpark(first); } } } /* * 原子操作。 * @param except:目前值 * @param update:要更新后的值 */ public final boolean compareAndSwapState(int except,int update){ return unsafe.compareAndSwapInt(this,stateOffset,except,update); } //通过反射机制获取到Unsafe对象 private static final Unsafe unsafe = UnsafeInstance.reflectGetUnsafe(); //在内存的偏移量值，因为CAS种需要此参数 private static long stateOffset; static { try { //找到state对象在内存中的偏移量 stateOffset = unsafe.objectFieldOffset(AQS.class.getDeclaredField(\\\"state\\\")); } catch (NoSuchFieldException e) { e.printStackTrace(); } } static class UnsafeInstance{ //获取Unsafe对象 public static Unsafe reflectGetUnsafe() { //通过反射机制获取到Unsafe类 Field field = null; try { field = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); field.setAccessible(true); return (Unsafe) field.get(null); } catch (Exception e) { e.printStackTrace(); } return null; } } } \"]},\"176\":{\"h\":\"参考资料\",\"t\":[\"https://www.cnblogs.com/leesf456/p/5350186.html\",\"https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html\",\"https://zhuanlan.zhihu.com/p/642177775\"]},\"177\":{\"h\":\"ReentrantLock源码解析\",\"t\":[\"在分析了AbstractQueuedSynchronier源码后，接下来将具体分析ReentrantLock的源码。\"]},\"178\":{\"h\":\"ReentrantLock数据结构\",\"t\":[\"ReentrantLock的底层数据结构是借助AbstractQueuedSynchronizer实现，所以ReentrantLock数据结构依附于AbstractQueuedSynchronizer的数据结构，关于AQS的数据结构，可以看前面的文章。\"]},\"179\":{\"h\":\"ReentrantLock类继承关系\",\"t\":[\"ReentrantLock的继承关系如下：\",\"public class ReentrantLock implements Lock, java.io.Serializable { } \",\"ReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个条件。Lock接口代码如下：\",\"public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition(); } \"]},\"180\":{\"h\":\"类的属性\",\"t\":[\"public class ReentrantLock implements Lock, java.io.Serializable { // 序列号 private static final long serialVersionUID = 7373984872572414699L; // 同步队列 private final Sync sync; } \",\"ReentrantLock类的Sync变量是实现Lock功能的关键，Sync继承了AbstractQueuedSynchronizer，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。\",\"ReentrantLock中的内部抽象类Sync继承了AbstractQueuedSynchronizer；而Sync有两个子类类分别为FairSync和NonfairSync。\"]},\"181\":{\"h\":\"类的构造函数\",\"t\":[\"无参构造函数默认使用非公平策略的锁：\",\" public ReentrantLock() { sync = new NonfairSync(); } \",\"有参构造函数，以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略。\",\" public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } \"]},\"182\":{\"h\":\"类的内部类\"},\"183\":{\"h\":\"Sync类\",\"t\":[\"abstract static class Sync extends AbstractQueuedSynchronizer { // 序列号 private static final long serialVersionUID = -5179523762034025860L; // 获取锁 abstract void lock(); // 非公平方式获取 final boolean nonfairTryAcquire(int acquires) { // 当前线程 final Thread current = Thread.currentThread(); // 获取状态 int c = getState(); if (c == 0) { // 表示没有线程正在竞争该锁 if (compareAndSetState(0, acquires)) { // 比较并设置状态成功，状态0表示锁没有被占用 // 设置当前线程独占 setExclusiveOwnerThread(current); return true; // 成功 } } else if (current == getExclusiveOwnerThread()) { // 当前线程拥有该锁 int nextc = c + acquires; // 增加重入次数 if (nextc < 0) // overflow throw new Error(\\\"Maximum lock count exceeded\\\"); // 设置状态 setState(nextc); // 成功 return true; } // 失败 return false; } // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) // 当前线程不为独占线程 throw new IllegalMonitorStateException(); // 抛出异常 // 释放标识 boolean free = false; if (c == 0) { free = true; // 已经释放，清空独占 setExclusiveOwnerThread(null); } // 设置标识 setState(c); return free; } // 判断资源是否被当前线程占有 protected final boolean isHeldExclusively() { // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); } // 新生一个条件 final ConditionObject newCondition() { return new ConditionObject(); } // Methods relayed from outer class // 返回资源的占用线程 final Thread getOwner() { return getState() == 0 ? null : getExclusiveOwnerThread(); } // 返回状态 final int getHoldCount() { return isHeldExclusively() ? getState() : 0; } // 资源是否被占用 final boolean isLocked() { return getState() != 0; } /** * Reconstitutes the instance from a stream (that is, deserializes it). */ // 自定义反序列化逻辑 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } \",\"Sync类存在如下方法和作用如下:\",\"img\"]},\"184\":{\"h\":\"NonfairSync类\",\"t\":[\"NonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法，源码如下。\",\"// 非公平锁 static final class NonfairSync extends Sync { // 版本号 private static final long serialVersionUID = 7316153563782823691L; // 获得锁 final void lock() { if (compareAndSetState(0, 1)) // 比较并设置状态成功，状态0表示锁没有被占用 // 把当前线程设置独占了锁 setExclusiveOwnerThread(Thread.currentThread()); else // 锁已经被占用，或者set失败 // 以独占模式获取对象，忽略中断 acquire(1); } protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } } \",\"从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。\"]},\"185\":{\"h\":\"FairSyn类\",\"t\":[\"FairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法，源码如下：\",\" static final class FairSync extends Sync { // 版本序列化 private static final long serialVersionUID = -3000897897090466540L; final void lock() { // 以独占模式获取对象，忽略中断 acquire(1); } /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ // 尝试公平获取锁 protected final boolean tryAcquire(int acquires) { // 获取当前线程 final Thread current = Thread.currentThread(); // 获取状态 int c = getState(); if (c == 0) { // 状态为0 if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) { // 不存在已经等待更久的线程并且比较并且设置状态成功 // 设置当前线程独占 setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { // 状态不为0，即资源已经被线程占据 // 下一个状态 int nextc = c + acquires; if (nextc < 0) // 超过了int的表示范围 throw new Error(\\\"Maximum lock count exceeded\\\"); // 设置状态 setState(nextc); return true; } return false; } } \",\"跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列（AbstractQueuedSynchronizer中的数据结构）是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。其中，FairSync类的lock的方法调用如下，只给出了主要的方法。\",\"img\",\"可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和Nonfair最大的区别，Nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。\"]},\"186\":{\"h\":\"ReentrantLock在Dubbo中的使用\",\"t\":[\"在Dubbo的DefaultFuture类中使用了ReentrantLock去实现以下的功能：\",\"当 RPC 返回结果之前，阻塞调用线程，让调用线程等待；\",\"当 RPC 返回结果后，唤醒调用线程，让调用线程重新执行。\",\"// 创建锁与条件变量 private final Lock lock = new ReentrantLock(); private final Condition done = lock.newCondition(); // 调用方通过该方法等待结果 Object get(int timeout){ long start = System.nanoTime(); lock.lock(); try { while (!isDone()) { done.await(timeout); long cur=System.nanoTime(); if (isDone() || cur-start > timeout){ break; } } } finally { lock.unlock(); } if (!isDone()) { throw new TimeoutException(); } return returnFromResponse(); } // RPC结果是否已经返回 boolean isDone() { return response != null; } // RPC结果返回时调用该方法 private void doReceived(Response res) { lock.lock(); try { response = res; if (done != null) { done.signal(); } } finally { lock.unlock(); } } \",\"这个方法里面，你看到的都是熟悉的“面孔”：调用 lock() 获取锁，在 finally 里面调用 unlock() 释放锁；获取锁后，通过经典的在循环中调用 await() 方法来实现等待。\",\"当 RPC 结果返回时，会调用 doReceived() 方法，这个方法里面，调用 lock() 获取锁，在 finally 里面调用 unlock() 释放锁，获取锁后通过调用 signal() 来通知调用线程，结果已经返回，不用继续等待了。\"]},\"187\":{\"h\":\"ReentrantLock使用示例\",\"t\":[\"使用ReentrantLock和condition实现一个阻塞队列，代码如下：\",\"package io.github.forezp.concurrentlab.lock; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ReentrantLockDemo2 { public static void main(String[] args) { BlockingQ queue = new BlockingQ(300); new Producer(queue).produce(300); new Producer(queue).produce(200); new Consumer(queue).consume(300); new Consumer(queue).consume(200); } static class BlockingQ { int size; int capacity; Lock lock = new ReentrantLock(); Condition full = lock.newCondition(); Condition empty = lock.newCondition(); public BlockingQ(int capacity) { this.capacity = capacity; } public void produce(int num) { lock.lock(); try { int left = num; while (left > 0) { while (size >= capacity) { System.out.println(Thread.currentThread() + \\\" before await\\\"); full.await(); System.out.println(Thread.currentThread() + \\\" after await\\\"); } int incr=(left + size) > capacity ? (capacity - size) : left; left -= incr; size += incr; System.out.println(\\\"produce = \\\" + incr + \\\", size = \\\" + size); empty.signal(); } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void consume(int no) { lock.lock(); int left = no; try { while (left > 0) { while (size <= 0) { System.out.println(Thread.currentThread() + \\\" before await\\\"); empty.await(); System.out.println(Thread.currentThread() + \\\" after await\\\"); } int dec = (size - left) > 0 ? left : size; left -= dec; size -= dec; System.out.println(\\\"consume = \\\" + dec + \\\", size = \\\" + size); full.signal(); } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } static class Consumer { private BlockingQ queue; public Consumer(BlockingQ queue) { this.queue = queue; } public void consume(int no) { new Thread(new Runnable() { @Override public void run() { queue.consume(no); } }, no + \\\" consume thread\\\").start(); } } static class Producer { private BlockingQ queue; public Producer(BlockingQ queue) { this.queue = queue; } public void produce(int no) { new Thread(new Runnable() { @Override public void run() { queue.produce(no); } }, no + \\\" produce thread\\\").start(); } } } \"]},\"188\":{\"h\":\"ReentrantLock的特点总结\",\"t\":[\"ReentrantLock 是 Java 中的一种可重入锁，具有以下特点：\",\"可重入性：允许同一个线程多次获取同一把锁而不发生死锁，使得同步代码块或方法在持有锁的情况下可以被多次进入。\",\"公平性控制：提供了公平锁和非公平锁的获取方式\",\"条件变量支持：通过 Condition 接口支持条件变量，使得线程能够在特定的条件下等待，并在条件满足时被唤醒，实现更灵活的线程协作机制。\",\"高度可定制性：支持各种操作的精确控制，如尝试获取锁、限时获取锁等\"]},\"189\":{\"h\":\"CountDownLatch源码解析\"},\"190\":{\"h\":\"CountDownLatch简介\",\"t\":[\"CountDownLatch 是 Java 并发包中提供的一种同步工具，它可以让一个或多个线程等待其他线程完成操作之后再继续执行。\",\"CountDownLatch 主要包括两个重要的方法：\",\"await(): 当一个线程调用 await() 方法时，它会被阻塞，直到计数器 count 减为 0，即其他线程已经完成任务，才能继续执行。\",\"countDown(): 每当一个线程完成了自己的任务时，需要调用 countDown() 方法使得计数器 count 减一，表示一个工作任务已经完成。\",\"通过这两个方法，可以实现线程之间的协调和同步，等待所有任务完成后再进行后续操作。\"]},\"191\":{\"h\":\"CountDownLatch使用示例\",\"t\":[\"假设有一个对账系统，订单量和派送单量巨大，需要查询订单和派单的数量，并执行对账操作。其中查询订单和派单是可以异步执行了，执行了这2个操作，再执行对账操作。\",\"其中一种写法，使用join函数：\",\"public class JoinDemo { public static void main(String[] args) throws InterruptedException { //查询订单 boolean hasOrder=true; while (hasOrder){ Thread t1=new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"查询订单\\\"); } }); //查询派单 Thread t2=new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"查询派单\\\"); } }); t1.start(); t2.start(); t1.join(); t2.join(); //执行对账 Thread.sleep(500); System.out.println(\\\"对账成功\\\"); System.out.println(\\\"---------\\\"); } } } \",\"在上面的代码中，创建了两个线程 T1 和 T2，并行执行查询未对账订单 和查询派送单 这两个操作。在主线程中执行对账操作。不过需要注意的是：主线程需要等待线程 T1 和 T2 执行完才能执行对账操作，为此我们通过调用 T1.join() 和 T2.join() 来实现等待，当 T1 和 T2 线程退出时，调用 T1.join() 和 T2.join() 的主线程就会从阻塞态被唤醒，从而执行之后的对账。\",\"但是有while 循环里面每次都会创建新的线程，而创建线程可是个耗时的操作。所以线程池就能解决这个问题。但是如果使用线程池就不能使用线程的Join()方法。\",\"我们可以使用一个计数器，初始值设置成 2，当执行完未对账订单 和查询派送单操作各减1，知道到0，才执行主线程的对账操作。\",\"在 Java 并发包里提供的CountDownLatch，也可以解决上面的问题，直接上代码：\",\"package io.github.forezp.concurrentlab.syntools; import io.github.forezp.concurrentlab.bfart.threadpool.ThreadPool; import java.util.concurrent.CountDownLatch; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CountDownLatchDemo2 { static ExecutorService executorService = Executors.newFixedThreadPool(2); public static void main(String[] args) throws InterruptedException { boolean hasOrder = true; while (hasOrder) { CountDownLatch latch=new CountDownLatch(2); //查询订单 executorService.submit(new Runnable() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"查询订单\\\"); latch.countDown(); } }); //查询派单 executorService.submit(new Runnable() { @Override public void run() { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\\\"查询派单\\\"); latch.countDown(); } }); latch.await(); //执行对账 Thread.sleep(500); System.out.println(\\\"对账成功\\\"); System.out.println(\\\"---------\\\"); } } } \",\"执行上面代码，输出：\",\"查询订单 查询派单\",\"对账成功\"]},\"192\":{\"h\":\"CountDownLatch源码解析\"},\"193\":{\"h\":\"CountDownLatch数据结构\",\"t\":[\"从源码可知，其底层是由AQS提供支持，所以其数据结构可以参考AQS的数据结构，而AQS的数据结构核心就是两个虚拟队列：同步队列sync queue 和条件队列condition queue，不同的条件会有不同的条件队列。读者可以参考之前介绍的AQS。\"]},\"194\":{\"h\":\"类的继承关系\",\"t\":[\"public class CountDownLatch {} \",\"可以看到CountDownLatch没有显示继承哪个父类或者实现哪个父接口，根据Java语言规定，可知其父类是Object。\"]},\"195\":{\"h\":\"类的属性\",\"t\":[\"public class CountDownLatch { // 同步队列 private final Sync sync; } \",\"可以看到CountDownLatch类的内部只有一个Sync类型的属性，这个属性相当重要，后面会进行分析。\"]},\"196\":{\"h\":\"类的构造函数\",\"t\":[\"CountDownLatch(int) 型构造函数：\",\"public CountDownLatch(int count) { if (count < 0) throw new IllegalArgumentException(\\\"count < 0\\\"); // 初始化状态数 this.sync = new Sync(count); } \",\"该构造函数可以构造一个用给定计数初始化的CountDownLatch，并且构造函数内完成了sync的初始化，并设置了状态数。\"]},\"197\":{\"h\":\"类的内部类\",\"t\":[\"CountDownLatch类存在一个内部类Sync，继承自AbstractQueuedSynchronizer，其源代码如下。\",\"private static final class Sync extends AbstractQueuedSynchronizer { // 版本号 private static final long serialVersionUID = 4982264981922014374L; // 构造器 Sync(int count) { setState(count); } // 返回当前计数 int getCount() { return getState(); } // 试图在共享模式下获取对象状态 protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } // 试图设置状态来反映共享模式下的一个释放 protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero // 无限循环 for (;;) { // 获取状态 int c = getState(); if (c == 0) // 没有被线程占有 return false; // 下一个状态 int nextc = c-1; if (compareAndSetState(c, nextc)) // 比较并且设置成功 return nextc == 0; } } } \",\"对CountDownLatch方法的调用会转发到对Sync或AQS的方法的调用，所以，AQS对CountDownLatch提供支持。\"]},\"198\":{\"h\":\"await函数\",\"t\":[\"此函数将会使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。其源码如下\",\" public void await() throws InterruptedException { // 转发到sync对象上 sync.acquireSharedInterruptibly(1); } \",\"源码可知，对CountDownLatch对象的await的调用会转发为对Sync的acquireSharedInterruptibly（从AQS继承的方法）方法的调用，acquireSharedInterruptibly源码如下\",\" public final void acquireSharedInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) < 0) doAcquireSharedInterruptibly(arg); } \",\"从源码中可知，acquireSharedInterruptibly又调用了CountDownLatch的内部类Sync的tryAcquireShared和AQS的doAcquireSharedInterruptibly函数。tryAcquireShared函数的源码如下\",\" protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1; } \",\"该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。doAcquireSharedInterruptibly函数的源码如下\",\" private void doAcquireSharedInterruptibly(int arg) throws InterruptedException { // 添加节点至等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try { for (;;) { // 无限循环 // 获取node的前驱节点 final Node p = node.predecessor(); if (p == head) { // 前驱节点为头结点 // 试图在共享模式下获取对象状态 int r = tryAcquireShared(arg); if (r >= 0) { // 获取成功 // 设置头结点并进行繁殖 setHeadAndPropagate(node, r); // 设置节点next域 p.next = null; // help GC failed = false; return; } } if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt()) // 在获取失败后是否需要禁止线程并且进行中断检查 // 抛出异常 throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } \",\"在AQS的doAcquireSharedInterruptibly中可能会再次调用CountDownLatch的内部类Sync的tryAcquireShared方法和AQS的setHeadAndPropagate方法。setHeadAndPropagate方法源码如下。\",\" private void setHeadAndPropagate(Node node, int propagate) { // 获取头结点 Node h = head; // Record old head for check below // 设置头结点 setHead(node); // 进行判断 if (propagate > 0 || h == null || h.waitStatus < 0 || (h = head) == null || h.waitStatus < 0) { // 获取节点的后继 Node s = node.next; if (s == null || s.isShared()) // 后继为空或者为共享模式 // 以共享模式进行释放 doReleaseShared(); } } \",\"该方法设置头结点并且释放头结点后面的满足条件的结点，该方法中可能会调用到AQS的doReleaseShared方法，其源码如下。\",\"private void doReleaseShared() { // 无限循环 for (;;) { // 保存头结点 Node h = head; if (h != null && h != tail) { // 头结点不为空并且头结点不为尾结点 // 获取头结点的等待状态 int ws = h.waitStatus; if (ws == Node.SIGNAL) { // 状态为SIGNAL if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续 continue; // loop to recheck cases // 释放后继结点 unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续 continue; // loop on failed CAS } if (h == head) // 若头结点改变，继续循环 break; } } \",\"该方法在共享模式下释放，具体的流程再之后会通过一个示例给出。所以，对CountDownLatch的await调用大致会有如下的调用链。\",\"img\",\"上图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\"]},\"199\":{\"h\":\"countDown函数\",\"t\":[\"此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程\",\"public void countDown() { sync.releaseShared(1); } \",\"对countDown的调用转换为对Sync对象的releaseShared（从AQS继承而来）方法的调用。releaseShared源码如下\",\" public final boolean releaseShared(int arg) { if (tryReleaseShared(arg)) { doReleaseShared(); return true; } return false; } \",\"此函数会以共享模式释放对象，并且在函数中会调用到CountDownLatch的tryReleaseShared函数，并且可能会调用AQS的doReleaseShared函数，其中，tryReleaseShared源码如下\",\" protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero // 无限循环 for (;;) { // 获取状态 int c = getState(); if (c == 0) // 没有被线程占有 return false; // 下一个状态 int nextc = c-1; if (compareAndSetState(c, nextc)) // 比较并且设置成功 return nextc == 0; } } \",\"此函数会试图设置状态来反映共享模式下的一个释放。具体的流程在下面的示例中会进行分析。AQS的doReleaseShared的源码如下\",\" private void doReleaseShared() { // 无限循环 for (;;) { // 保存头结点 Node h = head; if (h != null && h != tail) { // 头结点不为空并且头结点不为尾结点 // 获取头结点的等待状态 int ws = h.waitStatus; if (ws == Node.SIGNAL) { // 状态为SIGNAL if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) // 不成功就继续 continue; // loop to recheck cases // 释放后继结点 unparkSuccessor(h); } else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) // 状态为0并且不成功，继续 continue; // loop on failed CAS } if (h == head) // 若头结点改变，继续循环 break; } } \",\"此函数在共享模式下释放资源。\",\"所以，对CountDownLatch的countDown调用大致会有如下的调用链。\",\"img\",\"图给出了可能会调用到的主要方法，并非一定会调用到，之后，会通过一个示例给出详细的分析。\"]},\"200\":{\"h\":\"参考文档\",\"t\":[\"https://www.cnblogs.com/leesf456/p/5406191.html\"]},\"201\":{\"h\":\"CyclicBarrier源码解析\"},\"202\":{\"h\":\"CyclicBarrier简介\",\"t\":[\"CyclicBarrier 是 Java 并发包中提供的一种同步工具，它可以让多个线程在某个屏障点（barrier point）上相互等待，直到所有线程都到达屏障点才可以继续执行。\",\"CyclicBarrier 的设计思想是在多线程任务中形成一个屏障，使得线程能够互相等待，然后同时开始后续操作。\",\"CyclicBarrier 的主要特点包括：\",\"循环使用：与 CountDownLatch 不同，CyclicBarrier 可以被重置并再次使用。当所有线程都到达屏障点后，所有线程会被释放，CyclicBarrier 的内部计数器会被重置并重新开始等待。\",\"等待线程数量控制：和 CountDownLatch 不同，CyclicBarrier 要求所有应等待线程数在创建时就指定，并且等待线程数可以动态地改变。\",\"互相等待：在屏障点上，所有线程会相互等待，直到所有线程都到达后才能继续执行后续操作，从而实现了多个线程的同步。\"]},\"203\":{\"h\":\"CyclicBarrier使用示例\",\"t\":[\"在CountDownLatch使用示例，我们每次在执行while (hasOrder) {}方法体里面每次都去创建一个CountDownLatch去做线程的同步等待。我们可以使用CyclicBarrier也可以达到同样的效果。示例代码如下：\",\"package io.github.forezp.concurrentlab.syntools; import java.util.concurrent.*; public class CyclicBarrierDemo2 { static ExecutorService executorService = Executors.newFixedThreadPool(2); public static void main(String[] args) throws InterruptedException, BrokenBarrierException { CyclicBarrier cyclicBarrier =new CyclicBarrier(3); boolean hasOrder = true; while (hasOrder) { //查询订单 executorService.submit(new Runnable() { @Override public void run() { try { Thread.sleep(500); System.out.println(\\\"查询订单\\\"); } catch (InterruptedException e) { e.printStackTrace(); }finally { try { cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } } }); //查询派单 executorService.submit(new Runnable() { @Override public void run() { try { Thread.sleep(500); System.out.println(\\\"查询派单\\\"); cyclicBarrier.await(); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } } }); cyclicBarrier.await(); //执行对账 Thread.sleep(500); System.out.println(\\\"对账成功\\\"); System.out.println(\\\"---------\\\"); } } } \",\"上面这段代码使用了CyclicBarrier来模拟多个线程之间的同步。整个代码的逻辑流程如下：\",\"创建线程池和CyclicBarrier对象。\",\"进入循环，模拟多次执行订单查询、派单查询和对账操作。\",\"在每次循环中，提交查询订单的任务和查询派单的任务。这两个任务都会等待其他线程到达屏障点。\",\"当两个任务提交完成后，进入屏障点等待，直到所有线程都到达屏障点，才会继续执行。\",\"执行对账操作，然后循环继续。\",\"将 cyclicBarrier.await() 的位置移到了 finally 块中。这样无论线程是否发生异常，都能够保证在最后调用 await 方法，避免出现死锁或永久等待的情况。\"]},\"204\":{\"h\":\"CyclicBarrier源码解析\"},\"205\":{\"h\":\"CyclicBarrier数据结构\",\"t\":[\"分析源码可以知道，CyclicBarrier底层是基于ReentrantLock和AbstractQueuedSynchronizer来实现的，所以，CyclicBarrier的数据结构也依托于AQS的数据结构，在前面对AQS的分析中已经指出了其数据结构，在这里不再累赘。\"]},\"206\":{\"h\":\"类的继承关系\",\"t\":[\"public class CyclicBarrier {} \",\"说明：可以看到CyclicBarrier没有显示继承哪个父类或者实现哪个父接口，根据Java语言规定，可知其父类是Object。\"]},\"207\":{\"h\":\"类的内部类\",\"t\":[\"CyclicBarrier类存在一个内部类Generation，每一次使用的CycBarrier可以当成Generation的实例，其源代码如下\",\"private static class Generation { boolean broken = false; } \",\"说明：Generation类有一个属性broken，用来表示当前屏障是否被损坏。\"]},\"208\":{\"h\":\"类的属性\",\"t\":[\"public class CyclicBarrier { /** The lock for guarding barrier entry */ // 可重入锁 private final ReentrantLock lock = new ReentrantLock(); /** Condition to wait on until tripped */ // 条件队列 private final Condition trip = lock.newCondition(); /** The number of parties */ // 参与的线程数量 private final int parties; /* The command to run when tripped */ // 由最后一个进入 barrier 的线程执行的操作 private final Runnable barrierCommand; /** The current generation */ // 当前代 private Generation generation = new Generation(); // 正在等待进入屏障的线程数量 private int count; } \",\"说明：该属性有一个为ReentrantLock对象，有一个为Condition对象，而Condition对象又是基于AQS的，所以，归根到底，底层还是由AQS提供支持。\"]},\"209\":{\"h\":\"类的构造函数\"},\"210\":{\"h\":\"CyclicBarrier(int, Runnable)型构造函数\",\"t\":[\"public CyclicBarrier(int parties, Runnable barrierAction) { // 参与的线程数量小于等于0，抛出异常 if (parties <= 0) throw new IllegalArgumentException(); // 设置parties this.parties = parties; // 设置count this.count = parties; // 设置barrierCommand this.barrierCommand = barrierAction; } \",\"说明：该构造函数可以指定关联该CyclicBarrier的线程数量，并且可以指定在所有线程都进入屏障后的执行动作，该执行动作由最后一个进行屏障的线程执行。\"]},\"211\":{\"h\":\"CyclicBarrier(int)型构造函数\",\"t\":[\"public CyclicBarrier(int parties) { // 调用含有两个参数的构造函数 this(parties, null); } \",\"说明：该构造函数仅仅执行了关联该CyclicBarrier的线程数量，没有设置执行动作。\"]},\"212\":{\"h\":\"核心函数分析\"},\"213\":{\"h\":\"dowait函数\",\"t\":[\"此函数为CyclicBarrier类的核心函数，CyclicBarrier类对外提供的await函数在底层都是调用该了doawait函数，其源代码如下：\",\"private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException { // 保存当前锁 final ReentrantLock lock = this.lock; // 锁定 lock.lock(); try { // 保存当前代 final Generation g = generation; if (g.broken) // 屏障被破坏，抛出异常 throw new BrokenBarrierException(); if (Thread.interrupted()) { // 线程被中断 // 损坏当前屏障，并且唤醒所有的线程，只有拥有锁的时候才会调用 breakBarrier(); // 抛出异常 throw new InterruptedException(); } // 减少正在等待进入屏障的线程数量 int index = --count; if (index == 0) { // 正在等待进入屏障的线程数量为0，所有线程都已经进入 // 运行的动作标识 boolean ranAction = false; try { // 保存运行动作 final Runnable command = barrierCommand; if (command != null) // 动作不为空 // 运行 command.run(); // 设置ranAction状态 ranAction = true; // 进入下一代 nextGeneration(); return 0; } finally { if (!ranAction) // 没有运行的动作 // 损坏当前屏障 breakBarrier(); } } // loop until tripped, broken, interrupted, or timed out // 无限循环 for (;;) { try { if (!timed) // 没有设置等待时间 // 等待 trip.await(); else if (nanos > 0L) // 设置了等待时间，并且等待时间大于0 // 等待指定时长 nanos = trip.awaitNanos(nanos); } catch (InterruptedException ie) { if (g == generation && ! g.broken) { // 等于当前代并且屏障没有被损坏 // 损坏当前屏障 breakBarrier(); // 抛出异常 throw ie; } else { // 不等于当前带后者是屏障被损坏 // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \\\"belong\\\" to subsequent execution. // 中断当前线程 Thread.currentThread().interrupt(); } } if (g.broken) // 屏障被损坏，抛出异常 throw new BrokenBarrierException(); if (g != generation) // 不等于当前代 // 返回索引 return index; if (timed && nanos <= 0L) { // 设置了等待时间，并且等待时间小于0 // 损坏屏障 breakBarrier(); // 抛出异常 throw new TimeoutException(); } } } finally { // 释放锁 lock.unlock(); } } \",\"说明：dowait方法的逻辑会进行一系列的判断，大致流程如下：\",\"img\"]},\"214\":{\"h\":\"nextGeneration函数\",\"t\":[\"此函数在所有线程进入屏障后会被调用，即生成下一个版本，所有线程又可以重新进入到屏障中，其源代码如下：\",\" private void nextGeneration() { // signal completion of last generation // 唤醒所有线程 trip.signalAll(); // set up next generation // 恢复正在等待进入屏障的线程数量 count = parties; // 新生一代 generation = new Generation(); } \",\"在此函数中会调用AQS的signalAll方法，即唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。其源代码如下：\",\"public final void signalAll() { if (!isHeldExclusively()) // 不被当前线程独占，抛出异常 throw new IllegalMonitorStateException(); // 保存condition队列头结点 Node first = firstWaiter; if (first != null) // 头结点不为空 // 唤醒所有等待线程 doSignalAll(first); } \",\"此函数判断头结点是否为空，即条件队列是否为空，然后会调用doSignalAll函数，doSignalAll函数源码如下：\",\"private void doSignalAll(Node first) { // condition队列的头结点尾结点都设置为空 lastWaiter = firstWaiter = null; // 循环 do { // 获取first结点的nextWaiter域结点 Node next = first.nextWaiter; // 设置first结点的nextWaiter域为空 first.nextWaiter = null; // 将first结点从condition队列转移到sync队列 transferForSignal(first); // 重新设置first first = next; } while (first != null); } \",\"此函数会依次将条件队列中的节点转移到同步队列中，会调用到transferForSignal函数，其源码如下：\",\" final boolean transferForSignal(Node node) { /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus; if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true; } \",\"此函数的作用就是将处于条件队列中的节点转移到同步队列中，并设置结点的状态信息，其中会调用到enq函数，其源代码如下：\",\"private Node enq(final Node node) { for (;;) { // 无限循环，确保结点能够成功入队列 // 保存尾结点 Node t = tail; if (t == null) { // 尾结点为空，即还没被初始化 if (compareAndSetHead(new Node())) // 头结点为空，并设置头结点为新生成的结点 tail = head; // 头结点与尾结点都指向同一个新生结点 } else { // 尾结点不为空，即已经被初始化过 // 将node结点的prev域连接到尾结点 node.prev = t; if (compareAndSetTail(t, node)) { // 比较结点t是否为尾结点，若是则将尾结点设置为node // 设置尾结点的next域为node t.next = node; return t; // 返回尾结点 } } } } \",\"此函数完成了结点插入同步队列的过程，也很好理解。综合上面的分析可知，newGeneration函数的主要方法的调用如下，之后会通过一个例子详细讲解。\",\"img\"]},\"215\":{\"h\":\"breakBarrier函数\",\"t\":[\"此函数的作用是损坏当前屏障，会唤醒所有在屏障中的线程。源代码如下：\",\"private void breakBarrier() { // 设置状态 generation.broken = true; // 恢复正在等待进入屏障的线程数量 count = parties; // 唤醒所有线程 trip.signalAll(); } \",\"可以看到，此函数也调用了AQS的signalAll函数，由signal函数提供支持。\"]},\"216\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/leesf456/p/5392816.html\"]},\"217\":{\"h\":\"并发包里的锁总结\"},\"218\":{\"h\":\"并发包的锁\",\"t\":[\"并发包有三种常见的锁，分别是ReentrantLock、ReadWriteLock、StampedLock等。\",\"image-20231223200719658\",\"它们的主要区别和特点：\",\"ReentrantLock（可重入锁）：\",\"特点：ReentrantLock 是一种独占锁（排他锁），允许同一个线程多次获取同一把锁（可重入性）。\",\"适用场景：适用于需要更灵活的锁操作、对锁的粒度要求较高、需要条件等待的场景。\",\"特点：它提供了独占的锁，不支持读写锁的共享特性。\",\"ReadWriteLock（读写锁）：\",\"特点：ReadWriteLock 使用读锁和写锁分离，允许多个线程同时获取读锁，但只允许一个线程获取写锁。\",\"适用场景：适用于读多写少的场景，能够提高读操作的并发性能，对写操作加了排他性的限制。\",\"特点：支持读锁的共享特性，不适合处理写操作频繁的场景。\",\"StampedLock（标记锁）：\",\"特点：StampedLock 是 Java 8 新引入的锁机制，是读写锁的扩展，支持乐观读锁（不阻塞其他读写操作）、悲观读锁和写锁。\",\"适用场景：适用于读操作远远多于写操作的场景，并且乐观读操作较为频繁的情况。\",\"特点：支持乐观读和悲观读、写操作，适合读多写少的场景，能够提供更好的并发性能。\"]},\"219\":{\"h\":\"ReentrantLock\",\"t\":[\"ReentrantLock是Java并发包中提供的一种可重入互斥锁（Reentrant Mutual Exclusion Lock）。它是一种独占锁，也称为独占模式的锁。\",\"使用ReentrantLock实现一个并发安全的缓存，示例代码如下：\",\"package io.github.forezp.concurrentlab.lock; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReentrantLock; public class ReentrantLockDemo3 { private Map<String, Object> cache = new HashMap<>(); private final ReentrantLock lock = new ReentrantLock();//默认非公平锁 public void put(String key, Object value) { try { lock.lock(); cache.put(key, value); } finally { lock.unlock(); } } public Object get(String key) { try { lock.lock(); return cache.get(key); } finally { lock.unlock(); } } } \"]},\"220\":{\"h\":\"ReadWriteLock\",\"t\":[\"ReadWriteLock是Java并发包中提供的一种读写锁机制，它以更细粒度的方式控制对共享资源的并发访问。\",\"ReadWriteLock的特点包括：\",\"读锁共享，写锁独占：多个线程可以同时获取读锁，实现读并发性能的提升。当一个线程获取写锁时，它会独占资源，阻塞其他线程的读和写操作。\",\"公平性选择：根据创建ReadWriteLock时的参数，可以选择是否使用公平策略。\",\"可重入性：和ReentrantLock一样，读锁和写锁都是可重入的\",\"读写分离：ReadWriteLock将读锁和写锁分离，这样可以允许多个读线程同时获取读锁，但只允许一个写线程获取写锁。\",\"使用ReadWriteLock实现一个并发安全的缓存，示例代码如下：\",\"public class ReadWriteLockDemo { private Map<String, Object> cache = new HashMap<>(); private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();//默认非公平锁 Lock readLock = readWriteLock.readLock();//读锁和写锁是互斥的 Lock writeLock = readWriteLock.writeLock(); public void put(String key, Object value) { try { writeLock.lock(); cache.put(key, value); } finally { writeLock.unlock(); } } public Object get(String key) { try { readLock.lock(); return cache.get(key); } finally { readLock.unlock(); } } } \"]},\"221\":{\"h\":\"StampedLock\",\"t\":[\"StampedLock是Java 8中引入的一种新的并发锁机制，属于读写锁的一种扩展。它比ReentrantLock和ReadWriteLock更加灵活和高效，适用于读多写少的场景。\",\"StampedLock支持三种模式的访问：\",\"写模式（Write Lock）：与传统的独占写锁类似，一个线程获取了写锁后，其他线程无法同时获取读锁或写锁。写模式是排它的，保证了数据的一致性。\",\"读模式（Read Lock）：多个线程可以同时获取读锁，在没有线程持有写锁或等待的写锁时，读模式是共享的。读锁不会阻塞读线程，只有在有线程持有写锁时，读线程会被阻塞。\",\"乐观读模式（Optimistic Read）：**乐观读是一种特殊的读模式，与读锁类似，它允许多个线程同时进入，但不会引起冲突。**乐观读并不会阻塞其他线程获取写锁，因此是一种快速的读操作。在使用乐观读结果进行后续操作前，需要使用validate方法验证数据是否被其他线程修改。\",\"使用StampedLock可以在读多写少的情况下提供更好的性能，但使用时需要注意乐观读操作可能会发生写冲突，需要使用validate方法进行数据验证。此外，StampedLock并不支持可重入的读模式。\",\"使用StampedLock实现一个并发安全的缓存，示例代码如下：\",\"package io.github.forezp.concurrentlab.lock; import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.StampedLock; /** * StampedLock 的性能之所以比 ReadWriteLock 还要好， * 其关键是 StampedLock 支持乐观读的方式。ReadWriteLock * 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞； * 而 StampedLock 提供的乐观读，是允许一个线程获取写锁的， * 也就是说不是所有的写操作都被阻塞。 */ public class StampedLockDemo { private Map<String, Object> cache = new HashMap<>(); final StampedLock sl = new StampedLock();//不可重入锁 public Object get(String key) { long stamp = sl.tryOptimisticRead(); Object result = cache.get(key); if (!sl.validate(stamp)) { try { stamp = sl.tryReadLock(); result = cache.get(key); } finally { sl.unlock(stamp); } } return result; } public void write(String key, Object value) { long stamp = 0; try { stamp = sl.writeLock(); cache.put(key, value); } finally { sl.unlock(stamp); } } } \"]},\"222\":{\"h\":\"并发容器详解\",\"t\":[\"Java并发包里有很多内容都是并发容器的内容，在多线程并发情况下也能安全的使用这些容器。在Java 的老版本的SDK中，提供了同步容器，比如Vector、Hashtable，这些都是基于synchronized关键字实现的，通常一个容器的所有操作共用一把锁，当容器数据量达到一定规模和读写量达到一定规模的时候，静态条件经常触发，性能比较差。\",\"新版并发容器在设计上采用了更加细粒度的锁机制和无锁算法，从而提供了更好的并发性能。它们可以在不同的线程之间并发访问容器，而无需在每次访问时都获取全局锁。新版并发容器通过使用同步控制变量、CAS（Compare and Swap）操作、内部锁等机制，实现了高效的并发访问。\",\"在juc包中，并发容器的数量非常多，可以把它们分为四类，分别是List、Map、Set 和 Queue，如下图所示：\"]},\"223\":{\"h\":\"List\",\"t\":[\"CopyOnWriteArrayList 提供了一种基于\\\"写时复制\\\"（Copy-On-Write）策略，以保证读操作的线程安全性，而在写操作时对数组进行复制，从而避免了写操作对读操作的影响。下面是CopyOnWriteArrayList的简单实现原理：\",\"内部数组： CopyOnWriteArrayList 内部维护了一个数组，所有的元素都存储在这个数组中。成员变量 array 就指向这个内部数组。\",\"image-20240101105046850\",\"写时复制： 当有写操作（如添加、修改、删除元素）发生时，CopyOnWriteArrayList 会创建一个新的数组，并将修改后的元素添加到新数组中。这样一来，原始数组不会被修改，而是保持不变。\",\"image-20240101105106318\",\"读操作： 所有的读操作都是基于原始的 array 进行的，因为写操作并不会修改原始数组，所以读操作可以完全不加锁，从而实现了读操作的线程安全性。\",\"CopyOnWriteArrayList 内部采用写时复制的机制，通过创建新的数组来处理写操作，从而在读多写少的场景下提供了较好的性能。由于读操作无需加锁，因此适用于读操作频繁、写操作相对较少的多线程环境。\"]},\"224\":{\"h\":\"Map\",\"t\":[\"在并发包中提供类了ConcurrentHashMap和ConcurrentSkipListMap。ConcurrentHashMap 是一个线程安全且高效的哈希表实现，支持高并发的读写操作。它的key和value都不允许为null值。ConcurrentSkipListMap 是基于跳表的线程安全的有序映射实现，支持高并发的读写操作，并且它的key和value也不允许为null值\",\"下面是一个总结了 Map 相关实现类对于 key 和 value 的要求的表格：\",\"实现类\",\"key\",\"value\",\"HashMap\",\"可为null （1）\",\"可为null （2）\",\"HashTable\",\"不可为null\",\"不可为null\",\"LinkedHashMap\",\"可为null （1）\",\"可为null （2）\",\"TreeMap\",\"不可为null\",\"可为null\",\"ConcurrentHashMap\",\"不可为null\",\"不可为null\",\"ConcurrentSkipListMap\",\"不可为null\",\"不可为null\"]},\"225\":{\"h\":\"Set\",\"t\":[\"在并发包里，提供了CopyOnWriteArraySet和ConcurrentSkipListSet 的两种实现。\",\"CopyOnWriteArraySet: 内部使用CopyOnWriteArrayList来实现，保证了读操作的线程安全性。在写操作时，会创建一个新的数组来完成写操作，从而避免了写操作对读操作的影响。适用于读多写少的场景，且无需保持顺序。\",\"ConcurrentSkipListSet: 内部使用ConcurrentSkipListMap来实现。它基于跳表的数据结构，在插入元素时会自动维护有序性。由于是有序的，适用于需要有序遍历的场景。\"]},\"226\":{\"h\":\"Queue\",\"t\":[\"Java并发包中的Queue是一类相对复杂的并发容器，可以通过以下两个维度进行分类。\",\"阻塞与非阻塞：\",\"阻塞：当队列已满时，入队操作会阻塞；当队列已空时，出队操作也会阻塞。阻塞队列都以Blocking关键字标识。\",\"非阻塞：当队列已满时，入队操作立即返回一个结果，可以是布尔值或异常。当队列已空时，出队操作也立即返回一个结果。\",\"单端与双端：\",\"单端：只能在队尾进行入队操作，在队首进行出队操作。标识为Queue。\",\"双端：既可以在队尾进行入队操作，也可以在队首进行出队操作。标识为Deque。\",\"根据以上维度的组合，可以将Queue细分为四大类：\",\"单端阻塞队列：\",\"ArrayBlockingQueue：使用数组实现的有界阻塞队列。\",\"LinkedBlockingQueue：使用链表实现的有界或无界阻塞队列。\",\"SynchronousQueue：不持有队列的阻塞队列，入队操作必须等待相应的出队操作。\",\"LinkedTransferQueue：融合了LinkedBlockingQueue和SynchronousQueue的功能。\",\"PriorityBlockingQueue：支持按照优先级出队的阻塞队列。\",\"DelayQueue：支持延时出队的阻塞队列。\",\"双端阻塞队列：\",\"LinkedBlockingDeque：使用链表实现的双端阻塞队列。\",\"单端非阻塞队列：\",\"ConcurrentLinkedQueue：使用链表实现的非阻塞队列。\",\"双端非阻塞队列：\",\"ConcurrentLinkedDeque：使用链表实现的双端非阻塞队列。\",\"需要特别注意的是**，使用队列时要注意队列是否支持有界，即内部的队列是否有容量限制。只有ArrayBlockingQueue和LinkedBlockingQueue是支持有界的，其他队列都是无界的。因此，在使用无界队列时要注意潜在的OOM风险。**\",\"以上是对Java并发包中Queue的分类和一些示例的说明。在实际工作中，需要根据具体需求选择适合的队列类型，并注意其特点和潜在的问题。\"]},\"227\":{\"h\":\"总结\",\"t\":[\"在实际工作中，了解并掌握Java并发容器的特性很重要，但更关键的是能够正确地选择和使用适合的容器。每种容器都有其特定的用途和适应场景，因此，在选择容器时需要根据实际需求进行评估和决策。\",\"同时，熟悉并理解每种容器的使用方法也很重要。可以通过查阅具体容器的API文档来了解它们的用法和详细说明。\",\"接下来会从源码的角度来探讨几种经典的并发容器。\"]},\"228\":{\"h\":\"CopyOnWriteArrayList源码解析\",\"t\":[\"CopyOnWriteArrayList 是 Java 并发包中的一个线程安全的集合类，它实现了 List 接口。与其他并发集合不同的是，CopyOnWriteArrayList 的读操作是无锁的，而写操作则是通过创建并复制底层数组的方式实现的。\"]},\"229\":{\"h\":\"CopyOnWriteArrayList介绍\",\"t\":[\"CopyOnWriteArrayList 内部维护了一个数组，所有的元素都存储在这个数组中。成员变量 array 就指向这个内部数组。\",\"image-20240101105046850\",\"写时复制： 当有写操作（如添加、修改、删除元素）发生时，CopyOnWriteArrayList 会创建一个新的数组，并将修改后的元素添加到新数组中。这样一来，原始数组不会被修改，而是保持不变。\",\"image-20240101105106318\",\"特点：\",\"线程安全：CopyOnWriteArrayList 在写入数据时会创建一个新的底层数组来保存数据，这样保证了写操作的线程安全性。\",\"读取效率较高：由于读操作不需要加锁，所以可以并发进行，不会阻塞读取操作。\",\"使用场景：\",\"读多写少：CopyOnWriteArrayList 的主要优势在于读取操作的高效性，适用于多读少写的场景。\",\"数据不经常更新：由于写操作需要复制底层数组，因此对于频繁的写操作，CopyOnWriteArrayList 的性能可能较低。\"]},\"230\":{\"h\":\"CopyOnWriteArrayList使用示例\",\"t\":[\"import java.util.concurrent.CopyOnWriteArrayList; public class Example { public static void main(String[] args) { CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(); // 添加元素 list.add(\\\"A\\\"); list.add(\\\"B\\\"); list.add(\\\"C\\\"); // 迭代元素 for (String element : list) { System.out.println(element); } // 修改元素（会创建新的底层数组） list.set(0, \\\"D\\\"); // 移除元素（会创建新的底层数组） list.remove(2); } } \",\"以上是关于 CopyOnWriteArrayList 的简要介绍和示例用法。\"]},\"231\":{\"h\":\"CopyOnWriteArrayList源码解析\"},\"232\":{\"h\":\"类的继承关系\",\"t\":[\"public class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {} \",\"CopyOnWriteArrayList实现了List接口，List接口定义了对列表的基本操作；同时实现了RandomAccess接口，表示可以随机访\"]},\"233\":{\"h\":\"类的属性\",\"t\":[\"public class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { // 版本序列号 private static final long serialVersionUID = 8673264195747942595L; // 可重入锁 final transient ReentrantLock lock = new ReentrantLock(); // 对象数组，用于存放元素 private transient volatile Object[] array; // 反射机制 private static final sun.misc.Unsafe UNSAFE; // lock域的内存偏移量 private static final long lockOffset; static { try { UNSAFE = sun.misc.Unsafe.getUnsafe(); Class<?> k = CopyOnWriteArrayList.class; lockOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\\\"lock\\\")); } catch (Exception e) { throw new Error(e); } } } \",\"属性中有一个可重入锁，用来保证线程安全访问，还有一个Object类型的数组，用来存放具体的元素。当然，也使用到了反射机制和CAS来保证原子性的修改lock域。\"]},\"234\":{\"h\":\"类的构造函数\",\"t\":[\"CopyOnWriteArrayList()型构造函数:\",\" public CopyOnWriteArrayList() { // 设置数组 setArray(new Object[0]); } \",\"CopyOnWriteArrayList(Collection<? extends E>)型构造函数:\",\" public CopyOnWriteArrayList(Collection<? extends E> c) { Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) // 类型相同 // 获取c集合的数组 elements = ((CopyOnWriteArrayList<?>)c).getArray(); else { // 类型不相同 // 将c集合转化为数组并赋值给elements elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) // elements类型不为Object[]类型 // 将elements数组转化为Object[]类型的数组 elements = Arrays.copyOf(elements, elements.length, Object[].class); } // 设置数组 setArray(elements); } \",\"说明：该构造函数用于创建一个按 collection 的迭代器返回元素的顺序包含指定 collection 元素的列表。该构造函数的处理流程如下:\",\"① 判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组（Object[]），并且设置当前CopyOnWriteArrayList的数组（Object[]数组），进入步骤③；否则，进入步骤②\",\"② 将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型（toArray方法可能不会返回Object类型的数组），若不是，则将elements转化为Object类型的数组。进入步骤③\",\"③ 设置当前CopyOnWriteArrayList的Object[]为elements。\",\"CopyOnWriteArrayList(E[])型构造函数:\",\" public CopyOnWriteArrayList(E[] toCopyIn) { // 将toCopyIn转化为Object[]类型数组，然后设置当前数组 setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class)); } \",\"该构造函数用于创建一个保存给定数组的副本的列表。\"]},\"235\":{\"h\":\"类的内部类\",\"t\":[\"COWIterator类:\",\"static final class COWIterator<E> implements ListIterator<E> { /** Snapshot of the array */ // 快照 private final Object[] snapshot; /** Index of element to be returned by subsequent call to next. */ // 游标 private int cursor; // 构造函数 private COWIterator(Object[] elements, int initialCursor) { cursor = initialCursor; snapshot = elements; } // 是否还有下一项 public boolean hasNext() { return cursor < snapshot.length; } // 是否有上一项 public boolean hasPrevious() { return cursor > 0; } // next项 @SuppressWarnings(\\\"unchecked\\\") public E next() { if (! hasNext()) // 不存在下一项，抛出异常 throw new NoSuchElementException(); // 返回下一项 return (E) snapshot[cursor++]; } @SuppressWarnings(\\\"unchecked\\\") public E previous() { if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; } // 下一项索引 public int nextIndex() { return cursor; } // 上一项索引 public int previousIndex() { return cursor-1; } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; {@code remove} * is not supported by this iterator. */ // 不支持remove操作 public void remove() { throw new UnsupportedOperationException(); } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; {@code set} * is not supported by this iterator. */ // 不支持set操作 public void set(E e) { throw new UnsupportedOperationException(); } /** * Not supported. Always throws UnsupportedOperationException. * @throws UnsupportedOperationException always; {@code add} * is not supported by this iterator. */ // 不支持add操作 public void add(E e) { throw new UnsupportedOperationException(); } @Override public void forEachRemaining(Consumer<? super E> action) { Objects.requireNonNull(action); Object[] elements = snapshot; final int size = elements.length; for (int i = cursor; i < size; i++) { @SuppressWarnings(\\\"unchecked\\\") E e = (E) elements[i]; action.accept(e); } cursor = size; } } \",\"COWIterator表示迭代器，其也有一个Object类型的数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用。此数组在迭代器的生存期内不会更改，因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。\"]},\"236\":{\"h\":\"核心函数分析\",\"t\":[\"对于CopyOnWriteArrayList的函数分析，主要明白Arrays.copyOf方法即可理解CopyOnWriteArrayList其他函数的意义。\"]},\"237\":{\"h\":\"copyOf函数\",\"t\":[\"public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) { @SuppressWarnings(\\\"unchecked\\\") // 确定copy的类型（将newType转化为Object类型，将Object[].class转化为Object类型，判断两者是否相等，若相等，则生成指定长度的Object数组 // 否则,生成指定长度的新类型的数组） T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 将original数组从下标0开始，复制长度为(original.length和newLength的较小者),复制到copy数组中（也从下标0开始） System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } \"]},\"238\":{\"h\":\"add函数\",\"t\":[\" public boolean add(E e) { // 可重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 元素数组 Object[] elements = getArray(); // 数组长度 int len = elements.length; // 复制数组 Object[] newElements = Arrays.copyOf(elements, len + 1); // 存放元素e newElements[len] = e; // 设置数组 setArray(newElements); return true; } finally { // 释放锁 lock.unlock(); } } \",\"此函数用于将指定元素添加到此列表的尾部，处理流程如下\",\"① 获取锁（保证多线程的安全访问），获取当前的Object数组，获取Object数组的长度为length，进入步骤②。\",\"② 根据Object数组复制一个长度为length+1的Object数组为newElements（此时，newElements[length]为null），进入步骤③。\",\"③ 将下标为length的数组元素newElements[length]设置为元素e，再设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。\"]},\"239\":{\"h\":\"addIfAbsent\",\"t\":[\"private boolean addIfAbsent(E e, Object[] snapshot) { // 重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 获取数组 Object[] current = getArray(); // 数组长度 int len = current.length; if (snapshot != current) { // 快照不等于当前数组，对数组进行了修改 // Optimize for lost race to another addXXX operation // 取较小者 int common = Math.min(snapshot.length, len); for (int i = 0; i < common; i++) // 遍历 if (current[i] != snapshot[i] && eq(e, current[i])) // 当前数组的元素与快照的元素不相等并且e与当前元素相等 // 表示在snapshot与current之间修改了数组，并且设置了数组某一元素为e，已经存在 // 返回 return false; if (indexOf(e, current, common, len) >= 0) // 在当前数组中找到e元素 // 返回 return false; } // 复制数组 Object[] newElements = Arrays.copyOf(current, len + 1); // 对数组len索引的元素赋值为e newElements[len] = e; // 设置数组 setArray(newElements); return true; } finally { // 释放锁 lock.unlock(); } } \",\"说明：该函数用于添加元素（如果数组中不存在，则添加；否则，不添加，直接返回）。可以保证多线程环境下不会重复添加元素，该函数的流程如下\",\"① 获取锁，获取当前数组为current，current长度为len，判断数组之前的快照snapshot是否等于当前数组current，若不相等，则进入步骤②；否则，进入步骤④\",\"② 不相等，表示在snapshot与current之间，对数组进行了修改（如进行了add、set、remove等操作），获取长度（snapshot与current之间的较小者），对current进行遍历操作，若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等（可能进行了set操作），进入步骤⑤，否则，进入步骤③\",\"③ 在当前数组中索引指定元素，若能够找到，进入步骤⑤，否则，进入步骤④\",\"④ 复制当前数组current为newElements，长度为len+1，此时newElements[len]为null。再设置newElements[len]为指定元素e，再设置数组，进入步骤⑤\",\"⑤ 释放锁，返回。\"]},\"240\":{\"h\":\"set函数\",\"t\":[\" public E set(int index, E element) { // 可重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 获取数组 Object[] elements = getArray(); // 获取index索引的元素 E oldValue = get(elements, index); if (oldValue != element) { // 旧值等于element // 数组长度 int len = elements.length; // 复制数组 Object[] newElements = Arrays.copyOf(elements, len); // 重新赋值index索引的值 newElements[index] = element; // 设置数组 setArray(newElements); } else { // Not quite a no-op; ensures volatile write semantics // 设置数组 setArray(elements); } // 返回旧值 return oldValue; } finally { // 释放锁 lock.unlock(); } } \",\"此函数用于用指定的元素替代此列表指定位置上的元素，也是基于数组的复制来实现的。\"]},\"241\":{\"h\":\"remove函数\",\"t\":[\"public E remove(int index) { // 可重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 获取数组 Object[] elements = getArray(); // 数组长度 int len = elements.length; // 获取旧值 E oldValue = get(elements, index); // 需要移动的元素个数 int numMoved = len - index - 1; if (numMoved == 0) // 移动个数为0 // 复制后设置数组 setArray(Arrays.copyOf(elements, len - 1)); else { // 移动个数不为0 // 新生数组 Object[] newElements = new Object[len - 1]; // 复制index索引之前的元素 System.arraycopy(elements, 0, newElements, 0, index); // 复制index索引之后的元素 System.arraycopy(elements, index + 1, newElements, index, numMoved); // 设置索引 setArray(newElements); } // 返回旧值 return oldValue; } finally { // 释放锁 lock.unlock(); } } \",\"说明：此函数用于移除此列表指定位置上的元素。处理流程如下\",\"① 获取锁，获取数组elements，数组长度为length，获取索引的值elements[index]，计算需要移动的元素个数（length - index - 1）,若个数为0，则表示移除的是数组的最后一个元素，复制elements数组，复制长度为length-1，然后设置数组，进入步骤③；否则，进入步骤②\",\"② 先复制index索引前的元素，再复制index索引后的元素，然后设置数组。\",\"③ 释放锁，返回旧值。\"]},\"242\":{\"h\":\"总结\",\"t\":[\"CopyOnWriteArrayList 的实现使用了快照的思路，通过创建新的底层数组来实现写操作的线程安全性，同时保证在迭代过程中不会抛出 ConcurrentModificationException 异常。\",\"具体而言，当有写操作发生时，CopyOnWriteArrayList 会创建一个底层数组的副本，然后在副本上进行写操作，这样迭代过程中使用的是原来的底层数组快照，保证了迭代的线程安全性和不会发生并发修改异常。\"]},\"243\":{\"h\":\"ConcurrentHashMap源码解析\"},\"244\":{\"h\":\"ConcurrentHashMap介绍\",\"t\":[\"ConcurrentHashMap 是 Java 并发包中提供的一个线程安全的哈希表实现。它被设计用来在多线程环境下进行并发访问，并且可以在高并发情况下提供更好的性能表现。在Java7版本和Java8～21的实现非常不同\"]},\"245\":{\"h\":\"Java7 基于分段锁的ConcurrentHashMap\",\"t\":[\"在Java 7中，ConcurrentHashMap实现了基于分段锁的并发访问机制。\",\"Java 7中对ConcurrentHashMap进行了改进，引入了分段锁机制。\",\"分段锁的基本思想是将整个数据结构分成多个段（Segment），每个段拥有自己的锁。这样一来，多个线程可以同时访问不同的段，从而提高并发性能。\",\"具体实现上，ConcurrentHashMap中使用了一个Segment数组，每个Segment中维护一个HashEntry数组，其中每个HashEntry是一个键值对。每个Segment拥有自己的锁对象，当多个线程访问不同的段时，它们可以同时进行操作，互不影响。\",\"通过使用分段锁，ConcurrentHashMap在Java 7中可以提供更高的并发性能，并且保持较低的锁竞争。这使得ConcurrentHashMap成为处理高并发情况下的线程安全哈希表的理想选择。\",\"img\"]},\"246\":{\"h\":\"Java 8基于CAS的ConcurrentHashMap\",\"t\":[\"在Java 8中，ConcurrentHashMap的实现发生了重大变化，它放弃了基于分段锁的实现，而是转而采用基于CAS（Compare and Swap）。\",\"Java 8中的ConcurrentHashMap摒弃了分段锁，而是采用了一种全新的数据结构和算法，基于CAS操作来实现对并发更新的支持。\",\"在Java 8中，ConcurrentHashMap使用了Node和TreeNode来表示哈希表中的节点，这些节点被组织成一个数组。在进行插入、删除和查找等操作时，ConcurrentHashMap使用CAS操作来保证线程安全。\",\"基于CAS的算法能够在多线程并发修改共享数据时，通过硬件的原子性指令来实现线程安全的更新操作，而不需要使用传统的锁机制。这使得ConcurrentHashMap在高并发情况下拥有更好的性能表现，减少了锁竞争的影响。\",\"img\"]},\"247\":{\"h\":\"ConcurrentHashMap使用示例\",\"t\":[\"示例代码如下：\",\"import java.util.concurrent.ConcurrentHashMap; public class ConcurrentHashMapExample { public static void main(String[] args) { // 创建 ConcurrentHashMap 实例 ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>(); // 插入元素 map.put(\\\"A\\\", 1); map.put(\\\"B\\\", 2); map.put(\\\"C\\\", 3); // 删除元素 map.remove(\\\"B\\\"); // 查询元素 int valueA = map.get(\\\"A\\\"); System.out.println(\\\"Value for key 'A': \\\" + valueA); // 遍历元素 for (String key : map.keySet()) { int value = map.get(key); System.out.println(\\\"Key: \\\" + key + \\\", Value: \\\" + value); } } } \",\"输出结果:\",\"Value for key 'A': 1 Key: A, Value: 1 Key: C, Value: 3 \"]},\"248\":{\"h\":\"ConcurrentHashMap源码解析\",\"t\":[\"基于java 1.8版本，1.8之后ConcurrentHashMap源码变化很小。\"]},\"249\":{\"h\":\"类的继承关系\",\"t\":[\"public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {} \",\"ConcurrentHashMap继承了AbstractMap抽象类，该抽象类定义了一些基本操作，同时，也实现了ConcurrentMap接口，ConcurrentMap接口也定义了一系列操作，实现了Serializable接口表示ConcurrentHashMap可以被序列化。\"]},\"250\":{\"h\":\"类的内部类\",\"t\":[\"ConcurrentHashMap包含了很多内部类，其中主要的内部类框架图如下图所示\",\"img\",\"img\",\"可以看到，ConcurrentHashMap的内部类非常的庞大，第二个图是在JDK1.8下增加的类，下面对其中主要的内部类进行分析和讲解。\"]},\"251\":{\"h\":\"Node类\",\"t\":[\"Node类主要用于存储具体键值对，其子类有ForwardingNode、ReservationNode、TreeNode和TreeBin四个子类。四个子类具体的代码在之后的具体例子中进行分析讲解。\"]},\"252\":{\"h\":\"Traverser类\",\"t\":[\"Traverser类主要用于遍历操作，其子类有BaseIterator、KeySpliterator、ValueSpliterator、EntrySpliterator四个类，BaseIterator用于遍历操作。KeySplitertor、ValueSpliterator、EntrySpliterator则用于键、值、键值对的划分。\"]},\"253\":{\"h\":\"CollectionView类\",\"t\":[\"CollectionView抽象类主要定义了视图操作，其子类KeySetView、ValueSetView、EntrySetView分别表示键视图、值视图、键值对视图。对视图均可以进行操作。\"]},\"254\":{\"h\":\"Segment类\",\"t\":[\"Segment类在JDK1.8中与之前的版本的JDK作用存在很大的差别，JDK1.8下，其在普通的ConcurrentHashMap操作中已经没有失效，其在序列化与反序列化的时候会发挥作用。\"]},\"255\":{\"h\":\"CounterCell\",\"t\":[\"CounterCell类主要用于对baseCount的计数。\"]},\"256\":{\"h\":\"类的属性\",\"t\":[\"public class ConcurrentHashMap<K,V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable { private static final long serialVersionUID = 7249069246763182397L; // 表的最大容量 private static final int MAXIMUM_CAPACITY = 1 << 30; // 默认表的大小 private static final int DEFAULT_CAPACITY = 16; // 最大数组大小 static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 默认并发数 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; // 装载因子 private static final float LOAD_FACTOR = 0.75f; // 转化为红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; // 由红黑树转化为链表的阈值 static final int UNTREEIFY_THRESHOLD = 6; // 转化为红黑树的表的最小容量 static final int MIN_TREEIFY_CAPACITY = 64; // 每次进行转移的最小值 private static final int MIN_TRANSFER_STRIDE = 16; // 生成sizeCtl所使用的bit位数 private static int RESIZE_STAMP_BITS = 16; // 进行扩容所允许的最大线程数 private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1; // 记录sizeCtl中的大小所需要进行的偏移位数 private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; // 一系列的标识 static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash // /** Number of CPUS, to place bounds on some sizings */ // 获取可用的CPU个数 static final int NCPU = Runtime.getRuntime().availableProcessors(); // /** For serialization compatibility. */ // 进行序列化的属性 private static final ObjectStreamField[] serialPersistentFields = { new ObjectStreamField(\\\"segments\\\", Segment[].class), new ObjectStreamField(\\\"segmentMask\\\", Integer.TYPE), new ObjectStreamField(\\\"segmentShift\\\", Integer.TYPE) }; // 表 transient volatile Node<K,V>[] table; // 下一个表 private transient volatile Node<K,V>[] nextTable; // /** * Base counter value, used mainly when there is no contention, * but also as a fallback during table initialization * races. Updated via CAS. */ // 基本计数 private transient volatile long baseCount; // /** * Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table. */ // 对表初始化和扩容控制 private transient volatile int sizeCtl; /** * The next table index (plus one) to split while resizing. */ // 扩容下另一个表的索引 private transient volatile int transferIndex; /** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */ // 旋转锁 private transient volatile int cellsBusy; /** * Table of counter cells. When non-null, size is a power of 2. */ // counterCell表 private transient volatile CounterCell[] counterCells; // views // 视图 private transient KeySetView<K,V> keySet; private transient ValuesView<K,V> values; private transient EntrySetView<K,V> entrySet; // Unsafe mechanics private static final sun.misc.Unsafe U; private static final long SIZECTL; private static final long TRANSFERINDEX; private static final long BASECOUNT; private static final long CELLSBUSY; private static final long CELLVALUE; private static final long ABASE; private static final int ASHIFT; static { try { U = sun.misc.Unsafe.getUnsafe(); Class<?> k = ConcurrentHashMap.class; SIZECTL = U.objectFieldOffset (k.getDeclaredField(\\\"sizeCtl\\\")); TRANSFERINDEX = U.objectFieldOffset (k.getDeclaredField(\\\"transferIndex\\\")); BASECOUNT = U.objectFieldOffset (k.getDeclaredField(\\\"baseCount\\\")); CELLSBUSY = U.objectFieldOffset (k.getDeclaredField(\\\"cellsBusy\\\")); Class<?> ck = CounterCell.class; CELLVALUE = U.objectFieldOffset (ck.getDeclaredField(\\\"value\\\")); Class<?> ak = Node[].class; ABASE = U.arrayBaseOffset(ak); int scale = U.arrayIndexScale(ak); if ((scale & (scale - 1)) != 0) throw new Error(\\\"data type scale not a power of two\\\"); ASHIFT = 31 - Integer.numberOfLeadingZeros(scale); } catch (Exception e) { throw new Error(e); } } } \",\"ConcurrentHashMap的属性很多，其中不少属性在HashMap中就已经介绍过，而对于ConcurrentHashMap而言，添加了Unsafe实例，主要用于反射获取对象相应的字段。\"]},\"257\":{\"h\":\"类的构造函数\",\"t\":[\"ConcurrentHashMap()型构造函数\",\"public ConcurrentHashMap() { } \"]},\"258\":{\"h\":\"核心函数分析\"},\"259\":{\"h\":\"putVal函数\",\"t\":[\" final V putVal(K key, V value, boolean onlyIfAbsent) { if (key == null || value == null) throw new NullPointerException(); // 键或值为空，抛出异常 // 键的hash值经过计算获得hash值 int hash = spread(key.hashCode()); int binCount = 0; for (Node<K,V>[] tab = table;;) { // 无限循环 Node<K,V> f; int n, i, fh; if (tab == null || (n = tab.length) == 0) // 表为空或者表的长度为0 // 初始化表 tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // 表不为空并且表的长度大于0，并且该桶不为空 if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null))) // 比较并且交换值，如tab的第i项为空则用新生成的node替换 break; // no lock when adding to empty bin } else if ((fh = f.hash) == MOVED) // 该结点的hash值为MOVED // 进行结点的转移（在扩容的过程中） tab = helpTransfer(tab, f); else { V oldVal = null; synchronized (f) { // 加锁同步 if (tabAt(tab, i) == f) { // 找到table表下标为i的节点 if (fh >= 0) { // 该table表中该结点的hash值大于0 // binCount赋值为1 binCount = 1; for (Node<K,V> e = f;; ++binCount) { // 无限循环 K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { // 结点的hash值相等并且key也相等 // 保存该结点的val值 oldVal = e.val; if (!onlyIfAbsent) // 进行判断 // 将指定的value保存至结点，即进行了结点值的更新 e.val = value; break; } // 保存当前结点 Node<K,V> pred = e; if ((e = e.next) == null) { // 当前结点的下一个结点为空，即为最后一个结点 // 新生一个结点并且赋值给next域 pred.next = new Node<K,V>(hash, key, value, null); // 退出循环 break; } } } else if (f instanceof TreeBin) { // 结点为红黑树结点类型 Node<K,V> p; // binCount赋值为2 binCount = 2; if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) { // 将hash、key、value放入红黑树 // 保存结点的val oldVal = p.val; if (!onlyIfAbsent) // 判断 // 赋值结点value值 p.val = value; } } } } if (binCount != 0) { // binCount不为0 if (binCount >= TREEIFY_THRESHOLD) // 如果binCount大于等于转化为红黑树的阈值 // 进行转化 treeifyBin(tab, i); if (oldVal != null) // 旧值不为空 // 返回旧值 return oldVal; break; } } } // 增加binCount的数量 addCount(1L, binCount); return null; } \",\"put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。\",\"① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②\",\"② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③\",\"③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④\",\"④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤\",\"⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥\",\"⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。\",\"在putVal函数中会涉及到如下几个函数：initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。下面对其中涉及到的函数进行分析。\",\"其中 initTable函数源码如下\",\"private final Node<K,V>[] initTable() { Node<K,V>[] tab; int sc; while ((tab = table) == null || tab.length == 0) { // 无限循环 if ((sc = sizeCtl) < 0) // sizeCtl小于0，则进行线程让步等待 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { // 比较sizeCtl的值与sc是否相等，相等则用-1替换 try { if ((tab = table) == null || tab.length == 0) { // table表为空或者大小为0 // sc的值是否大于0，若是，则n为sc，否则，n为默认初始容量 int n = (sc > 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\\\"unchecked\\\") // 新生结点数组 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n]; // 赋值给table table = tab = nt; // sc为n * 3/4 sc = n - (n >>> 2); } } finally { // 设置sizeCtl的值 sizeCtl = sc; } break; } } // 返回table表 return tab; } \",\"对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。\",\"tabAt函数源码如下:\",\"static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) { return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE); } \",\"此函数返回table数组中下标为i的结点，可以看到是通过Unsafe对象通过反射获取的，getObjectVolatile的第二项参数为下标为i的偏移地址。\",\"casTabAt函数源码如下:\",\" static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v) { return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v); } \",\"此函数用于比较table数组下标为i的结点是否为c，若为c，则用v交换操作。否则，不进行交换操作。\",\"helpTransfer函数源码如下:\",\" Node<K,V>[] nextTab; int sc; if (tab != null && (f instanceof ForwardingNode) && (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) { // table表不为空并且结点类型使ForwardingNode类型，并且结点的nextTable不为空 int rs = resizeStamp(tab.length); while (nextTab == nextTable && table == tab && (sc = sizeCtl) < 0) { // 条件判断 if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex <= 0) // break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) { // 比较并交换 // 将table的结点转移到nextTab中 transfer(tab, nextTab); break; } } return nextTab; } return table; } \",\"此函数用于在扩容时将table表中的结点转移到nextTable中。\",\"putTreeVal函数源码如下:\",\"final TreeNode<K,V> putTreeVal(int h, K k, V v) { Class<?> kc = null; boolean searched = false; for (TreeNode<K,V> p = root;;) { int dir, ph; K pk; if (p == null) { first = root = new TreeNode<K,V>(h, k, v, null, null); break; } else if ((ph = p.hash) > h) dir = -1; else if (ph < h) dir = 1; else if ((pk = p.key) == k || (pk != null && k.equals(pk))) return p; else if ((kc == null && (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode<K,V> q, ch; searched = true; if (((ch = p.left) != null && (q = ch.findTreeNode(h, k, kc)) != null) || ((ch = p.right) != null && (q = ch.findTreeNode(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode<K,V> xp = p; if ((p = (dir <= 0) ? p.left : p.right) == null) { TreeNode<K,V> x, f = first; first = x = new TreeNode<K,V>(h, k, v, f, xp); if (f != null) f.prev = x; if (dir <= 0) xp.left = x; else xp.right = x; if (!xp.red) x.red = true; else { lockRoot(); try { root = balanceInsertion(root, x); } finally { unlockRoot(); } } break; } } assert checkInvariants(root); return null; } \",\"此函数用于将指定的hash、key、value值添加到红黑树中，若已经添加了，则返回null，否则返回该结点。\",\"treeifyBin函数源码如下:\",\"private final void treeifyBin(Node<K,V>[] tab, int index) { Node<K,V> b; int n, sc; if (tab != null) { // 表不为空 if ((n = tab.length) < MIN_TREEIFY_CAPACITY) // table表的长度小于最小的长度 // 进行扩容，调整某个桶中结点数量过多的问题（由于某个桶中结点数量超出了阈值，则触发treeifyBin） tryPresize(n << 1); else if ((b = tabAt(tab, index)) != null && b.hash >= 0) { // 桶中存在结点并且结点的hash值大于等于0 synchronized (b) { // 对桶中第一个结点进行加锁 if (tabAt(tab, index) == b) { // 第一个结点没有变化 TreeNode<K,V> hd = null, tl = null; for (Node<K,V> e = b; e != null; e = e.next) { // 遍历桶中所有结点 // 新生一个TreeNode结点 TreeNode<K,V> p = new TreeNode<K,V>(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) // 该结点前驱为空 // 设置p为头结点 hd = p; else // 尾节点的next域赋值为p tl.next = p; // 尾节点赋值为p tl = p; } // 设置table表中下标为index的值为hd setTabAt(tab, index, new TreeBin<K,V>(hd)); } } } } } \",\"此函数用于将桶中的数据结构转化为红黑树，其中，值得注意的是，当table的长度未达到阈值时，会进行一次扩容操作，该操作会使得触发treeifyBin操作的某个桶中的所有元素进行一次重新分配，这样可以避免某个桶中的结点数量太大。\",\"addCount函数源码如下:\",\"private final void addCount(long x, int check) { CounterCell[] as; long b, s; if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) { // counterCells不为空或者比较交换失败 CounterCell a; long v; int m; // 无竞争标识 boolean uncontended = true; if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) { // fullAddCount(x, uncontended); return; } if (check <= 1) return; s = sumCount(); } if (check >= 0) { Node<K,V>[] tab, nt; int n, sc; while (s >= (long)(sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) { int rs = resizeStamp(n); if (sc < 0) { if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); } } } \",\"此函数主要完成binCount的值加1的操作。\"]},\"260\":{\"h\":\"get函数\",\"t\":[\"public V get(Object key) { Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek; // 计算key的hash值 int h = spread(key.hashCode()); if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) { // 表不为空并且表的长度大于0并且key所在的桶不为空 if ((eh = e.hash) == h) { // 表中的元素的hash值与key的hash值相等 if ((ek = e.key) == key || (ek != null && key.equals(ek))) // 键相等 // 返回值 return e.val; } else if (eh < 0) // 结点hash值小于0 // 在桶（链表/红黑树）中查找 return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) { // 对于结点hash值大于0的情况 if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) return e.val; } } return null; } \",\"get函数根据key的hash值来计算在哪个桶中，再遍历桶，查找元素，若找到则返回该结点，否则，返回null。\"]},\"261\":{\"h\":\"replaceNode函数\",\"t\":[\"final V replaceNode(Object key, V value, Object cv) { // 计算key的hash值 int hash = spread(key.hashCode()); for (Node<K,V>[] tab = table;;) { // 无限循环 Node<K,V> f; int n, i, fh; if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) & hash)) == null) // table表为空或者表长度为0或者key所对应的桶为空 // 跳出循环 break; else if ((fh = f.hash) == MOVED) // 桶中第一个结点的hash值为MOVED // 转移 tab = helpTransfer(tab, f); else { V oldVal = null; boolean validated = false; synchronized (f) { // 加锁同步 if (tabAt(tab, i) == f) { // 桶中的第一个结点没有发生变化 if (fh >= 0) { // 结点hash值大于0 validated = true; for (Node<K,V> e = f, pred = null;;) { // 无限循环 K ek; if (e.hash == hash && ((ek = e.key) == key || (ek != null && key.equals(ek)))) { // 结点的hash值与指定的hash值相等，并且key也相等 V ev = e.val; if (cv == null || cv == ev || (ev != null && cv.equals(ev))) { // cv为空或者与结点value相等或者不为空并且相等 // 保存该结点的val值 oldVal = ev; if (value != null) // value为null // 设置结点value值 e.val = value; else if (pred != null) // 前驱不为空 // 前驱的后继为e的后继，即删除了e结点 pred.next = e.next; else // 设置table表中下标为index的值为e.next setTabAt(tab, i, e.next); } break; } pred = e; if ((e = e.next) == null) break; } } else if (f instanceof TreeBin) { // 为红黑树结点类型 validated = true; // 类型转化 TreeBin<K,V> t = (TreeBin<K,V>)f; TreeNode<K,V> r, p; if ((r = t.root) != null && (p = r.findTreeNode(hash, key, null)) != null) { // 根节点不为空并且存在与指定hash和key相等的结点 // 保存p结点的value V pv = p.val; if (cv == null || cv == pv || (pv != null && cv.equals(pv))) { // cv为空或者与结点value相等或者不为空并且相等 oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) // 移除p结点 setTabAt(tab, i, untreeify(t.first)); } } } } } if (validated) { if (oldVal != null) { if (value == null) // baseCount值减一 addCount(-1L, -1); return oldVal; } break; } } } return null; } \",\"此函数对remove函数提供支持，remove函数底层是调用的replaceNode函数实现结点的删除。\"]},\"262\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/leesf456/p/5453341.html\",\"http://blog.fangzhipeng.com/javainterview/2019/03/18/concurrenthashmap.html\"]},\"263\":{\"h\":\"BlockingQueue详解\",\"t\":[\"google-site-verification=5Sx1Ko4M39zIL01OlNc4To63Vx0yoNQ5AnFtinbe278\"]},\"264\":{\"h\":\"什么是BlockingQueue\",\"t\":[\"BlockingQueue 是 Java 并发包中的一个接口，它是一种特殊的队列。该队列支持在队列已满或为空时的阻塞操作。BlockingQueue允许线程安全地进行队列操作，并提供了一种有效的方式来进行线程间的数据交换。\",\"以下是 BlockingQueue 的一些关键特点：\",\"阻塞操作：BlockingQueue 提供了一系列的阻塞队列操作，如 put（插入元素）、take（获取并移除队首元素）、offer（插入元素但不阻塞）、poll（获取并移除队首元素但不阻塞）等。这些操作能够在队列满或为空时进行阻塞，直到条件满足。\",\"线程安全：BlockingQueue 的实现通常是线程安全的，这意味着你可以在多个线程中安全地操作队列而无需额外的同步控制。\",\"数据交换：BlockingQueue 可以用来进行线程间的数据交换。例如，一个线程可以向队列提交任务，而另一个线程则可以从队列中获取任务并执行。\",\"img\"]},\"265\":{\"h\":\"BlockingQueue接口定义\",\"t\":[\"BlockingQueue接口继承了Queue接口，在Queue接口基础上，又提供了其他方法，其源码如下：\",\"public interface BlockingQueue<E> extends Queue<E> { /** * 入队一个元素，如果有空间则直接插入，并返回true； * 如果没有空间则抛出IllegalStateException */ boolean add(E e); /** * 入队一个元素，如果有空间则直接插入，并返回true； * 如果没有空间返回false */ boolean offer(E e); /** * 入队一个元素，如果有空间则直接插入，如果没有空间则一直阻塞等待 */ void put(E e) throws InterruptedException; /** * 入队一个元素，如果有空间则直接插入，并返回true； * 如果没有空间则等待timeout时间，插入失败则返回false */ boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; /** * 出队一个元素，如果存在则直接出队，如果没有空间则一直阻塞等待 */ E take() throws InterruptedException; /** * 出队一个元素，如果存在则直接出队，如果没有空间则等待timeout时间，无元素则返回null */ E poll(long timeout, TimeUnit unit) throws InterruptedException; /** * 返回该队列剩余的容量（如果没有限制则返回Integer.MAX_VALUE） */ int remainingCapacity(); /** * 如果元素o在队列中存在，则从队列中删除 */ boolean remove(Object o); /** * 判断队列中是否存在元素o */ public boolean contains(Object o); /** * 将队列中的所有元素出队，并添加到给定的集合c中，返回出队的元素数量 */ int drainTo(Collection<? super E> c); /** * 将队列中的元素出队，限制数量maxElements个，并添加到给定的集合c中，返回出队的元素数量 */ int drainTo(Collection<? super E> c, int maxElements); } \",\"BlockingQueue 接口提供了一系列方法来支持队列的操作，包括入队、出队以及获取队首元素，这些方法可以通过不同的方式来处理队列已满或为空的情况，以满足不同的需求。\",\"方法\",\"抛出异常\",\"返回特定值\",\"阻塞\",\"阻塞特定时间\",\"入队\",\"add(e)\",\"offer(e)\",\"put(e)\",\"offer(e, time, unit)\",\"出队\",\"remove()\",\"poll()\",\"take()\",\"poll(time, unit)\",\"获取队首元素\",\"element()\",\"peek()\",\"不支持\",\"不支持\",\"抛出异常： 通过 add()、remove()、element() 方法在队列已满或为空时会抛出异常。\",\"返回特定值： 通过 offer()、poll()、peek() 方法在队列已满或为空时会返回特定值。\",\"阻塞： 通过 put()、take() 方法在队列已满或为空时会阻塞当前线程，直到条件满足。\",\"阻塞特定时间： 通过 offer(e, time, unit)、poll(time, unit) 方法在队列已满或为空时会阻塞当前线程一段特定的时间，在给定的时间内等待条件的成立。\"]},\"266\":{\"h\":\"BlockingQueue实现\",\"t\":[\"BlockingQueue 接口有多个实现类，下表列出了 BlockingQueue 的主要实现类及其功能：\",\"实现类\",\"功能\",\"ArrayBlockingQueue\",\"基于数组的阻塞队列，需要指定长度，有界队列\",\"LinkedBlockingQueue\",\"基于链表的阻塞队列，默认为无界队列，也可以设置容量\",\"SynchronousQueue\",\"没有缓冲的队列，生产者产生的数据会立即被消费者获取\",\"PriorityBlockingQueue\",\"基于优先级的阻塞队列，元素按优先级顺序出队\",\"DelayQueue\",\"延迟队列，元素需要等待指定延迟时间后才能出队\",\"在日常开发中，最常用的是 ArrayBlockingQueue 和 LinkedBlockingQueue。下面简要介绍这两个实现类的原理：\",\"ArrayBlockingQueue： 它基于数组实现，需要指定队列的长度，在队列已满时将会阻塞入队操作，直到队列有空间可用。在队列为空时，出队操作也会被阻塞，直到队列有元素可用。它是一个有界队列，适用于需要限制队列长度的场景。\",\"LinkedBlockingQueue： 它基于链表实现，默认情况下是一个无界队列，也可以通过指定容量来创建有界队列。它的入队和出队操作都是阻塞的，当队列已满时进行入队操作将会阻塞，直到队列有空间可用。当队列为空时进行出队操作也会被阻塞，直到队列有元素可用。它适用于需要灵活增减队列长度的场景。\"]},\"267\":{\"h\":\"ArrayBlockingQueue使用介绍\",\"t\":[\"下面是一个使用 ArrayBlockingQueue 的示例代码，展示了如何在生产者-消费者模式中使用 ArrayBlockingQueue 实现线程安全的数据传递。\",\"import java.util.concurrent.ArrayBlockingQueue; public class ProducerConsumerExample { // 创建一个最多存储3个元素的 ArrayBlockingQueue private static ArrayBlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3); public static void main(String[] args) { // 创建一个生产者线程和一个消费者线程 Thread producerThread = new Thread(new Producer()); Thread consumerThread = new Thread(new Consumer()); // 启动两个线程 producerThread.start(); consumerThread.start(); } static class Producer implements Runnable { @Override public void run() { try { int count = 1; while (true) { // 将数据放入队列中 queue.put(count); System.out.println(\\\"生产者生产数据：\\\" + count); count++; // 等待一段时间后继续生产数据 Thread.sleep(1000); } } catch (InterruptedException e) { e.printStackTrace(); } } } static class Consumer implements Runnable { @Override public void run() { try { while (true) { // 从队列中取出数据 int data = queue.take(); System.out.println(\\\"消费者消费数据：\\\" + data); // 等待一段时间后继续消费数据 Thread.sleep(2000); } } catch (InterruptedException e) { e.printStackTrace(); } } } } \",\"在上述示例中，我们创建了一个 ArrayBlockingQueue 对象 queue，它的容量为3，即最多可以存储3个元素。\",\"然后，我们创建了一个生产者线程和一个消费者线程，并启动这两个线程。\",\"生产者线程持续生产数据，每次生产一个数并将其放入队列中，然后等待1秒钟后继续生产。消费者线程从队列中取出数据并进行消费，每次消费一个数，然后等待2秒钟后继续消费。\",\"通过 ArrayBlockingQueue 的阻塞特性，当队列已满时，生产者线程将会被阻塞，直到队列有空间可用。当队列为空时，消费者线程将会被阻塞，直到队列有元素可用。\",\"这样，通过 ArrayBlockingQueue 的线程安全和阻塞机制，生产者和消费者可以在多线程环境下安全地进行数据传递，实现了生产者-消费者模式的功能。\"]},\"268\":{\"h\":\"ArrayBlockingQueue源码实现\"},\"269\":{\"h\":\"类的继承关系\",\"t\":[\"public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable {} \",\"可以看到ArrayBlockingQueue继承了AbstractQueue抽象类，AbstractQueue定义了对队列的基本操作；同时实现了BlockingQueue接口，BlockingQueue表示阻塞型的队列，其对队列的操作可能会抛出异常；同时也实现了Searializable接口，表示可以被序列化。\"]},\"270\":{\"h\":\"类的属性\",\"t\":[\"public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, java.io.Serializable { // 版本序列号 private static final long serialVersionUID = -817911632652898426L; // 存放实际元素的数组 final Object[] items; // 取元素索引 int takeIndex; // 获取元素索引 int putIndex; // 队列中的项 int count; // 可重入锁 final ReentrantLock lock; // 等待获取条件 private final Condition notEmpty; // 等待存放条件 private final Condition notFull; // 迭代器 transient Itrs itrs = null; } \",\"从类的属性中可以清楚的看到其底层的结构是Object类型的数组，取元素和存元素有不同的索引，有一个可重入锁ReentrantLock，两个条件Condition。\"]},\"271\":{\"h\":\"类的构造函数\",\"t\":[\"ArrayBlockingQueue(int)型构造函数\",\" public ArrayBlockingQueue(int capacity) { // 调用两个参数的构造函数 this(capacity, false); } \",\"该构造函数用于创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。\",\"ArrayBlockingQueue(int, boolean)型构造函数\",\" public ArrayBlockingQueue(int capacity, boolean fair) { // 初始容量必须大于0 if (capacity <= 0) throw new IllegalArgumentException(); // 初始化数组 this.items = new Object[capacity]; // 初始化可重入锁 lock = new ReentrantLock(fair); // 初始化等待条件 notEmpty = lock.newCondition(); notFull = lock.newCondition(); } \",\"该构造函数用于创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。\",\"ArrayBlockingQueue(int, boolean, Collection<? extends E>)型构造函数\",\" public ArrayBlockingQueue(int capacity, boolean fair, Collection<? extends E> c) { // 调用两个参数的构造函数 this(capacity, fair); // 可重入锁 final ReentrantLock lock = this.lock; // 上锁 lock.lock(); // Lock only for visibility, not mutual exclusion try { int i = 0; try { for (E e : c) { // 遍历集合 // 检查元素是否为空 checkNotNull(e); // 存入ArrayBlockingQueue中 items[i++] = e; } } catch (ArrayIndexOutOfBoundsException ex) { // 当初始化容量小于传入集合的大小时，会抛出异常 throw new IllegalArgumentException(); } // 元素数量 count = i; // 初始化存元素的索引 putIndex = (i == capacity) ? 0 : i; } finally { // 释放锁 lock.unlock(); } } \",\"该构造函数用于创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。\"]},\"272\":{\"h\":\"核心函数分析\"},\"273\":{\"h\":\"put函数\",\"t\":[\" public void put(E e) throws InterruptedException { checkNotNull(e); // 获取可重入锁 final ReentrantLock lock = this.lock; // 如果当前线程未被中断，则获取锁 lock.lockInterruptibly(); try { while (count == items.length) // 判断元素是否已满 // 若满，则等待 notFull.await(); // 入队列 enqueue(e); } finally { // 释放锁 lock.unlock(); } } \",\"put函数用于存放元素，在当前线程被中断时会抛出异常，并且当队列已经满时，会阻塞一直等待。其中，put会调用enqueue函数，enqueue函数源码如下：\",\"private void enqueue(E x) { // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; // 获取数组 final Object[] items = this.items; // 将元素放入 items[putIndex] = x; if (++putIndex == items.length) // 放入后存元素的索引等于数组长度（表示已满） // 重置存索引为0 putIndex = 0; // 元素数量加1 count++; // 唤醒在notEmpty条件上等待的线程 notEmpty.signal(); } \",\"enqueue函数用于将元素存入底层Object数组中，并且会唤醒等待notEmpty条件的线程。\"]},\"274\":{\"h\":\"offer函数\",\"t\":[\"public boolean offer(E e) { // 检查元素不能为空 checkNotNull(e); // 可重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { if (count == items.length) // 元素个数等于数组长度，则返回 return false; else { // 添加进数组 enqueue(e); return true; } } finally { // 释放数组 lock.unlock(); } } \",\"offer函数也用于存放元素，在调用ArrayBlockingQueue的add方法时，会间接的调用到offer函数，offer函数添加元素不会抛出异常，当底层Object数组已满时，则返回false，否则，会调用enqueue函数，将元素存入底层Object数组。并唤醒等待notEmpty条件的线程。\"]},\"275\":{\"h\":\"take函数\",\"t\":[\" public E take() throws InterruptedException { // 可重入锁 final ReentrantLock lock = this.lock; // 如果当前线程未被中断，则获取锁，中断会抛出异常 lock.lockInterruptibly(); try { while (count == 0) // 元素数量为0，即Object数组为空 // 则等待notEmpty条件 notEmpty.await(); // 出队列 return dequeue(); } finally { // 释放锁 lock.unlock(); } } \",\"take函数用于从ArrayBlockingQueue中获取一个元素，其与put函数相对应，在当前线程被中断时会抛出异常，并且当队列为空时，会阻塞一直等待。其中，take会调用dequeue函数，dequeue函数源码如下：\",\" private E dequeue() { // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") // 取元素 E x = (E) items[takeIndex]; // 该索引的值赋值为null items[takeIndex] = null; // 取值索引等于数组长度 if (++takeIndex == items.length) // 重新赋值取值索引 takeIndex = 0; // 元素个数减1 count--; if (itrs != null) itrs.elementDequeued(); // 唤醒在notFull条件上等待的线程 notFull.signal(); return x; } \",\"dequeue函数用于将取元素，并且会唤醒等待notFull条件的线程。\"]},\"276\":{\"h\":\"poll函数\",\"t\":[\" public E poll() { // 重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 若元素个数为0则返回null，否则，调用dequeue，出队列 return (count == 0) ? null : dequeue(); } finally { // 释放锁 lock.unlock(); } } \",\"poll函数用于获取元素，其与offer函数相对应，不会抛出异常，当元素个数为0是，返回null，否则，调用dequeue函数，并唤醒等待notFull条件的线程。并返回。\"]},\"277\":{\"h\":\"clear函数\",\"t\":[\"public void clear() { // 数组 final Object[] items = this.items; // 可重入锁 final ReentrantLock lock = this.lock; // 获取锁 lock.lock(); try { // 保存元素个数 int k = count; if (k > 0) { // 元素个数大于0 // 存数元素索引 final int putIndex = this.putIndex; // 取元素索引 int i = takeIndex; do { // 赋值为null items[i] = null; if (++i == items.length) // 重新赋值i i = 0; } while (i != putIndex); // 重新赋值取元素索引 takeIndex = putIndex; // 元素个数为0 count = 0; if (itrs != null) itrs.queueIsEmpty(); for (; k > 0 && lock.hasWaiters(notFull); k--) // 若有等待notFull条件的线程，则逐一唤醒 notFull.signal(); } } finally { // 释放锁 lock.unlock(); } } \",\"clear函数用于清空ArrayBlockingQueue，并且会释放所有等待notFull条件的线程（存放元素的线程）。\"]},\"278\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/leesf456/p/5533770.html\"]},\"279\":{\"h\":\"ThreadLocal详解\"},\"280\":{\"h\":\"什么是ThreadLocal\",\"t\":[\"ThreadLocal是线程本地变量，它提供了线程本地变量的支持。每个ThreadLocal对象都维护了一个独立的变量副本，每个线程都可以访问自己的副本，对其他线程而言是隔离的。\",\"使用ThreadLocal，可以为每个线程创建独立的变量副本，每个线程可以通过ThreadLocal对象来获取和设置自己的变量副本，不存在多线程间共享的问题。\",\"ThreadLocal 提供了线程本地的变量副本。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。\",\"下图可以增强理解：\",\"image-20240106113729346\"]},\"281\":{\"h\":\"ThreadLocal的使用示例\",\"t\":[\"下面是一个简单的示例，演示了如何在多个线程中使用ThreadLocal：\",\"import java.util.concurrent.atomic.AtomicInteger; public class ThreadLocalExample { private static ThreadLocal<AtomicInteger> threadLocal = ThreadLocal.withInitial(AtomicInteger::new); public static void main(String[] args) { Runnable incrementTask = () -> { // 获取当前线程的变量副本 AtomicInteger value = threadLocal.get(); // 对变量进行操作 value.incrementAndGet(); // 打印当前线程的变量值 System.out.println(Thread.currentThread().getName() + \\\": \\\" + value.get()); // 清除当前线程的变量副本 threadLocal.remove(); }; // 创建多个线程并执行任务 Thread thread1 = new Thread(incrementTask); Thread thread2 = new Thread(incrementTask); Thread thread3 = new Thread(incrementTask); thread1.start(); thread2.start(); thread3.start(); } } \",\"在上面的示例中，首先创建了一个ThreadLocal对象 threadLocal，初始值为一个AtomicInteger对象。每个线程通过 threadLocal.get() 方法获取自己的变量副本，并进行+1操作。最后，通过 threadLocal.remove() 方法清除变量副本。\",\"运行示例代码，可以看到每个线程都有自己独立的变量副本，并且执行自己的操作，而不会互相干扰。\"]},\"282\":{\"h\":\"ThreadLocal原理分析\",\"t\":[\"在线程的内部有一个变量threadLocals，它是一个ThreadLocal.ThreadLocalMap对象，这个对象是一个定制化的Map，用于存储本地变量的。threadLocals的key需要是ThreadLocal对象，所以一个线程可以存储多个ThreadLocal对象：\",\"/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; \",\"ThreadLocalMap是由ThreadLocal维护的静态内部类。在使用ThreadLocal的get()、set()方法时，其实都是调用了线程中threadLocals变量的ThreadLocalMap类对应的get()、set()方法。在调用set方法，首先获取当前线程对象：\",\"public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } \",\"然后通过getMap方法来获取当前线程中的threadLocals：\",\"ThreadLocalMap getMap(Thread t) { return t.threadLocals; } \",\"如果Thread中的threadLocals变量为null，会创建一个ThreadLocalMap并赋值给Thread：\",\"void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } \",\"如果已经存在，则通过ThreadLocalMap的set方法设置值，这里我们可以看到set中key为this，也就是当前ThreadLocal对象，而value值则是我们要存的值。\",\"对应的get方法源码如下：\",\"public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\\\"unchecked\\\") T result = (T)e.value; return result; } } return setInitialValue(); } \",\"下面我们通过一个流程图来汇总一下上述流程：\",\"image-20240106122058598\"]},\"283\":{\"h\":\"ThreadLocal的使用场景\",\"t\":[\"ThreadLocal在多线程编程中有各种使用场景。以下是一些常见的使用场景：\",\"线程安全的对象：使用ThreadLocal可以实现每个线程拥有自己的对象实例，从而避免多线程并发访问时的线程安全问题。比如，在Web开发中，可以使用ThreadLocal来保存每个请求的用户身份信息，以便在处理请求的过程中使用，而不需要在每个方法中传递这些信息。\",\"数据库连接管理：在多线程环境下，使用ThreadLocal可以确保每个线程都有自己的数据库连接。这样可以避免多个线程共享同一个数据库连接时的并发问题，同时还可以减少连接的创建和销毁开销。\",\"事务管理：在某些情况下，需要在多个方法之间共享事务状态。使用ThreadLocal可以在每个线程中保存事务状态，以便在需要时进行回滚或提交。\",\"用户级别的上下文信息：在某些应用场景中，需要将某些用户级别的上下文信息在同一个线程中共享，而不需要在每个方法中显式传递这些信息。ThreadLocal可以用于保存用户的上下文信息。比如Log4j的MDC。\",\"缓存管理：ThreadLocal可以用于保存每个线程的缓存实例，以避免多个线程共享同一个缓存实例时的并发问题。\",\"需要注意的是，尽管ThreadLocal可以用于保存线程本地的对象实例，但并不是说所有的情况都适合使用ThreadLocal。在使用ThreadLocal时，需要注意线程安全性、内存泄漏以及资源的释放等问题。\"]},\"284\":{\"h\":\"ThreadLocal内存泄露\",\"t\":[\"ThreadLocal使用不当可能会出现内存泄露，进而可能导致内存溢出。下面我们就来分析一下内存泄露的原因及相关设计思想。\"]},\"285\":{\"h\":\"内存引用链路\",\"t\":[\"在使用ThreadLocal时，每个线程都会在自己的ThreadLocalMap对象中为该ThreadLocal对象创建一个Entry对象，并将ThreadLocal对象作为key，value为业务需要存储的Object。\",\"假设ThreadLocal对象被定义为静态变量，那么它的生命周期会与ClassLoader相同，并一直存在于内存中，不会被回收。而每个线程的ThreadLocalMap对象则是随着线程的销毁而销毁，而且ThreadLocalMap的Entry对象是使用ThreadLocal的弱引用作为Key创建的，因此当ThreadLocal对象没有其他强引用指向时，它会被垃圾回收，对应的Entry也会被从ThreadLocalMap中删除。这样，在业务中无需担心内存泄漏的问题。\",\"image-20240106124807435\",\"下面我们先来了解一下Java中引用的分类。\"]},\"286\":{\"h\":\"Java中的引用\",\"t\":[\"Java中通常会存在以下类型的引用：强引用、弱引用、软引用、虚引用。\",\"强引用：通常new出来的对象就是强引用类型，只要引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候；\",\"软引用：使用SoftReference修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收。如果回收之后，还没有足够的内存，才会抛出内存溢出异常；\",\"弱引用：使用WeakReference修饰的对象被称为弱引用，只要发生垃圾回收，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。\",\"虚引用：虚引用是最弱的引用，在Java中使用PhantomReference进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知。\"]},\"287\":{\"h\":\"泄露原因分析\",\"t\":[\"正常来说，当Thread执行完会被销毁，Thread.threadLocals指向的ThreadLocalMap实例也随之变为垃圾，它里面存放的Entity也会被回收。这种情况是不会发生内存泄漏的。\",\"发生内存泄露的场景一般存在于线程池的情况下。此时，Thread生命周期比较长（存在循环使用），threadLocals引用一直存在，当其存放的ThreadLocal被回收（弱引用生命周期比较短）后，对应的Entity就成了key为null的实例，但value值不会被回收。如果此Entity一直不被get()、set()、remove()，就一直不会被回收，也就发生了内存泄漏。\",\"所以，通常在使用完ThreadLocal后需要调用remove()方法进行内存的清除。\",\"比如在web请求当中，我们可以通过过滤器等进行回收方法的调用：\",\"public void doFilter(ServeletRequest request, ServletResponse){ try{ //设置ThreadLocal变量 localName.set(\\\"程序新视界\\\"); chain.doFilter(request, response) }finally{ //调用remove方法溢出threadLocal中的变量 localName.remove(); } } \"]},\"288\":{\"h\":\"InheritableThreadLocal 父子线程间的数据共享\",\"t\":[\"InheritableThreadLocal是ThreadLocal的一个变种，它允许子线程继承父线程的ThreadLocal变量值。\",\"ThreadLocal变量通常在一个线程内部使用，并且对其他线程是不可见的。但是有时候，我们希望父线程设置的ThreadLocal变量的值可以被其创建的子线程继承和使用。这就是使用InheritableThreadLocal的场景。\",\"InheritableThreadLocal和ThreadLocal的使用方式非常相似，可以通过set方法设置变量的值，通过get方法获取变量的值。不同之处在于，InheritableThreadLocal可以在父线程和子线程之间实现变量值的传递。当一个线程创建了一个子线程时，子线程会继承父线程中的InheritableThreadLocal的值。\",\"InheritableThreadLocal的原理和内部实现与ThreadLocal类似，每个线程都维护一个InheritableThreadLocalMap对象，用于保存线程本地变量的值。当一个线程创建子线程时，子线程会复制父线程的InheritableThreadLocalMap，并继承父线程中的InheritableThreadLocal的值。\",\"需要注意的是，InheritableThreadLocal并不能解决所有线程间的共享数据问题。它只是提供了一种在父子线程之间传递ThreadLocal变量值的机制，并且对其他线程仍然是不可见的。对于多个线程之间需要共享数据的情况，仍然需要使用其他的线程同步机制，如锁、信号量等。\",\"使用示例：\",\"public class InheritableThreadLocalTest { public static void main(String[] args) { ThreadLocal<String> threadLocal = new ThreadLocal<>(); InheritableThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>(); threadLocal.set(\\\"123\\\"); inheritableThreadLocal.set(\\\"123\\\"); Thread thread = new Thread(()->{ System.out.println(\\\"ThreadLocal value \\\" + threadLocal.get()); System.out.println(\\\"InheritableThreadLocal value \\\" + inheritableThreadLocal.get()); }); thread.start(); } } //运行结果 ThreadLocal value null InheritableThreadLocal value 123 \",\"可以发现，在子线程中，是可以获取到父线程的 InheritableThreadLocal 类型变量的值，但是不能获取到 ThreadLocal 类型变量的值。\",\"获取不到ThreadLocal 类型的值，我们可以好理解，因为它是线程隔离的嘛。InheritableThreadLocal 是如何做到的呢？原理是什么呢？\",\"在Thread类中，除了成员变量threadLocals之外，还有另一个成员变量：inheritableThreadLocals。它们两类型是一样的：\",\"public class Thread implements Runnable { ThreadLocalMap threadLocals = null; ThreadLocalMap inheritableThreadLocals = null; } \",\"Thread类的init方法中，有一段初始化设置：\",\"private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { ...... if (inheritThreadLocals && parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); } static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) { return new ThreadLocalMap(parentMap); } \",\"可以发现，当parent的inheritableThreadLocals不为null时，就会将parent的inheritableThreadLocals，赋值给前线程的inheritableThreadLocals。说白了，就是如果当前线程的inheritableThreadLocals不为null，就从父线程哪里拷贝过来一个过来，类似于另外一个ThreadLocal，但是数据从父线程那里来的。\"]},\"289\":{\"h\":\"参考\",\"t\":[\"https://heapdump.cn/article/2591416\",\"https://juejin.cn/post/7126708538440679460\"]},\"290\":{\"h\":\"JAVA并发包的线程池:ThreadPoolExecutor详解\"},\"291\":{\"h\":\"前言\",\"t\":[\"《阿里巴巴Java手册》手册中要求：\",\"线程资源必须通过线程池提供，不允许在应用自行显式创建线程； 说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗内存或者“过度切换”的问题。\",\"这么做的原因是，创建线程的开销很大，需要大约2MB的内存。如果创建线程和销毁线程的频次很高，需要频繁的创建线程和销毁线程，会造成频繁的GC，影响程序的整体性能。\",\"使用线程池的主要目的是为了更高效地管理和利用线程资源：\",\"降低线程创建和销毁的开销：线程的创建和销毁是有一定开销的，包括内存分配、上下文切换等。频繁地创建和销毁线程会浪费大量的资源，降低系统性能。而线程池中的线程可以被重复利用，避免了频繁的创建和销毁，从而降低了开销。\",\"提高系统的响应速度和吞吐量：线程池中的线程处于就绪状态，可以立即执行任务，不需要等待线程的创建。同时，由于线程池可以控制线程的数量，可以根据系统负载动态调整线程数量，进一步提高系统的吞吐量。\",\"避免线程的过度创建和资源耗尽：如果大量的任务没有采用线程池的方式去执行，而是直接通过创建线程的方式执行，可能会导致系统中的线程数量过度膨胀，消耗大量的系统资源。而线程池可以通过合理的配置，控制线程的数量，避免这种情况的发生。\",\"统一管理线程的执行和状态：线程池提供了统一的管理和监控机制，可以更方便地管理线程的执行状态、优先级、超时时间、中断机制等。可以更好地适应业务需求，提供更加灵活和可控的线程管理方式。\"]},\"292\":{\"h\":\"ThreadPoolExecutor类图\",\"t\":[\"Java并发包中的线程池，核心实现类是ThreadPoolExecutor，它的类图如下所示：\",\"img\",\"Executor线程池顶级接口，它有一个任务执行的方法。\",\"ExecutorService继承并扩展了Executor接口，提供了Runnable、FutureTask等主要线程实现接口扩展\",\"ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务\",\"ScheduledExecutorService继承ExecutorService接口，并定义延迟或定期执行的方法\",\"ScheduledThreadPoolExecutor继承ThreadPoolExecutor并实现了ScheduledExecutorService接口，是延时执行类任务的主要实现\"]},\"293\":{\"h\":\"ThreadPoolExecutor线程池的生命周期\",\"t\":[\"private static final int RUNNING = -1 << COUNT_BITS; private static final int SHUTDOWN = 0 << COUNT_BITS; private static final int STOP = 1 << COUNT_BITS; private static final int TIDYING = 2 << COUNT_BITS; private static final int TERMINATED = 3 << COUNT_BITS; \",\"RUNNING：表示线程池处于运行状态，可以接收新的任务并执行。\",\"SHUTDOWN：表示线程池已经关闭，不再接受新的任务，但会执行已经提交的任务。\",\"STOP：表示线程池已经停止，不接受新任务，也不再执行已提交的任务，并且会中断正在执行的任务。\",\"TIDYING：表示线程池正在进行一些清理工作，例如线程回收等。\",\"TERMINATED：表示线程池已经终止，所有任务已经完成，所有线程已经关闭。此时，线程池的状态已经结束。\",\"image\",\"总的可以概括线程池的生命周期，包括以下几个阶段：\",\"创建阶段：在这个阶段，线程池被创建，并进行了一些初始化操作，包括创建线程池的内部数据结构、预先启动一定数量的核心线程等。\",\"运行阶段：在创建阶段之后，线程池进入了运行状态。此时，线程池可以接受任务，并使用可用的线程来执行任务。当任务队列中有任务时，线程池会从任务队列中获取任务，并将其分派给空闲的线程执行。\",\"关闭阶段：当不再需要线程池时，可以调用线程池的关闭方法进行关闭操作。在关闭阶段，线程池将不再接受新的任务，并开始逐渐停止执行任务。已经提交但尚未执行的任务，根据具体的关闭策略可能会被丢弃或者等待执行完成。\",\"终止阶段：在关闭阶段之后，线程池进入终止状态。在终止阶段，线程池的所有任务都已经执行完毕，所有的线程都已经关闭。此时，线程池被认为是终止状态，并且可以进行资源清理和释放。\"]},\"294\":{\"h\":\"ThreadPoolExecutor构造函数\",\"t\":[\"查看源码，ThreadPoolExecutor的构造函数如下：\",\"public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } \",\"ThreadPoolExecutor的构造函数包含了7个核心参数，如下：\",\"corePoolSize：核心线程池的大小\",\"maximumPoolSize：最大线程池的大小\",\"keepAliveTime：当线程池中线程数大于corePoolSize，并且没有可执行任务时，大于corePoolSize那部分线程会被销毁，keepAliveTime被销毁线程的存活时间\",\"unit：keepAliveTime的时间单位\",\"workQueue：用来保存任务的工作队列\",\"threadFactory：线程工厂，用来提供线程的创建方式，默认使用Executors.defaultThreadFactory()\",\"handler：线程池拒绝策略，当线程池所处理的任务数超过其可以处理的容量时，会调用的拒绝策略\",\"如果想要创建一个符合业务场景的线程池，不仅需要对线程池的核心参数需要了解清楚，而且还需要通过压测或者开发经验去大概评估参数的设置。\"]},\"295\":{\"h\":\"corePoolSize\",\"t\":[\"corePoolSize 是线程池中的核心线程数量。在创建线程池时，核心线程会被立即创建并准备好接受任务。这些核心线程会一直存在于线程池中，除非显式地调用了线程池的 setCorePoolSize() 或 allowCoreThreadTimeOut(boolean) 方法来更改核心线程数量或允许核心线程超时。\",\"在核心线程数量内，线程池的线程会一直存活，即使线程处于空闲状态也不被销毁。这有助于快速响应任务请求并提供较低的响应延迟。\",\"核心线程数量的设置应该根据具体应用的需求来进行调整。过大的核心线程数量可能会占用过多的系统资源，而过小的核心线程数量可能无法满足任务执行的需求。在进行调整时，需要综合考虑任务的类型、数量、执行时间以及系统的硬件资源等因素。\",\"一般工程经验，对于CPU密集型的任务，一般核心线程数是Cpu的个数+1；而对于IO密集型的任务，一般核心线程数是Cpu的个数*2+1。\",\"也可以使用下面的公式去确定核心线程数可以参考以下公式： [![img](https://cdn.nlark.com/yuque/__latex/4c8ae8034f2c6247e9b0cfc4425463a6.svg#card=math&code=N_{thread}%3DN_{cpu} * U_{cpu} * (1%2BW%2FC)&height=19&id=cxIGD)](https://cdn.nlark.com/yuque/__latex/4c8ae8034f2c6247e9b0cfc4425463a6.svg#card=math&code=N_{thread}%3DN_{cpu} * U_{cpu} * (1%2BW%2FC)&height=19&id=cxIGD) 其中参数含义如下：\",\"是处理器的核数目，可以通过Runtime.getRuntime().availableProcessors()获得\",\"是期望的CPU利用率，介于0-1之间\",\"W/C是等待时间与计算时间的比率\"]},\"296\":{\"h\":\"keepAliveTime\",\"t\":[\"keepAliveTime 是指线程在空闲状态下的存活时间。当线程池中的线程数量超过核心线程数时，并且有一段时间没有任务可执行时，多余的线程会根据 keepAliveTime 的设定被回收。\",\"具体来说，当线程池中的线程数量超过 corePoolSize，并且没有新的任务到达时，多余的线程将会根据 keepAliveTime 的设定进行等待。如果在 keepAliveTime 的时间内仍然没有新的任务提交，那么这些多余的线程将会被终止，减少线程池中的线程数量。\",\"通过设置合适的 keepAliveTime 值，可以控制线程池中线程的数量，避免资源浪费和线程过多导致的性能下降。\"]},\"297\":{\"h\":\"workQueue\",\"t\":[\"workQueue 是线程池中用于存放待执行任务的队列。当线程池中的线程数量达到核心线程数(corePoolSize)时，如果有新的任务提交给线程池，，这些新的任务会被放入 workQueue 中等待执行。\",\"workQueue 可以是不同类型的队列，常见的队列类型包括：\",\"无界队列：任务可以无限制地添加进队列中，默认为无界队列。例如，使用无容量限制的 LinkedBlockingQueue，它可以存放任意数量的任务，直到内存耗尽。不建议使用。\",\"有界队列：任务数量有上限。例如，使用 ArrayBlockingQueue，或者有容量限制的LinkedBlockingQueue，需要指定队列的容量，超过容量后会阻塞新任务的提交。\",\"同步队列：任务只能一个一个地被提交给线程池进行执行。例如，使用 SynchronousQueue，每个任务都需要等待一个空闲的线程来处理，适合于负载较高的场景。通常不推荐。\"]},\"298\":{\"h\":\"SynchronousQueue\",\"t\":[\"SynchronousQueue并不能算得上一个真正的队列，虽然实现了BlockingQueue接口，但是并没有容量，不能存储任务。只是维护一组线程，在等待着把元素加入或移出队列，相当于直接交接任务给具体执行的线程。 如果没有立即可用的线程来运行任务，则尝试将任务排队失败，因此将构造一个新线程。在处理可能具有内部依赖关系的请求集时，此策略可避免锁定。这种队列方式通常需要无限的maximumPoolSizes以避免拒绝新提交的任务。当任务提交的平均到达速度快于线程处理速度时，线程存在无限增长的可能性，而CachedThreadPool正式采用这种形式。\"]},\"299\":{\"h\":\"LinkedBlockingQueue\",\"t\":[\"LinkedBlockingQueue是采用链表实现的无界队列，如果使用没有预定义容量的LinkedBlockingQueue，当所有corePoolSize线程都在处理任务时，将导致新任务都会在队列中等待，不会创建超过corePoolSize个线程。这种场景下maximumPoolSize的值对于线程数量没有任何影响。 这种依托队列处理任务的方式恰与SynchronousQueue依托线程处理任务的方式相反。\"]},\"300\":{\"h\":\"ArrayBlockingQueue\",\"t\":[\"ArrayBlockingQueue是通过数组实现的有界队列。有界队列在与有限的maximumPoolSizes一起使用时有助于防止资源耗尽，但可能更难以调整和控制。使用ArrayBlockingQueue可以根据应用场景，预先估计池和队列的容量，互相权衡队列大小和最大池大小：\",\"使用大队列和小池：减少线程数量，可以最大限度地减少CPU使用率、操作系统资源和上下文切换开销，但可能会导致吞吐量降低\",\"使用小队列大池：较大数量的线程，如果任务提交速度过快，会在短时间内提升CPU使用率，理论上可以提高系统的吞吐量。如果任务经常阻塞（如受到IO限制），会使得CPU切换更加频繁，可能会遇到更大的调度开销，这也会降低吞吐量\"]},\"301\":{\"h\":\"threadFactory\",\"t\":[\"该参数提供了线程池中线程的创建方式，这里使用了工厂模式ThreadFactory创建新线程，默认情况下，会使用 Executors.defaultThreadFactory，它创建的线程都在同一个ThreadGroup中，并具有相同的NORM_PRIORITY优先级和非守护进程状态。\"]},\"302\":{\"h\":\"handler\",\"t\":[\"如果线程池处于饱和状态，没有足够的线程数或者队列空间来处理提交的任务，或者是线程池已经处于关闭状态但还在处理进行中的任务，那么继续提交的任务就会根据线程池的拒绝策略处理。\",\"无论哪种情况，execute方法都会调用其RejectedExecutionHandler的rejectedExecution方法。线程池中提供了四个预定义的处理程序策略：\",\"CallerRunsPolicy：当线程池无法接受新的任务时，执行任务的线程会使用调用线程来执行该任务。也就是说，提交任务的线程会自己执行任务，这样可以避免任务丢失，但可能会影响提交任务线程的性能。\",\"AbortPolicy：当线程池无法接受新的任务时，抛出 RejectedExecutionException 异常，拒绝执行该任务。这是默认的处理策略。\",\"DiscardPolicy：当线程池无法接受新的任务时，直接丢弃该任务，不会有任何异常抛出。\",\"DiscardOldestPolicy：当线程池无法接受新的任务时，丢弃队列中最旧的等待任务，并尝试重新提交被拒绝的任务。\",\"这些预定义策略都实现了RejectedExecutionHandler接口，也可以定义实现类重写拒绝策略。\"]},\"303\":{\"h\":\"线程池的工作流程\",\"t\":[\"线程池的工作流程如下如下图所示：\",\"在这里插入图片描述\",\"创建线程池：首先，根据需求配置线程池的参数，包括核心线程数、最大线程数、keepAliveTime、workQueue 等。\",\"提交任务：当有任务需要执行时，将任务提交给线程池。\",\"判断核心线程是否创建：线程池会根据核心线程数来判断是否需要创建新的线程来执行任务。如果当前运行的线程数小于核心线程数，线程池就会创建一个新的线程来执行任务，此过程是非阻塞的。\",\"加入工作队列：如果当前运行的线程数已经达到核心线程数，但有新的任务到达，线程池会将任务放入 workQueue 中等待执行。\",\"判断最大线程是否创建：如果线程池中的线程数已经达到核心线程数，并且工作队列已满，此时线程池会判断是否需要创建新的线程来执行任务。如果当前运行的线程数小于最大线程数，线程池会创建一个新的线程来执行任务。\",\"任务被拒绝时的处理：如果线程池已经达到最大线程数，并且工作队列也已满，此时线程池会根据设置的拒绝策略来处理提交的任务，比如抛出异常或者丢弃任务。\"]},\"304\":{\"h\":\"为什么线程池不允许使用Executors去创建?\",\"t\":[\"线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端：\",\"newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。\",\"newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。\"]},\"305\":{\"h\":\"推荐方式 1\",\"t\":[\"首先引入：commons-lang3包\",\"ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().namingPattern(\\\"example-schedule-pool-%d\\\").daemon(true).build()); \"]},\"306\":{\"h\":\"推荐方式 2\",\"t\":[\"首先引入：com.google.guava包\",\"ThreadFactory namedThreadFactory = new ThreadFactoryBuilder().setNameFormat(\\\"demo-pool-%d\\\").build(); //Common Thread Pool ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); // excute pool.execute(()-> System.out.println(Thread.currentThread().getName())); //gracefully shutdown pool.shutdown(); \"]},\"307\":{\"h\":\"ThreadPoolExecutor源码详解\"},\"308\":{\"h\":\"几个关键属性\",\"t\":[\"//这个属性是用来存放 当前运行的worker数量以及线程池状态的 //int是32位的，这里把int的高3位拿来充当线程池状态的标志位,后29位拿来充当当前运行worker的数量 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); //存放任务的阻塞队列 private final BlockingQueue<Runnable> workQueue; //worker的集合,用set来存放 private final HashSet<Worker> workers = new HashSet<Worker>(); //历史达到的worker数最大值 private int largestPoolSize; //当队列满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略 private volatile RejectedExecutionHandler handler; //超出coreSize的worker的生存时间 private volatile long keepAliveTime; //常驻worker的数量 private volatile int corePoolSize; //最大worker的数量,一般当workQueue满了才会用到这个参数 private volatile int maximumPoolSize; \"]},\"309\":{\"h\":\"内部状态\",\"t\":[\"private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); private static final int COUNT_BITS = Integer.SIZE - 3; private static final int CAPACITY = (1 << COUNT_BITS) - 1; // runState is stored in the high-order bits private static final int RUNNING = -1 << COUNT_BITS; private static final int SHUTDOWN = 0 << COUNT_BITS; private static final int STOP = 1 << COUNT_BITS; private static final int TIDYING = 2 << COUNT_BITS; private static final int TERMINATED = 3 << COUNT_BITS; // Packing and unpacking ctl private static int runStateOf(int c) { return c & ~CAPACITY; } private static int workerCountOf(int c) { return c & CAPACITY; } private static int ctlOf(int rs, int wc) { return rs | wc; } \",\"其中AtomicInteger变量ctl的功能非常强大: 利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态:\",\"RUNNING: -1 << COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；\",\"SHUTDOWN: 0 << COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；\",\"STOP : 1 << COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；\",\"TIDYING : 2 << COUNT_BITS，即高3位为010, 所有的任务都已经终止；\",\"TERMINATED: 3 << COUNT_BITS，即高3位为011, terminated()方法已经执行完成\",\"img\"]},\"310\":{\"h\":\"任务的执行\",\"t\":[\"execute –> addWorker –>runworker (getTask)\",\"线程池的工作线程通过Woker类实现，在ReentrantLock锁的保证下，把Woker实例插入到HashSet后，并启动Woker中的线程。 从Woker类的构造方法实现可以发现: 线程工厂在创建线程thread时，将Woker实例本身this作为参数传入，当执行start方法启动线程thread时，本质是执行了Worker的runWorker方法。 firstTask执行完成之后，通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；\"]},\"311\":{\"h\":\"execute()方法\",\"t\":[\"ThreadPoolExecutor.execute(task)实现了Executor.execute(task)\",\"public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); if (workerCountOf(c) < corePoolSize) { //workerCountOf获取线程池的当前线程数；小于corePoolSize，执行addWorker创建新线程执行command任务 if (addWorker(command, true)) return; c = ctl.get(); } // double check: c, recheck // 线程池处于RUNNING状态，把提交的任务成功放入阻塞队列中 if (isRunning(c) && workQueue.offer(command)) { int recheck = ctl.get(); // recheck and if necessary 回滚到入队操作前，即倘若线程池shutdown状态，就remove(command) //如果线程池没有RUNNING，成功从阻塞队列中删除任务，执行reject方法处理任务 if (! isRunning(recheck) && remove(command)) reject(command); //线程池处于running状态，但是没有线程，则创建线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); } // 往线程池中创建新的线程失败，则reject任务 else if (!addWorker(command, false)) reject(command); } \",\"为什么需要double check线程池的状态?\",\"在多线程环境下，线程池的状态时刻在变化，而ctl.get()是非原子操作，很有可能刚获取了线程池状态后线程池状态就改变了。判断是否将command加入workque是线程池之前的状态。倘若没有double check，万一线程池处于非running状态(在多线程环境下很有可能发生)，那么command永远不会执行。\"]},\"312\":{\"h\":\"addWorker方法\",\"t\":[\"从方法execute的实现可以看出: addWorker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:\",\"private final ReentrantLock mainLock = new ReentrantLock(); private boolean addWorker(Runnable firstTask, boolean core) { // CAS更新线程池数量 retry: for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs >= SHUTDOWN && ! (rs == SHUTDOWN && firstTask == null && ! workQueue.isEmpty())) return false; for (;;) { int wc = workerCountOf(c); if (wc >= CAPACITY || wc >= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop } } boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try { w = new Worker(firstTask); final Thread t = w.thread; if (t != null) { // 线程池重入锁 final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) { if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s > largestPoolSize) largestPoolSize = s; workerAdded = true; } } finally { mainLock.unlock(); } if (workerAdded) { t.start(); // 线程启动，执行任务(Worker.thread(firstTask).start()); workerStarted = true; } } } finally { if (! workerStarted) addWorkerFailed(w); } return workerStarted; } \"]},\"313\":{\"h\":\"Worker类的runworker方法\",\"t\":[\" private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); // 创建线程 } /** Delegates main run loop to outer runWorker */ public void run() { runWorker(this); } // ... } \",\"继承了AQS类，可以方便的实现工作线程的中止操作；\",\"实现了Runnable接口，可以将自身作为一个任务在工作线程中执行；\",\"当前提交的任务firstTask作为参数传入Worker的构造方法；\",\"一些属性还有构造方法:\",\"//运行的线程,前面addWorker方法中就是直接通过启动这个线程来启动这个worker final Thread thread; //当一个worker刚创建的时候,就先尝试执行这个任务 Runnable firstTask; //记录完成任务的数量 volatile long completedTasks; Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; //创建一个Thread,将自己设置给他,后面这个thread启动的时候,也就是执行worker的run方法 this.thread = getThreadFactory().newThread(this); } \",\"runWorker方法是线程池的核心:\",\"线程启动之后，通过unlock方法释放锁，设置AQS的state为0，表示运行可中断；\",\"Worker执行firstTask或从workQueue中获取任务: \",\"进行加锁操作，保证thread不被其他线程中断(除非线程池被中断)\",\"检查线程池状态，倘若线程池处于中断状态，当前线程将中断。\",\"执行beforeExecute\",\"执行任务的run方法\",\"执行afterExecute方法\",\"解锁操作\",\"通过getTask方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；\",\"final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try { // 先执行firstTask，再从workerQueue中取task(getTask()) while (task != null || (task = getTask()) != null) { w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))) && !wt.isInterrupted()) wt.interrupt(); try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } \"]},\"314\":{\"h\":\"getTask方法\",\"t\":[\"下面来看一下getTask()方法，这里面涉及到keepAliveTime的使用，从这个方法我们可以看出线程池是怎么让超过corePoolSize的那部分worker销毁的。\",\"private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) { decrementWorkerCount(); return null; } int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) { if (compareAndDecrementWorkerCount(c)) return null; continue; } try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } \",\"注意这里一段代码是keepAliveTime起作用的关键:\",\"boolean timed = allowCoreThreadTimeOut || wc > corePoolSize; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); \",\"allowCoreThreadTimeOut为false，线程即使空闲也不会被销毁；倘若为ture，在keepAliveTime内仍空闲则会被销毁。\",\"如果线程允许空闲等待而不被销毁timed == false，workQueue.take任务: 如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务，并执行；\",\"如果线程不允许无休止空闲timed == true, workQueue.poll任务: 如果在keepAliveTime时间内，阻塞队列还是没有任务，则返回null；\"]},\"315\":{\"h\":\"任务的提交\",\"t\":[\"img\",\"submit任务，等待线程池execute\",\"执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；\",\"FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；\",\"public class Test{ public static void main(String[] args) { ExecutorService es = Executors.newCachedThreadPool(); Future<String> future = es.submit(new Callable<String>() { @Override public String call() throws Exception { try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"future result\\\"; } }); try { String result = future.get(); System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } \",\"在实际业务场景中，Future和Callable基本是成对出现的，Callable负责产生结果，Future负责获取结果。\",\"Callable接口类似于Runnable，只是Runnable没有返回值。\",\"Callable任务除了返回正常结果之外，如果发生异常，该异常也会被返回，即Future可以拿到异步执行任务各种结果；\",\"Future.get方法会导致主线程阻塞，直到Callable任务执行完成；\"]},\"316\":{\"h\":\"submit方法\",\"t\":[\"AbstractExecutorService.submit()实现了ExecutorService.submit() 可以获取执行完的返回值, 而ThreadPoolExecutor 是AbstractExecutorService.submit()的子类，所以submit方法也是ThreadPoolExecutor`的方法。\",\"// submit()在ExecutorService中的定义 <T> Future<T> submit(Callable<T> task); <T> Future<T> submit(Runnable task, T result); Future<?> submit(Runnable task); // submit方法在AbstractExecutorService中的实现 public Future<?> submit(Runnable task) { if (task == null) throw new NullPointerException(); // 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。 RunnableFuture<Void> ftask = newTaskFor(task, null); execute(ftask); return ftask; } \",\"通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；\"]},\"317\":{\"h\":\"FutureTask对象\",\"t\":[\"public class FutureTask<V> implements RunnableFuture<V> 可以将FutureTask提交至线程池中等待被执行(通过FutureTask的run方法来执行)\",\"内部状态\",\"/* The run state of this task, initially NEW. * ... * Possible state transitions: * NEW -> COMPLETING -> NORMAL * NEW -> COMPLETING -> EXCEPTIONAL * NEW -> CANCELLED * NEW -> INTERRUPTING -> INTERRUPTED */ private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; \",\"内部状态的修改通过sun.misc.Unsafe修改\",\"get方法\",\"public V get() throws InterruptedException, ExecutionException { int s = state; if (s <= COMPLETING) s = awaitDone(false, 0L); return report(s); } \",\"内部通过awaitDone方法对主线程进行阻塞，具体实现如下:\",\"private int awaitDone(boolean timed, long nanos) throws InterruptedException { final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) { if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } int s = state; if (s > COMPLETING) { if (q != null) q.thread = null; return s; } else if (s == COMPLETING) // cannot time out yet Thread.yield(); else if (q == null) q = new WaitNode(); else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset,q.next = waiters, q); else if (timed) { nanos = deadline - System.nanoTime(); if (nanos <= 0L) { removeWaiter(q); return state; } LockSupport.parkNanos(this, nanos); } else LockSupport.park(this); } } \",\"如果主线程被中断，则抛出中断异常；\",\"判断FutureTask当前的state，如果大于COMPLETING，说明任务已经执行完成，则直接返回；\",\"如果当前state等于COMPLETING，说明任务已经执行完，这时主线程只需通过yield方法让出cpu资源，等待state变成NORMAL；\",\"通过WaitNode类封装当前线程，并通过UNSAFE添加到waiters链表；\",\"最终通过LockSupport的park或parkNanos挂起线程；\"]},\"318\":{\"h\":\"run方法\",\"t\":[\"public void run() { if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable<V> c = callable; if (c != null && state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s >= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } \",\"FutureTask.run方法是在线程池中被执行的，而非主线程\",\"通过执行Callable任务的call方法；\",\"如果call执行成功，则通过set方法保存结果；\",\"如果call执行有异常，则通过setException保存异常；\"]},\"319\":{\"h\":\"任务的关闭\",\"t\":[\"shutdown方法会将线程池的状态设置为SHUTDOWN,线程池进入这个状态后,就拒绝再接受任务,然后会将剩余的任务全部执行完\",\"public void shutdown() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //检查是否可以关闭线程 checkShutdownAccess(); //设置线程池状态 advanceRunState(SHUTDOWN); //尝试中断worker interruptIdleWorkers(); //预留方法,留给子类实现 onShutdown(); // hook for ScheduledThreadPoolExecutor } finally { mainLock.unlock(); } tryTerminate(); } private void interruptIdleWorkers() { interruptIdleWorkers(false); } private void interruptIdleWorkers(boolean onlyOne) { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //遍历所有的worker for (Worker w : workers) { Thread t = w.thread; //先尝试调用w.tryLock(),如果获取到锁,就说明worker是空闲的,就可以直接中断它 //注意的是,worker自己本身实现了AQS同步框架,然后实现的类似锁的功能 //它实现的锁是不可重入的,所以如果worker在执行任务的时候,会先进行加锁,这里tryLock()就会返回false if (!t.isInterrupted() && w.tryLock()) { try { t.interrupt(); } catch (SecurityException ignore) { } finally { w.unlock(); } } if (onlyOne) break; } } finally { mainLock.unlock(); } } \",\"shutdownNow做的比较绝，它先将线程池状态设置为STOP，然后拒绝所有提交的任务。最后中断左右正在运行中的worker,然后清空任务队列。\",\"public List<Runnable> shutdownNow() { List<Runnable> tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { checkShutdownAccess(); //检测权限 advanceRunState(STOP); //中断所有的worker interruptWorkers(); //清空任务队列 tasks = drainQueue(); } finally { mainLock.unlock(); } tryTerminate(); return tasks; } private void interruptWorkers() { final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { //遍历所有worker，然后调用中断方法 for (Worker w : workers) w.interruptIfStarted(); } finally { mainLock.unlock(); } } \"]},\"320\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/starsray/p/16220051.html\",\"https://juejin.cn/post/6844904146856837128\",\"https://blog.csdn.net/programmer_at/article/details/79799267\"]},\"321\":{\"h\":\"FutureTask详解\"},\"322\":{\"h\":\"什么是FutureTask\",\"t\":[\"FutureTask 是 Java 中用于表示异步计算结果的类。它实现了 Future 接口，可以用于提交给线程池执行，并在将来的某个时间获取计算结果。\",\"img\",\"FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。\",\"FutureTask 是 Java 中用于表示异步计算结果的类。它实现了 Future 接口，可以用于提交给线程池执行，也可以直接提交给Thread类执行，并在将来的某个时间获取计算结果。\",\"FutureTask 的主要特点包括：\",\"异步执行：FutureTask 可以在后台执行一个任务，不会阻塞当前线程，并且可以获取计算结果。\",\"取消任务：可以通过 cancel() 方法取消任务的执行。如果任务已经开始执行或已经完成，则无法取消。\",\"等待结果：可以通过 get() 方法获取任务的结果。如果任务还未完成，get() 方法会阻塞当前线程直到任务完成并返回结果。\",\"超时等待：可以通过重载的 get() 方法设置等待任务结果的时间限制。如果任务在指定时间内未完成，则会抛出 TimeoutException 异常。\",\"判断任务是否完成：可以通过 isDone() 方法判断任务是否已经完成。\"]},\"323\":{\"h\":\"FutureTask使用示例\",\"t\":[\"常用使用方式：\",\"第1种方式: Future + ExecutorService\",\"第2种方式: FutureTask + Thread\",\"第3种方式: FutureTask + ExecutorService（推荐）\",\"Future + ExecutorService\",\"当使用 Future 结合 ExecutorService 时，可以实现异步提交任务，并通过 Future 获取任务的执行结果，以下是一个简单的示例：\",\"import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; public class FutureWithExecutorServiceExample { public static void main(String[] args) { // 创建一个 ExecutorService，这里使用固定大小为 1 的线程池 ExecutorService executor = Executors.newFixedThreadPool(1); // 创建一个 Callable 对象，用于执行具体的任务 Callable<Integer> task = () -> { int sum = 0; for (int i = 1; i <= 10; i++) { sum += i; Thread.sleep(500); // 模拟耗时操作 } return sum; }; // 提交任务并获得 Future 对象 Future<Integer> future = executor.submit(task); System.out.println(\\\"任务已提交，等待计算结果...\\\"); try { // 等待任务执行完成，并获取计算结果 Integer result = future.get(); System.out.println(\\\"计算结果为：\\\" + result); } catch (Exception e) { System.out.println(\\\"任务执行出错：\\\" + e.getMessage()); } // 关闭线程池 executor.shutdown(); } } \",\"在上述示例中，我们首先创建一个固定大小为 1 的线程池 ExecutorService，然后创建一个 Callable 对象 task，表示具体的任务。接着，通过 executor.submit(task) 方法提交任务并获得一个 Future 对象。我们通过 future.get() 等待任务执行完成，并获取执行结果。最后，我们关闭线程池。\",\"这样就可以利用 Future 结合 ExecutorService 实现异步任务的提交和获取执行结果。\",\"FutureTask + Thread\",\"当使用FutureTask结合Thread时，可以手动创建一个线程来执行FutureTask，以下是一个简单的示例：\",\"import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class FutureTaskWithThreadExample { public static void main(String[] args) { // 创建一个 Callable 对象，用于执行具体的任务 Callable<Integer> task = () -> { int sum = 0; for (int i = 1; i <= 10; i++) { sum += i; Thread.sleep(500); // 模拟耗时操作 } return sum; }; // 创建一个 FutureTask 对象，将 Callable 对象作为参数传入 FutureTask<Integer> futureTask = new FutureTask<>(task); // 创建一个线程，并将 FutureTask 对象传入 Thread thread = new Thread(futureTask); System.out.println(\\\"任务已提交，等待计算结果...\\\"); // 启动线程执行任务 thread.start(); try { // 等待任务执行完成，并获取计算结果 Integer result = futureTask.get(); System.out.println(\\\"计算结果为：\\\" + result); } catch (InterruptedException | ExecutionException e) { System.out.println(\\\"任务执行出错：\\\" + e.getMessage()); } } } \",\"在上述示例中，我们创建了一个Callable对象task，表示具体的任务。接着，我们将task作为参数传入FutureTask构造器创建一个FutureTask对象futureTask。然后，我们创建了一个线程，并将futureTask传入。启动线程后，我们可以通过futureTask.get()方法等待任务执行完成，并获取执行结果。\",\"这样就可以手动创建线程来执行FutureTask，并获取任务的执行结果。\",\"FutureTask + ExecutorService\",\"以下是一个使用 FutureTask 的简单示例：\",\"import java.util.concurrent.*; public class FutureTaskExample { public static void main(String[] args) { // 创建一个 Callable 对象，用于执行具体的任务 Callable<Integer> task = () -> { int sum = 0; for (int i = 1; i <= 10; i++) { sum += i; Thread.sleep(500); // 模拟耗时操作 } return sum; }; // 创建一个 FutureTask 对象，将 Callable 对象作为参数传入 FutureTask<Integer> futureTask = new FutureTask<>(task); // 创建一个线程池，并将 FutureTask 提交给线程池执行 ExecutorService executor = Executors.newSingleThreadExecutor(); executor.submit(futureTask); System.out.println(\\\"任务已提交，等待计算结果...\\\"); try { // 等待任务执行完成，并获取计算结果，可以设置超时时间 Integer result = futureTask.get(5, TimeUnit.SECONDS); System.out.println(\\\"计算结果为：\\\" + result); } catch (InterruptedException | ExecutionException | TimeoutException e) { System.out.println(\\\"任务执行出错：\\\" + e.getMessage()); } // 关闭线程池 executor.shutdown(); } } \",\"在上述示例中，我们创建了一个 Callable 对象，表示需要执行的具体任务。然后将该 Callable 对象传入 FutureTask 构造器创建一个 FutureTask 对象。接着，将 FutureTask 对象提交给线程池执行。我们通过 get() 方法等待任务执行完成，并获取执行结果。在等待任务完成时，可以设置超时时间。最后，我们关闭线程池。\"]},\"324\":{\"h\":\"FutureTask源码解析\"},\"325\":{\"h\":\"Callable接口\",\"t\":[\"对于需要执行的任务需要实现Callable接口，Callable接口定义如下:\",\"public interface Callable<V> { V call() throws Exception; } \",\"可以看到Callable是个泛型接口，泛型V就是要call()方法返回的类型。Callable接口和Runnable接口很像，都可以被另外一个线程执行，但是正如前面所说的，Runnable不会返回数据也不能抛出异常。\"]},\"326\":{\"h\":\"Future接口\",\"t\":[\"Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future接口的定义如下:\",\"public interface Future<V> { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } \",\"cancel():cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。\",\"isCanceled():判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。\",\"isDone():判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。\",\"get():获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。\",\"get(long timeout,Timeunit unit):带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。\"]},\"327\":{\"h\":\"FutureTask\",\"t\":[\"FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。\"]},\"328\":{\"h\":\"核心属性\",\"t\":[\"//内部持有的callable任务，运行完毕后置空 private Callable<V> callable; //从get()中返回的结果或抛出的异常 private Object outcome; // non-volatile, protected by state reads/writes //运行callable的线程 private volatile Thread runner; //使用Treiber栈保存等待线程 private volatile WaitNode waiters; //任务状态 private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; \",\"NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。\",\"COMPLETING:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。\",\"NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。\",\"EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。\",\"CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。\",\"INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。\",\"INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。\",\"有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。\",\"各个状态之间的可能转换关系如下图所示:\",\"img\"]},\"329\":{\"h\":\"run方法\",\"t\":[\"run()方法实现如下:\",\"public void run() { // 1. 状态如果不是NEW，说明任务或者已经执行过，或者已经被取消，直接返回 // 2. 状态如果是NEW，则尝试把当前执行线程保存在runner字段中 // 如果赋值失败则直接返回 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try { Callable<V> c = callable; if (c != null && state == NEW) { V result; boolean ran; try { // 3. 执行任务 result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; // 4. 任务异常 setException(ex); } if (ran) // 4. 任务正常执行完毕 set(result); } } finally { // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; // 5. 如果任务被中断，执行中断处理 if (s >= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } \",\"run()方法首先会\",\"判断当前任务的state是否等于NEW,如果不为NEW则说明任务或者已经执行过，或者已经被取消，直接返回。\",\"如果状态为NEW则接着会通过unsafe类把任务执行线程引用CAS的保存在runner字段中，如果保存失败，则直接返回。\",\"执行任务。\",\"如果任务执行发生异常，则调用setException()方法保存异常信息。setException()方法如下：\",\"protected void setException(Throwable t) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); } } \",\"在setException()方法中\",\"首先会CAS的把当前的状态从NEW变更为COMPLETING状态。\",\"把异常原因保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因。\",\"CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。这个状态转换对应着上图中的二。\",\"调用finishCompletion()。关于这个方法后面在分析。\",\"如果任务成功执行则调用set()方法设置执行结果，该方法实现如下:\",\"protected void set(V v) { if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) { outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); } } \",\"这个方法跟上面分析的setException()差不多，\",\"首先会CAS的把当前的状态从NEW变更为COMPLETING状态。\",\"把任务执行结果保存在outcome字段中。\",\"CAS的把当前任务状态从COMPLETING变更为NORMAL。这个状态转换对应着上图中的一。\",\"调用finishCompletion()。\",\"发起任务线程跟执行任务线程通常情况下都不会是同一个线程，在任务执行线程执行任务的时候，任务发起线程可以查看任务执行状态、获取任务执行结果、取消任务等等操作，接下来分析下这些操作。\"]},\"330\":{\"h\":\"get方法\",\"t\":[\"任务发起线程可以调用get()方法来获取任务执行结果，如果此时任务已经执行完毕则会直接返回任务结果，如果任务还没执行完毕，则调用方会阻塞直到任务执行结束返回结果为止。get()方法实现如下:\",\"public V get() throws InterruptedException, ExecutionException { int s = state; if (s <= COMPLETING) s = awaitDone(false, 0L); return report(s); } \",\"get()方法实现比较简单，会\",\"判断任务当前的state <= COMPLETING是否成立。前面分析过，COMPLETING状态是任务是否执行完成的临界状态。\",\"如果成立，表明任务还没有结束(这里的结束包括任务正常执行完毕，任务执行异常，任务被取消)，则会调用awaitDone()进行阻塞等待。\",\"如果不成立表明任务已经结束，调用report()返回结果。\"]},\"331\":{\"h\":\"awaitDone方法\",\"t\":[\"当调用get()获取任务结果但是任务还没执行完成的时候，调用线程会调用awaitDone()方法进行阻塞等待，该方法定义如下:\",\"private int awaitDone(boolean timed, long nanos) throws InterruptedException { // 计算等待截止时间 final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) { // 1. 判断阻塞线程是否被中断,如果被中断则在等待队 // 列中删除该节点并抛出InterruptedException异常 if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } // 2. 获取当前状态，如果状态大于COMPLETING // 说明任务已经结束(要么正常结束，要么异常结束，要么被取消) // 则把thread显示置空，并返回结果 int s = state; if (s > COMPLETING) { if (q != null) q.thread = null; return s; } // 3. 如果状态处于中间状态COMPLETING // 表示任务已经结束但是任务执行线程还没来得及给outcome赋值 // 这个时候让出执行权让其他线程优先执行 else if (s == COMPLETING) // cannot time out yet Thread.yield(); // 4. 如果等待节点为空，则构造一个等待节点 else if (q == null) q = new WaitNode(); // 5. 如果还没有入队列，则把当前节点加入waiters首节点并替换原来waiters else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) { // 如果需要等待特定时间，则先计算要等待的时间 // 如果已经超时，则删除对应节点并返回对应的状态 nanos = deadline - System.nanoTime(); if (nanos <= 0L) { removeWaiter(q); return state; } // 6. 阻塞等待特定时间 LockSupport.parkNanos(this, nanos); } else // 6. 阻塞等待直到被其他线程唤醒 LockSupport.park(this); } } \",\"awaitDone()中有个死循环，每一次循环都会\",\"判断调用get()的线程是否被其他线程中断，如果是的话则在等待队列中删除对应节点然后抛出InterruptedException异常。\",\"获取任务当前状态，如果当前任务状态大于COMPLETING则表示任务执行完成，则把thread字段置null并返回结果。\",\"如果任务处于COMPLETING状态，则表示任务已经处理完成(正常执行完成或者执行出现异常)，但是执行结果或者异常原因还没有保存到outcome字段中。这个时候调用线程让出执行权让其他线程优先执行。\",\"如果等待节点为空，则构造一个等待节点WaitNode。\",\"如果第四步中新建的节点还没如队列，则CAS的把该节点加入waiters队列的首节点。\",\"阻塞等待。\",\"假设当前state=NEW且waiters为NULL,也就是说还没有任何一个线程调用get()获取执行结果，这个时候有两个线程threadA和threadB先后调用get()来获取执行结果。再假设这两个线程在加入阻塞队列进行阻塞等待之前任务都没有执行完成且threadA和threadB都没有被中断的情况下(因为如果threadA和threadB在进行阻塞等待结果之前任务就执行完成或线程本身被中断的话，awaitDone()就执行结束返回了)，执行过程是这样的，以threadA为例:\",\"第一轮for循环，执行的逻辑是q == null,所以这时候会新建一个节点q。第一轮循环结束。\",\"第二轮for循环，执行的逻辑是!queue，这个时候会把第一轮循环中生成的节点的netx指针指向waiters，然后CAS的把节点q替换waiters。也就是把新生成的节点添加到waiters链表的首节点。如果替换成功，queued=true。第二轮循环结束。\",\"第三轮for循环，进行阻塞等待。要么阻塞特定时间，要么一直阻塞知道被其他线程唤醒。\"]},\"332\":{\"h\":\"cancel方法\",\"t\":[\"用户可以调用cancel(boolean)方法取消任务的执行，cancel()实现如下:\",\"public boolean cancel(boolean mayInterruptIfRunning) { // 1. 如果任务已经结束，则直接返回false if (state != NEW) return false; // 2. 如果需要中断任务执行线程 if (mayInterruptIfRunning) { // 2.1. 把任务状态从NEW转化到INTERRUPTING if (!UNSAFE.compareAndSwapInt(this, stateOffset, NEW, INTERRUPTING)) return false; Thread t = runner; // 2.2. 中断任务执行线程 if (t != null) t.interrupt(); // 2.3. 修改状态为INTERRUPTED UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); // final state } // 3. 如果不需要中断任务执行线程，则直接把状态从NEW转化为CANCELLED else if (!UNSAFE.compareAndSwapInt(this, stateOffset, NEW, CANCELLED)) return false; // 4. finishCompletion(); return true; } \",\"cancel()方法会做下面几件事:\",\"判断任务当前执行状态，如果任务状态不为NEW，则说明任务或者已经执行完成，或者执行异常，不能被取消，直接返回false表示执行失败。\",\"判断需要中断任务执行线程，则\",\"把任务状态从NEW转化到INTERRUPTING。这是个中间状态。\",\"中断任务执行线程。\",\"修改任务状态为INTERRUPTED。这个转换过程对应上图中的四。\",\"如果不需要中断任务执行线程，直接把任务状态从NEW转化为CANCELLED。如果转化失败则返回false表示取消失败。这个转换过程对应上图中的四。\",\"调用finishCompletion()。\"]},\"333\":{\"h\":\"finishCompletion方法\",\"t\":[\"根据前面的分析，不管是任务执行异常还是任务正常执行完毕，或者取消任务，最后都会调用finishCompletion()方法，该方法实现如下:\",\"private void finishCompletion() { // assert state > COMPLETING; for (WaitNode q; (q = waiters) != null;) { if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; } break; } } done(); callable = null; // to reduce footprint } \",\"这个方法的实现比较简单，依次遍历waiters链表，唤醒节点中的线程，然后把callable置空。\",\"被唤醒的线程会各自从awaitDone()方法中的LockSupport.park*()阻塞中返回，然后会进行新一轮的循环。在新一轮的循环中会返回执行结果(或者更确切的说是返回任务的状态)。\"]},\"334\":{\"h\":\"参考\",\"t\":[\"https://www.cnblogs.com/linghu-java/p/8991824.html\"]},\"335\":{\"h\":\"CompletableFuture使用详解\"},\"336\":{\"h\":\"前言\",\"t\":[\"我们一般使用多线程来提交系统的吞吐量，通常使用线程池+Runnable来实现，也可以使用Thread+Runnable来实现，但是这种方式没有返回值。如果需要使用返回值，我们会使用Future+Thread的方式来实现。在上一篇文章\",\"FutureTask详解中已经讲解了这种实现：\",\"package io.github.forezp.concurrentlab.threadpool; import java.util.concurrent.*; public class FutureTaskExample { public static void main(String[] args) { // 创建一个 Callable 对象，用于执行具体的任务 Callable<Integer> task = () -> { int sum = 0; for (int i = 1; i <= 10; i++) { sum += i; Thread.sleep(500); // 模拟耗时操作 } return sum; }; // 创建一个 FutureTask 对象，将 Callable 对象作为参数传入 FutureTask<Integer> futureTask = new FutureTask<>(task); // 创建一个线程池，并将 FutureTask 提交给线程池执行 ExecutorService executor = Executors.newSingleThreadExecutor(); executor.submit(futureTask); System.out.println(\\\"任务已提交，等待计算结果...\\\"); try { //模拟主线程执行耗时任务 Thread.sleep(1000); // 等待任务执行完成，并获取计算结果，可以设置超时时间 Integer result = futureTask.get(5, TimeUnit.SECONDS); System.out.println(\\\"计算结果为：\\\" + result); } catch (InterruptedException | ExecutionException | TimeoutException e) { System.out.println(\\\"任务执行出错：\\\" + e.getMessage()); } // 关闭线程池 executor.shutdown(); } } \",\"运行上面代码可以知道当调用代码 Integer result = futureTask.get(5, TimeUnit.SECONDS); 的时候，当前主线程是阻塞状态。因此Future+Thread这种模式有一定的局限性：在获取返回值的时候会阻塞主线程。\",\"Java8引入的**CompletableFuture**可以解决上面的问题。\"]},\"337\":{\"h\":\"CompletableFuture介绍\",\"t\":[\"image-20240108205738858\",\"CompletableFuture 是 Java 8 引入的一个用于异步编程的工具类，CompletableFuture 类实现了Future接口，并提供了额外的方法来管理异步计算的完成和组合。它提供了强大的功能来简化异步操作、串行/并行组合以及处理异步计算结果的方法。\",\"以下是 CompletableFuture 类的一些主要特性和用法：\",\"异步操作：CompletableFuture 可以通过 supplyAsync() 或 runAsync() 等静态方法，以及 CompletableFuture 对象的 thenApplyAsync()，thenComposeAsync() 等方法来执行异步操作。\",\"回调函数：CompletableFuture 通过 thenApply()，thenCompose()，thenAccept()，thenCombine()等方法支持链式调用和操作组合，可方便地对异步计算结果进行后续处理。\",\"异常处理：CompletableFuture 提供了异常处理的方法，如exceptionally()，handle() 等，方便处理异步操作中的异常情况。\",\"组合操作：CompletableFuture 可以通过 thenCombine()，thenCompose()，thenAcceptBoth() 等方法进行多个异步操作的组合。\",\"等待结果：通过 get() 方法，可以等待异步操作的完成并获取计算结果，也可以指定超时时间。\",\"组合多个 CompletableFuture：可以利用 allOf()，anyOf() 等方法来组合多个CompletableFuture对象。\",\"异步任务线程配置：可以通过 CompletableFuture 的一些静态方法设置线程池、执行器等执行异步任务的线程配置。\",\"使用 CompletableFuture 可以简化异步编程的复杂性，提供了丰富的方法和组合操作，使得异步操作和结果处理变得更加灵活和高效。\"]},\"338\":{\"h\":\"CompletableFuture使用示例\"},\"339\":{\"h\":\"CompletableFuture具有Future的功能\",\"t\":[\"以下是一个简单的使用示例，演示如何使用 CompletableFuture 执行异步操作并处理异步计算的结果：\",\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class CompletableFutureExample { public static void main(String[] args) { // 异步执行任务，并返回计算结果 CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); try { Integer result = future.get(); System.out.println(\\\"计算结果为：\\\" + result); } catch (InterruptedException | ExecutionException e) { System.out.println(\\\"等待任务执行出错：\\\" + e.getMessage()); } } } \",\"在上面的示例中，我们首先通过 CompletableFuture.supplyAsync() 方法提交一个异步任务，该任务返回一个固定的整数值。然后，通过 future.get() 方法等待异步任务执行完成，并获取计算结果。\"]},\"340\":{\"h\":\"task异步完成后使用回调函数\",\"t\":[\"import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class CompletableFutureExample { public static void main(String[] args) { // 1.异步执行任务，并返回计算结果 CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); // 2.处理异步计算的结果,task完成后回调使用回调函数thenApply() future.thenApply(result -> result * 2) .thenAcceptAsync(finalResult -> System.out.println(\\\"最终结果为：\\\" + finalResult)) .exceptionally(throwable -> { System.out.println(\\\"任务执行出错：\\\" + throwable.getMessage()); return null; }); // 3.等待异步任务执行完成 try { Integer result = future.get(); System.out.println(\\\"计算结果为：\\\" + result); } catch (InterruptedException | ExecutionException e) { System.out.println(\\\"等待任务执行出错：\\\" + e.getMessage()); } } } \",\"在上面的示例中，我们首先通过 CompletableFuture.supplyAsync() 方法提交一个异步任务，该任务返回一个固定的整数值。然后，使用 thenApply() 方法对任务的结果进行二倍处理，并通过 thenAcceptAsync() 方法异步处理最终的结果。同时，我们使用 exceptionally() 方法来处理可能发生的异常情况。\",\"最后，通过 future.get() 方法等待异步任务执行完成，并获取计算结果。\",\"这个示例展示了如何使用 CompletableFuture 执行异步操作、处理结果以及异常情况，以及如何进行链式操作和组合操作。\"]},\"341\":{\"h\":\"完成任意一个Task就开始执行回调函数\",\"t\":[\"当你想要在任意一个 CompletableFuture 完成后执行回调函数时，你可以使用 anyOf 方法并配合回调函数实现这个需求。示例代码如下：\",\"package io.github.forezp.concurrentlab.threadpool; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class CompletableFutureAnyOfExample { public static void main(String[] args) { // 创建两个CompletableFuture CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"Hello\\\"; }); // 任意一个CompletableFuture完成后执行回调函数 CompletableFuture<Object> resultFuture = CompletableFuture.anyOf(future1, future2); resultFuture.thenAcceptAsync(result -> { System.out.println(\\\"第一个完成的任务结果为：\\\" + result); // 在此处编写你想要执行的回调函数逻辑 }); // 使用get()等待异步任务执行完成 try { System.out.println(future1.get()); Thread.sleep(3000); // 等待异步任务完成 } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } \",\"在这个示例中，我们创建了两个 CompletableFuture 对象 future1 和 future2。然后，我们使用 CompletableFuture.anyOf 方法来创建一个新的 CompletableFuture 对象 resultFuture，它会在任意一个 future1 或 future2 完成后执行回调函数。在回调函数中，我们可以处理首先完成的任务的结果，以及定义接下来的逻辑操作。\"]},\"342\":{\"h\":\"完成全部Task就开始执行回调函数\",\"t\":[\"当你想要在所有的 CompletableFuture 都完成后执行回调函数时，你可以使用 allOf 方法并配合回调函数实现这个需求。示例代码如下：\",\"package io.github.forezp.concurrentlab.threadpool; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class CompletableFutureAllOfExample { public static void main(String[] args) { // 创建多个CompletableFuture CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> { // 模拟耗时操作 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return \\\"Hello\\\"; }); // 在所有CompletableFuture完成后执行回调函数 CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2); allFutures.thenRun(() -> { System.out.println(\\\"所有任务完成，开始执行回调函数\\\"); try { System.out.println(\\\"future1:\\\"+future1.get()); System.out.println(\\\"future2:\\\"+future2.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } // 在此处编写你想要执行的回调函数逻辑 }); // 使用get()等待异步任务执行完成 try { System.out.println(allFutures.get()); // Thread.sleep(3000); // 等待异步任务完成 } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } \",\"在这个示例中，我们创建了两个 CompletableFuture 对象 future1 和 future2。然后，我们使用 CompletableFuture.allOf 方法来创建一个新的 CompletableFuture 对象 allFutures，它会在所有的 future1 和 future2 都完成后执行回调函数。在回调函数中，我们可以处理所有任务完成后的逻辑操作。\"]},\"343\":{\"h\":\"总结\",\"t\":[\"CompletableFuture 是Java中用于异步编程的工具类。它能执行异步任务，并处理任务的结果。以下是 CompletableFuture 的关键特点：\",\"异步操作：使用 supplyAsync() 方法执行异步任务。\",\"回调函数：使用 thenApply() 或 thenAccept() 添加回调函数。\",\"异常处理：使用 exceptionally() 捕获和处理异常。\",\"组合操作：使用 thenCombine()、thenCompose() 等方法组合多个 CompletableFuture。\",\"等待任务完成：使用 get() 方法等待任务执行完成并获取结果。\",\"并发控制：使用 allOf() 和 anyOf() 控制多个任务的并发执行。\",\"超时处理：使用 completeOnTimeout() 设置任务的超时时间。\",\"CompletableFuture 可以提高代码的性能和可读性，实现并发和并行操作，并轻松处理异常情况和组合多个异步任务的结果。再实际的开发中，选择什么样的工具可以根据实际的场景来决定。\"]},\"344\":{\"h\":\"Fork/Join使用详解\"},\"345\":{\"h\":\"简介\",\"t\":[\"Java Fork/Join 是 Java 7 引入的一个框架，用于实现并行计算。它基于 \\\"分而治之\\\" 的思想，使用递归的方式将一个大任务拆分成多个小任务，然后并行地执行这些小任务，最后将结果合并起来得到最终结果。\",\"Fork/Join的运行流程大致如下所示：\",\"image-20240121201736740\"]},\"346\":{\"h\":\"核心模块\",\"t\":[\"Java Fork/Join 框架的核心是 ForkJoinPool 类，它是一个特殊的线程池，内部使用工作窃取算法来实现任务的并行执行。\",\"Fork/Join 框架中的主要组件包括：\",\"ForkJoinPool：是一个线程池，用于执行 Fork/Join 任务。它管理和调度任务的执行，并可根据需要创建新的工作线程。\",\"ForkJoinTask：是一个抽象类，表示 Fork/Join 框架中的任务。ForkJoinTask 分为两个子类：\",\"RecursiveTask：用于返回结果的任务，继承它并实现 compute() 方法来执行任务并返回结果。\",\"RecursiveAction：用于不返回结果的任务，继承它并实现 compute() 方法来执行任务。\"]},\"347\":{\"h\":\"ForkJoinPool继承关系\",\"t\":[\"img\",\"内部类介绍:\",\"ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread\",\"DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类\",\"InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。\",\"EmptyTask: 内部占位类，用于替换队列中 join 的任务。\",\"ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。\",\"WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。 \",\"工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。\",\"工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。\",\"伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。\"]},\"348\":{\"h\":\"ForkJoinTask继承关系\",\"t\":[\"img\",\"ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable/Callable 任务提供的适配器类，用于把 Runnable/Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。\"]},\"349\":{\"h\":\"使用示例\",\"t\":[\"以下是一个简单的使用 Fork/Join 框架的示例，假设我们要计算一个较大数组中所有元素的总和：\",\"package io.github.forezp.concurrentlab.threadpool; import java.util.concurrent.ForkJoinPool; import java.util.concurrent.RecursiveTask; public class ForkJoinExample { static class SumTask extends RecursiveTask<Long> { private static final int THRESHOLD = 1000; // 设置阈值，小于该阈值的任务将不再细分，直接计算结果 private int[] array; private int start; private int end; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { if (end - start <= THRESHOLD) { // 如果任务足够小，直接计算结果 long sum = 0; for (int i = start; i < end; i++) { sum += array[i]; } return sum; } else { // 否则细分为更小的子任务 int mid = (start + end) >>> 1; SumTask left = new SumTask(array, start, mid); SumTask right = new SumTask(array, mid, end); left.fork(); // 异步执行左边的子任务 long rightResult = right.compute(); // 同步执行右边的子任务 long leftResult = left.join(); // 获取左边子任务的结果 return leftResult + rightResult; } } } public static void main(String[] args) { int[] array = {1,2,3,4,5,6,7,8}; // 假设有一个很大的数组 ForkJoinPool forkJoinPool = new ForkJoinPool(); long result = forkJoinPool.invoke(new SumTask(array, 0, array.length)); // 同步执行任务，并获取结果 System.out.println(\\\"Sum: \\\" + result); } } \",\"在上面的示例中，我们定义了一个继承 RecursiveTask 的 SumTask 类来表示计算数组元素总和的任务。在 compute() 方法中，我们检查了任务的大小是否小于阈值，如果小于阈值，则直接计算结果；否则将任务拆分为更小的子任务，并使用 fork() 和 join() 方法实现子任务的并行执行和结果的合并。\",\"具体将任务拆成了四个子任务：\",\"1+2\",\"3+4\",\"5+6\",\"7+8\",\"image-20240121211859054\",\"最终等待子任务执行完成，合并结果。\"]},\"350\":{\"h\":\"参考\",\"t\":[\"https://pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html\"]},\"351\":{\"h\":\"Java Collection概述\",\"t\":[\"Java Collection 集合是 Java 编程语言中用于存储和操作对象的框架。它提供了一组接口和类，用于处理不同类型的集合，如List、Set、Queue、Map等。\",\"下面是Java Collection 框架的一些关键概念：\",\"集合接口（Collection Interface）：是 Java Collection 框架的根接口，它定义了集合的基本操作，如添加、删除、遍历等。常见的集合接口包括 List、Set 和 Queue。\",\"列表（List）：以有序的方式存储对象的集合，允许重复元素。常见的列表实现类有 ArrayList 和 LinkedList。\",\"集（Set）：以无序的方式存储对象的集合，不允许重复元素。常见的集实现类有 HashSet 和 TreeSet。\",\"队列（Queue）：一种先进先出（FIFO）的数据结构，用于保存元素并控制元素的插入、删除操作。常见的队列实现类有 LinkedList 和 PriorityQueue。\",\"散列（Map）：以键值对（Key-Value）的形式存储数据，每个键都是唯一的。常见的映射实现类有 HashMap 和 TreeMap。它是Collection框架的一部分，虽然它不是Collection Interface的继承接口。\",\"Java Collection 框架的类的思维导图如下：\"]},\"352\":{\"h\":\"List 接口\",\"t\":[\"Java 的 List 接口是 Collection 接口的继承接口之一，用于表示有序的元素集合，允许元素的重复。List 接口中的元素按照插入的顺序存储，并且可以通过索引进行访问和操作。\",\"List 接口的主要特点包括：\",\"有序性：List 中的元素按照插入的顺序进行存储，元素的顺序可以根据插入和删除操作的顺序动态改变。\",\"可重复性：List 允许包含重复的元素，相同的元素可以出现在列表的不同位置。\",\"可变大小：List 的大小可以根据需要进行动态调整，可以添加或删除元素。\",\"List 接口定义了很多常用的方法，用于添加、删除、获取和操作列表中的元素。例如：\",\"添加元素：使用 add、addAll 方法将元素或集合添加到列表中。\",\"删除元素：使用 remove、removeAll 方法删除指定元素或集合中的元素。\",\"获取元素：使用 get、indexOf、lastIndexOf 方法获取元素或元素的索引。\",\"修改元素：使用 set 方法修改列表中指定位置的元素。\",\"列表操作：使用 subList、sort、reverse 方法实现对列表的操作，如截取子列表、排序、反转等。\",\"遍历列表：使用迭代器、增强的 for 循环或 forEach 方法遍历列表中的元素。\",\"举个例子演示如何使用 List 接口：\",\"import java.util.ArrayList; import java.util.List; public class ListExample { public static void main(String[] args) { // 创建一个 List 对象 List<String> fruits = new ArrayList<>(); // 添加元素到列表中 fruits.add(\\\"Apple\\\"); fruits.add(\\\"Banana\\\"); fruits.add(\\\"Orange\\\"); fruits.add(\\\"Mango\\\"); // 获取列表的大小 int size = fruits.size(); System.out.println(\\\"List size: \\\" + size); // 访问列表中的元素 String firstFruit = fruits.get(0); System.out.println(\\\"First fruit: \\\" + firstFruit); // 遍历列表中的元素 System.out.println(\\\"Fruits:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 检查列表中是否包含某个元素 boolean containsApple = fruits.contains(\\\"Apple\\\"); System.out.println(\\\"Contains Apple? \\\" + containsApple); // 修改列表中的元素 fruits.set(1, \\\"Grapes\\\"); System.out.println(\\\"Updated list:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 删除列表中的元素 fruits.remove(2); System.out.println(\\\"Updated list after removing element:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 清空列表 fruits.clear(); System.out.println(\\\"List is empty? \\\" + fruits.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"List size: 4 First fruit: Apple Fruits: Apple Banana Orange Mango Contains Apple? true Updated list: Apple Grapes Orange Mango Updated list after removing element: Apple Grapes Mango List is empty? true \"]},\"353\":{\"h\":\"Set接口\",\"t\":[\"Set 接口是 Collection 接口的子接口之一，用于存储不重复的元素。Set 中的元素没有固定的顺序，且不允许包含重复的元素。\",\"Set 接口的主要特点包括：\",\"不重复性：Set 中的元素是唯一的，不会包含重复的元素。添加重复元素时，添加操作会失败并返回 false。\",\"无序性：Set 中的元素没有固定的顺序。具体的排列顺序可能因实现类或元素的添加顺序而不同。\",\"快速查找：Set 提供了高效的查找操作，可以快速判断一个元素是否存在于集合中。\",\"Set 接口继承自 Collection 接口，因此包含了一些常用的方法，例如添加元素、删除元素、判断元素是否存在、获取集合大小等。\",\"举个简单的示例，演示如何使用 Set 接口：\",\"import java.util.HashSet; import java.util.Set; public class SetExample { public static void main(String[] args) { // 创建一个 Set 对象 Set<String> names = new HashSet<>(); // 添加元素到集合中 names.add(\\\"Alice\\\"); names.add(\\\"Bob\\\"); names.add(\\\"Charlie\\\"); names.add(\\\"Bob\\\"); // 重复元素，将不会被添加进去 // 获取集合的大小 int size = names.size(); System.out.println(\\\"Set size: \\\" + size); // 遍历集合中的元素 System.out.println(\\\"Names:\\\"); for (String name : names) { System.out.println(name); } // 检查集合中是否包含某个元素 boolean containsBob = names.contains(\\\"Bob\\\"); System.out.println(\\\"Contains Bob? \\\" + containsBob); // 从集合中删除元素 names.remove(\\\"Charlie\\\"); System.out.println(\\\"Updated set:\\\"); for (String name : names) { System.out.println(name); } // 清空集合 names.clear(); System.out.println(\\\"Set is empty? \\\" + names.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Set size: 3 Names: Bob Charlie Alice Contains Bob? true Updated set: Bob Alice Set is empty? true \",\"上面的例子演示了如何创建 Set 对象，添加、获取、遍历和删除集合中的元素，以及判断集合是否为空。\"]},\"354\":{\"h\":\"Map接口\",\"t\":[\"Map 接口是集合框架中用于存储键值对（Key-Value）的映射关系。每个键值对都是一个条目（Entry），键是唯一的，值可以重复。它和Collection接口属于并列的关系。\",\"Map 接口的主要特点如下：\",\"键的唯一性：Map 中的键是唯一的，不允许重复。如果使用相同的键插入多个值，后面的值会覆盖前面的值。\",\"快速查找：Map 提供了根据键快速查找对应值的方法。\",\"无固定顺序：Map 中的键值对没有固定的顺序。具体的迭代顺序可能因实现类或元素的插入顺序而不同。\",\"Map 接口定义了常用的操作方法，例如添加键值对、删除键值对、获取键值对数量、按键查找值等。常用的 Map 接口的实现类有 HashMap、LinkedHashMap 和 TreeMap。\",\"举个例子演示如何使用 HashMap：\",\"import java.util.HashMap; import java.util.Map; public class HashMapExample { public static void main(String[] args) { // 创建一个 HashMap 对象 Map<String, Integer> scores = new HashMap<>(); // 添加键值对到 HashMap 中 scores.put(\\\"Alice\\\", 95); scores.put(\\\"Bob\\\", 80); scores.put(\\\"Charlie\\\", 90); // 获取键对应的值 int aliceScore = scores.get(\\\"Alice\\\"); System.out.println(\\\"Alice's score: \\\" + aliceScore); // 检查 HashMap 中是否包含某个键 boolean containsKey = scores.containsKey(\\\"Bob\\\"); System.out.println(\\\"Contains key 'Bob'? \\\" + containsKey); // 获取 HashMap 的大小（键值对数量） int size = scores.size(); System.out.println(\\\"HashMap size: \\\" + size); // 遍历 HashMap 中的键值对 System.out.println(\\\"Scores:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 修改某个键对应的值 scores.put(\\\"Bob\\\", 85); System.out.println(\\\"Updated score for Bob: \\\" + scores.get(\\\"Bob\\\")); // 删除某个键值对 scores.remove(\\\"Charlie\\\"); System.out.println(\\\"After removing Charlie:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 清空 HashMap scores.clear(); System.out.println(\\\"HashMap is empty? \\\" + scores.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Alice's score: 95 Contains key 'Bob'? true HashMap size: 3 Scores: Alice: 95 Bob: 80 Charlie: 90 Updated score for Bob: 85 After removing Charlie: Alice: 95 Bob: 85 HashMap is empty? true \",\"上面的例子演示了如何创建 HashMap ，以及添加、获取、遍历和删元素对象，以及判断 HashMap 的大小和是否为空。\"]},\"355\":{\"h\":\"总结\",\"t\":[\"本文介绍了Java中的Collection框架，包括了最常见的List、Set和Map接口，以及常见的实现类。然后用案例讲解了这些类的使用。\",\"在如今Java面试八股文满天飞的时代，上面的内容可能不会被面试官问到，因为太基础了，但是Java集合的源码或者手写Java Collection的实现还是经常被问到。所以在接下来的文章会从源码和Java Collection的手写实现两个维度来讲解常见的集合类的具体实现。\"]},\"356\":{\"h\":\"ArrayList源码解析\"},\"357\":{\"h\":\"ArrayList的类结构图\",\"t\":[\"ArrayList 是 java 集合框架中比较常用的用于存储单列数据的容器。它继承自 AbstractList，实现了 List 接口，同时还实现了 RandomAccess、Cloneable、Serializable 接口，所以ArrayList 支持快速访问、复制、序列化。ArrayList底层基于数组实现，容量大小动态可以变化。\",\"ArrayList继承了AbstractList类并实现类List接口，所以ArrayList具有了AbstractList和List的功能。而AbstractList内部已经实现了获取Iterator和ListIterator的方法。所\",\"ArrayList实现了RandomAccess接口，表明ArrayList支持随机访问。\",\"ArrayList实现了Cloneable接口，表明ArrayList支持克隆。\",\"ArrayList实现了Serializable接口，表明ArrayList支持序列，可以将ArrayList以流的形式通过ObjectInputStream/ObjectOutputStream来写/读。\"]},\"358\":{\"h\":\"ArrayList底层是如何实现的？\",\"t\":[\"ArrayList 是通过基于数组的方式实现的动态数组。\",\"在 ArrayList 内部，有一个对象数组（elementData）用于存储元素。当创建 ArrayList 对象时，会初始化一个初始容量的数组。随着元素的不断添加，ArrayList 会根据需要自动进行扩容。\",\"当添加元素时，ArrayList 会检查当前数组容量是否足够，如果不够，则会创建一个新的更大容量的数组，并将原有元素复制到新数组中。这个过程称为扩容。通过这种方式，ArrayList 实现了动态调整数组容量。\",\"在进行删除操作时，ArrayList 会将删除位置后面的元素向前移动一个位置，以填补被删除元素的空缺。同时，ArrayList 会判断是否需要缩小数组容量，如果数组容量过大且元素数量远小于容量的 1/4，则会进行缩容操作，减少内存占用。\",\"由于 ArrayList 的底层采用数组实现，所以随机访问元素的时间复杂度为 O(1)，即常数时间。但是在进行插入和删除操作时，为了保持数组的连续性，可能需要移动大量元素，时间复杂度为 O(n)，其中 n 是元素的数量。因此，ArrayList 适用于对随机访问的需求较多，而对插入和删除操作效率要求不高的场景。\",\"ArrayList的底层使用数组实现的源码如下：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //存储ArrayList元素的数组缓冲区。 ArrayList的容量就是这个数组缓冲区的长度。任何 empty ArrayList with //elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 将在添加第一个元素时扩展为DEFAULT_CAPACITY。 transient Object[] elementData; .... } \",\"注意，本文的源码为JDK18\"]},\"359\":{\"h\":\"ArrayList的初始化\",\"t\":[\"ArrayList会在构造函数执行的时候初始化，ArrayList有三种构造函数，分别为：\",\"带初始化容量大小参数(initialCapacity)的构造函数\",\"无参构造函数，默认会初始化容量大小为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值为10，所以默认的初始化大小为10；这种最常用。\",\"带有Collection参数的构造函数，会将Collection的元素Copy到elementData成员变量中。\",\" public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(Collection<? extends E> c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; } \"]},\"360\":{\"h\":\"添加元素\",\"t\":[\"方法名\",\"描述\",\"public boolean add(E e)\",\"添加元素\",\"public void add(int index, E element)\",\"在制定位置添加元素\",\"public boolean addAll(Collection<? extends E> c)\",\"将Collection的全部元素添加到集合中\",\"public boolean addAll(int index, Collection<? extends E> c)\",\"将Collection的按照index位置开始的所有元素添加到集合中\",\"添加元素的源码如下：\",\" public boolean add(E e) { modCount++; add(e, elementData, size);//将元素添加到size的位置 return true; } public void add(int index, E element) { rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; //index的值和elementData的长度相等，则扩容 if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); //将元素的放到索引位置 elementData[index] = element; //容器的size+1 size = s + 1; } \"]},\"361\":{\"h\":\"扩容\",\"t\":[\"扩容是在grow()函数中进行，它返回的是一个新的Object[] 数组，新数组已经将就数据拷贝。\",\"如果elementData是DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组），并且元素小于DEFAULT_CAPACITY（10 个），则对空数组进行初始化\",\"如果不为空数组，则进行初始化，正常情况下新的数组大小是旧数组的1.5倍 \",\"如果超出了Interger的软最大值则报错\",\"最多返回Interger的软最大值（ SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8）\",\" private Object[] grow() { return grow(size + 1); } private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity >> 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { //对空数组进行初始化 return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; } } public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength >= 0 // assert minGrowth > 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); } } private static int hugeLength(int oldLength, int minGrowth) { int minLength = oldLength + minGrowth; if (minLength < 0) { // overflow throw new OutOfMemoryError( \\\"Required array length \\\" + oldLength + \\\" + \\\" + minGrowth + \\\" is too large\\\"); } else if (minLength <= SOFT_MAX_ARRAY_LENGTH) { return SOFT_MAX_ARRAY_LENGTH; } else { return minLength; } } \"]},\"362\":{\"h\":\"删除元素\",\"t\":[\"remove(Object o) 方法：该方法用于删除指定的元素。\",\" public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; found: { if (o == null) { for (; i < size; i++) if (es[i] == null) break found; } else { for (; i < size; i++) if (o.equals(es[i])) break found; } return false; } fastRemove(es, i); return true; } private void fastRemove(Object[] es, int i) { modCount++; final int newSize; if ((newSize = size - 1) > i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null; } \",\"首先，remove(Object o) 方法会判断是否删除的是 null 值，然后遍历 ArrayList 查找匹配的元素。\",\"如果找到匹配的元素，会调用 fastRemove(int index) 方法进行快速删除，该方法将需要删除元素的位置（index）后面的元素向前移动，覆盖需要删除的元素。\",\"最后，将 size 赋值为newSize，newSize实际上是减一了，表示 ArrayList 的元素总数减少一个。\",\"并将最后一个位置上的元素清空。\"]},\"363\":{\"h\":\"查找元素\",\"t\":[\"get(int index)用于获取指定位置的元素，如果index超出长度，则报IndexOutOfBoundsException异常。查找指定位置元素的时间复杂度为O(1)。\",\" public E get(int index) { Objects.checkIndex(index, size); return elementData(index); } \",\"contains(Object o) 方法：该方法用于判断 ArrayList 是否包含指定的元素。\",\"public boolean contains(Object o) { return indexOf(o) >= 0; } \",\"contains(Object o) 方法内部调用了 indexOf(Object o) 方法\",\"public int indexOf(Object o) { if (o == null) { for (int i = 0; i < size; i++) if (elementData[i] == null) return i; } else { for (int i = 0; i < size; i++) if (o.equals(elementData[i])) return i; } return -1; } \",\"indexOf(Object o) 方法首先判断要查找的元素是否为 null，如果是，则遍历 ArrayList 的元素，找到第一个值为 null 的元素，返回其索引值。\",\"如果要查找的元素不为 null，则遍历 ArrayList 的元素，调用元素的 equals 方法进行比较，找到第一个相等的元素，返回其索引值。\",\"如果未找到指定元素，则返回 -1。\"]},\"364\":{\"h\":\"迭代器源码解析\",\"t\":[\"ArrayList 的迭代器（Iterator）是通过内部类 Itr 来实现的，以下是对其源码的解析：\",\"private class Itr implements Iterator<E> { int cursor; // 下一个元素的索引 int lastRet = -1; // 上一个元素的索引 int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } @SuppressWarnings(\\\"unchecked\\\") public E next() { checkForComodification(); // 检查 ArrayList 是否被修改过 int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet < 0) throw new IllegalStateException(); checkForComodification(); // 检查 ArrayList 是否被修改过 try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } \",\"Itr 类实现了 Iterator<E> 接口，通过实现 hasNext()、next()、remove() 和 checkForComodification() 方法来支持迭代。\",\"cursor 属性表示下一个元素的索引，lastRet 属性表示上一个元素的索引，expectedModCount 属性表示预期的修改次数。\",\"hasNext() 方法用于判断是否还有下一个元素，即判断 cursor 是否等于 size。\",\"next() 方法用于获取下一个元素，首先调用 checkForComodification() 方法检查 ArrayList 是否被修改过，然后根据 cursor 获取下一个元素并返回，同时更新 lastRet 和 cursor 的值。\",\"remove() 方法用于移除上一个元素，首先检查 lastRet 是否小于 0，如果是则抛出异常，然后再次调用 checkForComodification() 方法检查 ArrayList 是否被修改过，在通过 ArrayList.this.remove(lastRet) 方法移除元素后，更新 cursor 和 lastRet 的值，并将 expectedModCount 修改为当前的 modCount。\",\"checkForComodification() 方法用于检查 ArrayList 是否被修改过，即判断 modCount 是否等于 expectedModCount，如果不相等则抛出异常。\",\"ArrayList 的迭代器通过内部类 Itr 实现，支持对集合进行顺序迭代，并支持在迭代过程中通过迭代器的 remove() 方法删除元素。迭代器在每次访问元素之前会检查 ArrayList 是否被修改过，利用 modCount 和 expectedModCount 来实现快速失败机制，保证在迭代过程中对集合的修改不会产生错误的结果。\",\"需要注意的是，在使用迭代器遍历 ArrayList 的过程中，不建议直接使用 ArrayList 对象的 remove() 方法进行元素的删除操作，而应该使用迭代器的 remove() 方法进行删除，以避免产生并发修改异常。\"]},\"365\":{\"h\":\"LinkedList源码解析\"},\"366\":{\"h\":\"LinkedList的类结构图\",\"t\":[\"LinkedList是java集合中比较常见的线性表的数据结构，是用于存储单列数据的容器。LinkedList除了继承AbstractSequentialList之外，同时还实现了Deque、Cloneable、Serializable 接口，也就是说LinkedList可以被当做队列使用，还支持快复制、序列化。\",\"如下图，LinkedList的类结构图如下：\",\"LinkedList的底层数据结构是使用一个双向的链表结构实现的，链表中的每个节点（Node）都包含两个引用，prev指向当前节点前一个节点，next指向当前节点后一个节点，可以从头结点遍历到尾结点，也可以从尾结点遍历到头结点。\",\"LinkedList类主要由LinkedList和它的内部类Node构成，这两个类的UML图如下：\",\"+------------------+ | LinkedList | +------------------+ | - size : int | | - first : Node | | - last : Node | +------------------+ | + add(E element) | | + remove() | | + get(int index) | | + size() | +------------------+ +-------------------+ | Node | +-------------------+ | - item : E | | - next : Node | | - prev : Node | +-------------------+ \",\"LinkedList 类是 LinkedList 的主要类。它包含了 size、first 和 last 三个实例变量，分别表示链表的大小、头结点和尾节点。\",\"add(E element) 方法用于在链表尾部添加元素。\",\"remove() 方法用于删除链表头部的元素。\",\"get(int index) 方法用于获取指定索引位置上的元素。\",\"size() 方法用于返回链表的大小。\",\"Node 类是 LinkedList 内部定义的节点类。它包含了 item、next 和 prev 三个实例变量，分别表示节点的数据、下一个节点和上一个节点。\"]},\"367\":{\"h\":\"构造函数\",\"t\":[\"LinkedList 类的构造函数有两个重载的构造函数，其中是一个无参的构造函数，没有任何的代码，因为它是双链表结构，不需要初始化容量长度等，源码如下：\",\"public LinkedList() { } \",\"第二个构造函数可以穿入一个Collection接口的实现类对象，将Collection中的元素都添加到LinkedList中，它的源码如下：\",\" public LinkedList(Collection<? extends E> c) { this(); addAll(c); } \"]},\"368\":{\"h\":\"add(E e)方法\",\"t\":[\"LinkedList 的 add(E e) 方法用于在链表的尾部添加元素。 add(E e) 方法的源码如下：\",\"public boolean add(E e) { linkLast(e); return true; } private void linkLast(E e) { Node<E> newNode = new Node<>(last, e, null); if (last == null) { first = newNode; } else { last.next = newNode; } last = newNode; size++; } \",\"add(E e) 方法先调用 linkLast(e) 方法来执行元素的插入操作。\",\"在 linkLast(e) 方法中，首先创建一个新的节点 newNode，节点的数据为指定的元素 e，前向节点为链表的当前尾节点 last，后向节点为 null。\",\"如果链表的尾节点 last 为 null，说明链表为空链表，即当前插入的节点即为头节点，将 first 设置为 newNode。\",\"如果链表的尾节点 last 不为 nul，将当前尾节点 last 的后向节点指向 newNode，即将 last.next 设置为 newNode。\",\"最后，将链表的尾节点 last 更新为 newNode，并增加链表的大小 size。\",\"方法返回 true，表示插入操作成功。\"]},\"369\":{\"h\":\"get(int index)方法\",\"t\":[\"LinkedList 的 get(int index) 方法用于获取链表中指定索引处的元素。 get(int index) 方法的源码如下：\",\"public E get(int index) { checkElementIndex(index); return node(index).item; } private Node<E> node(int index) { // 如果索引位于链表的前半段，从头节点开始向后遍历 if (index < (size >> 1)) { Node<E> x = first; for (int i = 0; i < index; i++) { x = x.next; } return x; } // 如果索引位于链表的后半段，从尾节点开始向前遍历 else { Node<E> x = last; for (int i = size - 1; i > index; i--) { x = x.prev; } return x; } } private void checkElementIndex(int index) { if (!isElementIndex(index)) { throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size); } } private boolean isElementIndex(int index) { return index >= 0 && index < size; } \",\"get(int index) 方法先调用 checkElementIndex(index) 方法检查索引是否有效，如果索引无效，则抛出 IndexOutOfBoundsException 异常。\",\"然后调用 node(index) 方法，根据索引获取对应的节点。\",\"在 node(int index) 方法中，如果索引 index 小于链表大小的一半，说明索引位于链表的前半段，从头节点开始向后遍历，找到对应的节点并返回。\",\"如果索引 index 大于等于链表大小的一半，说明索引位于链表的后半段，从尾节点开始向前遍历，找到对应的节点并返回。\",\"最后，在获取到对应节点后，返回节点的数据域 item。\"]},\"370\":{\"h\":\"remove(int index)方法\",\"t\":[\"LinkedList 的 remove(int index) 方法用于删除链表中指定索引处的元素。下面是 remove(int index) 方法的源码：\",\"public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } private E unlink(Node<E> x) { final E element = x.item; final Node<E> prev = x.prev; final Node<E> next = x.next; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; return element; } private void checkElementIndex(int index) { if (!isElementIndex(index)) { throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size); } } private boolean isElementIndex(int index) { return index >= 0 && index < size; } \",\"解析：\",\"remove(int index) 方法先调用 checkElementIndex(index) 方法检查索引是否有效，如果索引无效，则抛出 IndexOutOfBoundsException 异常。\",\"然后调用 unlink(node(index)) 方法，根据索引获取对应的节点，并进行删除操作。 \",\"在 unlink(Node<E> x) 方法中，首先保存节点 x 的数据到 element 中。\",\"然后获取节点 x 的前向节点 prev 和后向节点 next。\",\"如果节点 x 的前向节点 prev 为 null，即 x 为头节点，则将头节点指向 x 的后向节点 next。\",\"否则，将节点 x 的前向节点 prev 的后向节点指向 x 的后向节点 next，即 prev.next = next。并将节点 x 的前向节点 prev 的前向引用置为 null，即 x.prev = null。\",\"同样的方式，如果节点 x 的后向节点 next 为 null，即 x 为尾节点，则将尾节点指向 x 的前向节点 prev。\",\"否则，将节点 x 的后向节点 next 的前向节点指向 x 的前向节点 prev，即 next.prev = prev。并将节点 x 的后向节点 next 的后向引用置为 null，即 x.next = null。\",\"接着将节点 x 的数据域 item 置为 null，减小链表的大小 size。\",\"最后返回删除节点的数据域。\"]},\"371\":{\"h\":\"总结\",\"t\":[\"LinkedList 是通过双向链表实现的数据结构，每个节点有前向和后向两个指针，用来连接上一个节点和下一个节点。这种结构使得在插入和删除元素时具有较高的效率，因为只需要修改节点的指针，而无需移动其他元素。\",\"LinkedList 提供了多种方法来操作链表，包括在链表的头部或尾部插入元素、在指定位置插入元素、获取指定位置的元素、删除指定位置的元素等等。这使得 LinkedList 在需要频繁插入和删除元素的场景下很有优势。\",\"然而，LinkedList 在访问元素时相对较慢，因为需要从头部或尾部开始遍历链表。与数组相比，LinkedList 的内存占用较高，因为每个节点需要额外的存储空间来保存前向和后向指针。\",\"综上所述，LinkedList 是一个适用于插入和删除操作频繁的数据结构，但对于随机访问和占用内存方面可能存在劣势。\"]},\"372\":{\"h\":\"HashMap原理解析\"},\"373\":{\"h\":\"HashMap的类结构图\",\"t\":[\"HashMap 是 java 集合框架中用于存储双列数据的散列表，应用非常的广泛。HashMap的类结构图如下：\",\"HashMap继承了AbstractMap类并实现类Map接口，所以HashMap具有了AbstractMap和Map的功能。\",\"HashMap实现了Cloneable接口，表明HashMap支持克隆。\",\"HashMap实现了Serializable接口，表明HashMap支持序列，可以将HashMap以流的形式通过ObjectInputStream/ObjectOutputStream来写/读。\"]},\"374\":{\"h\":\"HashMap的底层数据结构\",\"t\":[\"HashMap 的的底层数据结构为数组+链表（或者红黑树）结构，如下图所示：\",\"HashMap 通过 Node 类来存储键值对（K 表示键的类型，V 表示值的类型）。每个 Node 对象包含了键、值以及指向下一个 Node 的引用。\",\"在 JDK 8 以后的版本中，如果链表长度超过阈值（默认为8），且 HashMap 的容量达到了一个较大的值（默认为64），则部分链表节点会转换为红黑树。这些红黑树节点被实现为 TreeNode 类，它拓展自 Node 类。\"]},\"375\":{\"h\":\"构造函数\",\"t\":[\"HashMap 有两种构造函数：无参构造函数和带初始容量和负载因子的构造函数。无参构造函数创建一个初始容量为16，负载因子为0.75的 HashMap 对象。\",\"public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = tableSizeFor(INITIAL_CAPACITY); } \",\"带参构造函数接收初始容量 initialCapacity 和负载因子 loadFactor 作为参数，创建一个 HashMap 对象。\",\"public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; threshold = tableSizeFor(initialCapacity); } \",\"tableSizeFor(initialCapacity) 方法用于计算大于等于给定容量的最小 2 的幂。\"]},\"376\":{\"h\":\"存储元素过程\",\"t\":[\"首先我们先创建一个HashMap对象，然后使用put(key,value)方法，把元素存储在HashMap对象中，代码如下：\",\" Map<String,String> map=new HashMap<>(); map.put(\\\"james\\\",\\\"1\\\"); map.put(\\\"kobe\\\",\\\"1\\\"); map.put(\\\"robin\\\",\\\"1\\\"); map.put(\\\"sam\\\",\\\"1\\\"); \",\"要把键值对 (“james”,”1”)存入map中，首先，根据传入的 key 对象计算哈希值 hash，计算hash的源码如下：\",\" static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"调用 hash 和 key 对象作为参数，使用 table 数组的长度 table.length 计算出键值对在 table 数组中的索引位置 i。如果该 i 索引位置没有键值对，则直接将键值对存储在该位置。\",\"if ((p = tab[i = (n - 1) & hash]) == null){ tab[i] = newNode(hash, key, value, null); } \",\"如果索引 i 处有键值对，且发生了哈希冲突，则遍历该位置上的链表或红黑树进行操作。\",\" Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) //如果头节点上treeNode e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 如果是链表 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st //链表转treeNode treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; //遍历链表，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则更新其对应的值为新的 `value` 值。 p = e; } } \",\"遍历链表或红黑树的过程中，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则更新其对应的值为新的 value 值。\",\"如果没有找到相同的键，则将新的键值对插入到链表或红黑树的头部。如果链表长度超过了阈值（默认为8），并且 table 数组的长度大于阈值（默认为64），则将链表转换为红黑树。\",\"if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st //链表转treeNode treeifyBin(tab, hash); \",\"在插入新键值对后，如果 HashMap 中的键值对数量超过了负载因子乘以 table 数组的长度，即达到了负载因子阈值，需要进行扩容操作。\",\" final Node<K,V>[] resize() { } \"]},\"377\":{\"h\":\"扩容\",\"t\":[\"如果需要进行扩容操作，首先会检查当前的 table 数组是否为 null，若为 null，则表示 HashMap 还未进行过初始化操作，会调用 resize() 方法来初始化 table 数组。\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"在进行扩容之前会将当前 table 数组的引用赋值给一个临时变量 oldTab。在扩容操作中，会根据当前的 table 数组长度 oldCap 和负载因子 loadFactor 计算出新数组的长度 newCap，通常是将 oldCap 扩大一倍。\",\" int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } \",\"创建一个新的 Node[] 数组，长度为 newCap，作为新的 table 数组进行存储。\",\" Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; \",\"如果 HashMap 的当前 size 大于 0，则需要将旧的键值对重新分布到新的 table 数组中。遍历 oldTab 数组，将每个非空的位置上的键值对重新计算哈希值，并存储到新的 table 数组对应的位置。\",\"完成键值对的重新分布后，会将新的 table 数组赋值给 HashMap 的 table 属性。\",\"最后，在新的 table 数组中重新计算 key 的哈希值，并将键值对插入到对应索引位置 i 处。如果该位置已经有键值对，则按链表或红黑树的规则进行处理。\",\" if (oldTab != null) { for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // preserve order Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } \"]},\"378\":{\"h\":\"获取元素\",\"t\":[\"在对HashMap对象查找元素的时候，我们调用的是get(Object key)。\",\"public V get(Object key) { Node<K, V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\"首先，根据传入的 key 对象计算哈希值 hash。\",\"根据 hash 的值在 table 数组中找到对应的索引位置 i。如果该索引位置上没有键值对，则返回 null。\",\"如果索引 i 处有键值对，且发生了哈希冲突，则遍历该位置上的链表或红黑树进行查找操作。\",\"遍历链表或红黑树的过程中，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则返回对应的值。\",\"如果遍历完链表或红黑树仍未找到相同的键，则返回 null。\",\"下面是 HashMap get(Object key) 方法的简化版源码：\",\"public V get(Object key) { Node<K, V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K, V> getNode(int hash, Object key) { Node<K, V>[] tab; Node<K, V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K, V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"在上述源码中：\",\"getNode(int hash, Object key) 方法用于根据哈希值和键在 table 数组中查找并返回对应的节点。\",\"首先将 table 数组赋值给 tab 变量，然后根据哈希值计算出索引位置 ((n - 1) & hash)，并将对应位置的第一个节点赋值给 first 变量。\",\"如果 first 节点不为空，则首先检查 first 节点是否与传入的键匹配，如果匹配则直接返回 first 节点。\",\"如果 first 节点与传入的键不匹配，则判断 first 节点是否为红黑树节点，如果是，则调用红黑树节点的 getTreeNode() 方法进行查找操作，否则使用循环遍历链表中的其他节点进行查找。\",\"如果在链表或红黑树中找到键对应的节点，则返回对应的节点，否则返回 null。\"]},\"379\":{\"h\":\"总结\",\"t\":[\"HashMap 是 Java 中常用的哈希表实现，用于存储键值对。HashMap 提供了高效的键值对存储和查找能力。它利用哈希函数将键映射到数组的索引位置，在处理哈希冲突时，通过链表和红黑树的形式来解决。同时，HashMap 也支持动态扩容和再散列，保证了存储的键值对的分布合理性和查询性能的稳定性。\",\"需要注意的是，HashMap不是线程安全的，不能在多个线程中操作同一个HashMap，会导致一些并发问题。如果需要在多线程中操作同一个Map，建议使用ConcurrentHashMap。\"]},\"380\":{\"h\":\"HashSet原理解析\"},\"381\":{\"h\":\"类结构图\",\"t\":[\"HashSet 是 java 集合框架中用于存储单列数据。不同于ArrayList可以存储重复元素，HashSet存储的元素不会重复。下面是HashSet的类结构图：\",\"HashSet继承了AbstractSet类并实现类Set接口，所以HashSet具有了AbstractSet和Set的功能。\",\"HashSet实现了Cloneable接口，表明HashMap支持克隆。\",\"HashSet实现了Serializable接口，表明HashSet支持序列，可以将HashSet以流的形式通过ObjesctInputStream/ObjectOutputStream来写/读。\"]},\"382\":{\"h\":\"底层数据结构\",\"t\":[\"HashSet 的底层数据结构是基于 HashMap 实现的。在 HashSet 中，实际上是使用 HashSet 的元素作为 HashMap 的键（key），并将一个固定的对象作为 HashMap 的值（value）。\",\"在 HashSet 中，所有元素都会被映射到 HashMap 中的不同键上（通过 hashCode 和 equals 方法进行判断），因为 HashMap 不允许存在重复的键，所以它天然的保证了 HashSet 中元素的唯一性。\",\"img\",\"HashSet使用HashMap作为底层存储数据的结构，既保存了数组查询和修改元素效率快的优点，也保存了链表在添加和删除元素时效率快的特点。\",\"HashSet 的性能取决于哈希函数的质量和哈希表的大小。一般情况下，HashSet 的查找、添加和删除操作的时间复杂度为 O(1)。\",\"但同时HashSet和HashMap一样，是线程安全的。\"]},\"383\":{\"h\":\"简单示例\",\"t\":[\"使用代码示例如下：\",\" public static void main(String[] args) { Set<String> set=new HashSet<>(); set.add(\\\"1\\\"); set.add(\\\"2\\\"); set.add(\\\"3\\\"); set.add(\\\"3\\\"); set.add(\\\"1\\\"); for (String s: set) { System.out.println(s); } } \",\"执行上面代码输出：\",\"1 2 3\"]},\"384\":{\"h\":\"源码解析\"},\"385\":{\"h\":\"构造函数\",\"t\":[\"无参构造函数\",\"HashSet 类有多个构造函数，下面我们来分析其中一个常用的构造函数:\",\"public HashSet() { map = new HashMap<>(); } \",\"这个构造函数没有参数，用于创建一个空的 HashSet 对象。\",\"在构造函数中，通过 new HashMap<>() 创建了一个新的 HashMap 对象，并将其赋值给 HashSet 内部的 map 成员变量。\",\"HashSet 的元素将会以键的形式存储在 HashMap 中，而 HashMap 的值则被忽略，只使用键来判断元素的唯一性。\",\"传递一个集合参数的构造函数\",\"/** * 可以将集合中的数据全部添加到新创建的HashSet集合中，会去除掉重复的值。 * @param c */ public HashSet(Collection<? extends E> c) { map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } \"]},\"386\":{\"h\":\"添加元素\",\"t\":[\"HashSet 的元素添加操作是通过调用 HashMap 的 put 方法实现的。下面是 HashSet 的 add 方法的源码：\",\"public boolean add(E e) { return map.put(e, PRESENT) == null; } \",\"add 方法接受一个元素 e 作为参数，并返回一个布尔值，表示添加元素是否成功。\",\"在方法内部，通过调用 HashMap 的 put 方法将元素 e 作为键、一个固定的占位符对象（比如 PRESENT）作为值存储在 HashMap 中。\",\"当调用 put 方法时，如果 HashMap 中之前不存在相同的键，那么会返回 null，表示添加成功。\",\"如果 HashMap 中已经存在相同的键，那么会将新的值替换旧的值，并返回旧的值。但在 HashSet 中，我们并不关心值的内容，只关心添加操作是否成功。所以，当返回值不为 null 时，表示已经存在相同的元素，添加失败。\",\"add 方法最后根据 put 方法的返回结果，返回一个布尔值，表示添加操作是否成功。\"]},\"387\":{\"h\":\"查找元素\",\"t\":[\"HashSet 的 contains(Object o) 方法用于检查 HashSet 中是否包含指定的元素。下面是 contains 方法的源码分析：\",\"public boolean contains(Object o) { return map.containsKey(o); } \",\"contains 方法接受一个对象 o 作为参数，并返回一个布尔值，表示 HashSet 是否包含该对象。\",\"在方法内部，它调用 HashMap 的 containsKey 方法来判断 HashMap 中是否包含指定的键 o（即是否存在指定的元素）。\",\"containsKey 方法会根据指定键的哈希值和相等性判断，检查 HashMap 中是否存在该键。如果存在，则返回 true；否则返回 false。\",\"因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，如果 HashMap 中存在指定的键，即表示 HashSet 中包含指定的元素。\",\"contains 方法最终返回 containsKey 方法的结果。\"]},\"388\":{\"h\":\"删除元素\",\"t\":[\"HashSet 的元素删除操作是通过调用 HashMap 的 remove 方法实现的。下面是 HashSet 的 remove 方法的源码分析：\",\"public boolean remove(Object o) { return map.remove(o) == PRESENT; } \",\"remove 方法接受一个对象 o 作为参数，并返回一个布尔值，表示删除操作是否成功。\",\"在方法内部，它调用 HashMap 的 remove 方法来删除 HashMap 中指定键 o 对应的键值对。\",\"remove 方法会根据指定键的哈希值和相等性判断，在 HashMap 中找到对应的键值对并删除。如果删除成功，则返回被删除的值；否则返回 null。\",\"因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，当调用 remove 方法成功时，返回的值应该是固定的占位符对象（比如 PRESENT），表示删除成功。\",\"remove 方法将 remove 方法的返回值与固定的占位符对象 PRESENT 进行比较。如果相等，则表示删除操作成功。\"]},\"389\":{\"h\":\"总结\",\"t\":[\"HashSet 是一种无序、唯一性的集合实现。它基于哈希表的数据结构，通过使用 HashMap 来存储元素，并具有很好的性能特性。\",\"HashSet 是非线程安全的，如果在多线程环境下使用 HashSet，需要进行同步处理或使用线程安全的替代品，如 ConcurrentHashSet\"]},\"390\":{\"h\":\"BitSet使用讲解\"},\"391\":{\"h\":\"类结构关系\",\"t\":[\"Java提供了BitSet来实现位图，BitSet是采用一个long型的数组来实现位图的，每个 long 变量都包含了 64 个位。BitSet的继承关系结构图如下：\",\"BitSet实现了Cloneable接口，表明HashMap支持克隆。\",\"BitSet实现了Serializable接口，表明HashSet支持序列，可以将HashSet以流的形式通过ObjesctInputStream/ObjectOutputStream来写/读。\"]},\"392\":{\"h\":\"BitSet介绍\",\"t\":[\"BitSet的优点就是省内存，举个简单的例子来说明吧。\",\"比如说有这么个场景：股票的的交易日记为1，休息日记为0， 那要记录一整年的数据，那就是 365 个数字，由1和0组成。 若数字是 int 类型，那 365 个数字，就是 1460 字节。 如果用 BitSet 来记录，理论上 48 个字节就可以了。\",\"BitSet 使用 long 数组来记录数据，long 有8 个字节、64 位，每位可对应一天的数据。 比如第1天是交易日，在 long 的第 1 位，记录为 1， 第2天是休息日，在 long 的第 2 位，记录为 0， 以此类推，365 天， 6 个 long 就搞定。\",\"BitSet中底层的存储结构选用了long数组，一个long整数占64比特，位长是一个byte整数的8倍，在需要处理的数据范围比较大的场景下可以有效减少扩容的次数。BitSet顶部有一些关于其设计上的注释，这里简单罗列概括成几点：\",\"BitSet是可增长比特向量的一个实现，设计上每个比特都是一个布尔值，比特的逻辑索引是非负整数\",\"BitSet的所有比特的初始化值为false（整数0）\",\"BitSet的size属性与其实现有关，length属性（比特表的逻辑长度）与实现无关\",\"BitSet在设计上是非线程安全，多线程环境下需要额外的同步处理\"]},\"393\":{\"h\":\"BitSet的简单使用\",\"t\":[\"BitSet 类的UML图如下图所示：\",\"--------------------- | BitSet | --------------------- | - long[] words | | - int wordsInUse | | - int size | --------------------- | + and(BitSet set)| | + or(BitSet set) | | + xor(BitSet set)| | + set(int bitIndex)| | + set(int bitIndex, boolean value)| | + get(int bitIndex)| | + clear(int bitIndex)| | + cardinality() | | + isEmpty() | | + size() | | + length() | | + toByteArray() | | + toString() | | + stream() | --------------------- \",\"BitSet 类内部维护了一个 long 类型的数组 words，用来存储位信息。每个 long 值都可以容纳 64 个位。\",\"wordsInUse 表示实际用于存储位信息的 words 数组的大小。\",\"size 表示 BitSet 的位数，即总共能表示的位的数量。\",\"以下是一些常用的 BitSet 方法和用法示例：\",\"import java.util.BitSet; public class BitSetExample { public static void main(String[] args) { BitSet bitSet = new BitSet(16); // 设置位 bitSet.set(1); bitSet.set(3); bitSet.set(5); bitSet.set(7); // 获取位值 boolean value = bitSet.get(3); System.out.println(\\\"Bit at index 3: \\\" + value); // 输出 true // 清除位 bitSet.clear(3); System.out.println(\\\"Bit at index 3: \\\" + bitSet.get(3)); // 输出 false // 位运算操作 BitSet anotherBitSet = new BitSet(16); anotherBitSet.set(3); anotherBitSet.set(7); // OR 操作 bitSet.or(anotherBitSet); // 遍历位集合 for (int i = 0; i < bitSet.size(); i++) { boolean bit = bitSet.get(i); System.out.println(\\\"Bit at index \\\" + i + \\\": \\\" + bit); } } } \",\"以上示例代码演示了 BitSet 的基本用法，包括设置位、获取位值、清除位、位运算等操作。\"]},\"394\":{\"h\":\"使用场景\",\"t\":[\"常见的应用是那些需要对海量数据进行一些统计工作的时候，比如日志分析、用户数统计等等\",\"如统计40亿个数据中没有出现的数据，将40亿个不同数据进行排序等。\",\"现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来\"]},\"395\":{\"h\":\"代码示例\",\"t\":[\"package util; import java.util.Arrays; import java.util.BitSet; public class BitSetDemo { /** * 求一个字符串包含的char * */ public static void containChars(String str) { BitSet used = new BitSet(); for (int i = 0; i < str.length(); i++) used.set(str.charAt(i)); // set bit for char StringBuilder sb = new StringBuilder(); sb.append(\\\"[\\\"); int size = used.size(); System.out.println(size); for (int i = 0; i < size; i++) { if (used.get(i)) { sb.append((char) i); } } sb.append(\\\"]\\\"); System.out.println(sb.toString()); } /** * 求素数 有无限个。一个大于1的自然数，如果除了1和它本身外，不能被其他自然数整除(除0以外）的数称之为素数(质数） 否则称为合数 */ public static void computePrime() { BitSet sieve = new BitSet(1024); int size = sieve.size(); for (int i = 2; i < size; i++) sieve.set(i); int finalBit = (int) Math.sqrt(sieve.size()); for (int i = 2; i < finalBit; i++) if (sieve.get(i)) for (int j = 2 * i; j < size; j += i) sieve.clear(j); int counter = 0; for (int i = 1; i < size; i++) { if (sieve.get(i)) { System.out.printf(\\\"%5d\\\", i); if (++counter % 15 == 0) System.out.println(); } } System.out.println(); } /** * 进行数字排序 */ public static void sortArray() { int[] array = new int[] { 423, 700, 9999, 2323, 356, 6400, 1,2,3,2,2,2,2 }; BitSet bitSet = new BitSet(2 << 13); // 虽然可以自动扩容，但尽量在构造时指定估算大小,默认为64 System.out.println(\\\"BitSet size: \\\" + bitSet.size()); for (int i = 0; i < array.length; i++) { bitSet.set(array[i]); } //剔除重复数字后的元素个数 int bitLen=bitSet.cardinality(); //进行排序，即把bit为true的元素复制到另一个数组 int[] orderedArray = new int[bitLen]; int k = 0; for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { orderedArray[k++] = i; } System.out.println(\\\"After ordering: \\\"); for (int i = 0; i < bitLen; i++) { System.out.print(orderedArray[i] + \\\"\\\\t\\\"); } System.out.println(\\\"iterate over the true bits in a BitSet\\\"); //或直接迭代BitSet中bit为true的元素iterate over the true bits in a BitSet for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { System.out.print(i+\\\"\\\\t\\\"); } System.out.println(\\\"---------------------------\\\"); } /** * 将BitSet对象转化为ByteArray * @param bitSet * @return */ public static byte[] bitSet2ByteArray(BitSet bitSet) { byte[] bytes = new byte[bitSet.size() / 8]; for (int i = 0; i < bitSet.size(); i++) { int index = i / 8; int offset = 7 - i % 8; bytes[index] |= (bitSet.get(i) ? 1 : 0) << offset; } return bytes; } /** * 将ByteArray对象转化为BitSet * @param bytes * @return */ public static BitSet byteArray2BitSet(byte[] bytes) { BitSet bitSet = new BitSet(bytes.length * 8); int index = 0; for (int i = 0; i < bytes.length; i++) { for (int j = 7; j >= 0; j--) { bitSet.set(index++, (bytes[i] & (1 << j)) >> j == 1 ? true : false); } } return bitSet; } } \"]},\"396\":{\"h\":\"参考\",\"t\":[\"https://zhuanlan.zhihu.com/p/520277367?utm_id=0\"]},\"397\":{\"h\":\"Java IO学习总结\"},\"398\":{\"h\":\"简介\",\"t\":[\"Java IO（Input/Output）是 Java 编程语言用于处理输入和输出的标准库。它提供了处理文件、流、网络传输等操作的类和接口。\",\"IO流主要包括字节流和字符流两种类型，以及文件操作、网络通信和对象序列化等功能。Java IO 可以处理二进制和文本数据，并提供了高效的缓冲流和便捷的文件操作。\"]},\"399\":{\"h\":\"IO流基本类\",\"t\":[\"Java IO库提供了多个基本的IO流类，主要包括以下几类：\",\"字节流（Byte Streams）：\",\"InputStream：抽象类，用于从源中读取字节数据。\",\"OutputStream：抽象类，用于将字节数据写入目标。\",\"字符流（Character Streams）：\",\"Reader：抽象类，用于从源中读取字符数据。\",\"Writer：抽象类，用于将字符数据写入目标。\",\"缓冲流（Buffered Streams）：\",\"BufferedInputStream：字节缓冲流，用于提供更高效的字节读取功能。\",\"BufferedOutputStream：字节缓冲流，用于提供更高效的字节写入功能。\",\"BufferedReader：字符缓冲流，用于提供更高效的字符读取功能。\",\"BufferedWriter：字符缓冲流，用于提供更高效的字符写入功能。\",\"文件操作：\",\"File：表示文件或目录的抽象类，提供了相关操作方法。\",\"FileInputStream：用于从文件中读取字节数据的流。\",\"FileOutputStream：用于将字节数据写入文件的流。\",\"FileReader：用于从文件中读取字符数据的流。\",\"FileWriter：用于将字符数据写入文件的流。\",\"这些基本的IO流类提供了在Java程序中进行输入输出操作的基础功能。\",\"字符流 VS 字节流\",\"字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：\",\"读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\",\"处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\",\"结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。\"]},\"400\":{\"h\":\"Java流类图结构\",\"t\":[\"JavaIO的类图结构如下：\",\"image-20231204151718877\"]},\"401\":{\"h\":\"Java IO流对象\",\"t\":[\"**1.输入字节流InputStream **\",\"InputStream 是所有的输入字节流的父类，它是一个抽象类，提供了基本的类操作方法，被许多具体的子类继承和实现。\",\"ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。\",\"PipedInputStream 是从与其它线程共用的管道中读取数据。\",\"ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 \",\"BufferedInputStream：缓冲输入流，提供了读取数据的高效能力，可以减少实际读取操作对底层资源的访问。\",\"DataInputStream：处理二进制数据，提供了读取基本数据类型（如 int、double 等）的方法。\",\"PushbackInputStream：允许将读取的字节推回输入流中，提供了 unread() 方法。\",\"2.输出字节流OutputStream\",\"OutputStream 是 Java IO 库中用于写入字节数据的抽象类。它也是一个顶级父类，被许多具体的子类继承和实现.\",\"ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。\",\"PipedOutputStream 是向与其它线程共用的管道中写入数据，\",\"ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 \",\"BufferedOutputStream：缓冲输出流，提供了写入数据的高效能力，可以减少实际写入操作对底层资源的访问。\",\"DataOutputStream：处理二进制数据，提供了写入基本数据类型（如 int、double 等）的方法。\",\"3.字节流的输入与输出的对应\",\"图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。从上面的图中可以看出Java IO 中的字节流是极其对称的。“存在及合理”我们看看这些字节流中不太对称的几个类吧！\",\"LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。\",\"PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。\",\"StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。\",\"SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。\",\"PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！\",\"4.字符输入流Reader\",\"Reader 是 Java IO 库中用于读取字符数据的抽象类。它是一个顶级父类，被许多具体的子类继承和实现。\",\"CharArrayReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。\",\"PipedReader 是从与其它线程共用的管道中读取数据。\",\"BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。\",\"FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。\",\"InputStreamReader 将字节流转换为字符流，是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。 \",\"FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。\",\"5.字符输出流Writer\",\"在上面的关系图中可以看出：\",\"Writer 是 Java IO 库中用于写入字符数据的抽象类。它也是一个顶级父类，被许多具体的子类继承和实现。\",\"CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据\",\"PipedWriter 是向与其它线程共用的管道中写入数据\",\"BufferedWriter 是一个装饰器为Writer ，提供了字符缓冲功能，增加了写入字符的效率，并提供了一行一行写入字符的方法。\",\"PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。\",\"OutputStreamWriter 是OutputStream 到Writer转换的桥梁 \",\"它的子类FileWriter ：将字符写入到文件中。\",\"6.字符流的输入与输出的对应\",\"img\",\"7.字符流与字节流转换\",\"转换流的特点：\",\"字符流和字节流之间相互转换\",\"可对读取到的字节数据经过指定编码转换成字符\",\"可对读取到的字符数据经过指定编码转换成字节\",\"何时使用转换流？\",\"当字节和字符之间有转换动作时；\",\"流操作的数据需要编码或解码时。 具体的对象体现：\",\"InputStreamReader:字节到字符的桥梁\",\"OutputStreamWriter:字符到字节的桥梁\",\"这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。\",\"8.File类\",\"File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。\",\"9.RandomAccessFile类 该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：\",\"该对象只能操作文件，在构造函数接收两种类型的参数：字符串文件路径；File对象。\",\"该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw) 注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。\"]},\"402\":{\"h\":\"Java NIO学习总结\"},\"403\":{\"h\":\"简介\",\"t\":[\"Java NIO（New I/O）是 Java 在 JDK 1.4 版本中引入的新的 I/O API。它提供了一种基于缓冲区、通道和非阻塞 I/O 模型的开发方式，相对于传统的 Java IO来说，Java NIO 更加灵活和高效。\",\"Java NIO 的主要特点和组成部分包括：\",\"缓冲区（Buffer）：Java NIO 的数据读写以缓冲区为中心，Buffer 类提供了读写数据的方法，来支持高效的 I/O 操作。常见的Buffer覆盖了能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。如下：\",\"ByteBuffer\",\"CharBuffer\",\"DoubleBuffer\",\"FloatBuffer\",\"IntBuffer\",\"LongBuffer\",\"ShortBuffer\",\"通道（Channel）：通道是一个用于读写数据的对象，可以非阻塞地进行读写操作，提供了更高效的数据传输能力。在 Java NIO 中，大部分 I/O 操作都是基于通道进行的。JAVA NIO中的一些主要Channel的实现，如下：\",\"FileChannel：从文件中读写数据\",\"DatagramChannel：能通过UDP读写网络中的数据\",\"SocketChannel：能通过TCP读写网络中的数据\",\"ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样，对每一个新进来的连接都会创建一个SocketChannel。\",\"选择器（Selector）：选择器是 Java NIO 提供的一种多路复用的机制，允许单个线程处理多个通道（如网络连接或文件），从而提高了系统的吞吐量和响应速度。\",\"非阻塞模式：Java NIO 支持非阻塞（非同步）I/O 操作，可以在等待 I/O 操作完成时同时执行其他任务，提高了程序的性能和响应能力。\",\"文件操作：Java NIO 提供了对文件的更强大和灵活的支持，包括文件读写、文件锁定、文件映射等功能。\",\"Java NIO 可以用于构建高并发、高性能的网络服务器，特别是在面对大量连接的场景下。它提供了更多的控制权和灵活性，使开发者能够更好地利用系统资源，提高 I/O 操作的效率。同时，Java NIO 还被广泛应用于大数据处理、分布式系统和高性能计算等领域。\"]},\"404\":{\"h\":\"Channel\",\"t\":[\"在 Java NIO 中，Channel（通道）是连接数据源和目标的管道，用于对数据进行读取和写入操作。它是 Java NIO 进行 I/O 操作的核心组件之一。\",\"Channel 的特点和功能包括：\",\"支持双向操作：Channel 可以用于读取和写入数据，因此它可以在一个方向上读取数据，同时在另一个方向上写入数据。\",\"高效的数据传输：Channel 实现了高效的数据传输，可以直接将数据从缓冲区读取到通道，或者从通道写入到缓冲区，提高了数据传输的效率。\",\"非阻塞模式：Channel 可以以非阻塞的方式进行读写操作，即在没有数据可读或可写时并不会阻塞线程，可以同时处理多个通道的 I/O 操作。\",\"以下是一些常见的 Channel 类型：\",\"FileChannel：用于对文件进行读写操作。\",\"SocketChannel：用于通过 TCP 协议进行网络连接，进行网络数据的读写操作。\",\"ServerSocketChannel：用于监听和接收客户端的连接请求。\",\"DatagramChannel：用于通过 UDP 协议进行网络数据的读写操作。\",\"Pipe.SinkChannel 和 Pipe.SourceChannel：用于在同一程序中进行线程间通信。\"]},\"405\":{\"h\":\"FileChannel\",\"t\":[\"以下是一个使用 FileChannel 进行文件读写操作的基本示例：\",\"import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelExample { public static void main(String[] args) { try { // 打开一个 RandomAccessFile，以读写模式 RandomAccessFile file = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\"); FileChannel channel = file.getChannel(); // 从文件中读取数据到缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = channel.read(buffer); while (bytesRead != -1) { buffer.flip(); // 切换缓冲区为读取模式 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); // 逐个字节读取并输出 } buffer.clear(); // 清空缓冲区 bytesRead = channel.read(buffer); } // 将数据写入文件 String data = \\\"Hello, FileChannel!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); // 切换缓冲区为写入模式 channel.write(buffer); // 关闭通道和文件 channel.close(); file.close(); } catch (Exception e) { e.printStackTrace(); } } } \",\"以上示例演示了如何使用 FileChannel 从文件中读取数据，并将数据写入到文件中。\",\"首先通过 RandomAccessFile 创建一个文件对象，并通过 getChannel() 获取文件对应的 FileChannel。\",\"然后创建一个 ByteBuffer 作为缓冲区，通过 read() 方法从文件通道中读取数据到缓冲区，再通过 flip() 切换为读取模式逐个字节输出。\",\"我们将字符串数据写入到缓冲区，并通过 write() 方法将数据写入文件通道。\",\"最后，关闭通道和文件。\"]},\"406\":{\"h\":\"Buffer\",\"t\":[\"Buffer 是 Java NIO 中的一个关键组件，用于高效地进行数据读写操作。它是一个对象数组，可以存储不同类型的数据，并提供了一系列方法来管理数据的读写。\",\"Buffer 的主要属性和方法包括：\",\"容量（Capacity）：Buffer 的容量是在创建时预先确定的，它表示可以存储的最大数据量。创建 Buffer 时会指定容量，并且无法更改。\",\"位置（Position）：位置表示下一个要读取或写入的元素索引，初始位置为 0。对于写入操作，每次写入后位置会自动递增；对于读取操作，每次读取后位置也会递增。\",\"上界（Limit）：上界表示缓冲区中已经存储的元素数量。在写入模式下，上界等于缓冲区的容量；在读取模式下，上界等于最后一个写入元素的索引加一。\",\"标记（Mark）：可以通过 mark() 方法将当前位置设置为标记位置，并通过 reset() 方法将位置重置为标记位置。\",\"读写模式切换：flip() 方法将写入模式切换为读取模式，同时将位置设置为 0，并将上界设置为当前位置。clear() 方法将读取模式切换为写入模式，同时将位置设置为 0，并将上界设置为容量。\",\"2.png\",\"基本的 Buffer 类型包括 ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 和 DoubleBuffer，它们分别用于读写不同类型的数据。\",\"Buffer 的常用操作包括：\",\"put()：向缓冲区写入数据。\",\"get()：从缓冲区读取数据。\",\"flip()：切换为读取模式，重置位置和上界，准备读取缓冲区中的数据。\",\"clear()：切换为写入模式，重置位置和上界，准备写入数据到缓冲区。\",\"rewind()：重置位置为 0，保持上界不变，准备重新读取缓冲区中的数据。\",\"compact()：在写入模式下，将所有未读完的数据移到缓冲区的开头，重置位置和上界，准备继续写入数据。\",\"Buffer 在进行数据读写时，会通过位置来确定当前要操作的数据元素，通过上界来限制读写的范围。通过适当地使用这些方法，可以有效地管理缓冲区的状态，实现高效的数据处理。\",\"下面是一个使用 Buffer 进行基本操作的示例代码：\",\"import java.nio.Buffer; import java.nio.ByteBuffer; public class BufferExample { public static void main(String[] args) { // 创建一个 ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(10); // 写入数据到缓冲区 buffer.put((byte) 'H'); buffer.put((byte) 'e'); buffer.put((byte) 'l'); buffer.put((byte) 'l'); buffer.put((byte) 'o'); // 切换为读取模式 buffer.flip(); // 从缓冲区读取数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); // 清空缓冲区 buffer.clear(); // 再次写入数据 buffer.put((byte) 'W'); buffer.put((byte) 'o'); buffer.put((byte) 'r'); buffer.put((byte) 'l'); buffer.put((byte) 'd'); // 切换为读取模式 buffer.flip(); // 从缓冲区读取部分数据 System.out.println(\\\"First: \\\" + (char) buffer.get()); System.out.println(\\\"Second: \\\" + (char) buffer.get()); // compact() 方法演示 buffer.compact(); // 从缓冲区读取剩余数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); // rewind() 方法演示 buffer.rewind(); // 从缓冲区重新读取数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); } } \",\"以上示例演示了 ByteBuffer 的常用操作。首先创建一个容量为 10 的 ByteBuffer，然后通过 put() 方法写入数据到缓冲区。接着，通过 flip() 方法切换为读取模式，并使用 get() 方法逐个字节读取数据并输出。然后，通过 clear() 方法清空缓冲区，并再次使用 put() 方法写入数据。再次切换为读取模式，并使用 get() 方法读取部分数据。随后演示了 compact() 方法的使用，可以将缓冲区中未读完的数据移到缓冲区的开头。最后，通过 rewind() 方法将缓冲区的位置重置为 0，并重新读取缓冲区中的数据。\"]},\"407\":{\"h\":\"Selector\",\"t\":[\"Selector 是一种多路复用的机制，允许单个线程同时监听多个通道的事件。通过使用 Selector，可以实现在单个线程中处理多个通道的 I/O 操作，提高系统的吞吐量和响应性能。\",\"nio-selector\",\"Selector 的工作原理如下：\",\"创建 Selector 对象：通过调用 Selector.open() 方法创建一个 Selector 实例。\",\"注册通道：将需要监听的通道注册到 Selector 上，并指定感兴趣的事件，如读（SelectionKey.OP_READ）、写（SelectionKey.OP_WRITE）、连接（SelectionKey.OP_CONNECT）或接受（SelectionKey.OP_ACCEPT）等。\",\"轮询就绪事件：通过调用 Selector 的 select() 方法来轮询监听注册的通道，当有通道有感兴趣的事件发生时，该方法将返回。\",\"处理就绪事件：通过 selectedKeys() 方法获取到 Selector 所管理的所有就绪的 SelectionKey，然后遍历这些 SelectionKey，根据就绪的事件类型执行相应的处理逻辑。\",\"取消注册或更新事件：如果某个通道的事件处理完成后，需要取消注册或更新感兴趣的事件，可以通过调用 SelectionKey 对象的相应方法进行操作。\",\"Selector 的优势在于可以使用较少的线程来处理多个通道的 I/O 操作，避免了为每个通道创建一个线程的开销。这使得它非常适用于需要同时处理大量连接的网络编程场景。通过 Selector，开发者可以实现高并发、高性能的网络服务器，提高了系统的资源利用率和响应速度。\",\"需要注意的是，Selector 是非阻塞模式下的特性，因此它和非阻塞的通道（如 SocketChannel 和 ServerSocketChannel）结合使用，以实现高效的 I/O 操作。\"]},\"408\":{\"h\":\"总结\",\"t\":[\"本文主要介绍了NIO的一些基本组件，主要包括通道Channel、缓冲区Buffer、选择器Selecotor组件。后面的文章将以案例的形式介绍SocketChannel、ServerSocketChannel的网络编程。\"]},\"409\":{\"h\":\"Java NIO案列实战\"},\"410\":{\"h\":\"SocketChannel介绍\",\"t\":[\"SocketChannel 是 Java NIO 中用于 TCP 网络通信的通道之一。它提供了非阻塞的 TCP 客户端和服务器端的实现，并且可以与选择器（Selector）一起使用，实现高效的多路复用 I/O。通过 SocketChannel，可以进行连接的建立、数据的读写以及连接的关闭操作。\",\"在使用 SocketChannel 时，通常需要遵循以下步骤：\",\"打开 SocketChannel：通过调用静态的 open() 方法来打开一个 SocketChannel 对象。\",\"连接远程服务器：调用 SocketChannel 的 connect() 方法来连接远程服务器。\",\"读写数据：通过 SocketChannel 对象的 read() 方法进行数据的读取，通过 write() 方法进行数据的写入。\",\"非阻塞模式：SocketChannel 可以通过 configureBlocking(false) 方法设置为非阻塞模式，配合选择器一起使用可以实现高效的多路复用 I/O。\",\"关闭通道：通信结束后，调用 SocketChannel 的 close() 方法关闭通道。\",\"示例代码如下：\",\"// 打开 SocketChannel SocketChannel socketChannel = SocketChannel.open(); // 连接远程服务器 socketChannel.connect(new InetSocketAddress(\\\"服务器IP\\\", 8080)); // 读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = socketChannel.read(buffer); // 写入数据 String data = \\\"Hello, Server!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { socketChannel.write(buffer); } // 非阻塞模式 socketChannel.configureBlocking(false); // 关闭通道 socketChannel.close(); \",\"SocketChannel 提供了灵活而高效的 TCP 网络通信能力，适用于需要使用非阻塞 I/O 和高并发处理的网络编程场景。\"]},\"411\":{\"h\":\"ServerSocketChannel介绍\",\"t\":[\"ServerSocketChannel 是 Java NIO 中用于 TCP 服务器端的通道之一。它用于监听客户端的连接请求，并在接受到连接请求时创建对应的 SocketChannel 与客户端进行通信。ServerSocketChannel 可以与选择器（Selector）一起使用，实现高效的多路复用 I/O。通过 ServerSocketChannel，可以进行服务器的初始化、接受连接、数据的读写以及关闭操作。\",\"在使用 ServerSocketChannel 时，通常需要遵循以下步骤：\",\"打开 ServerSocketChannel：通过调用静态的 open() 方法来打开一个 ServerSocketChannel 对象。\",\"绑定端口：通过 ServerSocketChannel 对象的 bind() 方法绑定服务器端口，并设置为非阻塞模式。\",\"接受连接：调用 accept() 方法来接受客户端的连接请求，返回一个对应的 SocketChannel 用于与客户端进行通信。\",\"读写数据：通过返回的 SocketChannel 对象进行数据的读取和写入。\",\"非阻塞模式：ServerSocketChannel 可以通过 configureBlocking(false) 方法设置为非阻塞模式，配合选择器一起使用可以实现高效的多路复用 I/O。\",\"关闭通道：通信结束后，关闭 ServerSocketChannel。\",\"示例代码如下：\",\"// 打开 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定端口并设置非阻塞模式 serverSocketChannel.bind(new InetSocketAddress(8080)); serverSocketChannel.configureBlocking(false); // 接受连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = socketChannel.read(buffer); // 写入数据 String data = \\\"Hello, Client!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { socketChannel.write(buffer); } // 关闭连接 socketChannel.close(); // 关闭 ServerSocketChannel serverSocketChannel.close(); \",\"ServerSocketChannel 提供了灵活而高效的 TCP 服务器端编程能力，适用于需要使用非阻塞 I/O 和高并发处理的网络服务器编程场景。\"]},\"412\":{\"h\":\"Selector介绍\",\"t\":[\"Selector 是 Java NIO 中非常重要的组件，用于多路复用非阻塞 I/O。使用 Selector 可以用单线程处理多个 Channel，这样就可以管理多个网络连接，并且在有数据可读或可写的通道上进行处理，提高了 I/O 操作的效率。\",\"Selector 的主要作用包括：\",\"监控多个 Channel 的事件：比如读、写、连接、接受连接等事件。\",\"管理注册的 Channel：可以将多个 Channel 注册到一个 Selector 上，并根据事件类型进行监听。\",\"非阻塞 I/O 多路复用：在一个线程内处理多个 Channel 的 I/O 事件，提高了系统的并发处理能力。\",\"在使用 Selector 时，通常需要遵循以下步骤：\",\"打开 Selector：通过调用 Selector.open() 方法创建一个 Selector 对象。\",\"将 Channel 注册到 Selector 上：通过调用 Channel 的 register() 方法将要监听的事件和对应的事件处理器注册到 Selector 上。\",\"轮询事件：通过调用 Selector 的 select() 方法来轮询已注册的 Channel 上是否有对应的 I/O 事件发生。\",\"处理事件：根据 select() 方法的返回值，处理具体的 I/O 事件。\",\"示例代码如下：\",\"// 打开 Selector Selector selector = Selector.open(); // 将 Channel 注册到 Selector 上 channel1.register(selector, SelectionKey.OP_READ); channel2.register(selector, SelectionKey.OP_WRITE); while (true) { // 轮询事件 int readyChannels = selector.select(); if (readyChannels == 0) { continue; } Set<SelectionKey> selectedKeys = selector.selectedKeys(); Iterator<SelectionKey> keyIterator = selectedKeys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // 处理接受连接事件 } else if (key.isReadable()) { // 处理读事件 } else if (key.isWritable()) { // 处理写事件 } keyIterator.remove(); } } \",\"Selector 提供了高效的事件多路复用能力，适用于需要同时处理多个 Channel 的网络编程场景，能够实现高性能的并发 I/O 操作。\"]},\"413\":{\"h\":\"案列介绍\",\"t\":[\"服务端使用ServerSocketChannel和Selector\",\"客户端使用SocketChannel\",\"服务器端不关闭不停接收客户端的数据，并返回接收结果给客户端 。\",\"ClientA不关闭不断发送数据给服务端\"]},\"414\":{\"h\":\"服务端代码\",\"t\":[\"使用 Java NIO（New I/O）包实现的简单的基于 NIO 的服务器端程序，示例代码如下：\",\"package io.github.forezp.javabasiclab.nio; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.nio.charset.StandardCharsets; import java.util.Iterator; public class ServerConnect { private static final int BUF_SIZE = 1024; private static final int PORT = 8080; private static final int TIMEOUT = 3000; public static void main(String[] args) { selector(); } public static void handleAccept(SelectionKey key) throws IOException { ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel(); SocketChannel sc = ssChannel.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE)); } public static void handleRead(SelectionKey key) throws IOException { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buf = (ByteBuffer) key.attachment(); long bytesRead = sc.read(buf); while (bytesRead > 0) { buf.flip(); while (buf.hasRemaining()) { System.out.print((char) buf.get()); } System.out.println(); buf.clear(); bytesRead = sc.read(buf); } buf.put((\\\"服务器端成功接收信息.\\\").getBytes()); buf.flip(); sc.write(buf); buf.clear(); if (bytesRead == -1) { sc.close(); } } public static void handleWrite(SelectionKey key) throws IOException { System.out.println(\\\"write to client\\\"); ByteBuffer buf = (ByteBuffer) key.attachment(); buf.flip(); String data = \\\"Hello, Client!\\\"; buf.put(data.getBytes(StandardCharsets.UTF_8)); SocketChannel sc = (SocketChannel) key.channel(); while (buf.hasRemaining()) { sc.write(buf); } buf.compact(); } public static void selector() { Selector selector = null; ServerSocketChannel ssc = null; try { selector = Selector.open(); ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(PORT)); ssc.configureBlocking(false); ssc.register(selector, SelectionKey.OP_ACCEPT); while (true) { if (selector.select(TIMEOUT) == 0) { System.out.println(\\\"==\\\"); continue; } Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); if (key.isAcceptable()) { handleAccept(key); } if (key.isReadable()) { handleRead(key); } if (key.isWritable() && key.isValid()) { handleWrite(key); } if (key.isConnectable()) { System.out.println(\\\"isConnectable = true\\\"); } iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } finally { try { if (selector != null) { selector.close(); } if (ssc != null) { ssc.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"这个程序使用 Selector 来监听多个 Channel，并根据不同的事件类型进行处理。\",\"主要功能包括：\",\"在 selector() 方法中，首先打开一个 Selector，并创建一个 ServerSocketChannel，并将其注册到 Selector 上，并且设置为非阻塞模式。然后进入一个无限循环，不断轮询 Selector 上注册的事件。\",\"在 handleAccept(SelectionKey key) 方法中，当有新连接到来时，调用 ServerSocketChannel.accept() 方法接收连接，并将其设置为非阻塞模式，并注册到 Selector 上以监听读事件。\",\"在 handleRead(SelectionKey key) 方法中，处理读事件。它先创建一个 ByteBuffer 对象，用来读取数据。然后通过 SocketChannel 的 read 方法从 Channel 中读取数据，将其打印到控制台，并向客户端发送\\\"服务器端成功接收信息\\\"。\",\"在 handleWrite(SelectionKey key) 方法中，处理写事件。它首先创建一个 ByteBuffer 对象，并向其中放入要发送给客户端的数据\\\"Hello, Client!\\\"，然后通过 SocketChannel 的 write 方法向客户端写入数据。\",\"在 selector() 方法中，通过无限循环不断调用 Selector.select() 等待事件就绪，一旦有就绪的事件，就遍历处理相应的事件类型。\",\"这段代码实现了一个基于 Java NIO 的简单的非阻塞服务器端程序，能够同时处理多个客户端连接，并实现了事件的注册、轮询和处理。\"]},\"415\":{\"h\":\"客户端代码\",\"t\":[\"使用 Java NIO（New I/O）包实现了基于 NIO 的客户端程序，示例代码如下：\",\"package io.github.forezp.javabasiclab.nio; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SocketChannel; import java.util.concurrent.TimeUnit; public class ClientConnect { public static void main(String[] args) { try { client(); } catch (IOException e) { e.printStackTrace(); } } public static void client() throws IOException { ByteBuffer buffer = ByteBuffer.allocate(1024); SocketChannel socketChannel = null; try { socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); socketChannel.connect(new InetSocketAddress(\\\"127.0.0.1\\\", 8080)); if (socketChannel.finishConnect()) { int i = 0; while (true) { TimeUnit.SECONDS.sleep(1); String info = \\\"I'm \\\" + i++ + \\\"-th information from client\\\"; buffer.clear(); buffer.put(info.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { //System.out.println(new String(buffer.array())); socketChannel.write(buffer); } // buffer.clear(); int len = socketChannel.read(buffer); buffer.flip(); byte[] bytes = new byte[buffer.remaining()]; buffer.get(bytes); System.out.println(new String(bytes, 0 , len)); buffer.clear(); } } } catch (IOException | InterruptedException e) { e.printStackTrace(); } finally { try { if (socketChannel != null) { socketChannel.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"代码的主要功能包括：\",\"在 client() 方法中，首先创建一个 ByteBuffer 对象用于读写数据，然后创建一个 SocketChannel，并将其设置为非阻塞模式。接着通过 socketChannel.connect(new InetSocketAddress(\\\"127.0.0.1\\\", 8080)) 进行连接服务器端。\",\"使用 socketChannel.finishConnect() 来确保连接已经建立，然后进入一个无限循环，向服务器端发送消息，并接收服务器端的响应。\",\"在while循环中，每隔一秒向服务器端发送一条消息，并且接收服务器端发送的反馈消息。\",\"在 finally 块中关闭 SocketChannel。\",\"这段代码实现了一个基于 Java NIO 的简单的非阻塞客户端程序，能够与服务器端建立连接，进行数据的发送和接收。\",\"依次启动服务端程序和客户端程序，服务端打印如下：\",\"== I'm 0-th information from client I'm 1-th information from client I'm 2-th information from client I'm 3-th information from client\",\"客户端打印如下：\",\"服务器端成功接收信息. 服务器端成功接收信息. 服务器端成功接收信息.\"]},\"416\":{\"h\":\"NIO底层原理\",\"t\":[\"NIO的特点是由底层原理决定的，如图：\",\"nio-jieshao\",\"总结来说，和阻塞 I/O（BIO）相比，使用多路复用器（比如 Selector）和非阻塞 I/O（NIO）的方式能够更高效地处理多个连接的读写事件。\",\"在使用 NIO 的情况下，当调用 select() 启动多路复用器时，连接事件会被交由多路复用器管理，这会触发内核中的 epoll() 函数，将网卡中所有连接的读写事件数据以链表的形式一次性拷贝到内存中的特定区域。这样一来，当 Selector 轮询到连接事件时便会触发内核中的 recvFrom(NOBlocking…) 函数，将数据从特定区域零拷贝到用户空间，实现了零拷贝的优化功能。\",\"与阻塞 I/O 不同的是，使用 NIO 和 Selector 能够保证即使某个连接阻塞，也不会影响其他连接的数据已就绪的读写事件。这是因为在 Selector 的轮询机制下，各个客户端的数据已经提前拷贝到内存中，所以不会因为某个连接的阻塞而影响其他连接的读写事件的处理。\",\"因此，使用 NIO 和 Selector 能够更高效地处理多个连接的读写事件，并且能够避免阻塞影响其他连接的特点成为了非常重要的优势。\"]},\"417\":{\"h\":\"java基础高频面试题1\"},\"418\":{\"h\":\"重载与重写的区别\",\"t\":[\"重载（Overloading）和重写（Overriding）是Java语言中的两个重要概念，它们都是用于类的方法。正是由于重载和重写，类的多态性得到了充分的展现。\",\"重载（Overloading）：\",\"重载指的是在一个类中定义多个方法，这些方法具有相同的方法名称，但是参数的个数不同，或者参数的类型不同，或者是参数的顺序不同。重载的方法通过调用时的参数的类型或者数量、顺序来区分调用了哪个方法。重载的方法的返回结果的类型也可以是不同的，但是不能返回结果的类型来定义方法的重载。\",\"重载有以下的特点：\",\"方法名称相同，参数的类型可以不同、参数的个数也可以不同、参数的顺序也可以不同\",\"不同的重载方法可以返回不同的结果；但是不同的返回结果不能作为方法重载的定义。\",\"编译是通过方法的不同的参数来确定方法\",\"代码示例：\",\"public class OverLodingDemo { public static void main(String[] args) { OverLodingDemo demo=new OverLodingDemo(); demo.greeting(\\\"lisi\\\"); demo.greeting(\\\"lisi\\\",\\\"wangwu\\\"); } public void greeting(String name){ System.out.println(\\\"hello \\\"+name); } public void greeting(String name1,String name2){ System.out.println(\\\"hello \\\"+name1 ); System.out.println(\\\"hello \\\"+name2 ); } } \",\"在上面的例子中，有两个greeting方法，这两个greeting方法有不同的参数个数，属于方法的重载。\",\"重写（Overriding）：\",\"重写是指子类对父类方法的重写，它是子类对父类的同名方法且具有相同的参数的重新实现。子类通过重写父类的方法来修改或者扩展父类方法的行为。\",\"被重写的方法具有以下的特点：\",\"子类的方法名称和父类完全相同，且具有相同的参数和返回结构类型\",\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别。\",\"它是动态绑定来确定运行时对象的实际方法的调用。\",\"举个简单的例子，有Animal的父类，有一个eat的方法：\",\"public class Animal { public void eat(){ System.out.println(\\\"animal eat\\\"); } } \",\"Sheep继承了Animal父类，并重写了eat方法：\",\"public class Sheep extends Animal{ @Override public void eat(){ System.out.println(\\\"sheep eat grass\\\"); } } \",\"Dog继承了Animal父类，没有重写了eat方法：\",\"public class Dog extends Animal{ } \",\"写一个测试类：\",\"public class OverwrittingDemo { public static void main(String[] args) { Animal sheep=new Sheep(); sheep.eat(); Animal dog=new Dog(); dog.eat(); } } \",\"执行结果如下：\",\"sheep eat grass animal eat\",\"总结：\",\"重载是针对于同个类中，重新是发生在子类和父类的继承关系之间。\",\"重载是根据方法的参数列表进行区分，重写是根据方法的名称和参数列表进行区分。\",\"重载方法在编译时静态地绑定，而重写方法在运行时动态地绑定。\",\"重载方法可以有不同的返回类型，而重写方法必须具有相同的返回类型。\"]},\"419\":{\"h\":\"抽象类和接口的区别\",\"t\":[\"抽象类\",\"抽象类通过使用关键字 \\\"abstract\\\" 来声明，它不能被实例化，只能用作基类或父类来使用。抽象类用于定义通用的属性和行为，可以包含抽象方法、普通方法、字段以及构造方法。抽象方法只有方法签名，没有方法体。抽象方法必须在非抽象子类中被重写实现。\",\"抽象类通常为其子类提供一个通用的模板，子类必须实现抽象类中的抽象方法。\",\"以下是一个抽象类的示例：\",\"public abstract class Shape { private String color; public Shape(String color) { this.color = color; } abstract double getArea(); } public class Circle extends Shape{ private double radius; public Circle(String color, double radius) { super(color); this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } } public class Demo { public static void main(String[] args) { Shape circle=new Circle(\\\"blue\\\",23); System.out.println(circle.getArea()); } } \",\"在上面的这个例子中，抽象类 Shape 声明了抽象方法 getArea() 。Circle 是其子类，并实现了抽象方法。需要注意的是虽然抽象类Shape具有构造函数，但是它是不能给被实例化的。可以通过抽象类的引用变量来指向它的实现类的实例。在上述示例中，可以使用 Shape 类型的引用变量 引用了 Circle 的实例对象。\",\"接口\",\"接口使用interface关键字定义的，它定义了一组方法的方法，通常是抽象方法，这些方法只有方法签名，没有方法体。这些抽象方法通常是定义了一组规范或者行为，但是没有实现。\",\"接口可以被类实现，一个类可以实现多个接口，而且同一个接口可以被多个类实现，从而使得一个实现类有不同接口的多态性。\",\"在接口定义中，方法默认是抽象类并且是pulic方法，所以在定义接口方法时不需要添加关键字 public和abstract。接口定义中可以包含常量、默认方法（Java 8 及以上版本）、静态方法（Java 8 及以上版本）和私有方法（Java 9 及以上版本）。\",\"以下是一个接口的示例：\",\" interface Animal { int LEGS = 4; // 常量 void makeSound(); // 抽象方法 default void sleep() { // 默认方法 System.out.println(\\\"Animal is sleeping.\\\"); } static void eat() { // 静态方法 System.out.println(\\\"Animal is eating.\\\"); } private void run() { // 私有方法 System.out.println(\\\"Animal is running.\\\"); } } public class Dog implements Animal{ @Override public void makeSound() { System.out.println(\\\"dog bark\\\"); } } public class AnimalDemo { public static void main(String[] args) { Dog dog = new Dog(); dog.makeSound(); dog.sleep(); Animal.eat(); } } \",\"在上面的例子中，\",\"接口Animal，定义了常量 LEGS 和抽象方法 makeSound()，以及默认方法 sleep() 和静态方法 eat()。Dog 类实现了 Animal 接口，实现了 makeSound() 方法。\",\"注意几点：\",\"类通过使用关键字 \\\"implements\\\" 来实现接口。一个类可以实现多个接口\",\"接口中的常量默认是静态常量。默认被 public static final 关键字修饰，可以直接通过接口名直接访问。\",\"接口的默认方法可以被实现该接口的类直接使用，实现类也可以重写接口的默认方法。\",\"静态方法在接口中提供了一些与接口相关的工具方法，可以直接通过接口名调用。\",\"私有方法在接口中定义一些辅助方法，只能在接口内部被调用，不能被实现类调用。\",\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为。通过实现接口，我们可以实现代码的解耦和类之间的松耦合。接口还为多重继承提供了解决方案，使得一个类可以具备多种类型的行为。\",\"抽象类VS接口\",\"抽象类和接口是Java中用于实现抽象和多态性的两个关键概念。它们有一些共同点，但也有一些区别。\",\"区别如下：\",\"实现方式：\",\"抽象类：通过关键字 abstract 定义的类，可以包含普通方法和抽象方法，可以有实例变量和构造方法。可以被继承，用于构建类的继承层级结构。\",\"接口：通过关键字 interface 定义的，只能包含常量和抽象方法（Java 8 之后，接口也可以包含默认方法和静态方法）。没有实例变量和构造方法。可以被类实现，用于实现类的多态性。\",\"多继承的支持：\",\"抽象类：Java只支持单继承，一个类只能继承一个抽象类。\",\"接口：Java支持多实现，一个类可以实现多个接口。\",\"构造方法：\",\"抽象类：可以有构造方法，用于实例化抽象类的对象。\",\"接口：不能有构造方法，接口只提供方法的声明，不能实例化对象。\",\"方法实现：\",\"抽象类：可以包含普通方法的实现。子类可以选择性地重写或调用父类的普通方法。\",\"接口：只能包含抽象方法的声明，不包含方法的实现。实现接口的类必须提供所有抽象方法的具体实现。\",\"设计目的：\",\"抽象类：用于描述一种通用的概念，如动物类、车类等，提供一些通用方法的实现，用作其他类的基类。\",\"接口：用于定义一组合同类型的操作，描述了一个类应该具备的行为，提供了一种通用的规范，用于实现类的多态性。\",\"需要注意的是，如果一个类既需要作为其他类的基类，又需要进行多种类型的实现，那么在设计时可以考虑将类设计为抽象类，并实现相关接口。这样可以兼顾抽象类和接口的优势。\"]},\"420\":{\"h\":\"为什么Java不支持多继承\",\"t\":[\"多继承是指一个类可以从多个父类继承属性和方法。尽管多继承在某些情况下可能很有用，但它也带来了一些问题。\",\"命名冲突：当一个类从多个父类继承相同名称的属性或方法时，可能会产生命名冲突。解决这些冲突需要额外的语法规则和解析过程，增加了语言的复杂性和理解上的困惑。\",\"菱形继承问题：多继承可能导致菱形继承问题，即当一个类同时继承自两个具有共同父类的类时，可能在继承链中得到两个相同的父类实例，导致不确定性。\",\"Java不支持多继承是为了避免多继承带来的上述问题。\",\"Java选择了单继承并使用了接口（interface）来解决多继承的需要。一个类可以实现多个接口，从而达到类似多继承的效果。使用接口可以避免命名冲突和菱形继承问题，并且提供了更灵活的类组合方式。\",\"在Java中，接口的设计可以更好地支持代码的组织和抽象，同时提供了更好的可维护性和扩展性。Java的设计理念是\\\"Prefer composition over inheritance\\\"（倾向于组合而非继承），鼓励使用组合和接口实现代码的复用和扩展。这种设计思想能够提高代码的可读性、可维护性和可扩展性。\"]},\"421\":{\"h\":\"String和StringBuffer、StringBuilder的区别是什么\",\"t\":[\"在Java中，String、StringBuffer和StringBuilder是用于处理字符串的类，它们之间有以下区别：\",\"可变性： \",\"String是不可变（Immutable）的类，一旦创建就不能被修改。每次对String进行修改操作都会创建一个新的String对象，原来的String对象不会被改变。\",\"StringBuffer和StringBuilder是可变（Mutable）的类，可以在原有对象的基础上进行修改。可以对其进行修改、删除、替换等操作，而不会创建新的对象。\",\"线程安全性： \",\"String是线程安全的，可以被多个线程同时访问而不会导致错误。\",\"StringBuffer是线程安全的，它的方法都使用了synchronized关键字来进行同步，保证了线程安全。\",\"StringBuilder是非线程安全的，在单线程环境中，StringBuilder的性能比StringBuffer性能更好。\",\"性能： \",\"由于String是不可变的，每次对String进行修改时都要创建一个新的对象，当需要频繁修改字符串时会产生大量的垃圾对象，对性能会有一定的影响。\",\"StringBuffer和StringBuilder是可变的，对字符串进行操作时不需要创建新的对象，因此在频繁修改字符串的场景下，性能较好。\",\"使用场景：\",\"当字符串不需要修改时，可以使用String。\",\"当需要对字符串进行频繁的修改时，建议使用StringBuffer或StringBuilder。\",\"如果在多线程环境下执行字符串操作，建议使用StringBuffer来保证线程安全。\",\"如果在单线程环境下进行字符串操作，可以使用StringBuilder来获得更好的性能。\"]},\"422\":{\"h\":\"如何理解面向过程和面向对象\",\"t\":[\"面向过程（Procedural Programming）和面向对象（Object-Oriented Programming）是两种不同的编程范式。\",\"面向过程是一种基于步骤和函数的编程方法。在面向过程编程中，程序被分解为可重用的功能模块，每个模块都包含一系列的操作步骤。程序按照一定的顺序执行这些步骤来完成任务。面向过程的关注点主要在于解决问题的步骤和流程。\",\"相比之下，面向对象是一种基于对象和类的编程方法。在面向对象编程中，程序由相互作用的对象组成，每个对象都是某个类的实例。每个对象都有自己的状态（属性）和行为（方法）。对象之间通过消息传递来进行通信和协作。面向对象的关注点主要在于构建对象的结构和定义对象的行为。\",\"面向过程和面向对象都有各自的优点和适用场景。面向过程更适合简单的任务和算法，它更直观、易于理解和调试。面向对象更适合复杂的应用，它具有更好的可维护性、可扩展性和重用性。\",\"在实际编程中，可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法，或者结合两者的特点使用混合编程。\"]},\"423\":{\"h\":\"Java基本类型为什么需要包装类\",\"t\":[\"Java基本类型（比如int、char、float、double等）需要包装类的原因有以下几个方面：\",\"泛型支持：Java的泛型不支持基本类型，只能使用对象类型。所以如果想要在泛型中使用一个基本类型的值，就需要将其包装成相应的对象类型。\",\"null赋值: 基本类型的取值范围是有限的，不能表示空值或null。使用包装类可以使得变量可以被赋值为null，方便更好地表示一个变量无值的状态。\",\"面向对象：Java是一种面向对象的语言，基本类型不是对象。如果使用基本类型，就无法访问其对象方法和属性。使用包装类可以让基本类型像一个对象一样使用。\",\"方法重载：Java不允许在方法中使用同名的不同类型的参数。因为基本类型的参数值之间无法进行隐式转换，所以需要使用包装类来为这些基本类型提供一个相应的对象类型，以便方法可以在这些对象类型之间进行选择。\",\"其他一些功能：包装类还提供了许多其他功能，比如数学运算、类型转换和字符串解析等。\",\"Java提供了对应的包装类来对基本类型进行包装，例如Integer、Character、Float、Double等等。这些包装类实现了相应类型的对象类型，提供了访问基本类型数据的方法。\",\"对于包装类，还有一些需要注意的点：\",\"包装类都是不可变的，一旦创建，其值就不能被修改。\",\"包装类的值比较应该使用equals()方法而不是==，因为包装类对象在使用==比较时，比较的是引用而不是值，这可能导致意外的结果。\",\"在自动装箱和拆箱时，Java会自动调用相应的包装类方法。\",\"例如，以下代码演示了使用包装类实现基本类型的自动装箱和拆箱：\",\"Integer i = 10; // 自动装箱 int j = i; // 自动拆箱 \",\"在这个例子中，编译器会自动将10包装成一个Integer对象，并将其赋值给i。在下一行，编译器又将i自动拆箱成int值，然后赋值给j。\"]},\"424\":{\"h\":\"如何理解java中的多态\",\"t\":[\"在 Java 中，多态是面向对象编程的一个核心概念，它允许我们使用父类的引用变量来引用子类的对象实例。多态主要体现在方法的重写和方法的动态绑定上。\",\"具体来说，可以通过以下几个方面来理解 Java 中的多态：\",\"父类引用指向子类对象实例。这样做的好处是可以通过统一的接口来操作不同的子类对象，实现了代码的灵活性和扩展性。\",\"方法的重写：子类可以重写（覆盖）从父类继承过来的方法。当使用父类引用指向子类对象时，通过父类引用调用重写的方法时，实际上会调用子类中的方法，这就实现了运行时的动态绑定。\",\"动态绑定：Java 的方法调用是基于运行时类型而不是编译时类型。也就是说，当调用一个对象的方法时，实际调用的是该对象的实际类型中定义的方法。这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象，实现了多态性的特性。\",\"多态性是继承的一个重要应用，它让我们可以使用父类的引用变量来引用不同子类的对象，并根据实际对象的类型来执行对应的方法。这样做的好处是实现了代码的灵活性、可扩展性和易维护性。\",\"例如，假设有一个抽象类 Animal 和它的两个子类 Cat 和 Dog，它们都有一个共同的方法 makeSound()：\",\"abstract class Animal { public abstract void makeSound(); } class Cat extends Animal { @Override public void makeSound() { System.out.println(\\\"Meow!\\\"); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\\\"Woof!\\\"); } } \",\"现在我们可以通过 Animal 类的引用变量来引用 Cat 或 Dog 对象，并根据实际对象的类型来调用 makeSound() 方法：\",\"Animal animal1 = new Cat(); Animal animal2 = new Dog(); animal1.makeSound(); // 输出 \\\"Meow!\\\" animal2.makeSound(); // 输出 \\\"Woof!\\\" \",\"在这个例子中，我们使用父类 Animal 的引用变量 animal1 和 animal2 分别引用了 Cat 和 Dog 对象。当调用 makeSound() 方法时，由于动态绑定的机制，实际上调用的是 Cat 和 Dog 对象中重写的 makeSound() 方法。\",\"需要注意的是在使用父类引用的变量去调用方法时，只能调用父类中声明的方法和子类中重写了父类的方法。要调用子类特有的方法，需要将父类引用的变量进行转换成子类的类型。\"]},\"425\":{\"h\":\"\"},\"426\":{\"h\":\"谈谈final、finally、finalize的区别\"},\"427\":{\"h\":\"java基础高频面试题2\"},\"428\":{\"h\":\"\\\"==\\\" 和 \\\"equals\\\" 的区别\",\"t\":[\"\\\"==\\\" 和 \\\"equals\\\" 都可以用于比较 Java 中的对象，但是它们之间有一些区别。\"]},\"429\":{\"h\":\"关系操作符号“==”\",\"t\":[\"基本数据类型\",\"在Java中有八种基本数据类型：\",\"浮点型：float(4 byte), double(8 byte)\",\"整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)\",\"字符型: char(2 byte)\",\"布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)\",\"对于基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符 “== ”来进行比较时，比较的就是“值”本身。要注意的是，浮点型和整型都是有符号类型的（最高位仅用于表示正负，不参与计算【以 byte 为例，其范围为 -2^7 ~ 2^7 - 1，-0即-128】），而char是无符号类型的（所有位均参与计算，所以char类型取值范围为0~2^16-1）。\",\"举个例子：\",\"int a = 5; int b = 5; System.out.println(a == b); // true \",\"引用类型变量\",\"在Java中，引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址。如果使用== 操作符去判断引用类型的变量，则比较的内容是判断两个变量的引用是否相等，即它们是否指向同一个对象。如果两个变量的引用指向同一个对象，那么它们之间的 == 比较结果为 true。如果两个引用指向不同的对象，那么它们之间的 ==比较结果为 false。例如：\",\"String str1 = \\\"abc\\\"; String str2 = \\\"abc\\\"; String str3 = new String(\\\"abc\\\"); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false \",\"在上述示例中，str1 和 str2 都指向常量池中的同一个字符串对象，因此它们之间的 == 比较结果为 true。而 str3 则指向一个新创建的字符串对象，所以它们之间的 == 比较结果为 false。\"]},\"430\":{\"h\":\"\\\"equals\\\"\",\"t\":[\"在初学Java的时候，很多人会说在比较对象的时候，“==”操作符是比较两个变量的内存地址，equals()是比较对象的内容，其实不然。\",\"在Object类中，equals()方法是比较两个对象的内存地址是否相等，代码如下：\",\"public boolean equals(Object obj){ return (this == obj); } \",\"为什么会有人把equals方法当做是比较两个内容的比较呢？是因为在String、Double等封装类中，已经重写了(ov了Object类的equals()方法。比如在String内中，它比较的是对字符串内容的比较：\",\"public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } \",\"在String类的方法中，先比较的是字符串地址是否相等，如果相等，则字符串内容肯定是相等；然后地址不相等，则比较字符串内容是否相等。\",\"在实际的开发中，我们对对象内容的比较，通常都需要重写equals()方法。当我们重写equals()方法，需要遵循以下几个规则：\",\"自反性：对于任何非null的引用值x，x.equals(x)应返回true。\",\"对称性：对于任何非null的引用值x和y，如果x.equals(y)返回true，则y.equals(x)也应返回true。\",\"传递性：对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，则x.equals(z)也应返回true。\",\"一致性：对于任何非null的引用值x和y，如果用于比较的对象信息没有被修改，则x.equals(y)的多次调用应始终返回相同的结果。\",\"非空性：对于任何非null的引用值x，x.equals(null)应返回false。\"]},\"431\":{\"h\":\"\\\"equals\\\" 和hashcode的关系\",\"t\":[\"当我们在重写equals()方法时，通常也需要重写hashCode()方法。这是因为我们在使用基于散列的数据结构，比如如哈希表，以及一些集合类（如HashSet、HashMap）时，hashCode()方法的返回值将被用作对象的索引。\",\"当我们重写equals()方法时，经常选择使用对象的一些属性进行比较，以确定两个对象是否相等。在这种情况下，为了保持一致性，我们需要使用相同的属性来计算hashCode()值。\",\"如果我们没有重写hashCode()方法，那么hashCode()的默认行为是使用对象的内存地址计算哈希码，这与equals()方法的比较内容无关。这将导致具有相等内容的对象，通过hashCode()方法计算出来的哈希码可能不相等，这将导致在存储和查找对象时出现问题。\",\"所以，正确地重写hashCode()方法是很重要的。以下是一些在重写hashCode()方法时需要注意的规则：\",\"一致性：在对象的生命周期中，只要对象的属性没有发生改变，那么hashCode()应始终返回相同的值。\",\"相等性：如果两个对象根据equals()方法比较相等，那么它们的hashCode()方法应返回相同的值。\",\"分布均匀性：尽量避免不同对象返回相同的hashCode()值，以减少哈希冲突的概率，提高散列存储结构的性能。\",\"一种常用的方式来重写hashCode()方法是，根据对象的每个属性计算一个哈希码，然后将这些哈希码组合在一起，以获得最终的哈希码。这可以通过使用乘法和加法等算法来实现。如果某个属性可以为null，则需要特殊处理，以避免空指针异常。\",\"比如在String类中，hashCode()方法的定义如下：\",\" public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i < value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } \"]},\"432\":{\"h\":\"java中的异常处理机制\",\"t\":[\"Java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况，以确保程序的正常执行。\",\"异常类层次结构\",\"在Java中，Exception、Error和Throwable是一个类层次结构中的相关类。\",\" <<class>> Throwable ---------------- | | <<class>> <<class>> Exception Error | ------------------ | | checked unchecked \",\"Throwable是所有异常类的根类，它位于异常类的最顶层。它定义了可以被抛出和捕获的异常对象的基本功能。Throwable有两个重要的子类：Exception和Error。\",\"Exception是可控制的异常类，通常表示程序中可预见的异常情况，可以被捕获并进行相应处理。它是Throwable的一个子类。\",\"Exception又分为两种类型：checked异常和unchecked异常。checked异常需要在代码中进行处理或声明，否则编译器会报错；unchecked异常不要求在代码中进行处理或声明。\",\"自定义异常：Java允许开发者自定义异常类，以便更好地抽象和组织程序中可能发生的异常情况。自定义异常类通常继承自Exception或RuntimeException类\",\"Error是不可控制的严重问题的异常类，通常表示系统的严重错误或问题，大多数情况下不会被程序显式地捕获和处理，而是由Java运行时环境（JVM）来处理。Error也是Throwable的一个子类。\",\"异常处理语句\",\"Java语言中提供了一些列的异常处理关键字和处理模板。\",\"抛出异常，使用throw语句。可以使用throw语句在程序中主动抛出异常，从而触发异常处理机制。\",\"声明异常：使用throws关键字，在方法签名中明确指定可能抛出的异常类型，这样调用者就能清楚地知道需要处理哪些异常。\",\"捕获异常，常使用try-catch-finally异常处理语句模板 \",\"try块：try块用于包裹可能发生异常的代码片段。当try块中的代码发生异常时，异常将被抛出，程序流程将跳转到catch块或finally块。\",\"catch块：catch块用于捕获并处理指定类型的异常。catch块可以捕获多个异常类型，并按照顺序处理异常。\",\"finally块：finally块用于定义无论是否发生异常都需要执行的代码，例如释放资源。finally块在try块或catch块执行完毕后执行。\",\"举个例子，演示了try-catch-finally的用法：\",\"public class ExceptionExample { public static void main(String[] args) { try { int result = divide(10, 0); System.out.println(\\\"结果：\\\" + result); } catch (ArithmeticException e) { System.out.println(\\\"除零错误：\\\" + e.getMessage()); } finally { System.out.println(\\\"执行finally块\\\"); } } public static int divide(int num1, int num2) { return num1 / num2; } } \",\"在上述代码中，定义了一个divide方法，用于计算两个数的除法操作。由于除数为0会产生算术异常（ArithmeticException），我们使用try-catch语句对可能发生异常的代码块进行了包裹。\",\"在try代码块中，我们调用了divide方法并将结果存储在result变量中。\",\"如果在此过程中发生了异常，程序会立即跳转到catch代码块中，并执行与异常类型匹配的处理代码。在\",\"无论是否发生异常，finally代码块中的代码始终会执行。\",\"执行上述代码，输出如下：\",\"除零错误：/ by zero 执行finally块 \",\"Java的异常处理机制是Java程序设计中非常重要的一个方面，它能够有效地处理程序中可能发生的异常情况，并提供了良好的可读性和可维护性。通过合理地使用try-catch-finally块，对异常进行合适的处理，防止程序因为出现异常而奔溃，是程序的稳定性和健壮性的一种保护机制。\"]},\"433\":{\"h\":\"JDK、JRE、JVM的区别和联系\",\"t\":[\"JDK（Java Development Kit）是Java开发工具包，提供了一套完整的开发工具，包括编译器（javac）、调试器（jdb）、打包工具（jar）等。使用JDK可以进行Java应用程序的开发和构建，生成可执行的Java应用程序。JDK还提供了各种开发文档和示例代码，帮助开发者学习和使用Java。\",\"JRE（Java Runtime Environment）是Java运行时环境，是在目标机器上运行Java应用程序所需的最小环境。它包含了JVM（Java Virtual Machine）和Java类库。当用户在目标机器上运行Java应用程序时，需要先安装JRE。JRE只提供了Java应用程序的运行环境，不包含开发工具。\",\"JVM（Java Virtual Machine）是Java虚拟机，是Java平台的核心部分。它是一个抽象的计算机，可以在不同的操作系统上运行Java程序，实现了Java的跨平台特性。JVM解析Java字节码，并将其转换为底层操作系统可以执行的机器码。它还具有内存管理、垃圾回收等功能，确保Java应用程序的安全、高效执行。\",\"他们之间的关系如下：\",\"JDK包含JRE，因为在开发Java应用程序时需要运行Java程序来进行测试和调试。\",\"JRE包含JVM，因为在运行Java应用程序时需要虚拟机来解释和执行Java字节码。\"]},\"434\":{\"h\":\"final关键字详解\"},\"435\":{\"h\":\"final关键字的基本用法\",\"t\":[\"final关键字，用于表示不可变，表示变量或者方法定义后不能被修改或者重写。final关键字可以用于修饰类、方法和变量。\",\"修饰类：当类被声明为final时，表明该类不能被继承。它是一个最终类，不能有子类继承它。\",\"public final class FinalTest { } \",\"修饰方法: 当方法被声明为final时，该方法不能被子类重写。子类只能继承父类中的final方法，但不能修改其实现。\",\"public class FinalMethodDemo { public final void test(){ System.out.println(\\\"test\\\"); } static class FinalMethodeDemo2 extends FinalMethodDemo{ //编译不通过 @Override public void test(){ System.out.println(\\\"test\\\"); } } } \",\"FinalMethodeDemo2是不能重新它的父类FinalMethodDemo的final方法的，编译的时候会报错。idea会提示错误，如下图所示：\",\"修饰变量: 当变量被声明为final时，该变量的值不能被修改，即它成为一个常量。一旦被赋值，就不能再更改。\",\"对于实例变量（成员变量），可以在代码块中赋值，也可以在构造函数中赋值，一旦赋值就不能被改变：\",\" private final String s1=\\\"s1\\\"; // { // s1=\\\"s1\\\"; //在代码快中赋值 // } private static final String s2; static { s2=\\\"s2\\\"; //在静态代码快中赋值 } private final String s3; //在构造函数中赋值 public FinalTest(String s3) { this.s3 = s3; } \",\"对于被final修饰的局部变量，在使用前必须赋值。\",\" public void test2(){ final String s; s=\\\"ss\\\"; System.out.println(s);//在使用final变量前必须赋值 } \",\"如果被final修饰的变量时引用类型，则在变量初始化后，就不能再指向另一个对象了，但是变量的值是可以被修改的。示例代码如下：\",\"public class FinalObject { public static void main(String[] args) { final int[] arrays=new int[]{1,2,3}; // arrays=null; 非法 final Person person=new Person(\\\"sam\\\",1); person.setAge(2); // person=null; 非法 } static class Person { private String Name; private int age; public Person(String name, int age) { Name = name; this.age = age; } public String getName() { return Name; } public void setName(String name) { Name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } } \",\"final关键字的使用可以增加代码的可读性，提高代码的安全性，以及优化性能。它可以在合适的场景中使用，例如常量、线程安全等需要不可变性的情况。\"]},\"436\":{\"h\":\"为什么内部类引用的外部变量必须用final修饰\",\"t\":[\"JDK1.8之后，如果将局部变量（或表达式）传递给匿名内部类或Lambda表达式作为捕捉的变量，它们会被隐式地视为final，是不可以被更改的。\",\"为什么会这样呢？\",\"public abstract class Task { public abstract void run(); } public class FinalDemo { public void run1(final String taskname) { Task task = new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname +\\\" run\\\"); } }; task.run(); } public void run2(final String taskname) { new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname+\\\" run\\\"); } }.run(); } public static void main(String[] args) { FinalDemo demo = new FinalDemo(); demo.run1(\\\"task1\\\"); demo.run2(\\\"task2\\\"); } } \",\"首先，内部类和外部类其实是处于同一个级别，反编译中可以看到都是对象级别的类文件，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁。\",\"如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。\",\"如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中(反编译class文件中可以看到)，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。\"]},\"437\":{\"h\":\"谈谈final、finally、finalize的区别\",\"t\":[\"final是Java中的修饰符，可以用来修饰类、方法和变量，表示不可改变的\",\"修饰类：当类被声明为final时，该类不能被继承，成为最终类。\",\"修饰方法：当方法被声明为final时，该方法不能被子类重写，成为最终方法。\",\"修饰变量：当变量被声明为final时，该变量的值一旦被赋值，不能被修改，成为常量。\",\"finally：finally是Java中的关键字，用于异常处理的最后一个代码块，在try-catch语句中使用。无论是否发生异常，finally块中的代码都会被执行。\",\"try { // 可能会发生异常的代码 } catch (Exception e) { // 异常处理逻辑 } finally { // 最终会执行的代码块 } \",\"finally块通常用于释放资源、关闭连接等必须执行的操作，以确保代码的可靠性。即使在try块或catch块中出现return语句，finally块中的代码也会在方法返回之前执行。\",\"finalize：finalize是一个方法，它是在对象被垃圾回收器回收之前调用的。每个类都可以重写finalize方法来执行对象的清理操作。\",\"需要注意的是，finalize方法已经过时，不推荐使用了。因为垃圾回收器的工作是由Java虚拟机自动处理的，无法保证finalize方法的及时执行。更好的做法是使用try-finally或其他资源管理机制来确保资源的释放。\",\"@Override protected void finalize() throws Throwable { // 进行资源释放或清理操作 super.finalize(); } \"]},\"438\":{\"h\":\"finally语句到底是在return之前还是之后执行？\",\"t\":[\"在回答这个问题前，先来说一下finally语句是不会被执行的情况：\",\"try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要条件是：相应的try语句一定被执行到。\",\"在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，finally语句也不会被执行到。\",\"finally语句到底是在return之前还是之后执行？\",\"当没有发生异常时：如果在try块中没有发生异常，finally语句将在try块执行完毕后立即执行。然后，程序将继续执行后续的代码。finally块中的代码将在return语句执行之后、方法返回之前执行。\",\"请看下面的示例代码：\",\"public class FinalReturn1 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a = 1; try { return a; } finally { a = 2; //idea提示：The value 2 assigned to 'a' is never used System.out.println(\\\"Finally block executed.\\\"); } } } \",\"在这个示例中，无论try块中是否发生异常，finally块中的代码都会被执行。控制台会输出以下内容：\",\"Finally block executed. 1 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在catch中再次使用了return操作，则会覆盖try里面的return操作。\",\"package io.github.forezp.javabasiclab.finaltest; public class FinalReturn2 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 2 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\",\"public class FinalReturn3 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); a=3; return 4; } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 4 \",\"总结来说，finally语句在Java中用于定义一段无论是否发生异常都会执行的代码块。它在try块或catch块中的代码执行完毕后立即执行，并且在方法返回之前被执行。\",\"在try或catch块中使用return语句时，finally块中的代码也会在return语句执行后执行。(finally语句中没有使用return操作)\",\"如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\"]}},\"dirtCount\":0,\"index\":[[\"请看下面的示例代码\",{\"1\":{\"438\":1}}],[\"请求状态码\",{\"1\":{\"98\":2}}],[\"请求路径\",{\"1\":{\"98\":2}}],[\"请求的最大耗时\",{\"1\":{\"97\":1}}],[\"请求的总耗时\",{\"1\":{\"97\":1}}],[\"请求的总次数\",{\"1\":{\"97\":1}}],[\"请求都是在100ms以内\",{\"1\":{\"78\":1}}],[\"他们之间的关系如下\",{\"1\":{\"433\":1}}],[\"垃圾回收等功能\",{\"1\":{\"433\":1}}],[\"垃圾回收器将永远不会回收被引用的对象\",{\"1\":{\"286\":1}}],[\"帮助开发者学习和使用java\",{\"1\":{\"433\":1}}],[\"声明异常\",{\"1\":{\"432\":1}}],[\"声明了抽象方法\",{\"1\":{\"419\":1}}],[\"仅规定其只能够取字面值\",{\"1\":{\"429\":1}}],[\"布尔型\",{\"1\":{\"429\":1}}],[\"浮点型和整型都是有符号类型的\",{\"1\":{\"429\":1}}],[\"浮点型\",{\"1\":{\"429\":1}}],[\"谈谈final\",{\"0\":{\"426\":1,\"437\":1}}],[\"覆盖\",{\"1\":{\"424\":1}}],[\"覆盖需要删除的元素\",{\"1\":{\"362\":1}}],[\"父类引用指向子类对象实例\",{\"1\":{\"424\":1}}],[\"父子线程间的数据共享\",{\"0\":{\"288\":1}}],[\"泛型支持\",{\"1\":{\"423\":1}}],[\"泛型v就是要call\",{\"1\":{\"325\":1}}],[\"易于理解和调试\",{\"1\":{\"422\":1}}],[\"替换等操作\",{\"1\":{\"421\":1}}],[\"替代\",{\"1\":{\"153\":1}}],[\"鼓励使用组合和接口实现代码的复用和扩展\",{\"1\":{\"420\":1}}],[\"倾向于组合而非继承\",{\"1\":{\"420\":1}}],[\"菱形继承问题\",{\"1\":{\"420\":1}}],[\"车类等\",{\"1\":{\"419\":1}}],[\"区别如下\",{\"1\":{\"419\":1}}],[\"私有方法在接口中定义一些辅助方法\",{\"1\":{\"419\":1}}],[\"私有方法\",{\"1\":{\"419\":1}}],[\"及以上版本\",{\"1\":{\"419\":3}}],[\"及划分责任和算法\",{\"1\":{\"12\":1}}],[\"引用类型的变量存储的并不是\",{\"1\":{\"429\":1}}],[\"引用类型变量\",{\"1\":{\"429\":1}}],[\"引用了\",{\"1\":{\"419\":1}}],[\"引入的一个框架\",{\"1\":{\"345\":1}}],[\"引入的一个用于异步编程的工具类\",{\"1\":{\"337\":1}}],[\"引入了分段锁机制\",{\"1\":{\"245\":1}}],[\"引入了轻量级锁机制\",{\"1\":{\"153\":1}}],[\"引入了偏向锁的概念\",{\"1\":{\"153\":1}}],[\"引入了适应性自旋的机制\",{\"1\":{\"153\":1}}],[\"引入一个适配器类兼容现有目标类\",{\"1\":{\"27\":1}}],[\"普通方法\",{\"1\":{\"419\":1}}],[\"子类只能继承父类中的final方法\",{\"1\":{\"435\":1}}],[\"子类可以重写\",{\"1\":{\"424\":1}}],[\"子类可以选择性地重写或调用父类的普通方法\",{\"1\":{\"419\":1}}],[\"子类必须实现抽象类中的抽象方法\",{\"1\":{\"419\":1}}],[\"子类的方法名称和父类完全相同\",{\"1\":{\"418\":1}}],[\"子类通过重写父类的方法来修改或者扩展父类方法的行为\",{\"1\":{\"418\":1}}],[\"子线程会复制父线程的inheritablethreadlocalmap\",{\"1\":{\"288\":1}}],[\"子线程会继承父线程中的inheritablethreadlocal的值\",{\"1\":{\"288\":1}}],[\"顺序来区分调用了哪个方法\",{\"1\":{\"418\":1}}],[\"顺序相反\",{\"1\":{\"143\":1}}],[\"服务端打印如下\",{\"1\":{\"415\":1}}],[\"服务端代码\",{\"0\":{\"414\":1}}],[\"服务端使用serversocketchannel和selector\",{\"1\":{\"413\":1}}],[\"服务器端成功接收信息\",{\"1\":{\"414\":2,\"415\":3}}],[\"服务器端不关闭不停接收客户端的数据\",{\"1\":{\"413\":1}}],[\"服务器端编程能力\",{\"1\":{\"411\":1}}],[\"服务器端的通道之一\",{\"1\":{\"411\":1}}],[\"服务器ip\",{\"1\":{\"410\":1}}],[\"案列介绍\",{\"0\":{\"413\":1}}],[\"案例实战\",{\"0\":{\"36\":1,\"50\":1}}],[\"轮询到连接事件时便会触发内核中的\",{\"1\":{\"416\":1}}],[\"轮询和处理\",{\"1\":{\"414\":1}}],[\"轮询事件\",{\"1\":{\"412\":2}}],[\"轮询就绪事件\",{\"1\":{\"407\":1}}],[\"事件发生\",{\"1\":{\"412\":1}}],[\"事件\",{\"1\":{\"412\":2}}],[\"事务管理\",{\"1\":{\"283\":1}}],[\"管理注册的\",{\"1\":{\"412\":1}}],[\"绑定端口并设置非阻塞模式\",{\"1\":{\"411\":1}}],[\"绑定端口\",{\"1\":{\"411\":1}}],[\"配合选择器一起使用可以实现高效的多路复用\",{\"1\":{\"410\":1,\"411\":1}}],[\"配置\",{\"1\":{\"107\":1}}],[\"配置讲解\",{\"0\":{\"107\":1}}],[\"配置文件中包含了4个部分\",{\"1\":{\"106\":1}}],[\"配置和启动alertmanager\",{\"1\":{\"101\":1}}],[\"配置请求的p95耗时\",{\"1\":{\"100\":1}}],[\"配置的表达式如下\",{\"1\":{\"100\":2}}],[\"配置grafana视图\",{\"0\":{\"100\":1}}],[\"配置完成后\",{\"1\":{\"99\":1}}],[\"配置完成后保存\",{\"1\":{\"71\":1}}],[\"配置如下\",{\"1\":{\"99\":1}}],[\"配置prometheus采集\",{\"0\":{\"99\":1}}],[\"配置prometheus采集node\",{\"1\":{\"66\":1}}],[\"配置界面的路径和配置如下\",{\"1\":{\"71\":1}}],[\"配置信息如下\",{\"1\":{\"69\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"1\":1,\"2\":1}}],[\"连接事件会被交由多路复用器管理\",{\"1\":{\"416\":1}}],[\"连接远程服务器\",{\"1\":{\"410\":2}}],[\"连接\",{\"1\":{\"407\":1,\"412\":1}}],[\"连上了usb接口\",{\"1\":{\"26\":1}}],[\"准备继续写入数据\",{\"1\":{\"406\":1}}],[\"准备重新读取缓冲区中的数据\",{\"1\":{\"406\":1}}],[\"准备写入数据到缓冲区\",{\"1\":{\"406\":1}}],[\"准备读取缓冲区中的数据\",{\"1\":{\"406\":1}}],[\"向服务器端发送消息\",{\"1\":{\"415\":1}}],[\"向缓冲区写入数据\",{\"1\":{\"406\":1}}],[\"向量匹配符号\",{\"0\":{\"88\":1}}],[\"向量里面的标签是左侧和右侧共同匹配的标签\",{\"1\":{\"85\":1}}],[\"切换为写入模式\",{\"1\":{\"406\":1}}],[\"切换为读取模式\",{\"1\":{\"406\":3}}],[\"切换为读取模式逐个字节输出\",{\"1\":{\"405\":1}}],[\"切换缓冲区为写入模式\",{\"1\":{\"405\":1}}],[\"切换缓冲区为读取模式\",{\"1\":{\"405\":1}}],[\"逐个字节读取并输出\",{\"1\":{\"405\":1}}],[\"打包工具\",{\"1\":{\"433\":1}}],[\"打开\",{\"1\":{\"410\":2,\"411\":2,\"412\":2}}],[\"打开一个\",{\"1\":{\"405\":1}}],[\"打印当前线程的变量值\",{\"1\":{\"281\":1}}],[\"协议进行网络数据的读写操作\",{\"1\":{\"404\":1}}],[\"协议进行网络连接\",{\"1\":{\"404\":1}}],[\"特别是在面对大量连接的场景下\",{\"1\":{\"403\":1}}],[\"特点\",{\"1\":{\"218\":6,\"229\":1}}],[\"高效执行\",{\"1\":{\"433\":1}}],[\"高效的数据传输\",{\"1\":{\"404\":1}}],[\"高性能的网络服务器\",{\"1\":{\"403\":1,\"407\":1}}],[\"高度可定制性\",{\"1\":{\"188\":1}}],[\"选择器selecotor组件\",{\"1\":{\"408\":1}}],[\"选择器是\",{\"1\":{\"403\":1}}],[\"选择器\",{\"1\":{\"403\":1}}],[\"选择什么样的工具可以根据实际的场景来决定\",{\"1\":{\"343\":1}}],[\"像web服务器那样\",{\"1\":{\"403\":1}}],[\"何时使用转换流\",{\"1\":{\"401\":1}}],[\"到writer转换的桥梁\",{\"1\":{\"401\":1}}],[\"到下一个generation\",{\"1\":{\"347\":1}}],[\"极其类似\",{\"1\":{\"401\":1}}],[\"库中用于写入字符数据的抽象类\",{\"1\":{\"401\":1}}],[\"库中用于写入字节数据的抽象类\",{\"1\":{\"401\":1}}],[\"库中用于读取字符数据的抽象类\",{\"1\":{\"401\":1}}],[\"纯洁的decorator\",{\"1\":{\"401\":1}}],[\"纯洁\",{\"1\":{\"401\":1}}],[\"却让其更\",{\"1\":{\"401\":1}}],[\"部分\",{\"1\":{\"401\":1}}],[\"词法分析部分\",{\"1\":{\"401\":1}}],[\"好像更不入流了\",{\"1\":{\"401\":1}}],[\"看起来也是可以的\",{\"1\":{\"401\":1}}],[\"至于什么时候分行\",{\"1\":{\"401\":1}}],[\"至于具体线程等待队列的维护\",{\"1\":{\"164\":1}}],[\"紫色的虚线部分代表这些流一般要搭配使用\",{\"1\":{\"401\":1}}],[\"红色的部分就是不对应部分\",{\"1\":{\"401\":1}}],[\"红黑树\",{\"1\":{\"260\":1}}],[\"缓冲区buffer\",{\"1\":{\"408\":1}}],[\"缓冲区\",{\"1\":{\"403\":1}}],[\"缓冲输出流\",{\"1\":{\"401\":1}}],[\"缓冲输入流\",{\"1\":{\"401\":1}}],[\"缓冲流\",{\"1\":{\"399\":1}}],[\"缓存行是2的整数幂个连续字节\",{\"1\":{\"347\":1}}],[\"缓存系统中是以缓存行\",{\"1\":{\"347\":1}}],[\"缓存管理\",{\"1\":{\"283\":1}}],[\"缓存导致的可见性问题\",{\"0\":{\"119\":1}}],[\"缓存能够存储经常使用的数据与指令\",{\"1\":{\"118\":1}}],[\"字段以及构造方法\",{\"1\":{\"419\":1}}],[\"字符型\",{\"1\":{\"429\":1}}],[\"字符串文件路径\",{\"1\":{\"401\":1}}],[\"字符数组\",{\"1\":{\"401\":1}}],[\"字符到字节的桥梁\",{\"1\":{\"401\":1}}],[\"字符输出流writer\",{\"1\":{\"401\":1}}],[\"字符输入流reader\",{\"1\":{\"401\":1}}],[\"字符缓冲流\",{\"1\":{\"399\":2}}],[\"字符流和字节流之间相互转换\",{\"1\":{\"401\":1}}],[\"字符流与字节流转换\",{\"1\":{\"401\":1}}],[\"字符流的输入与输出的对应\",{\"1\":{\"401\":1}}],[\"字符流的由来\",{\"1\":{\"399\":1}}],[\"字符流以字符为单位\",{\"1\":{\"399\":1}}],[\"字符流\",{\"1\":{\"399\":2}}],[\"字节到字符的桥梁\",{\"1\":{\"401\":1}}],[\"字节缓冲流\",{\"1\":{\"399\":2}}],[\"字节流的输入与输出的对应\",{\"1\":{\"401\":1}}],[\"字节流能处理所有类型的数据\",{\"1\":{\"399\":1}}],[\"字节流以字节\",{\"1\":{\"399\":1}}],[\"字节流和字符流的区别\",{\"1\":{\"399\":1}}],[\"字节流\",{\"1\":{\"399\":2}}],[\"字节\",{\"1\":{\"392\":1}}],[\"网络通信能力\",{\"1\":{\"410\":1}}],[\"网络通信的通道之一\",{\"1\":{\"410\":1}}],[\"网络通信和对象序列化等功能\",{\"1\":{\"398\":1}}],[\"网络传输等操作的类和接口\",{\"1\":{\"398\":1}}],[\"网络适配器等\",{\"1\":{\"118\":1}}],[\"流操作的数据需要编码或解码时\",{\"1\":{\"401\":1}}],[\"流\",{\"1\":{\"398\":1}}],[\"流行的\",{\"1\":{\"71\":1}}],[\"剔除重复数字后的元素个数\",{\"1\":{\"395\":1}}],[\"质数\",{\"1\":{\"395\":1}}],[\"整型\",{\"1\":{\"429\":1}}],[\"整数0\",{\"1\":{\"392\":1}}],[\"整个代码的逻辑流程如下\",{\"1\":{\"203\":1}}],[\"休息日记为0\",{\"1\":{\"392\":1}}],[\"股票的的交易日记为1\",{\"1\":{\"392\":1}}],[\"唯一性的集合实现\",{\"1\":{\"389\":1}}],[\"传递给匿名内部类或lambda表达式作为捕捉的变量\",{\"1\":{\"436\":1}}],[\"传递一个集合参数的构造函数\",{\"1\":{\"385\":1}}],[\"传递性\",{\"1\":{\"136\":1,\"430\":1}}],[\"既保存了数组查询和修改元素效率快的优点\",{\"1\":{\"382\":1}}],[\"既可以在队尾进行入队操作\",{\"1\":{\"226\":1}}],[\"建议使用stringbuffer来保证线程安全\",{\"1\":{\"421\":1}}],[\"建议使用stringbuffer或stringbuilder\",{\"1\":{\"421\":1}}],[\"建议使用concurrenthashmap\",{\"1\":{\"379\":1}}],[\"建一个first\",{\"1\":{\"108\":1}}],[\"节点是否为红黑树节点\",{\"1\":{\"378\":1}}],[\"节点是否与传入的键匹配\",{\"1\":{\"378\":1}}],[\"节点与传入的键不匹配\",{\"1\":{\"378\":1}}],[\"节点\",{\"1\":{\"378\":1}}],[\"节点不为空\",{\"1\":{\"378\":1}}],[\"节点的数据为指定的元素\",{\"1\":{\"368\":1}}],[\"扩大一倍\",{\"1\":{\"377\":1}}],[\"扩容是在grow\",{\"1\":{\"361\":1}}],[\"扩容\",{\"0\":{\"361\":1,\"377\":1}}],[\"扩容下另一个表的索引\",{\"1\":{\"256\":1}}],[\"`value`\",{\"1\":{\"376\":1}}],[\"索引位置没有键值对\",{\"1\":{\"376\":1}}],[\"负载因子为0\",{\"1\":{\"375\":1}}],[\"负责管理线程的状态变迁\",{\"1\":{\"163\":1}}],[\"负责执行指令\",{\"1\":{\"118\":1}}],[\"负责创建一族相关的具体产品对象\",{\"1\":{\"46\":1}}],[\"负责创建实例对象的类\",{\"1\":{\"40\":1}}],[\"置为\",{\"1\":{\"370\":1}}],[\"三个实例变量\",{\"1\":{\"366\":2}}],[\"利用\",{\"1\":{\"364\":1}}],[\"利用低29位表示线程池中线程数\",{\"1\":{\"309\":1}}],[\"个字节\",{\"1\":{\"392\":1}}],[\"个字节就可以了\",{\"1\":{\"392\":1}}],[\"个数字\",{\"1\":{\"392\":2}}],[\"个位\",{\"1\":{\"391\":1,\"393\":1}}],[\"个\",{\"1\":{\"361\":1,\"392\":1}}],[\"个人生活文章\",{\"0\":{\"0\":1}}],[\"空数组\",{\"1\":{\"361\":1}}],[\"描述了一个类应该具备的行为\",{\"1\":{\"419\":1}}],[\"描述\",{\"1\":{\"360\":1}}],[\"带参构造函数接收初始容量\",{\"1\":{\"375\":1}}],[\"带有collection参数的构造函数\",{\"1\":{\"359\":1}}],[\"带初始化容量大小参数\",{\"1\":{\"359\":1}}],[\"带超时时间的get\",{\"1\":{\"326\":1}}],[\"序列化\",{\"1\":{\"357\":1,\"366\":1}}],[\"序列号\",{\"1\":{\"180\":1,\"183\":1}}],[\"按键查找值等\",{\"1\":{\"354\":1}}],[\"按照\",{\"1\":{\"347\":1}}],[\"按照线程在队列中的排队顺序\",{\"1\":{\"164\":1}}],[\"增强的\",{\"1\":{\"352\":1}}],[\"增加bincount的值\",{\"1\":{\"259\":1}}],[\"增加bincount的数量\",{\"1\":{\"259\":1}}],[\"增加重入次数\",{\"1\":{\"183\":1}}],[\"增加了语言的复杂性和理解上的困惑\",{\"1\":{\"420\":1}}],[\"增加了写入字符的效率\",{\"1\":{\"401\":1}}],[\"增加了线程的延迟和系统开销\",{\"1\":{\"152\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"44\":1}}],[\"增加1和写回a的新值这三个步骤\",{\"1\":{\"119\":1}}],[\"增加告警规则的配置\",{\"1\":{\"108\":1}}],[\"增加采集node\",{\"1\":{\"69\":1}}],[\"增加项目的依赖\",{\"1\":{\"57\":1}}],[\"增加新的观察者\",{\"1\":{\"51\":1}}],[\"增加新的产品和新的工厂非常容易\",{\"1\":{\"44\":1}}],[\"增加系统的复杂性\",{\"1\":{\"47\":1}}],[\"排序\",{\"1\":{\"352\":1}}],[\"排他锁\",{\"1\":{\"218\":1}}],[\"散列\",{\"1\":{\"351\":1}}],[\"队列\",{\"1\":{\"351\":1}}],[\"队列中的项\",{\"1\":{\"270\":1}}],[\"集\",{\"1\":{\"351\":1}}],[\"集合框架中用于存储单列数据\",{\"1\":{\"381\":1}}],[\"集合框架中用于存储双列数据的散列表\",{\"1\":{\"373\":1}}],[\"集合框架中比较常用的用于存储单列数据的容器\",{\"1\":{\"357\":1}}],[\"集合接口\",{\"1\":{\"351\":1}}],[\"集合是\",{\"1\":{\"351\":1}}],[\"列表操作\",{\"1\":{\"352\":1}}],[\"列表\",{\"1\":{\"351\":1}}],[\"列中删除该节点并抛出interruptedexception异常\",{\"1\":{\"331\":1}}],[\"合并结果\",{\"1\":{\"349\":1}}],[\"合理设置抑制规则可以减少垃圾告警的产生\",{\"1\":{\"106\":1}}],[\"伪共享状态\",{\"1\":{\"347\":1}}],[\"伪代码的2\",{\"1\":{\"19\":1,\"121\":1}}],[\"伪代码如下\",{\"1\":{\"19\":1,\"121\":1}}],[\"窃取的任务位于其他线程的工作队列的队首\",{\"1\":{\"347\":1}}],[\"位置表示下一个要读取或写入的元素索引\",{\"1\":{\"406\":1}}],[\"位置\",{\"1\":{\"406\":1}}],[\"位运算等操作\",{\"1\":{\"393\":1}}],[\"位运算操作\",{\"1\":{\"393\":1}}],[\"位长是一个byte整数的8倍\",{\"1\":{\"392\":1}}],[\"位\",{\"1\":{\"347\":1,\"392\":3}}],[\"注册到\",{\"1\":{\"412\":2}}],[\"注册到一个\",{\"1\":{\"412\":1}}],[\"注册通道\",{\"1\":{\"407\":1}}],[\"注解修饰防止伪共享\",{\"1\":{\"347\":1}}],[\"注意几点\",{\"1\":{\"419\":1}}],[\"注意\",{\"1\":{\"358\":1,\"401\":1}}],[\"注意的是\",{\"1\":{\"319\":1}}],[\"注意这里一段代码是keepalivetime起作用的关键\",{\"1\":{\"314\":1}}],[\"框架的类的思维导图如下\",{\"1\":{\"351\":1}}],[\"框架的根接口\",{\"1\":{\"351\":1}}],[\"框架的一些关键概念\",{\"1\":{\"351\":1}}],[\"框架的示例\",{\"1\":{\"349\":1}}],[\"框架的核心是\",{\"1\":{\"346\":1}}],[\"框架中的任务\",{\"1\":{\"346\":1}}],[\"框架中的主要组件包括\",{\"1\":{\"346\":1}}],[\"捕获异常\",{\"1\":{\"432\":1}}],[\"捕获和处理异常\",{\"1\":{\"343\":1}}],[\"捕获并外部化对象的内部状态\",{\"1\":{\"12\":1}}],[\"任何\",{\"1\":{\"358\":1}}],[\"任意一个completablefuture完成后执行回调函数\",{\"1\":{\"341\":1}}],[\"任务提供的适配器类\",{\"1\":{\"348\":1}}],[\"任务\",{\"1\":{\"346\":1}}],[\"任务发起线程可以调用get\",{\"1\":{\"330\":1}}],[\"任务发起线程可以查看任务执行状态\",{\"1\":{\"329\":1}}],[\"任务正常执行完毕\",{\"1\":{\"329\":1}}],[\"任务正常执行完成\",{\"1\":{\"328\":1}}],[\"任务异常\",{\"1\":{\"329\":1}}],[\"任务还没开始执行或者已经执行但是还没有执行完成的时候\",{\"1\":{\"328\":1}}],[\"任务还没开始执行或者已经开始执行但是还没有执行完成的时候\",{\"1\":{\"328\":1}}],[\"任务已经执行完成并且任务执行结果已经保存到outcome字段\",{\"1\":{\"328\":1}}],[\"任务已经执行完成或者执行任务的时候发生异常\",{\"1\":{\"328\":1}}],[\"任务已提交\",{\"1\":{\"323\":3,\"336\":1}}],[\"任务状态\",{\"1\":{\"328\":1}}],[\"任务被取消\",{\"1\":{\"330\":1}}],[\"任务被取消也属于任务已完成\",{\"1\":{\"326\":1}}],[\"任务被拒绝时的处理\",{\"1\":{\"303\":1}}],[\"任务执行异常\",{\"1\":{\"330\":1}}],[\"任务执行异常或者任务被取消\",{\"1\":{\"328\":1}}],[\"任务执行发生异常并且异常原因已经保存到outcome字段中后\",{\"1\":{\"328\":1}}],[\"任务执行过程中发生异常\",{\"1\":{\"326\":1}}],[\"任务执行出错\",{\"1\":{\"323\":3,\"336\":1,\"340\":1}}],[\"任务的关闭\",{\"0\":{\"319\":1}}],[\"任务的提交\",{\"0\":{\"315\":1}}],[\"任务的执行\",{\"0\":{\"310\":1}}],[\"任务只能一个一个地被提交给线程池进行执行\",{\"1\":{\"297\":1}}],[\"任务数量有上限\",{\"1\":{\"297\":1}}],[\"任务可以无限制地添加进队列中\",{\"1\":{\"297\":1}}],[\"演示了try\",{\"1\":{\"432\":1}}],[\"演示了如何在多个线程中使用threadlocal\",{\"1\":{\"281\":1}}],[\"演示了如何使用\",{\"1\":{\"146\":1}}],[\"演示如何使用\",{\"1\":{\"339\":1,\"353\":1}}],[\"回调函数\",{\"1\":{\"337\":1,\"343\":1}}],[\"回滚到入队操作前\",{\"1\":{\"311\":1}}],[\"串行\",{\"1\":{\"337\":1}}],[\"依次启动服务端程序和客户端程序\",{\"1\":{\"415\":1}}],[\"依次遍历waiters链表\",{\"1\":{\"333\":1}}],[\"依赖反转原则\",{\"1\":{\"14\":1}}],[\"差不多\",{\"1\":{\"329\":1}}],[\"各个客户端的数据已经提前拷贝到内存中\",{\"1\":{\"416\":1}}],[\"各个状态之间的可能转换关系如下图所示\",{\"1\":{\"328\":1}}],[\"各种reader一层套一层\",{\"1\":{\"29\":1}}],[\"异步任务线程配置\",{\"1\":{\"337\":1}}],[\"异步操作\",{\"1\":{\"337\":1,\"343\":1}}],[\"异步执行左边的子任务\",{\"1\":{\"349\":1}}],[\"异步执行任务\",{\"1\":{\"339\":1,\"340\":1}}],[\"异步执行\",{\"1\":{\"322\":1}}],[\"异常将被抛出\",{\"1\":{\"432\":1}}],[\"异常类层次结构\",{\"1\":{\"432\":1}}],[\"异常处理逻辑\",{\"1\":{\"437\":1}}],[\"异常处理语句\",{\"1\":{\"432\":1}}],[\"异常处理\",{\"1\":{\"337\":1,\"343\":1}}],[\"异常\",{\"1\":{\"242\":1,\"302\":1,\"322\":1,\"369\":1,\"370\":1}}],[\"检测权限\",{\"1\":{\"319\":1}}],[\"检查\",{\"1\":{\"354\":1,\"364\":2,\"387\":1}}],[\"检查集合中是否包含某个元素\",{\"1\":{\"353\":1}}],[\"检查列表中是否包含某个元素\",{\"1\":{\"352\":1}}],[\"检查是否可以关闭线程\",{\"1\":{\"319\":1}}],[\"检查线程池状态\",{\"1\":{\"313\":1}}],[\"检查元素不能为空\",{\"1\":{\"274\":1}}],[\"检查元素是否为空\",{\"1\":{\"271\":1}}],[\"检查并且更新结点状态\",{\"1\":{\"173\":1}}],[\"留给子类实现\",{\"1\":{\"319\":1}}],[\"倘若为ture\",{\"1\":{\"314\":1}}],[\"倘若线程池处于中断状态\",{\"1\":{\"313\":1}}],[\"倘若没有double\",{\"1\":{\"311\":1}}],[\"万一线程池处于非running状态\",{\"1\":{\"311\":1}}],[\"往线程池中创建新的线程失败\",{\"1\":{\"311\":1}}],[\"常使用try\",{\"1\":{\"432\":1}}],[\"常量\",{\"1\":{\"419\":1}}],[\"常用的工具类\",{\"1\":{\"401\":1}}],[\"常用的\",{\"1\":{\"354\":1}}],[\"常用使用方式\",{\"1\":{\"323\":1}}],[\"常驻worker的数量\",{\"1\":{\"308\":1}}],[\"常见的buffer覆盖了能通过io发送的基本数据类型\",{\"1\":{\"403\":1}}],[\"常见的应用是那些需要对海量数据进行一些统计工作的时候\",{\"1\":{\"394\":1}}],[\"常见的映射实现类有\",{\"1\":{\"351\":1}}],[\"常见的队列实现类有\",{\"1\":{\"351\":1}}],[\"常见的队列类型包括\",{\"1\":{\"297\":1}}],[\"常见的集实现类有\",{\"1\":{\"351\":1}}],[\"常见的集合接口包括\",{\"1\":{\"351\":1}}],[\"常见的列表实现类有\",{\"1\":{\"351\":1}}],[\"常见的逻辑运算符如下\",{\"1\":{\"85\":1}}],[\"历史达到的worker数最大值\",{\"1\":{\"308\":1}}],[\"几乎实现相近的功能\",{\"1\":{\"401\":1}}],[\"几个关键属性\",{\"0\":{\"308\":1}}],[\"几分钟\",{\"1\":{\"107\":1}}],[\"甚至oom\",{\"1\":{\"304\":2}}],[\"规避资源耗尽的风险\",{\"1\":{\"304\":1}}],[\"规则规定了以下几种情况\",{\"1\":{\"136\":1}}],[\"规则的关键在于确保并发操作的顺序性和可见性\",{\"1\":{\"136\":1}}],[\"规则\",{\"0\":{\"136\":1},\"1\":{\"136\":1}}],[\"丢弃队列中最旧的等待任务\",{\"1\":{\"302\":1}}],[\"拒绝执行该任务\",{\"1\":{\"302\":1}}],[\"抛出\",{\"1\":{\"302\":1}}],[\"抛出异常\",{\"1\":{\"168\":2,\"183\":1,\"198\":1,\"210\":1,\"213\":5,\"214\":1,\"235\":1,\"259\":1,\"265\":2,\"432\":1,\"438\":2}}],[\"较大数量的线程\",{\"1\":{\"300\":1}}],[\"介于0\",{\"1\":{\"295\":1}}],[\"核心模块\",{\"0\":{\"346\":1}}],[\"核心属性\",{\"0\":{\"328\":1}}],[\"核心线程数量的设置应该根据具体应用的需求来进行调整\",{\"1\":{\"295\":1}}],[\"核心线程会被立即创建并准备好接受任务\",{\"1\":{\"295\":1}}],[\"核心线程池的大小\",{\"1\":{\"294\":1}}],[\"核心实现类是threadpoolexecutor\",{\"1\":{\"292\":1}}],[\"核心函数分析\",{\"0\":{\"212\":1,\"236\":1,\"258\":1,\"272\":1}}],[\"超时处理\",{\"1\":{\"343\":1}}],[\"超时等待\",{\"1\":{\"322\":1}}],[\"超时时间\",{\"1\":{\"291\":1}}],[\"超出coresize的worker的生存时间\",{\"1\":{\"308\":1}}],[\"超过容量后会阻塞新任务的提交\",{\"1\":{\"297\":1}}],[\"超过了int的表示范围\",{\"1\":{\"185\":1}}],[\"控制台会输出以下内容\",{\"1\":{\"438\":3}}],[\"控制台打出的结果如下\",{\"1\":{\"31\":1}}],[\"控制多个任务的并发执行\",{\"1\":{\"343\":1}}],[\"控制线程的数量\",{\"1\":{\"291\":1}}],[\"频繁地创建和销毁线程会浪费大量的资源\",{\"1\":{\"291\":1}}],[\"降低系统性能\",{\"1\":{\"291\":1}}],[\"降低线程创建和销毁的开销\",{\"1\":{\"291\":1}}],[\"降低逻辑单元之间的耦合度\",{\"1\":{\"37\":1}}],[\"影响程序的整体性能\",{\"1\":{\"291\":1}}],[\"手册中要求\",{\"1\":{\"291\":1}}],[\"手写一个aqs\",{\"0\":{\"175\":1}}],[\"阿里巴巴java手册\",{\"1\":{\"291\":1}}],[\"仍然需要使用其他的线程同步机制\",{\"1\":{\"288\":1}}],[\"仍然是一个瓶颈\",{\"1\":{\"118\":1}}],[\"泄露原因分析\",{\"0\":{\"287\":1}}],[\"哪怕内存不足的时候\",{\"1\":{\"286\":1}}],[\"虚引用中唯一的作用就是用队列接收对象即将死亡的通知\",{\"1\":{\"286\":1}}],[\"虚引用是最弱的引用\",{\"1\":{\"286\":1}}],[\"虚引用\",{\"1\":{\"286\":2}}],[\"软引用指向的对象在内存要溢出的时候被回收\",{\"1\":{\"286\":1}}],[\"软引用\",{\"1\":{\"286\":2}}],[\"软件功能在不受影响时\",{\"1\":{\"14\":1}}],[\"弱引用生命周期比较短\",{\"1\":{\"287\":1}}],[\"弱引用\",{\"1\":{\"286\":2}}],[\"强引用\",{\"1\":{\"286\":2}}],[\"假设有一个抽象类\",{\"1\":{\"424\":1}}],[\"假设有一个很大的数组\",{\"1\":{\"349\":1}}],[\"假设有一个对账系统\",{\"1\":{\"191\":1}}],[\"假设我们要计算一个较大数组中所有元素的总和\",{\"1\":{\"349\":1}}],[\"假设当前state=new且waiters为null\",{\"1\":{\"331\":1}}],[\"假设threadlocal对象被定义为静态变量\",{\"1\":{\"285\":1}}],[\"清除位\",{\"1\":{\"393\":2}}],[\"清除当前线程的变量副本\",{\"1\":{\"281\":1}}],[\"清空缓冲区\",{\"1\":{\"405\":1,\"406\":1}}],[\"清空\",{\"1\":{\"354\":1}}],[\"清空集合\",{\"1\":{\"353\":1}}],[\"清空列表\",{\"1\":{\"352\":1}}],[\"清空任务队列\",{\"1\":{\"319\":1}}],[\"清空独占\",{\"1\":{\"183\":1}}],[\"放入后存元素的索引等于数组长度\",{\"1\":{\"273\":1}}],[\"放入队列\",{\"1\":{\"168\":1}}],[\"容器的size+1\",{\"1\":{\"360\":1}}],[\"容量\",{\"1\":{\"406\":1}}],[\"容量大小动态可以变化\",{\"1\":{\"357\":1}}],[\"容量和指定访问策略的\",{\"1\":{\"271\":2}}],[\"容量和默认访问策略的\",{\"1\":{\"271\":1}}],[\"容易陷入\",{\"1\":{\"92\":1}}],[\"固定\",{\"1\":{\"271\":3}}],[\"消耗大量的系统资源\",{\"1\":{\"291\":1}}],[\"消费者模式的功能\",{\"1\":{\"267\":1}}],[\"消费者模式中使用\",{\"1\":{\"267\":1}}],[\"消费者线程将会被阻塞\",{\"1\":{\"267\":1}}],[\"消费者线程从队列中取出数据并进行消费\",{\"1\":{\"267\":1}}],[\"消费者消费数据\",{\"1\":{\"267\":1}}],[\"消息发布者publisher接口\",{\"1\":{\"50\":1}}],[\"展示了如何在生产者\",{\"1\":{\"267\":1}}],[\"展示prometheus数据\",{\"1\":{\"71\":1}}],[\"延迟队列\",{\"1\":{\"266\":1}}],[\"延迟初始化\",{\"1\":{\"20\":1}}],[\"生产者和消费者可以在多线程环境下安全地进行数据传递\",{\"1\":{\"267\":1}}],[\"生产者线程将会被阻塞\",{\"1\":{\"267\":1}}],[\"生产者线程持续生产数据\",{\"1\":{\"267\":1}}],[\"生产者生产数据\",{\"1\":{\"267\":1}}],[\"生产者产生的数据会立即被消费者获取\",{\"1\":{\"266\":1}}],[\"生成可执行的java应用程序\",{\"1\":{\"433\":1}}],[\"生成sizectl所使用的bit位数\",{\"1\":{\"256\":1}}],[\"生成指定长度的新类型的数组\",{\"1\":{\"237\":1}}],[\"限制数量maxelements个\",{\"1\":{\"265\":1}}],[\"限时获取锁等\",{\"1\":{\"188\":1}}],[\"出队列\",{\"1\":{\"275\":1,\"276\":1}}],[\"出队\",{\"1\":{\"265\":1}}],[\"出队以及获取队首元素\",{\"1\":{\"265\":1}}],[\"出队一个元素\",{\"1\":{\"265\":2}}],[\"出队操作也会被阻塞\",{\"1\":{\"266\":1}}],[\"出队操作也会阻塞\",{\"1\":{\"226\":1}}],[\"出队操作也立即返回一个结果\",{\"1\":{\"226\":1}}],[\"插入失败则返回false\",{\"1\":{\"265\":1}}],[\"插入元素但不阻塞\",{\"1\":{\"264\":1}}],[\"插入元素\",{\"1\":{\"247\":1,\"264\":1}}],[\"根节点不为空并且存在与指定hash和key相等的结点\",{\"1\":{\"261\":1}}],[\"根据对象的每个属性计算一个哈希码\",{\"1\":{\"431\":1}}],[\"根据就绪的事件类型执行相应的处理逻辑\",{\"1\":{\"407\":1}}],[\"根据码表映射字符\",{\"1\":{\"399\":1}}],[\"根据\",{\"1\":{\"378\":1,\"412\":1}}],[\"根据键的值与链表或红黑树的键进行比较\",{\"1\":{\"376\":2,\"378\":1}}],[\"根据传入的\",{\"1\":{\"376\":1,\"378\":1}}],[\"根据传入参数的不同\",{\"1\":{\"39\":1}}],[\"根据索引获取对应的节点\",{\"1\":{\"369\":1,\"370\":1}}],[\"根据前面的分析\",{\"1\":{\"333\":1}}],[\"根据需求配置线程池的参数\",{\"1\":{\"303\":1}}],[\"根据具体的关闭策略可能会被丢弃或者等待执行完成\",{\"1\":{\"293\":1}}],[\"根据具体需求来决定如何利用这个状态来控制并发访问\",{\"1\":{\"163\":1}}],[\"根据key的hash值取出table表中的结点元素\",{\"1\":{\"259\":1}}],[\"根据object数组复制一个长度为length+1的object数组为newelements\",{\"1\":{\"238\":1}}],[\"根据以上维度的组合\",{\"1\":{\"226\":1}}],[\"根据创建readwritelock时的参数\",{\"1\":{\"220\":1}}],[\"根据java语言规定\",{\"1\":{\"194\":1,\"206\":1}}],[\"根据aqs的源码\",{\"1\":{\"175\":1}}],[\"根据结果决定是否等待或执行打印操作\",{\"1\":{\"160\":1}}],[\"根据数据一致性的协议\",{\"1\":{\"130\":1}}],[\"根据实际情况\",{\"1\":{\"107\":1}}],[\"根据实际的情况做设计和优化\",{\"1\":{\"37\":1}}],[\"根据标签匹配\",{\"1\":{\"106\":1}}],[\"根据客户端传入的参数来创建相应的产品对象sofa\",{\"1\":{\"41\":1}}],[\"根据借款金额的不同\",{\"1\":{\"36\":1}}],[\"跳出循环\",{\"1\":{\"261\":1}}],[\"查找指定位置元素的时间复杂度为o\",{\"1\":{\"363\":1}}],[\"查找匹配的元素\",{\"1\":{\"362\":1}}],[\"查找元素\",{\"0\":{\"363\":1,\"387\":1},\"1\":{\"260\":1}}],[\"查看源码\",{\"1\":{\"294\":1}}],[\"查询元素\",{\"1\":{\"247\":1}}],[\"查询派单\",{\"1\":{\"191\":5,\"203\":2}}],[\"查询订单\",{\"1\":{\"191\":5,\"203\":2}}],[\"查询的是昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"83\":1}}],[\"查询的是当前时间的过去五分钟的数据\",{\"1\":{\"83\":1}}],[\"查询五分钟前的最新值\",{\"1\":{\"83\":1}}],[\"查询当前时间的最新值\",{\"1\":{\"83\":1}}],[\"查询语句为\",{\"1\":{\"81\":1}}],[\"链表转treenode\",{\"1\":{\"376\":2}}],[\"链表中的每个节点\",{\"1\":{\"366\":1}}],[\"链表\",{\"1\":{\"260\":1}}],[\"尾节点赋值为p\",{\"1\":{\"259\":1}}],[\"尾节点的next域赋值为p\",{\"1\":{\"259\":1}}],[\"尾结点为空\",{\"1\":{\"173\":2,\"214\":1}}],[\"尾结点不为空\",{\"1\":{\"173\":2,\"214\":1}}],[\"尾结点tail\",{\"1\":{\"170\":1}}],[\"尾结点\",{\"1\":{\"170\":1}}],[\"桶中的第一个结点没有发生变化\",{\"1\":{\"261\":1}}],[\"桶中的结点的hash值与key值与给定的hash值和key值相等\",{\"1\":{\"259\":1}}],[\"桶中第一个结点的hash值为moved\",{\"1\":{\"261\":1}}],[\"桶中存在结点并且结点的hash值大于等于0\",{\"1\":{\"259\":1}}],[\"调试器\",{\"1\":{\"433\":1}}],[\"调整某个桶中结点数量过多的问题\",{\"1\":{\"259\":1}}],[\"调用元素的\",{\"1\":{\"363\":1}}],[\"调用线程会调用awaitdone\",{\"1\":{\"331\":1}}],[\"调用report\",{\"1\":{\"330\":1}}],[\"调用remove方法溢出threadlocal中的变量\",{\"1\":{\"287\":1}}],[\"调用finishcompletion\",{\"1\":{\"329\":2,\"332\":1}}],[\"调用interrupt\",{\"1\":{\"328\":1}}],[\"调用dequeue函数\",{\"1\":{\"276\":1}}],[\"调用dequeue\",{\"1\":{\"276\":1}}],[\"调用两个参数的构造函数\",{\"1\":{\"271\":2}}],[\"调用含有两个参数的构造函数\",{\"1\":{\"211\":1}}],[\"调用\",{\"1\":{\"186\":2,\"191\":1,\"376\":1,\"410\":2,\"411\":1,\"414\":1}}],[\"调用方通过该方法等待结果\",{\"1\":{\"186\":1}}],[\"调用方法流程如下\",{\"1\":{\"173\":1}}],[\"调用shouldparkafterfailedacquire和parkandcheckinterrupt函数\",{\"1\":{\"173\":1}}],[\"调用start\",{\"1\":{\"155\":1}}],[\"调用acquirequeued函数\",{\"1\":{\"173\":1}}],[\"调用此方法的线程会试图在独占模式下获取对象状态\",{\"1\":{\"173\":1}}],[\"调用lock\",{\"1\":{\"160\":1}}],[\"调用指令将会检查方法的\",{\"1\":{\"147\":1}}],[\"⑥\",{\"1\":{\"259\":1}}],[\"旧值不为空\",{\"1\":{\"259\":1}}],[\"旧值等于element\",{\"1\":{\"240\":1}}],[\"赋值为newsize\",{\"1\":{\"362\":1}}],[\"赋值为null\",{\"1\":{\"277\":1}}],[\"赋值给前线程的inheritablethreadlocals\",{\"1\":{\"288\":1}}],[\"赋值给table\",{\"1\":{\"259\":1}}],[\"赋值结点value值\",{\"1\":{\"259\":1}}],[\"赋值pred结点的next域\",{\"1\":{\"173\":1}}],[\"退出循环\",{\"1\":{\"259\":1}}],[\"键的唯一性\",{\"1\":{\"354\":1}}],[\"键的hash值经过计算获得hash值\",{\"1\":{\"259\":1}}],[\"键是唯一的\",{\"1\":{\"354\":1}}],[\"键相等\",{\"1\":{\"260\":1}}],[\"键或值为空\",{\"1\":{\"259\":1}}],[\"键值对数量\",{\"1\":{\"354\":1}}],[\"键值对视图\",{\"1\":{\"253\":1}}],[\"键值对的划分\",{\"1\":{\"252\":1}}],[\"视图\",{\"1\":{\"256\":1}}],[\"旋转锁\",{\"1\":{\"256\":1}}],[\"装载因子\",{\"1\":{\"256\":1}}],[\"装饰模式不改变原有类的结构\",{\"1\":{\"30\":1}}],[\"装饰器非常的灵活\",{\"1\":{\"30\":1}}],[\"装饰器componentdecoratorb和componentdecoratora\",{\"1\":{\"30\":1}}],[\"装饰器模式的主角\",{\"1\":{\"401\":1}}],[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能\",{\"1\":{\"11\":1,\"29\":1}}],[\"装饰器模式经常使用到以下场景\",{\"1\":{\"30\":1}}],[\"装饰器模式\",{\"0\":{\"29\":1},\"1\":{\"11\":1,\"13\":1}}],[\"四个子类具体的代码在之后的具体例子中进行分析讲解\",{\"1\":{\"251\":1}}],[\"第2天是休息日\",{\"1\":{\"392\":1}}],[\"第2种方式\",{\"1\":{\"323\":1}}],[\"第三轮for循环\",{\"1\":{\"331\":1}}],[\"第二个构造函数可以穿入一个collection接口的实现类对象\",{\"1\":{\"367\":1}}],[\"第二个图是在jdk1\",{\"1\":{\"250\":1}}],[\"第二轮循环结束\",{\"1\":{\"331\":1}}],[\"第二轮for循环\",{\"1\":{\"331\":1}}],[\"第一轮循环结束\",{\"1\":{\"331\":1}}],[\"第一轮for循环\",{\"1\":{\"331\":1}}],[\"第一个完成的任务结果为\",{\"1\":{\"341\":1}}],[\"第一个结点没有变化\",{\"1\":{\"259\":1}}],[\"第一个线程获取到锁之后\",{\"1\":{\"175\":1}}],[\"第3种方式\",{\"1\":{\"323\":1}}],[\"第1种方式\",{\"1\":{\"323\":1}}],[\"删除文件和目录等方法\",{\"1\":{\"401\":1}}],[\"删除指定位置的元素等等\",{\"1\":{\"371\":1}}],[\"删除某个键值对\",{\"1\":{\"354\":1}}],[\"删除键值对\",{\"1\":{\"354\":1}}],[\"删除列表中的元素\",{\"1\":{\"352\":1}}],[\"删除操作\",{\"1\":{\"351\":1}}],[\"删除\",{\"1\":{\"351\":1,\"352\":1,\"421\":1}}],[\"删除和查找等操作时\",{\"1\":{\"246\":1}}],[\"删除元素\",{\"0\":{\"362\":1,\"388\":1},\"1\":{\"223\":1,\"229\":1,\"247\":1,\"352\":1,\"353\":1}}],[\"移动个数不为0\",{\"1\":{\"241\":1}}],[\"移动个数为0\",{\"1\":{\"241\":1}}],[\"移除p结点\",{\"1\":{\"261\":1}}],[\"移除或者更改\",{\"1\":{\"235\":1}}],[\"移除元素\",{\"1\":{\"230\":1}}],[\"⑤\",{\"1\":{\"239\":1,\"259\":1}}],[\"遍历位集合\",{\"1\":{\"393\":1}}],[\"遍历链表或红黑树的过程中\",{\"1\":{\"376\":1,\"378\":1}}],[\"遍历链表\",{\"1\":{\"376\":1}}],[\"遍历和删元素对象\",{\"1\":{\"354\":1}}],[\"遍历和删除集合中的元素\",{\"1\":{\"353\":1}}],[\"遍历列表中的元素\",{\"1\":{\"352\":1}}],[\"遍历列表\",{\"1\":{\"352\":1}}],[\"遍历等\",{\"1\":{\"351\":1}}],[\"遍历所有worker\",{\"1\":{\"319\":1}}],[\"遍历所有的worker\",{\"1\":{\"319\":1}}],[\"遍历集合中的元素\",{\"1\":{\"353\":1}}],[\"遍历集合\",{\"1\":{\"271\":1}}],[\"遍历桶中所有结点\",{\"1\":{\"259\":1}}],[\"遍历元素\",{\"1\":{\"247\":1}}],[\"遍历\",{\"1\":{\"239\":1,\"354\":1,\"377\":1}}],[\"元素的顺序可以根据插入和删除操作的顺序动态改变\",{\"1\":{\"352\":1}}],[\"元素的列表\",{\"1\":{\"234\":1}}],[\"元素个数为0\",{\"1\":{\"277\":1}}],[\"元素个数大于0\",{\"1\":{\"277\":1}}],[\"元素个数减1\",{\"1\":{\"275\":1}}],[\"元素个数等于数组长度\",{\"1\":{\"274\":1}}],[\"元素数量为0\",{\"1\":{\"275\":1}}],[\"元素数量加1\",{\"1\":{\"273\":1}}],[\"元素数量\",{\"1\":{\"271\":1}}],[\"元素数组\",{\"1\":{\"238\":1}}],[\"元素需要等待指定延迟时间后才能出队\",{\"1\":{\"266\":1}}],[\"元素按优先级顺序出队\",{\"1\":{\"266\":1}}],[\"复制\",{\"1\":{\"357\":1}}],[\"复制elements数组\",{\"1\":{\"241\":1}}],[\"复制index索引之后的元素\",{\"1\":{\"241\":1}}],[\"复制index索引之前的元素\",{\"1\":{\"241\":1}}],[\"复制后设置数组\",{\"1\":{\"241\":1}}],[\"复制当前数组current为newelements\",{\"1\":{\"239\":1}}],[\"复制数组\",{\"1\":{\"238\":1,\"239\":1,\"240\":1}}],[\"复制到copy数组中\",{\"1\":{\"237\":1}}],[\"复制长度为length\",{\"1\":{\"241\":1}}],[\"复制长度为\",{\"1\":{\"237\":1}}],[\"游标\",{\"1\":{\"235\":1}}],[\"快速查找\",{\"1\":{\"353\":1,\"354\":1}}],[\"快速的装载和卸载装饰器\",{\"1\":{\"32\":1}}],[\"快照不等于当前数组\",{\"1\":{\"239\":1}}],[\"快照\",{\"1\":{\"235\":1}}],[\"迭代器在每次访问元素之前会检查\",{\"1\":{\"364\":1}}],[\"迭代器源码解析\",{\"0\":{\"364\":1}}],[\"迭代器的遍历顺序添加元素\",{\"1\":{\"271\":1}}],[\"迭代器\",{\"1\":{\"270\":1}}],[\"迭代器就不会反映列表的添加\",{\"1\":{\"235\":1}}],[\"迭代器模式\",{\"1\":{\"12\":1}}],[\"迭代元素\",{\"1\":{\"230\":1}}],[\"熟悉并理解每种容器的使用方法也很重要\",{\"1\":{\"227\":1}}],[\"熟练使用23种设计模式是高阶程序员必须掌握的技能\",{\"1\":{\"13\":1}}],[\"了解并掌握java并发容器的特性很重要\",{\"1\":{\"227\":1}}],[\"融合了linkedblockingqueue和synchronousqueue的功能\",{\"1\":{\"226\":1}}],[\"双端非阻塞队列\",{\"1\":{\"226\":1}}],[\"双端阻塞队列\",{\"1\":{\"226\":1}}],[\"双端\",{\"1\":{\"226\":1}}],[\"双重检查的单例模式\",{\"1\":{\"121\":1}}],[\"双重检查模式\",{\"1\":{\"19\":1}}],[\"双重检查\",{\"0\":{\"19\":1}}],[\"入队\",{\"1\":{\"265\":1}}],[\"入队一个元素\",{\"1\":{\"265\":4}}],[\"入队操作必须等待相应的出队操作\",{\"1\":{\"226\":1}}],[\"入队操作立即返回一个结果\",{\"1\":{\"226\":1}}],[\"入队操作会阻塞\",{\"1\":{\"226\":1}}],[\"入队列\",{\"1\":{\"173\":1,\"273\":1}}],[\"修饰变量\",{\"1\":{\"435\":1,\"437\":1}}],[\"修饰方法\",{\"1\":{\"435\":1,\"437\":1}}],[\"修饰类\",{\"1\":{\"435\":1,\"437\":1}}],[\"修饰的方法或代码块前后自动加上加锁\",{\"1\":{\"147\":1}}],[\"修饰的方法或代码块\",{\"1\":{\"145\":1}}],[\"修改为当前的\",{\"1\":{\"364\":1}}],[\"修改某个键对应的值\",{\"1\":{\"354\":1}}],[\"修改列表中的元素\",{\"1\":{\"352\":1}}],[\"修改任务状态为interrupted\",{\"1\":{\"332\":1}}],[\"修改状态为interrupted\",{\"1\":{\"332\":1}}],[\"修改元素\",{\"1\":{\"230\":1,\"352\":1}}],[\"修改\",{\"1\":{\"223\":1,\"229\":1}}],[\"成为常量\",{\"1\":{\"437\":1}}],[\"成为最终方法\",{\"1\":{\"437\":1}}],[\"成为最终类\",{\"1\":{\"437\":1}}],[\"成员变量\",{\"1\":{\"223\":1,\"229\":1,\"385\":1,\"435\":1}}],[\"成功从阻塞队列中删除任务\",{\"1\":{\"311\":1}}],[\"成功\",{\"1\":{\"183\":2}}],[\"乐观读并不会阻塞其他线程获取写锁\",{\"1\":{\"221\":1}}],[\"乐观读是一种特殊的读模式\",{\"1\":{\"221\":1}}],[\"乐观读模式\",{\"1\":{\"221\":1}}],[\"悲观读锁和写锁\",{\"1\":{\"218\":1}}],[\"综合上面的分析可知\",{\"1\":{\"214\":1}}],[\"综上所述\",{\"1\":{\"51\":1,\"371\":1}}],[\"损坏屏障\",{\"1\":{\"213\":1}}],[\"损坏当前屏障\",{\"1\":{\"213\":3}}],[\"屏障被损坏\",{\"1\":{\"213\":1}}],[\"屏障被破坏\",{\"1\":{\"213\":1}}],[\"动作不为空\",{\"1\":{\"213\":1}}],[\"动态绑定\",{\"1\":{\"424\":1}}],[\"动态代理只能对接口进行代理\",{\"1\":{\"56\":1}}],[\"动态代理可以在运行时动态生成代理类\",{\"1\":{\"56\":1}}],[\"动态代理可以使用\",{\"1\":{\"55\":1}}],[\"动态代理的步骤是先实现invocationhandler接口\",{\"1\":{\"56\":1}}],[\"动态代理的优点是避免了手动创建代理类的麻烦\",{\"1\":{\"56\":1}}],[\"动态代理是使用java的反射机制来实现动态代理\",{\"1\":{\"56\":1}}],[\"动态代理是在运行时自动生成代理类并将方法调用转发到实际对象\",{\"1\":{\"56\":1}}],[\"动态代理机制和cglib动态代理\",{\"1\":{\"55\":1}}],[\"动态代理\",{\"0\":{\"55\":1,\"56\":1}}],[\"动态地实例化具体的产品类\",{\"1\":{\"41\":1}}],[\"归根到底\",{\"1\":{\"208\":1}}],[\"条件判断\",{\"1\":{\"259\":1}}],[\"条件队列\",{\"1\":{\"208\":1}}],[\"条件变量支持\",{\"1\":{\"188\":1}}],[\"派单查询和对账操作\",{\"1\":{\"203\":1}}],[\"示例代码如下\",{\"1\":{\"203\":1,\"219\":1,\"220\":1,\"221\":1,\"247\":1,\"341\":1,\"342\":1,\"410\":1,\"411\":1,\"412\":1,\"414\":1,\"415\":1,\"435\":1}}],[\"图给出了可能会调用到的主要方法\",{\"1\":{\"199\":1}}],[\"图中蓝色的为主要的对应部分\",{\"1\":{\"401\":1}}],[\"图中\",{\"1\":{\"25\":1,\"53\":1}}],[\"继续循环\",{\"1\":{\"198\":1,\"199\":1}}],[\"继续\",{\"1\":{\"198\":1,\"199\":1}}],[\"继承它并实现\",{\"1\":{\"346\":2}}],[\"继承了aqs类\",{\"1\":{\"313\":1}}],[\"继承了aproval\",{\"1\":{\"36\":1}}],[\"继承自abstractqueuedsynchronizer\",{\"1\":{\"197\":1}}],[\"添加失败\",{\"1\":{\"386\":1}}],[\"添加和删除操作的时间复杂度为\",{\"1\":{\"382\":1}}],[\"添加键值对到\",{\"1\":{\"354\":1}}],[\"添加\",{\"1\":{\"353\":1}}],[\"添加操作会失败并返回\",{\"1\":{\"353\":1}}],[\"添加重复元素时\",{\"1\":{\"353\":1}}],[\"添加回调函数\",{\"1\":{\"343\":1}}],[\"添加进数组\",{\"1\":{\"274\":1}}],[\"添加了unsafe实例\",{\"1\":{\"256\":1}}],[\"添加元素的源码如下\",{\"1\":{\"360\":1}}],[\"添加元素到集合中\",{\"1\":{\"353\":1}}],[\"添加元素到列表中\",{\"1\":{\"352\":1}}],[\"添加元素\",{\"0\":{\"360\":1,\"386\":1},\"1\":{\"230\":1,\"352\":1,\"360\":1}}],[\"添加节点至等待队列\",{\"1\":{\"198\":1}}],[\"添加等待者\",{\"1\":{\"173\":1}}],[\"转换流的特点\",{\"1\":{\"401\":1}}],[\"转换等计算\",{\"1\":{\"80\":1}}],[\"转变为reader\",{\"1\":{\"401\":1}}],[\"转化为\",{\"1\":{\"348\":1}}],[\"转化为红黑树的表的最小容量\",{\"1\":{\"256\":1}}],[\"转化为红黑树的阈值\",{\"1\":{\"256\":1}}],[\"转移\",{\"1\":{\"261\":1}}],[\"转发到sync对象上\",{\"1\":{\"198\":1}}],[\"构造方法\",{\"1\":{\"419\":1}}],[\"构造器创建一个\",{\"1\":{\"323\":1}}],[\"构造器\",{\"1\":{\"197\":1}}],[\"构造函数\",{\"0\":{\"367\":1,\"375\":1,\"385\":1},\"1\":{\"166\":1,\"168\":2,\"235\":1}}],[\"型构造函数\",{\"0\":{\"210\":1,\"211\":1},\"1\":{\"196\":1,\"234\":3,\"257\":1,\"271\":3}}],[\"读\",{\"1\":{\"357\":1,\"373\":1,\"381\":1,\"391\":1}}],[\"读多写少\",{\"1\":{\"229\":1}}],[\"读取数据\",{\"1\":{\"410\":1,\"411\":1}}],[\"读取效率较高\",{\"1\":{\"229\":1}}],[\"读取prometheus的指标时序\",{\"1\":{\"72\":1}}],[\"读操作\",{\"1\":{\"223\":1}}],[\"读线程会被阻塞\",{\"1\":{\"221\":1}}],[\"读模式是共享的\",{\"1\":{\"221\":1}}],[\"读模式\",{\"1\":{\"221\":1}}],[\"读写数据\",{\"1\":{\"410\":1,\"411\":1}}],[\"读写模式切换\",{\"1\":{\"406\":1}}],[\"读写单位不同\",{\"1\":{\"399\":1}}],[\"读写分离\",{\"1\":{\"220\":1}}],[\"读写锁\",{\"1\":{\"218\":1}}],[\"读锁不会阻塞读线程\",{\"1\":{\"221\":1}}],[\"读锁和写锁是互斥的\",{\"1\":{\"220\":1}}],[\"读锁和写锁都是可重入的\",{\"1\":{\"220\":1}}],[\"读锁共享\",{\"1\":{\"220\":1}}],[\"读者可以参考之前介绍的aqs\",{\"1\":{\"193\":1}}],[\"知道到0\",{\"1\":{\"191\":1}}],[\"循环或\",{\"1\":{\"352\":1}}],[\"循环\",{\"1\":{\"214\":1}}],[\"循环使用\",{\"1\":{\"202\":1}}],[\"循环里面每次都会创建新的线程\",{\"1\":{\"191\":1}}],[\"循环等待条件\",{\"1\":{\"140\":1}}],[\"订单量和派送单量巨大\",{\"1\":{\"191\":1}}],[\"公平性选择\",{\"1\":{\"220\":1}}],[\"公平性控制\",{\"1\":{\"188\":1}}],[\"公平锁\",{\"1\":{\"164\":1}}],[\"跟踪lock方法的源码可知\",{\"1\":{\"185\":1}}],[\"尝试中断worker\",{\"1\":{\"319\":1}}],[\"尝试公平获取锁\",{\"1\":{\"185\":1}}],[\"尝试进行加锁的算法\",{\"1\":{\"175\":1}}],[\"把元素存储在hashmap对象中\",{\"1\":{\"376\":1}}],[\"把任务状态从new转化到interrupting\",{\"1\":{\"332\":2}}],[\"把任务执行结果保存在outcome字段中\",{\"1\":{\"329\":1}}],[\"把异常原因保存在outcome字段中\",{\"1\":{\"329\":1}}],[\"把提交的任务成功放入阻塞队列中\",{\"1\":{\"311\":1}}],[\"把woker实例插入到hashset后\",{\"1\":{\"310\":1}}],[\"把当前线程设置独占了锁\",{\"1\":{\"184\":1}}],[\"把死锁转账的例子进行改造\",{\"1\":{\"142\":1}}],[\"获得当前目录中的文件列表\",{\"1\":{\"401\":1}}],[\"获得\",{\"1\":{\"295\":1}}],[\"获得锁\",{\"1\":{\"184\":1}}],[\"获取文件对应的\",{\"1\":{\"405\":1}}],[\"获取位值\",{\"1\":{\"393\":2}}],[\"获取指定位置的元素\",{\"1\":{\"371\":1}}],[\"获取下一个元素并返回\",{\"1\":{\"364\":1}}],[\"获取键对应的值\",{\"1\":{\"354\":1}}],[\"获取键值对数量\",{\"1\":{\"354\":1}}],[\"获取\",{\"1\":{\"353\":1,\"354\":2}}],[\"获取集合的大小\",{\"1\":{\"353\":1}}],[\"获取集合大小等\",{\"1\":{\"353\":1}}],[\"获取列表的大小\",{\"1\":{\"352\":1}}],[\"获取元素\",{\"0\":{\"378\":1},\"1\":{\"352\":1}}],[\"获取元素索引\",{\"1\":{\"270\":1}}],[\"获取和操作列表中的元素\",{\"1\":{\"352\":1}}],[\"获取左边子任务的结果\",{\"1\":{\"349\":1}}],[\"获取执行结果\",{\"1\":{\"331\":1}}],[\"获取任务当前状态\",{\"1\":{\"331\":1}}],[\"获取任务结果但是任务还没执行完成的时候\",{\"1\":{\"331\":1}}],[\"获取任务执行结果\",{\"1\":{\"326\":1,\"329\":1}}],[\"获取任务的执行结果\",{\"1\":{\"323\":1}}],[\"获取全局锁\",{\"1\":{\"312\":1}}],[\"获取不到threadlocal\",{\"1\":{\"288\":1}}],[\"获取可重入锁\",{\"1\":{\"273\":1}}],[\"获取可用的cpu个数\",{\"1\":{\"256\":1}}],[\"获取队首元素\",{\"1\":{\"265\":1}}],[\"获取并移除队首元素但不阻塞\",{\"1\":{\"264\":1}}],[\"获取并移除队首元素\",{\"1\":{\"264\":1}}],[\"获取索引的值elements\",{\"1\":{\"241\":1}}],[\"获取旧值\",{\"1\":{\"241\":1}}],[\"获取index索引的元素\",{\"1\":{\"240\":1}}],[\"获取长度\",{\"1\":{\"239\":1}}],[\"获取数组elements\",{\"1\":{\"241\":1}}],[\"获取数组\",{\"1\":{\"239\":1,\"240\":1,\"241\":1,\"273\":1}}],[\"获取object数组的长度为length\",{\"1\":{\"238\":1}}],[\"获取当前文件的路径名\",{\"1\":{\"401\":1}}],[\"获取当前状态\",{\"1\":{\"331\":1}}],[\"获取当前数组为current\",{\"1\":{\"239\":1}}],[\"获取当前的object数组\",{\"1\":{\"238\":1}}],[\"获取当前线程的变量副本\",{\"1\":{\"281\":1}}],[\"获取当前线程\",{\"1\":{\"185\":1}}],[\"获取c集合的数组\",{\"1\":{\"234\":1}}],[\"获取first结点的nextwaiter域结点\",{\"1\":{\"214\":1}}],[\"获取节点的后继\",{\"1\":{\"198\":1}}],[\"获取头结点的等待状态\",{\"1\":{\"198\":1,\"199\":1}}],[\"获取头结点\",{\"1\":{\"198\":1}}],[\"获取状态\",{\"1\":{\"183\":1,\"185\":1,\"197\":1,\"199\":1}}],[\"获取锁后通过调用\",{\"1\":{\"186\":1}}],[\"获取锁后\",{\"1\":{\"186\":1}}],[\"获取锁\",{\"1\":{\"183\":1,\"186\":2,\"238\":2,\"239\":2,\"240\":1,\"241\":2,\"274\":1,\"276\":1,\"277\":1}}],[\"获取unsafe对象\",{\"1\":{\"175\":1}}],[\"获取成功\",{\"1\":{\"198\":1}}],[\"获取成功跳出循环\",{\"1\":{\"175\":1}}],[\"获取成功之后才能执行方法体\",{\"1\":{\"147\":1}}],[\"获取到当前state初始值\",{\"1\":{\"175\":1}}],[\"获取node的前驱节点\",{\"1\":{\"198\":1}}],[\"获取node节点的下一个结点\",{\"1\":{\"173\":1}}],[\"获取node节点的前驱结点\",{\"1\":{\"173\":1}}],[\"获取node结点的等待状态\",{\"1\":{\"173\":1}}],[\"获取pred结点的下一个结点\",{\"1\":{\"173\":1}}],[\"获取前驱结点的状态\",{\"1\":{\"173\":1}}],[\"获取前驱结点\",{\"1\":{\"168\":1}}],[\"获取独占线程\",{\"1\":{\"166\":1}}],[\"获取了锁\",{\"1\":{\"158\":1}}],[\"获取了prometheus\",{\"1\":{\"81\":1}}],[\"获取通过热加载的方式重新加载配置文件\",{\"1\":{\"107\":1}}],[\"获取最近五分钟的样本\",{\"1\":{\"92\":1}}],[\"获取请求次数最多的5个请求\",{\"1\":{\"90\":1}}],[\"获取昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"83\":1}}],[\"试图设置状态来反映共享模式下的一个释放\",{\"1\":{\"197\":1}}],[\"试图在共享模式下获取对象状态\",{\"1\":{\"183\":1,\"197\":1,\"198\":1}}],[\"试图获取account对象的锁\",{\"1\":{\"139\":1}}],[\"失败\",{\"1\":{\"183\":1}}],[\"失败后\",{\"1\":{\"173\":1}}],[\"浪费时间\",{\"1\":{\"175\":1}}],[\"底层数据结构\",{\"0\":{\"382\":1}}],[\"底层还是由aqs提供支持\",{\"1\":{\"208\":1}}],[\"底层是使用cas算法保证线程安全的\",{\"1\":{\"175\":1}}],[\"底层实际上可能会被拆分成多条指令\",{\"1\":{\"120\":1}}],[\"④\",{\"1\":{\"173\":1,\"239\":1,\"259\":1}}],[\"③\",{\"1\":{\"173\":1,\"234\":1,\"238\":1,\"239\":1,\"241\":1,\"259\":1}}],[\"②\",{\"1\":{\"173\":1,\"234\":1,\"238\":1,\"239\":1,\"241\":1,\"259\":1}}],[\"判断指定文件是否存在\",{\"1\":{\"401\":1}}],[\"判断元素是否存在\",{\"1\":{\"353\":1}}],[\"判断元素是否已满\",{\"1\":{\"273\":1}}],[\"判断需要中断任务执行线程\",{\"1\":{\"332\":1}}],[\"判断调用get\",{\"1\":{\"331\":1}}],[\"判断阻塞线程是否被中断\",{\"1\":{\"331\":1}}],[\"判断任务当前执行状态\",{\"1\":{\"332\":1}}],[\"判断任务当前的state\",{\"1\":{\"330\":1}}],[\"判断任务是否已经完成\",{\"1\":{\"326\":1}}],[\"判断任务是否被取消\",{\"1\":{\"326\":1}}],[\"判断任务是否完成\",{\"1\":{\"322\":1}}],[\"判断futuretask当前的state\",{\"1\":{\"317\":1}}],[\"判断是否将command加入workque是线程池之前的状态\",{\"1\":{\"311\":1}}],[\"判断最大线程是否创建\",{\"1\":{\"303\":1}}],[\"判断核心线程是否创建\",{\"1\":{\"303\":1}}],[\"判断队列中是否存在元素o\",{\"1\":{\"265\":1}}],[\"判断存储的key\",{\"1\":{\"259\":1}}],[\"判断\",{\"1\":{\"259\":1}}],[\"判断数组之前的快照snapshot是否等于当前数组current\",{\"1\":{\"239\":1}}],[\"判断两者是否相等\",{\"1\":{\"237\":1}}],[\"判断elements的类型是否为object\",{\"1\":{\"234\":1}}],[\"判断传入的集合c的类型是否为copyonwritearraylist类型\",{\"1\":{\"234\":1}}],[\"判断资源是否被当前线程占有\",{\"1\":{\"183\":1}}],[\"判断当前任务的state是否等于new\",{\"1\":{\"329\":1}}],[\"判断当前对象是不是之前拿到锁的对象\",{\"1\":{\"175\":1}}],[\"判断当前线程是否是第一个等待的线程\",{\"1\":{\"175\":1}}],[\"判断当前的计数i是偶数还是奇数\",{\"1\":{\"160\":1}}],[\"判断结点的前驱是否为head并且是否成功获取\",{\"1\":{\"173\":1}}],[\"①\",{\"1\":{\"173\":1,\"234\":1,\"238\":1,\"239\":1,\"241\":1,\"259\":1}}],[\"逻辑如下\",{\"1\":{\"173\":1}}],[\"逻辑运算符作用于两个瞬时向量之间\",{\"1\":{\"87\":1}}],[\"逻辑运算符\",{\"0\":{\"87\":1}}],[\"找到对应的节点并返回\",{\"1\":{\"369\":2}}],[\"找到第一个相等的元素\",{\"1\":{\"363\":1}}],[\"找到第一个值为\",{\"1\":{\"363\":1}}],[\"找到table表下标为i的节点\",{\"1\":{\"259\":1}}],[\"找到state对象在内存中的偏移量\",{\"1\":{\"175\":1}}],[\"找到最前的状态小于等于0的结点\",{\"1\":{\"173\":1}}],[\"找到等待状态小于等于0的结点\",{\"1\":{\"173\":1}}],[\"找到node前驱结点中第一个状态小于0的结点\",{\"1\":{\"173\":1}}],[\"找到pred结点前面最近的一个状态不为cancelled的结点\",{\"1\":{\"173\":1}}],[\"标记\",{\"1\":{\"406\":1}}],[\"标记锁\",{\"1\":{\"218\":1}}],[\"标识为deque\",{\"1\":{\"226\":1}}],[\"标识为queue\",{\"1\":{\"226\":1}}],[\"标志\",{\"1\":{\"173\":1}}],[\"标签\",{\"1\":{\"85\":1}}],[\"现在我们可以通过\",{\"1\":{\"424\":1}}],[\"现在要求写出一种算法\",{\"1\":{\"394\":1}}],[\"现在有1千万个随机数\",{\"1\":{\"394\":1}}],[\"现在\",{\"1\":{\"173\":2}}],[\"现在使用责任链模式去模拟一个向公司借款的流程\",{\"1\":{\"36\":1}}],[\"若数字是\",{\"1\":{\"392\":1}}],[\"若mayinterruptifrunning为false\",{\"1\":{\"326\":1}}],[\"若mayinterruptifrunning为true\",{\"1\":{\"326\":1}}],[\"若有等待notfull条件的线程\",{\"1\":{\"277\":1}}],[\"若元素个数为0则返回null\",{\"1\":{\"276\":1}}],[\"若满\",{\"1\":{\"273\":1}}],[\"若找到则返回该结点\",{\"1\":{\"260\":1}}],[\"若已经添加了\",{\"1\":{\"259\":1}}],[\"若为\",{\"1\":{\"377\":1}}],[\"若为c\",{\"1\":{\"259\":1}}],[\"若为空\",{\"1\":{\"259\":1}}],[\"若bincount值达到红黑树转化的阈值\",{\"1\":{\"259\":1}}],[\"若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点\",{\"1\":{\"259\":1}}],[\"若遍历过程发现snapshot与current的元素不相等并且current的元素与指定元素相等\",{\"1\":{\"239\":1}}],[\"若该结点的的hash值为moved\",{\"1\":{\"259\":1}}],[\"若取出的结点为空\",{\"1\":{\"259\":1}}],[\"若table表为空或者长度为0\",{\"1\":{\"259\":1}}],[\"若tryacquire失败\",{\"1\":{\"173\":1}}],[\"若个数为0\",{\"1\":{\"241\":1}}],[\"若能够找到\",{\"1\":{\"239\":1}}],[\"若不相等\",{\"1\":{\"239\":1}}],[\"若不是\",{\"1\":{\"234\":1}}],[\"若相等\",{\"1\":{\"237\":1}}],[\"若头结点改变\",{\"1\":{\"198\":1,\"199\":1}}],[\"若park了当前线程\",{\"1\":{\"173\":1}}],[\"若是\",{\"1\":{\"173\":1,\"234\":1,\"259\":1}}],[\"若是则将尾结点设置为node\",{\"1\":{\"173\":1,\"214\":1}}],[\"若步骤①不满足\",{\"1\":{\"173\":1}}],[\"若步骤①均满足\",{\"1\":{\"173\":1}}],[\"若成功\",{\"1\":{\"173\":1}}],[\"若前驱结点为空\",{\"1\":{\"168\":1}}],[\"供子类调用\",{\"1\":{\"171\":1}}],[\"属性\",{\"1\":{\"377\":1,\"422\":1}}],[\"属性表示预期的修改次数\",{\"1\":{\"364\":1}}],[\"属性表示上一个元素的索引\",{\"1\":{\"364\":1}}],[\"属性表示下一个元素的索引\",{\"1\":{\"364\":1}}],[\"属性中有一个可重入锁\",{\"1\":{\"233\":1}}],[\"属性中包含了头结点head\",{\"1\":{\"170\":1}}],[\"属于方法的重载\",{\"1\":{\"418\":1}}],[\"属于中间状态\",{\"1\":{\"328\":1}}],[\"属于读写锁的一种扩展\",{\"1\":{\"221\":1}}],[\"属于创建型设计模式的一种\",{\"1\":{\"39\":1}}],[\"属于懒汉模式\",{\"1\":{\"20\":1}}],[\"头结点和尾节点\",{\"1\":{\"366\":1}}],[\"头结点不为空\",{\"1\":{\"214\":1}}],[\"头结点不为空并且头结点不为尾结点\",{\"1\":{\"198\":1,\"199\":1}}],[\"头结点不为空并且头结点状态不为0\",{\"1\":{\"174\":1}}],[\"头结点与尾结点都指向同一个新生结点\",{\"1\":{\"173\":1,\"214\":1}}],[\"头结点为空\",{\"1\":{\"173\":1,\"214\":1}}],[\"头结点\",{\"1\":{\"170\":1}}],[\"版本中引入的新的\",{\"1\":{\"403\":1}}],[\"版本\",{\"1\":{\"326\":1}}],[\"版本序列化\",{\"1\":{\"185\":1}}],[\"版本序列号\",{\"1\":{\"166\":1,\"233\":1,\"270\":1}}],[\"版本号\",{\"1\":{\"170\":1,\"184\":1,\"197\":1}}],[\"释放数组\",{\"1\":{\"274\":1}}],[\"释放锁\",{\"1\":{\"186\":2,\"213\":1,\"238\":2,\"239\":2,\"240\":1,\"241\":2,\"271\":1,\"273\":1,\"275\":1,\"276\":1,\"277\":1}}],[\"释放标识\",{\"1\":{\"183\":1}}],[\"释放头结点的后继结点\",{\"1\":{\"174\":1}}],[\"释放成功\",{\"1\":{\"174\":1}}],[\"释放许可\",{\"1\":{\"173\":1}}],[\"释放后继结点\",{\"1\":{\"173\":1,\"198\":1,\"199\":1}}],[\"释放node的前一个结点\",{\"1\":{\"173\":1}}],[\"释放条件\",{\"1\":{\"169\":1}}],[\"释放资源\",{\"1\":{\"142\":1}}],[\"唤醒节点中的线程\",{\"1\":{\"333\":1}}],[\"唤醒在notfull条件上等待的线程\",{\"1\":{\"275\":1}}],[\"唤醒在notempty条件上等待的线程\",{\"1\":{\"273\":1}}],[\"唤醒所有线程\",{\"1\":{\"214\":1,\"215\":1}}],[\"唤醒所有等待线程\",{\"1\":{\"169\":1,\"214\":1}}],[\"唤醒调用线程\",{\"1\":{\"186\":1}}],[\"唤醒一个等待线程\",{\"1\":{\"169\":1}}],[\"唤醒出队等\",{\"1\":{\"164\":1}}],[\"保持上界不变\",{\"1\":{\"406\":1}}],[\"保存元素个数\",{\"1\":{\"277\":1}}],[\"保存p结点的value\",{\"1\":{\"261\":1}}],[\"保存该结点的val值\",{\"1\":{\"259\":1,\"261\":1}}],[\"保存condition队列头结点\",{\"1\":{\"214\":1}}],[\"保存运行动作\",{\"1\":{\"213\":1}}],[\"保存当前结点\",{\"1\":{\"259\":1}}],[\"保存当前代\",{\"1\":{\"213\":1}}],[\"保存当前锁\",{\"1\":{\"213\":1}}],[\"保存头结点\",{\"1\":{\"174\":1,\"198\":1,\"199\":1}}],[\"保存结点的val\",{\"1\":{\"259\":1}}],[\"保存结点的后继\",{\"1\":{\"173\":1}}],[\"保存结点\",{\"1\":{\"173\":1}}],[\"保存node的前驱结点\",{\"1\":{\"173\":1}}],[\"保存尾结点\",{\"1\":{\"173\":2,\"214\":1}}],[\"保存前驱结点\",{\"1\":{\"168\":1}}],[\"保证在迭代过程中对集合的修改不会产生错误的结果\",{\"1\":{\"364\":1}}],[\"保证thread不被其他线程中断\",{\"1\":{\"313\":1}}],[\"保证多线程的安全访问\",{\"1\":{\"238\":1}}],[\"保证公平\",{\"1\":{\"175\":1}}],[\"保证任意时刻只有一个线程可以拿到\",{\"1\":{\"175\":1}}],[\"保证前面的线程都执行完\",{\"1\":{\"132\":1}}],[\"保证了线程安全\",{\"1\":{\"421\":1}}],[\"保证了存储的键值对的分布合理性和查询性能的稳定性\",{\"1\":{\"379\":1}}],[\"保证了迭代的线程安全性和不会发生并发修改异常\",{\"1\":{\"242\":1}}],[\"保证了读操作的线程安全性\",{\"1\":{\"225\":1}}],[\"保证了数据的一致性\",{\"1\":{\"221\":1}}],[\"保证了有序性\",{\"1\":{\"145\":1}}],[\"保证了代码的顺序性\",{\"1\":{\"145\":1}}],[\"保证了原子性\",{\"1\":{\"145\":1}}],[\"保证了这些对象之间的兼容性\",{\"1\":{\"47\":1}}],[\"保证了mac电脑对外接口的简单性\",{\"1\":{\"27\":1}}],[\"前向节点为链表的当前尾节点\",{\"1\":{\"368\":1}}],[\"前面分析过\",{\"1\":{\"330\":1}}],[\"前面addworker方法中就是直接通过启动这个线程来启动这个worker\",{\"1\":{\"313\":1}}],[\"前被取消则返回true\",{\"1\":{\"326\":1}}],[\"前言\",{\"0\":{\"291\":1,\"336\":1}}],[\"前驱的后继为e的后继\",{\"1\":{\"261\":1}}],[\"前驱不为空\",{\"1\":{\"261\":1}}],[\"前驱节点为头结点\",{\"1\":{\"198\":1}}],[\"前驱为头结点并且成功获得锁\",{\"1\":{\"173\":1}}],[\"前驱结点不为空\",{\"1\":{\"168\":1}}],[\"前驱结点为空\",{\"1\":{\"168\":1}}],[\"前驱结点\",{\"1\":{\"168\":1}}],[\"前提条件是两个告警的alertname\",{\"1\":{\"107\":1}}],[\"模型的开发方式\",{\"1\":{\"403\":1}}],[\"模拟主线程执行耗时任务\",{\"1\":{\"336\":1}}],[\"模拟耗时操作\",{\"1\":{\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":2,\"342\":2}}],[\"模拟多次执行订单查询\",{\"1\":{\"203\":1}}],[\"模式的双端任务队列\",{\"1\":{\"347\":1}}],[\"模式\",{\"1\":{\"168\":1,\"401\":1}}],[\"模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤\",{\"1\":{\"12\":1}}],[\"模板模式\",{\"1\":{\"12\":1}}],[\"说白了\",{\"1\":{\"288\":1}}],[\"说明索引位于链表的后半段\",{\"1\":{\"369\":1}}],[\"说明索引位于链表的前半段\",{\"1\":{\"369\":1}}],[\"说明链表为空链表\",{\"1\":{\"368\":1}}],[\"说明它也是一个可取消的异步运算任务\",{\"1\":{\"348\":1}}],[\"说明任务已经结束\",{\"1\":{\"331\":1}}],[\"说明任务已经执行完\",{\"1\":{\"317\":1}}],[\"说明任务已经执行完成\",{\"1\":{\"317\":1}}],[\"说明任务或者已经执行过\",{\"1\":{\"329\":1}}],[\"说明\",{\"1\":{\"166\":1,\"174\":1,\"206\":1,\"207\":1,\"208\":1,\"210\":1,\"211\":1,\"213\":1,\"234\":1,\"239\":1,\"241\":1,\"291\":1,\"304\":1}}],[\"说的简单一点就是多写\",{\"1\":{\"8\":1}}],[\"谁抢到就是谁的\",{\"1\":{\"164\":1}}],[\"又需要进行多种类型的实现\",{\"1\":{\"419\":1}}],[\"又提供了其他方法\",{\"1\":{\"265\":1}}],[\"又可分为公平锁和非公平锁\",{\"1\":{\"164\":1}}],[\"又被叫做最小知识原则\",{\"1\":{\"14\":1}}],[\"独占模式\",{\"1\":{\"168\":1}}],[\"独占模式下的线程\",{\"1\":{\"166\":1}}],[\"独占\",{\"1\":{\"164\":1}}],[\"期望值\",{\"1\":{\"163\":1}}],[\"与阻塞\",{\"1\":{\"416\":1}}],[\"与客户端进行通信\",{\"1\":{\"411\":1}}],[\"与实现无关\",{\"1\":{\"392\":1}}],[\"与数组相比\",{\"1\":{\"371\":1}}],[\"与其他并发集合不同的是\",{\"1\":{\"228\":1}}],[\"与读锁类似\",{\"1\":{\"221\":1}}],[\"与传统的独占写锁类似\",{\"1\":{\"221\":1}}],[\"与\",{\"1\":{\"202\":1}}],[\"与前面分析的函数大同小异\",{\"1\":{\"174\":1}}],[\"与notifyall\",{\"1\":{\"160\":1}}],[\"与java动态代理不同\",{\"1\":{\"57\":1}}],[\"等方法组合多个\",{\"1\":{\"343\":1}}],[\"等方法来组合多个completablefuture对象\",{\"1\":{\"337\":1}}],[\"等方法来执行异步操作\",{\"1\":{\"337\":1}}],[\"等方法进行多个异步操作的组合\",{\"1\":{\"337\":1}}],[\"等方法支持链式调用和操作组合\",{\"1\":{\"337\":1}}],[\"等静态方法\",{\"1\":{\"337\":1}}],[\"等于当前代并且屏障没有被损坏\",{\"1\":{\"213\":1}}],[\"等\",{\"1\":{\"159\":1,\"264\":1,\"303\":1,\"337\":1,\"401\":2,\"407\":1,\"433\":1}}],[\"等待事件就绪\",{\"1\":{\"414\":1}}],[\"等待任务完成\",{\"1\":{\"343\":1}}],[\"等待任务执行出错\",{\"1\":{\"339\":1,\"340\":1}}],[\"等待任务执行完成\",{\"1\":{\"323\":4,\"336\":1}}],[\"等待异步任务完成\",{\"1\":{\"341\":1,\"342\":1}}],[\"等待异步任务执行完成\",{\"1\":{\"340\":1,\"341\":1,\"342\":1}}],[\"等待计算结果\",{\"1\":{\"323\":3,\"336\":1}}],[\"等待结果\",{\"1\":{\"322\":1,\"337\":1}}],[\"等待state变成normal\",{\"1\":{\"317\":1}}],[\"等待存放条件\",{\"1\":{\"270\":1}}],[\"等待一段时间后继续消费数据\",{\"1\":{\"267\":1}}],[\"等待一段时间后继续生产数据\",{\"1\":{\"267\":1}}],[\"等待指定时长\",{\"1\":{\"213\":1}}],[\"等待所有任务完成后再进行后续操作\",{\"1\":{\"190\":1}}],[\"等待\",{\"1\":{\"169\":5,\"213\":1}}],[\"等待着获取锁\",{\"1\":{\"168\":2}}],[\"等待队列\",{\"1\":{\"163\":1}}],[\"等待某个条件的发生\",{\"1\":{\"159\":1}}],[\"等待获取条件\",{\"1\":{\"270\":1}}],[\"等待获取对象的锁以继续执行\",{\"1\":{\"158\":1}}],[\"等待获取该锁的其他线程会转换为就绪状态\",{\"1\":{\"157\":1}}],[\"等待状态的线程会转换为就绪状态\",{\"1\":{\"157\":1}}],[\"等待状态的线程正在等待另一线程执行特定的操作\",{\"1\":{\"155\":1}}],[\"等待监视器锁时\",{\"1\":{\"155\":1}}],[\"等待调度\",{\"1\":{\"155\":1}}],[\"等待线程池execute\",{\"1\":{\"315\":1}}],[\"等待线程数量控制\",{\"1\":{\"202\":1}}],[\"等待线程\",{\"1\":{\"140\":2}}],[\"等待1分钟\",{\"1\":{\"108\":1}}],[\"程在等待某个特定条件的发生\",{\"1\":{\"159\":1}}],[\"程序将继续执行后续的代码\",{\"1\":{\"438\":1}}],[\"程序会立即跳转到catch代码块中\",{\"1\":{\"432\":1}}],[\"程序会停止响应\",{\"1\":{\"139\":1}}],[\"程序流程将跳转到catch块或finally块\",{\"1\":{\"432\":1}}],[\"程序由相互作用的对象组成\",{\"1\":{\"422\":1}}],[\"程序按照一定的顺序执行这些步骤来完成任务\",{\"1\":{\"422\":1}}],[\"程序被分解为可重用的功能模块\",{\"1\":{\"422\":1}}],[\"程序新视界\",{\"1\":{\"287\":1}}],[\"程序次序规则\",{\"1\":{\"136\":1}}],[\"程序中的\",{\"1\":{\"121\":1}}],[\"程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的\",{\"1\":{\"14\":1}}],[\"程序计数器等\",{\"1\":{\"120\":1}}],[\"程序输出\",{\"1\":{\"119\":1}}],[\"程序要依赖于抽象接口\",{\"1\":{\"14\":1}}],[\"处\",{\"1\":{\"377\":1}}],[\"处有键值对\",{\"1\":{\"376\":1,\"378\":1}}],[\"处理写事件\",{\"1\":{\"412\":1,\"414\":1}}],[\"处理读事件\",{\"1\":{\"412\":1,\"414\":1}}],[\"处理接受连接事件\",{\"1\":{\"412\":1}}],[\"处理具体的\",{\"1\":{\"412\":1}}],[\"处理事件\",{\"1\":{\"412\":1}}],[\"处理就绪事件\",{\"1\":{\"407\":1}}],[\"处理二进制数据\",{\"1\":{\"401\":2}}],[\"处理对象不同\",{\"1\":{\"399\":1}}],[\"处理结果以及异常情况\",{\"1\":{\"340\":1}}],[\"处理异步计算的结果\",{\"1\":{\"340\":1}}],[\"处理流程如下\",{\"1\":{\"238\":1,\"241\":1}}],[\"处理类的实现类handlera\",{\"1\":{\"35\":1}}],[\"处理类handler\",{\"1\":{\"35\":1}}],[\"处于阻塞状态\",{\"1\":{\"158\":1}}],[\"立刻执行了同步代码块代码\",{\"1\":{\"158\":1}}],[\"阻塞中返回\",{\"1\":{\"333\":1}}],[\"阻塞等待\",{\"1\":{\"331\":1}}],[\"阻塞等待直到被其他线程唤醒\",{\"1\":{\"331\":1}}],[\"阻塞等待特定时间\",{\"1\":{\"331\":1}}],[\"阻塞队列还是没有任务\",{\"1\":{\"314\":1}}],[\"阻塞队列都以blocking关键字标识\",{\"1\":{\"226\":1}}],[\"阻塞特定时间\",{\"1\":{\"265\":2}}],[\"阻塞操作\",{\"1\":{\"264\":1}}],[\"阻塞与非阻塞\",{\"1\":{\"226\":1}}],[\"阻塞其他线程的读和写操作\",{\"1\":{\"220\":1}}],[\"阻塞调用线程\",{\"1\":{\"186\":1}}],[\"阻塞当前线程\",{\"1\":{\"175\":1}}],[\"阻塞状态\",{\"1\":{\"158\":1}}],[\"阻塞状态的线程会转换为就绪状态\",{\"1\":{\"157\":1}}],[\"阻塞\",{\"1\":{\"155\":1,\"226\":1,\"265\":2}}],[\"终止阶段\",{\"1\":{\"293\":1}}],[\"终止的各个状态\",{\"1\":{\"155\":1}}],[\"终止状态\",{\"1\":{\"155\":1}}],[\"终结器规则\",{\"1\":{\"136\":1}}],[\"陷入阻塞状态\",{\"1\":{\"155\":1}}],[\"尚未启动的线程状态\",{\"1\":{\"155\":1}}],[\"忙等待\",{\"1\":{\"153\":1}}],[\"追求吞吐量\",{\"1\":{\"152\":1}}],[\"追求响应时间\",{\"1\":{\"152\":1}}],[\"响应时间缓慢\",{\"1\":{\"152\":1}}],[\"竞争的线程不会阻塞\",{\"1\":{\"152\":1}}],[\"优先级\",{\"1\":{\"291\":1}}],[\"优先讲解面试过程中常见遇到的几种设计模式\",{\"1\":{\"8\":1}}],[\"优点\",{\"1\":{\"152\":1}}],[\"适合于负载较高的场景\",{\"1\":{\"297\":1}}],[\"适合读多写少的场景\",{\"1\":{\"218\":1}}],[\"适应性自旋的时间会根据当前环境的运行态势自动调整\",{\"1\":{\"153\":1}}],[\"适应性自旋\",{\"1\":{\"153\":1}}],[\"适用于对随机访问的需求较多\",{\"1\":{\"358\":1}}],[\"适用于多读少写的场景\",{\"1\":{\"229\":1}}],[\"适用于需要同时处理多个\",{\"1\":{\"412\":1}}],[\"适用于需要使用非阻塞\",{\"1\":{\"410\":1,\"411\":1}}],[\"适用于需要限制队列长度的场景\",{\"1\":{\"266\":1}}],[\"适用于需要有序遍历的场景\",{\"1\":{\"225\":1}}],[\"适用于需要更灵活的锁操作\",{\"1\":{\"218\":1}}],[\"适用于读操作远远多于写操作的场景\",{\"1\":{\"218\":1}}],[\"适用于读多写少的场景\",{\"1\":{\"218\":1,\"221\":1,\"225\":1}}],[\"适用于短暂的锁竞争\",{\"1\":{\"153\":1}}],[\"适用于只有一个线程访问同步块场景\",{\"1\":{\"152\":1}}],[\"适用于高并发场景中对资源访问的严格控制和保护\",{\"1\":{\"152\":1}}],[\"适用场景\",{\"1\":{\"152\":1,\"218\":3}}],[\"适配者类无论出现什么新功能\",{\"1\":{\"27\":1}}],[\"适配器只有同时实现或者持有目标接口和被适配的对象\",{\"1\":{\"26\":1}}],[\"适配器类只要不影响目标类的接口功能\",{\"1\":{\"27\":1}}],[\"适配器类adapter\",{\"1\":{\"25\":1}}],[\"适配器类即将要进行适配的抽象类或接口\",{\"1\":{\"25\":1}}],[\"适配器可以让不兼容的两个类一起协同工作\",{\"1\":{\"25\":1}}],[\"适配器模式的定义是\",{\"1\":{\"25\":1}}],[\"适配器模式就是将旧代码和新程序的中间的转换角色\",{\"1\":{\"25\":1}}],[\"适配器模式\",{\"0\":{\"25\":1},\"1\":{\"11\":1,\"13\":1}}],[\"信号量等\",{\"1\":{\"152\":1,\"288\":1}}],[\"轻量级锁使用\",{\"1\":{\"153\":1}}],[\"轻量级锁和偏向锁之间转换\",{\"1\":{\"152\":1}}],[\"轻量级锁会自动膨胀成重量级锁\",{\"1\":{\"151\":1}}],[\"轻量级锁的优化策略适用于短期的同步操作\",{\"1\":{\"151\":1}}],[\"轻量级锁\",{\"0\":{\"151\":1},\"1\":{\"152\":1,\"153\":1}}],[\"改为轻量级锁等其他形式的锁\",{\"1\":{\"150\":1}}],[\"之后某个线程对本线程unpark后\",{\"1\":{\"173\":1}}],[\"之后会通过一个例子详细讲解\",{\"1\":{\"214\":1}}],[\"之后会判断是否finally模块\",{\"1\":{\"173\":1}}],[\"之后会结合一个例子进行分析\",{\"1\":{\"173\":1}}],[\"之后会进行分析\",{\"1\":{\"173\":1}}],[\"之后会详细分析condtionobject的源码\",{\"1\":{\"169\":1}}],[\"之后\",{\"1\":{\"150\":1,\"198\":1,\"199\":1,\"419\":1,\"438\":2}}],[\"偏向锁会在第一个线程获得锁后\",{\"1\":{\"153\":1}}],[\"偏向锁才会撤销\",{\"1\":{\"150\":1}}],[\"偏向锁是一种用于减少同步操作的开销的优化技术\",{\"1\":{\"150\":1}}],[\"偏向锁\",{\"0\":{\"150\":1},\"1\":{\"152\":1,\"153\":1}}],[\"偏向锁和轻量级锁等一系列优化策略\",{\"1\":{\"149\":1}}],[\"锁定\",{\"1\":{\"213\":1}}],[\"锁已经被占用\",{\"1\":{\"184\":1}}],[\"锁的细粒度控制\",{\"1\":{\"153\":1}}],[\"锁\",{\"1\":{\"152\":1,\"153\":1}}],[\"锁总是由同一线程多次获得\",{\"1\":{\"150\":1}}],[\"锁粗化\",{\"1\":{\"149\":1,\"153\":1}}],[\"锁消除\",{\"1\":{\"149\":1,\"153\":1}}],[\"锁相关信息等内容\",{\"1\":{\"149\":1}}],[\"锁使用策略\",{\"1\":{\"140\":1}}],[\"重写是根据方法的名称和参数列表进行区分\",{\"1\":{\"418\":1}}],[\"重写是指子类对父类方法的重写\",{\"1\":{\"418\":1}}],[\"重写\",{\"1\":{\"418\":1}}],[\"重载方法可以有不同的返回类型\",{\"1\":{\"418\":1}}],[\"重载方法在编译时静态地绑定\",{\"1\":{\"418\":1}}],[\"重载是根据方法的参数列表进行区分\",{\"1\":{\"418\":1}}],[\"重载是针对于同个类中\",{\"1\":{\"418\":1}}],[\"重载有以下的特点\",{\"1\":{\"418\":1}}],[\"重载的方法的返回结果的类型也可以是不同的\",{\"1\":{\"418\":1}}],[\"重载的方法通过调用时的参数的类型或者数量\",{\"1\":{\"418\":1}}],[\"重载指的是在一个类中定义多个方法\",{\"1\":{\"418\":1}}],[\"重载\",{\"1\":{\"418\":2}}],[\"重载与重写的区别\",{\"0\":{\"418\":1}}],[\"重置位置为\",{\"1\":{\"406\":1}}],[\"重置位置和上界\",{\"1\":{\"406\":3}}],[\"重置存索引为0\",{\"1\":{\"273\":1}}],[\"重复元素\",{\"1\":{\"353\":1}}],[\"重入锁\",{\"1\":{\"239\":1,\"276\":1}}],[\"重量级锁是通过监视器\",{\"1\":{\"152\":1}}],[\"重量级锁是一种传统的同步机制\",{\"1\":{\"152\":1}}],[\"重量级锁的实现通常需要依赖底层的操作系统特性\",{\"1\":{\"152\":1}}],[\"重量级锁\",{\"0\":{\"152\":1},\"1\":{\"148\":1,\"152\":2}}],[\"重新是发生在子类和父类的继承关系之间\",{\"1\":{\"418\":1}}],[\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别\",{\"1\":{\"418\":1}}],[\"重新赋值取元素索引\",{\"1\":{\"277\":1}}],[\"重新赋值取值索引\",{\"1\":{\"275\":1}}],[\"重新赋值i\",{\"1\":{\"277\":1}}],[\"重新赋值index索引的值\",{\"1\":{\"240\":1}}],[\"重新设置first\",{\"1\":{\"214\":1}}],[\"重新运行打印的结果为10000\",{\"1\":{\"132\":1}}],[\"重新启动alertmanager\",{\"1\":{\"107\":1}}],[\"重新启动prometheus\",{\"1\":{\"116\":1}}],[\"重新启动prometheus或者热加载\",{\"1\":{\"99\":1}}],[\"重新启动prometheus的程序\",{\"1\":{\"69\":1}}],[\"重新加载一下配置\",{\"1\":{\"99\":1}}],[\"理论上\",{\"1\":{\"392\":1}}],[\"理论上可以提高系统的吞吐量\",{\"1\":{\"300\":1}}],[\"理论上其实也可以通过这两条指令来实现\",{\"1\":{\"147\":1}}],[\"理解可见性\",{\"0\":{\"117\":1}}],[\"反编译class文件中可以看到\",{\"1\":{\"436\":1}}],[\"反编译中可以看到都是对象级别的类文件\",{\"1\":{\"436\":1}}],[\"反编译查看字节码如下\",{\"1\":{\"147\":1}}],[\"反转等\",{\"1\":{\"352\":1}}],[\"反射机制\",{\"1\":{\"233\":1}}],[\"反之\",{\"1\":{\"143\":1}}],[\"文件映射等功能\",{\"1\":{\"403\":1}}],[\"文件锁定\",{\"1\":{\"403\":1}}],[\"文件长度\",{\"1\":{\"401\":1}}],[\"文件操作\",{\"1\":{\"399\":1,\"403\":1}}],[\"文件\",{\"1\":{\"147\":1}}],[\"文件系统里剩余的磁盘字节数\",{\"1\":{\"69\":1}}],[\"临界区是指一个需要互斥执行的代码段\",{\"1\":{\"147\":1}}],[\"非法\",{\"1\":{\"435\":2}}],[\"非空性\",{\"1\":{\"430\":1}}],[\"非同步\",{\"1\":{\"403\":1}}],[\"非同步的代码块\",{\"1\":{\"146\":4}}],[\"非阻塞模式\",{\"1\":{\"403\":1,\"404\":1,\"410\":2,\"411\":1}}],[\"非阻塞\",{\"1\":{\"226\":1,\"412\":1}}],[\"非公平方式获取\",{\"1\":{\"183\":1}}],[\"非公平锁\",{\"1\":{\"164\":1,\"184\":1}}],[\"非常容易的打包和部署\",{\"1\":{\"63\":1}}],[\"块中关闭\",{\"1\":{\"415\":1}}],[\"块中\",{\"1\":{\"203\":1}}],[\"块内部和外部的指令重排序\",{\"1\":{\"145\":1}}],[\"块时\",{\"1\":{\"145\":2}}],[\"关系操作符号\",{\"0\":{\"429\":1}}],[\"关系于\",{\"1\":{\"136\":1}}],[\"关于这个方法后面在分析\",{\"1\":{\"329\":1}}],[\"关于aqs的数据结构\",{\"1\":{\"178\":1}}],[\"关闭连接等必须执行的操作\",{\"1\":{\"437\":1}}],[\"关闭连接\",{\"1\":{\"411\":1}}],[\"关闭\",{\"1\":{\"411\":2}}],[\"关闭通道\",{\"1\":{\"410\":2,\"411\":1}}],[\"关闭通道和文件\",{\"1\":{\"405\":2}}],[\"关闭线程池\",{\"1\":{\"323\":2,\"336\":1}}],[\"关闭阶段\",{\"1\":{\"293\":1}}],[\"关键字修饰\",{\"1\":{\"419\":1}}],[\"关键字来代替\",{\"1\":{\"153\":1}}],[\"关键字的性能有了较大的提升\",{\"1\":{\"153\":1}}],[\"关键字的范围\",{\"1\":{\"153\":1}}],[\"关键字的作用是确保多线程环境下共享资源的正确访问和数据的一致性\",{\"1\":{\"145\":1}}],[\"关键字保证了\",{\"1\":{\"146\":1}}],[\"关键字\",{\"1\":{\"146\":2}}],[\"关键字时\",{\"1\":{\"146\":1}}],[\"关键字可以确保在同一时间只有一个线程可以执行被\",{\"1\":{\"145\":1}}],[\"否则编译器会报错\",{\"1\":{\"432\":1}}],[\"否则称为合数\",{\"1\":{\"395\":1}}],[\"否则使用循环遍历链表中的其他节点进行查找\",{\"1\":{\"378\":1}}],[\"否则将任务拆分为更小的子任务\",{\"1\":{\"349\":1}}],[\"否则将匹配不到\",{\"1\":{\"85\":1,\"86\":1,\"87\":1}}],[\"否则细分为更小的子任务\",{\"1\":{\"349\":1}}],[\"否则返回\",{\"1\":{\"378\":1,\"387\":1,\"388\":1}}],[\"否则返回false\",{\"1\":{\"326\":2}}],[\"否则返回该结点\",{\"1\":{\"259\":1}}],[\"否则会抛出java\",{\"1\":{\"147\":1}}],[\"否则\",{\"1\":{\"143\":1,\"173\":4,\"181\":1,\"234\":1,\"237\":1,\"239\":4,\"241\":1,\"259\":7,\"260\":1,\"274\":1,\"276\":2,\"370\":2}}],[\"避免资源浪费和线程过多导致的性能下降\",{\"1\":{\"296\":1}}],[\"避免这种情况的发生\",{\"1\":{\"291\":1}}],[\"避免线程的过度创建和资源耗尽\",{\"1\":{\"291\":1}}],[\"避免了为每个通道创建一个线程的开销\",{\"1\":{\"407\":1}}],[\"避免了频繁的创建和销毁\",{\"1\":{\"291\":1}}],[\"避免了线程阻塞和内核切换的开销\",{\"1\":{\"153\":1}}],[\"避免了遇到不同顺序而导致的循环等待\",{\"1\":{\"143\":1}}],[\"避免不必要的阻塞\",{\"1\":{\"152\":1}}],[\"避免出现死锁或永久等待的情况\",{\"1\":{\"203\":1}}],[\"避免出现一些无意义的计算\",{\"1\":{\"114\":1}}],[\"避免出现对业务的影响\",{\"1\":{\"65\":1}}],[\"决定获取锁的顺序\",{\"1\":{\"143\":2}}],[\"决定了系统的性能和处理能力\",{\"1\":{\"118\":1}}],[\"破换了占有且等待条件\",{\"1\":{\"142\":1}}],[\"破坏循环等待条件\",{\"0\":{\"143\":1},\"1\":{\"141\":1}}],[\"破坏不可抢占\",{\"1\":{\"141\":1}}],[\"破坏占有且等待\",{\"0\":{\"142\":1},\"1\":{\"141\":1}}],[\"来处理\",{\"1\":{\"432\":1}}],[\"来进行比较时\",{\"1\":{\"429\":1}}],[\"来解决多继承的需要\",{\"1\":{\"420\":1}}],[\"来声明\",{\"1\":{\"419\":1}}],[\"来确保连接已经建立\",{\"1\":{\"415\":1}}],[\"来监听多个\",{\"1\":{\"414\":1}}],[\"来支持高效的\",{\"1\":{\"403\":1}}],[\"来记录\",{\"1\":{\"392\":1}}],[\"来存储元素\",{\"1\":{\"389\":1}}],[\"来获取执行结果\",{\"1\":{\"331\":1}}],[\"来获取对共享锁对象lock的独占锁定\",{\"1\":{\"160\":1}}],[\"来通知调用线程\",{\"1\":{\"186\":1}}],[\"来唤醒其他因等待相同锁而处于暂停状态的线程\",{\"1\":{\"160\":1}}],[\"来实现接口\",{\"1\":{\"419\":1}}],[\"来实现快速失败机制\",{\"1\":{\"364\":1}}],[\"来实现等待\",{\"1\":{\"191\":1}}],[\"来实现的\",{\"1\":{\"148\":1,\"364\":1}}],[\"来实现线程同步\",{\"1\":{\"146\":1}}],[\"来申请资源\",{\"1\":{\"142\":1}}],[\"来避免死锁的例子\",{\"1\":{\"142\":1}}],[\"来预测主机可用磁盘空间的是否在24个小时候被占满\",{\"1\":{\"93\":1}}],[\"资源是否被占用\",{\"1\":{\"183\":1}}],[\"资源\",{\"1\":{\"173\":6}}],[\"资源可以被剥夺并分配给等待的线程\",{\"1\":{\"141\":1}}],[\"资源可以被强制剥夺并重新分配给其他线程\",{\"1\":{\"141\":1}}],[\"资源使用情况\",{\"1\":{\"65\":1}}],[\"确保java应用程序的安全\",{\"1\":{\"433\":1}}],[\"确保结点能够成功入队列\",{\"1\":{\"173\":1,\"214\":1}}],[\"确定copy的类型\",{\"1\":{\"237\":1}}],[\"确定当前告警应该如何处理\",{\"1\":{\"106\":1}}],[\"确实\",{\"1\":{\"141\":1}}],[\"占有的资源\",{\"1\":{\"140\":3}}],[\"占有且等待\",{\"1\":{\"140\":1}}],[\"已经重写了\",{\"1\":{\"430\":1}}],[\"已经被废弃了\",{\"1\":{\"401\":1}}],[\"已经被deprecated\",{\"1\":{\"401\":1}}],[\"已经提交但尚未执行的任务\",{\"1\":{\"293\":1}}],[\"已经存在\",{\"1\":{\"239\":1}}],[\"已经释放\",{\"1\":{\"183\":1}}],[\"已经取得共享资源\",{\"1\":{\"140\":1}}],[\"已解决\",{\"1\":{\"107\":1}}],[\"互相权衡队列大小和最大池大小\",{\"1\":{\"300\":1}}],[\"互相等待\",{\"1\":{\"202\":1}}],[\"互不影响\",{\"1\":{\"245\":1}}],[\"互不干扰\",{\"1\":{\"27\":1}}],[\"互斥性\",{\"1\":{\"145\":1}}],[\"互斥条件\",{\"1\":{\"140\":1}}],[\"正确地重写hashcode\",{\"1\":{\"431\":1}}],[\"正是由于重载和重写\",{\"1\":{\"418\":1}}],[\"正常情况下新的数组大小是旧数组的1\",{\"1\":{\"361\":1}}],[\"正常执行完成或者执行出现异常\",{\"1\":{\"331\":1}}],[\"正常执行结束或者执行异常结束\",{\"1\":{\"326\":1}}],[\"正常来说\",{\"1\":{\"287\":1}}],[\"正在等待进入屏障的线程数量为0\",{\"1\":{\"213\":1}}],[\"正在等待进入屏障的线程数量\",{\"1\":{\"208\":1}}],[\"正在等待获取a1对象的锁\",{\"1\":{\"139\":1}}],[\"正在等待获取a2对象的锁\",{\"1\":{\"139\":1}}],[\"正如mac电脑一样\",{\"1\":{\"27\":1}}],[\"死锁发生一般需要满足四个条件\",{\"1\":{\"140\":1}}],[\"死锁发生的条件\",{\"0\":{\"140\":1}}],[\"死锁是指在并发程序中\",{\"1\":{\"140\":1}}],[\"死锁是指两个或多个线程互相等待对方释放资源而无法继续执行的情况\",{\"1\":{\"138\":1}}],[\"死锁示例图\",{\"1\":{\"139\":1}}],[\"死锁示例\",{\"1\":{\"139\":1}}],[\"死锁通常发生在多个线程同时持有多个锁的情况下\",{\"1\":{\"138\":1}}],[\"海子的博客\",{\"1\":{\"137\":1}}],[\"深入理解jvm\",{\"1\":{\"137\":1}}],[\"且具有相同的参数和返回结构类型\",{\"1\":{\"418\":1}}],[\"且发生了哈希冲突\",{\"1\":{\"376\":1,\"378\":1}}],[\"且不允许包含重复的元素\",{\"1\":{\"353\":1}}],[\"且无需保持顺序\",{\"1\":{\"225\":1}}],[\"且id是确定的\",{\"1\":{\"143\":1}}],[\"且\",{\"1\":{\"136\":1,\"374\":1}}],[\"且只支持浮点数指标\",{\"1\":{\"74\":1}}],[\"变量直接存储的是\",{\"1\":{\"429\":1}}],[\"变量都包含了\",{\"1\":{\"391\":1}}],[\"变量\",{\"1\":{\"378\":2}}],[\"变量的访问是安全的\",{\"1\":{\"146\":1}}],[\"变量的写操作\",{\"1\":{\"136\":1}}],[\"变量规则\",{\"1\":{\"136\":1}}],[\"于该线程的终结\",{\"1\":{\"136\":1}}],[\"于该线程内的后续操作\",{\"1\":{\"136\":1}}],[\"于该对象的\",{\"1\":{\"136\":1}}],[\"于被中断线程中的任意操作\",{\"1\":{\"136\":1}}],[\"于随后对这个变量的读操作\",{\"1\":{\"136\":1}}],[\"于随后对这个锁的加锁操作\",{\"1\":{\"136\":1}}],[\"监视器锁规则\",{\"1\":{\"136\":1}}],[\"监控多个\",{\"1\":{\"412\":1}}],[\"监控系统需要迅速反应并通知管理员\",{\"1\":{\"65\":1}}],[\"监控对象的发现\",{\"1\":{\"64\":1}}],[\"虽允许编译器优化\",{\"1\":{\"136\":1}}],[\"虽然可以自动扩容\",{\"1\":{\"395\":1}}],[\"虽然可能会造成一定资源开销和浪费\",{\"1\":{\"18\":1}}],[\"虽然它不是collection\",{\"1\":{\"351\":1}}],[\"虽然实现了blockingqueue接口\",{\"1\":{\"298\":1}}],[\"虽然这些改进使得大多数程序能够在现代计算机系统上获得较好的性能\",{\"1\":{\"118\":1}}],[\"约束了编译器的优化行为\",{\"1\":{\"136\":1}}],[\"永远不会打印a的值\",{\"1\":{\"131\":1}}],[\"概率非常小\",{\"1\":{\"131\":1}}],[\"概览\",{\"0\":{\"58\":1}}],[\"起到了2个作用\",{\"1\":{\"130\":1}}],[\"起到了时序数据库的作用\",{\"1\":{\"101\":1}}],[\"被重写的方法具有以下的特点\",{\"1\":{\"418\":1}}],[\"被许多具体的子类继承和实现\",{\"1\":{\"401\":4}}],[\"被唤醒的线程会各自从awaitdone\",{\"1\":{\"333\":1}}],[\"被中断或到达指定最后期限之前一直处于等待状态\",{\"1\":{\"169\":1}}],[\"被中断或到达指定等待时间之前一直处于等待状态\",{\"1\":{\"169\":2}}],[\"被等待的线程会转换为就绪状态\",{\"1\":{\"157\":1}}],[\"被volatile修饰\",{\"1\":{\"132\":1}}],[\"被volatile关键字修饰变量不会指令重排序\",{\"1\":{\"130\":1}}],[\"被volatile关键字修饰变量\",{\"1\":{\"130\":1}}],[\"被称为time\",{\"1\":{\"74\":1}}],[\"禁止指令重排序\",{\"1\":{\"128\":1}}],[\"禁止规则会静音与一组匹配器匹配的警报\",{\"1\":{\"107\":1}}],[\"语言提供了\",{\"1\":{\"128\":1}}],[\"没有实例变量和构造方法\",{\"1\":{\"419\":1}}],[\"没有方法体\",{\"1\":{\"419\":2}}],[\"没有重写了eat方法\",{\"1\":{\"418\":1}}],[\"没有任何的代码\",{\"1\":{\"367\":1}}],[\"没有足够的线程数或者队列空间来处理提交的任务\",{\"1\":{\"302\":1}}],[\"没有缓冲的队列\",{\"1\":{\"266\":1}}],[\"没有设置等待时间\",{\"1\":{\"213\":1}}],[\"没有设置执行动作\",{\"1\":{\"211\":1}}],[\"没有运行的动作\",{\"1\":{\"213\":1}}],[\"没有被线程占有\",{\"1\":{\"197\":1,\"199\":1}}],[\"没有获取成功\",{\"1\":{\"175\":1}}],[\"没有来得及复制到主内存中\",{\"1\":{\"127\":1}}],[\"没有必要将多个事情给一个角色做完\",{\"1\":{\"27\":1}}],[\"写数据未指定位置\",{\"1\":{\"401\":1}}],[\"写入数据到缓冲区\",{\"1\":{\"406\":1}}],[\"写入数据\",{\"1\":{\"401\":1,\"410\":1,\"411\":1}}],[\"写入i的新值1\",{\"1\":{\"126\":1}}],[\"写时复制\",{\"1\":{\"223\":2,\"229\":1}}],[\"写模式是排它的\",{\"1\":{\"221\":1}}],[\"写模式\",{\"1\":{\"221\":1}}],[\"写锁独占\",{\"1\":{\"220\":1}}],[\"写操作相对较少的多线程环境\",{\"1\":{\"223\":1}}],[\"写操作\",{\"1\":{\"218\":1}}],[\"写\",{\"1\":{\"132\":1,\"407\":1,\"412\":1}}],[\"写一个接口如下\",{\"1\":{\"110\":1}}],[\"写一个观察者接口observer\",{\"1\":{\"50\":1}}],[\"写一个客户端实现类\",{\"1\":{\"54\":1}}],[\"写一个客户端用于测试\",{\"1\":{\"44\":1}}],[\"写一个客户端\",{\"1\":{\"41\":1}}],[\"写一个客户端测试类\",{\"1\":{\"31\":1,\"50\":1}}],[\"写一个测试类\",{\"1\":{\"36\":1,\"47\":1,\"57\":1,\"418\":1}}],[\"编程语言用于处理输入和输出的标准库\",{\"1\":{\"398\":1}}],[\"编程语言中用于存储和操作对象的框架\",{\"1\":{\"351\":1}}],[\"编发编程的概念\",{\"0\":{\"125\":1}}],[\"编译的时候会报错\",{\"1\":{\"435\":1}}],[\"编译不通过\",{\"1\":{\"435\":1}}],[\"编译是通过方法的不同的参数来确定方法\",{\"1\":{\"418\":1}}],[\"编译器又将i自动拆箱成int值\",{\"1\":{\"423\":1}}],[\"编译器会自动将10包装成一个integer对象\",{\"1\":{\"423\":1}}],[\"编译器会在\",{\"1\":{\"147\":1}}],[\"编译器和解释器的优化有时可能会导致意想不到的错误\",{\"1\":{\"121\":1}}],[\"编译器为了优化性能\",{\"1\":{\"121\":1}}],[\"编译优化带来的有序性问题\",{\"0\":{\"121\":1}}],[\"编译程序优化指令执行次序\",{\"1\":{\"118\":1}}],[\"共享模式\",{\"1\":{\"168\":1}}],[\"共享\",{\"1\":{\"164\":1}}],[\"共享变量\",{\"1\":{\"163\":1}}],[\"共享资源\",{\"1\":{\"140\":1}}],[\"共享数据存储在主内存中\",{\"1\":{\"124\":1}}],[\"共享对象\",{\"1\":{\"11\":1}}],[\"随机数的范围在1到1亿之间\",{\"1\":{\"394\":1}}],[\"随着元素的不断添加\",{\"1\":{\"358\":1}}],[\"随着计算机cpu运算能力的迅速增长\",{\"1\":{\"124\":1}}],[\"随后演示了\",{\"1\":{\"406\":1}}],[\"随后进入无限循环\",{\"1\":{\"259\":1}}],[\"随后分别启动这两个线程\",{\"1\":{\"119\":1}}],[\"先来说一下finally语句是不会被执行的情况\",{\"1\":{\"438\":1}}],[\"先比较的是字符串地址是否相等\",{\"1\":{\"430\":1}}],[\"先尝试调用w\",{\"1\":{\"319\":1}}],[\"先执行firsttask\",{\"1\":{\"313\":1}}],[\"先执行javac\",{\"1\":{\"147\":1}}],[\"先复制index索引前的元素\",{\"1\":{\"241\":1}}],[\"先到者先拿到锁\",{\"1\":{\"164\":1}}],[\"先获取当前账户的锁\",{\"1\":{\"143\":1}}],[\"先获取resmanager的锁\",{\"1\":{\"142\":1}}],[\"先聊聊java内存模型\",{\"1\":{\"123\":1}}],[\"先了解这些核心概念\",{\"1\":{\"102\":1}}],[\"今天先聊聊java如何解决多线程下解决可见性和有序性问题\",{\"1\":{\"123\":1}}],[\"今天这一讲\",{\"1\":{\"25\":1}}],[\"早在诞生之初\",{\"1\":{\"123\":1}}],[\"尽量避免不同对象返回相同的hashcode\",{\"1\":{\"431\":1}}],[\"尽量以通俗易懂的语言和代码案例去讲述\",{\"1\":{\"8\":1}}],[\"尽管多继承在某些情况下可能很有用\",{\"1\":{\"420\":1}}],[\"尽管threadlocal可以用于保存线程本地的对象实例\",{\"1\":{\"283\":1}}],[\"尽管重量级锁在竞争激烈的情况下可能会带来性能开销\",{\"1\":{\"152\":1}}],[\"尽管语句的顺序发生变化\",{\"1\":{\"121\":1}}],[\"然而内部类的某个方法还没有执行完\",{\"1\":{\"436\":1}}],[\"然而实际上可能并非如此\",{\"1\":{\"124\":1}}],[\"然而\",{\"1\":{\"121\":2,\"124\":2,\"157\":1,\"371\":1}}],[\"然后执行相应的catch块\",{\"1\":{\"438\":2}}],[\"然后执行javap\",{\"1\":{\"147\":1}}],[\"然后地址不相等\",{\"1\":{\"430\":1}}],[\"然后赋值给j\",{\"1\":{\"423\":1}}],[\"然后赋值给主线程\",{\"1\":{\"132\":1}}],[\"然后进入一个无限循环\",{\"1\":{\"414\":1,\"415\":1}}],[\"然后获取节点\",{\"1\":{\"370\":1}}],[\"然后调用\",{\"1\":{\"369\":1,\"370\":1}}],[\"然后调用中断方法\",{\"1\":{\"319\":1}}],[\"然后根据哈希值计算出索引位置\",{\"1\":{\"378\":1}}],[\"然后根据\",{\"1\":{\"364\":1}}],[\"然后遍历这些\",{\"1\":{\"407\":1}}],[\"然后遍历\",{\"1\":{\"362\":1}}],[\"然后并行地执行这些小任务\",{\"1\":{\"345\":1}}],[\"然后把callable置空\",{\"1\":{\"333\":1}}],[\"然后cas的把节点q替换waiters\",{\"1\":{\"331\":1}}],[\"然后创建一个\",{\"1\":{\"323\":1,\"405\":1,\"415\":1}}],[\"然后创建一个handlerinterceptoradapter的拦截器\",{\"1\":{\"98\":1}}],[\"然后清空任务队列\",{\"1\":{\"319\":1}}],[\"然后拒绝所有提交的任务\",{\"1\":{\"319\":1}}],[\"然后实现的类似锁的功能\",{\"1\":{\"319\":1}}],[\"然后会进行新一轮的循环\",{\"1\":{\"333\":1}}],[\"然后会将剩余的任务全部执行完\",{\"1\":{\"319\":1}}],[\"然后会调用dosignalall函数\",{\"1\":{\"214\":1}}],[\"然后等待2秒钟后继续消费\",{\"1\":{\"267\":1}}],[\"然后等待1秒钟后继续生产\",{\"1\":{\"267\":1}}],[\"然后设置数组\",{\"1\":{\"241\":2}}],[\"然后设置当前数组\",{\"1\":{\"234\":1}}],[\"然后循环继续\",{\"1\":{\"203\":1}}],[\"然后同时开始后续操作\",{\"1\":{\"202\":1}}],[\"然后返回\",{\"1\":{\"173\":1}}],[\"然后返回该线程是否已经被中断\",{\"1\":{\"173\":1}}],[\"然后与其他就绪状态的线程竞争执行权\",{\"1\":{\"163\":1}}],[\"然后线程继续循环执行以上步骤\",{\"1\":{\"160\":1}}],[\"然后再次调用\",{\"1\":{\"364\":1}}],[\"然后再次复制到高速缓存区\",{\"1\":{\"124\":1}}],[\"然后再获取账户之间资金转移所需的锁\",{\"1\":{\"142\":1}}],[\"然后需要执行运算\",{\"1\":{\"126\":1}}],[\"然后复制到自己的高速缓存区\",{\"1\":{\"124\":1}}],[\"然后将这些哈希码组合在一起\",{\"1\":{\"431\":1}}],[\"然后将该\",{\"1\":{\"323\":1}}],[\"然后将进入数设置为1\",{\"1\":{\"147\":1}}],[\"然后将另一个处于就绪状态的线程恢复执行的过程\",{\"1\":{\"120\":1}}],[\"然后将apistatinterceptor注册到webmvcconfigurer中\",{\"1\":{\"98\":1}}],[\"然后使用put\",{\"1\":{\"376\":1}}],[\"然后使用join\",{\"1\":{\"119\":1}}],[\"然后使用装饰器模式\",{\"1\":{\"31\":1}}],[\"然后用案例讲解了这些类的使用\",{\"1\":{\"355\":1}}],[\"然后用\",{\"1\":{\"108\":1}}],[\"然后通过\",{\"1\":{\"406\":1,\"414\":2}}],[\"然后通过getmap方法来获取当前线程中的threadlocals\",{\"1\":{\"282\":1}}],[\"然后通过命令行的方式的启动它\",{\"1\":{\"105\":1}}],[\"然后通过配置文件的形式来具体讲解\",{\"1\":{\"102\":1}}],[\"然后\",{\"1\":{\"97\":1,\"98\":1,\"120\":1,\"267\":1,\"323\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"406\":1,\"438\":1}}],[\"然后在副本上进行写操作\",{\"1\":{\"242\":1}}],[\"然后在休眠100毫秒后\",{\"1\":{\"139\":1}}],[\"然后在浏览器上访问http\",{\"1\":{\"98\":1}}],[\"然后在springboot的配置文件application\",{\"1\":{\"97\":1}}],[\"然后在grafana展示node\",{\"1\":{\"66\":1}}],[\"然后去grafana官方网站的dashboard社区找一个node\",{\"1\":{\"71\":1}}],[\"然后getinstance\",{\"1\":{\"18\":1}}],[\"因此它们之间的\",{\"1\":{\"429\":1}}],[\"因此它和非阻塞的通道\",{\"1\":{\"407\":1}}],[\"因此它可以在一个方向上读取数据\",{\"1\":{\"404\":1}}],[\"因此包含了一些常用的方法\",{\"1\":{\"353\":1}}],[\"因此future+thread这种模式有一定的局限性\",{\"1\":{\"336\":1}}],[\"因此将构造一个新线程\",{\"1\":{\"298\":1}}],[\"因此当threadlocal对象没有其他强引用指向时\",{\"1\":{\"285\":1}}],[\"因此不可能发生冲突\",{\"1\":{\"235\":1}}],[\"因此对于频繁的写操作\",{\"1\":{\"229\":1}}],[\"因此适用于读操作频繁\",{\"1\":{\"223\":1}}],[\"因此是一种快速的读操作\",{\"1\":{\"221\":1}}],[\"因此重量级锁在竞争激烈的情况下可能会影响性能\",{\"1\":{\"152\":1}}],[\"因此在频繁修改字符串的场景下\",{\"1\":{\"421\":1}}],[\"因此在这种情况下\",{\"1\":{\"151\":1}}],[\"因此在该线程第一次获得锁后\",{\"1\":{\"150\":1}}],[\"因此偏向锁能够有效地减少竞争和加锁解锁操作\",{\"1\":{\"150\":1}}],[\"因此\",{\"1\":{\"120\":1,\"148\":1,\"226\":1,\"227\":1,\"358\":1,\"416\":1,\"429\":1}}],[\"因此过多的线程切换可能导致系统性能下降\",{\"1\":{\"120\":1}}],[\"因为垃圾回收器的工作是由java虚拟机自动处理的\",{\"1\":{\"437\":1}}],[\"因为在运行java应用程序时需要虚拟机来解释和执行java字节码\",{\"1\":{\"433\":1}}],[\"因为在开发java应用程序时需要运行java程序来进行测试和调试\",{\"1\":{\"433\":1}}],[\"因为在唤醒线程的时候\",{\"1\":{\"175\":1}}],[\"因为包装类对象在使用==比较时\",{\"1\":{\"423\":1}}],[\"因为基本类型的参数值之间无法进行隐式转换\",{\"1\":{\"423\":1}}],[\"因为数据编码的不同\",{\"1\":{\"399\":1}}],[\"因为每个节点需要额外的存储空间来保存前向和后向指针\",{\"1\":{\"371\":1}}],[\"因为需要从头部或尾部开始遍历链表\",{\"1\":{\"371\":1}}],[\"因为只需要修改节点的指针\",{\"1\":{\"371\":1}}],[\"因为太基础了\",{\"1\":{\"355\":1}}],[\"因为如果threada和threadb在进行阻塞等待结果之前任务就执行完成或线程本身被中断的话\",{\"1\":{\"331\":1}}],[\"因为它是双链表结构\",{\"1\":{\"367\":1}}],[\"因为它是线程隔离的嘛\",{\"1\":{\"288\":1}}],[\"因为它是通过生成子类来代理目标类\",{\"1\":{\"57\":1}}],[\"因为写操作并不会修改原始数组\",{\"1\":{\"223\":1}}],[\"因为cas种需要此参数\",{\"1\":{\"175\":1}}],[\"因为reentrantreadwritelock也就是读写锁允许多个线程同时对某一资源进行读\",{\"1\":{\"164\":1}}],[\"因为\",{\"1\":{\"153\":1,\"348\":1,\"382\":1,\"387\":1,\"388\":1}}],[\"因为jvm已经假定该线程会继续拥有锁\",{\"1\":{\"150\":1}}],[\"因为线程t1持有a1对象的锁\",{\"1\":{\"139\":1}}],[\"因为线程readthread读取了主内存的ready为false\",{\"1\":{\"131\":1}}],[\"因为线程之间的执行顺序不确定\",{\"1\":{\"119\":1}}],[\"因为代码有可能发生指令重排序\",{\"1\":{\"128\":1}}],[\"因为这些问题容易成为\",{\"1\":{\"123\":1}}],[\"因为左侧的表达式有一个handler=\",{\"1\":{\"85\":1}}],[\"因为两个handler标签值不一样\",{\"1\":{\"85\":1}}],[\"因为重排序并不影响运行结果\",{\"1\":{\"19\":1,\"121\":1}}],[\"恢复正在等待进入屏障的线程数量\",{\"1\":{\"214\":1,\"215\":1}}],[\"恢复另一个线程的上下文信息\",{\"1\":{\"120\":1}}],[\"恢复等管理\",{\"1\":{\"63\":1}}],[\"让调用线程重新执行\",{\"1\":{\"186\":1}}],[\"让调用线程等待\",{\"1\":{\"186\":1}}],[\"让等待时间最久的线程获得锁\",{\"1\":{\"184\":1}}],[\"让步出线程\",{\"1\":{\"175\":1}}],[\"让多个任务看上去同时在运行\",{\"1\":{\"120\":1}}],[\"让其他的对象可以访问这个实例\",{\"1\":{\"16\":1}}],[\"存入map中\",{\"1\":{\"376\":1}}],[\"存入arrayblockingqueue中\",{\"1\":{\"271\":1}}],[\"存在及合理\",{\"1\":{\"401\":1}}],[\"存在循环使用\",{\"1\":{\"287\":1}}],[\"存在并发访问的情况\",{\"1\":{\"119\":1}}],[\"存数元素索引\",{\"1\":{\"277\":1}}],[\"存放任务的阻塞队列\",{\"1\":{\"308\":1}}],[\"存放元素的线程\",{\"1\":{\"277\":1}}],[\"存放元素e\",{\"1\":{\"238\":1}}],[\"存放实际元素的数组\",{\"1\":{\"270\":1}}],[\"存储元素过程\",{\"0\":{\"376\":1}}],[\"存储arraylist元素的数组缓冲区\",{\"1\":{\"358\":1}}],[\"存储自身的运行时数据\",{\"1\":{\"149\":1}}],[\"存储采集到的数据\",{\"1\":{\"101\":1}}],[\"存储了node\",{\"1\":{\"72\":1}}],[\"充分利用cpu的处理能力\",{\"1\":{\"118\":1}}],[\"操作的核心组件之一\",{\"1\":{\"404\":1}}],[\"操作的效率\",{\"1\":{\"403\":1,\"412\":1}}],[\"操作完成时同时执行其他任务\",{\"1\":{\"403\":1}}],[\"操作都是基于通道进行的\",{\"1\":{\"403\":1}}],[\"操作\",{\"1\":{\"222\":1,\"393\":1,\"403\":2,\"404\":1,\"407\":3,\"412\":1}}],[\"操作为原子性的\",{\"1\":{\"126\":1}}],[\"操作系统资源和上下文切换开销\",{\"1\":{\"300\":1}}],[\"操作系统能够合理地分配cpu资源\",{\"1\":{\"118\":1}}],[\"操作系统增加了进程与线程\",{\"1\":{\"118\":1}}],[\"操作符是比较两个变量的内存地址\",{\"1\":{\"430\":1}}],[\"操作符去判断引用类型的变量\",{\"1\":{\"429\":1}}],[\"操作符\",{\"0\":{\"84\":1},\"1\":{\"95\":1}}],[\"许多\",{\"1\":{\"118\":1}}],[\"硬盘驱动器\",{\"1\":{\"118\":1}}],[\"显示器\",{\"1\":{\"118\":1}}],[\"显示告警消息已经收到\",{\"1\":{\"109\":1}}],[\"输出部分的bufferedoutputstream\",{\"1\":{\"401\":1}}],[\"输出字节流outputstream\",{\"1\":{\"401\":1}}],[\"输出结果\",{\"1\":{\"247\":1}}],[\"输出\",{\"1\":{\"191\":1,\"393\":2,\"424\":2}}],[\"输出设备\",{\"1\":{\"118\":1}}],[\"输出如下\",{\"1\":{\"47\":1,\"54\":1,\"158\":1,\"159\":1,\"432\":1}}],[\"输入字节流inputstream\",{\"1\":{\"401\":1}}],[\"输入\",{\"1\":{\"118\":1}}],[\"表明该类不能被继承\",{\"1\":{\"435\":1}}],[\"表明hashset支持序列\",{\"1\":{\"381\":1,\"391\":1}}],[\"表明hashmap支持序列\",{\"1\":{\"373\":1}}],[\"表明hashmap支持克隆\",{\"1\":{\"373\":1,\"381\":1,\"391\":1}}],[\"表明arraylist支持序列\",{\"1\":{\"357\":1}}],[\"表明arraylist支持克隆\",{\"1\":{\"357\":1}}],[\"表明arraylist支持随机访问\",{\"1\":{\"357\":1}}],[\"表明任务还没有结束\",{\"1\":{\"330\":1}}],[\"表中的元素的hash值与key的hash值相等\",{\"1\":{\"260\":1}}],[\"表不为空\",{\"1\":{\"259\":1}}],[\"表不为空并且表的长度大于0并且key所在的桶不为空\",{\"1\":{\"260\":1}}],[\"表不为空并且表的长度大于0\",{\"1\":{\"259\":1}}],[\"表为空或者表的长度为0\",{\"1\":{\"259\":1}}],[\"表\",{\"1\":{\"256\":1}}],[\"表的最大容量\",{\"1\":{\"256\":1}}],[\"表达式的含义是计算每分钟handler=\",{\"1\":{\"116\":1}}],[\"表示不可改变的\",{\"1\":{\"437\":1}}],[\"表示变量或者方法定义后不能被修改或者重写\",{\"1\":{\"435\":1}}],[\"表示文件或目录的抽象类\",{\"1\":{\"399\":1}}],[\"表示实际用于存储位信息的\",{\"1\":{\"393\":1}}],[\"表示删除成功\",{\"1\":{\"388\":1}}],[\"表示删除操作是否成功\",{\"1\":{\"388\":1}}],[\"表示已经存在相同的元素\",{\"1\":{\"386\":1}}],[\"表示已满\",{\"1\":{\"273\":1}}],[\"表示添加操作是否成功\",{\"1\":{\"386\":1}}],[\"表示添加成功\",{\"1\":{\"386\":1}}],[\"表示添加元素是否成功\",{\"1\":{\"386\":1}}],[\"表示值的类型\",{\"1\":{\"374\":1}}],[\"表示键的类型\",{\"1\":{\"374\":1}}],[\"表示插入操作成功\",{\"1\":{\"368\":1}}],[\"表示\",{\"1\":{\"346\":1,\"362\":1,\"387\":1,\"393\":1}}],[\"表示任务已经结束但是任务执行线程还没来得及给outcome赋值\",{\"1\":{\"331\":1}}],[\"表示是个新的任务或者还没被执行完的任务\",{\"1\":{\"328\":1}}],[\"表示需要执行的具体任务\",{\"1\":{\"323\":1}}],[\"表示具体的任务\",{\"1\":{\"323\":2}}],[\"表示运行可中断\",{\"1\":{\"313\":1}}],[\"表示线程池正在进行一些清理工作\",{\"1\":{\"293\":1}}],[\"表示线程池已经终止\",{\"1\":{\"293\":1}}],[\"表示线程池已经停止\",{\"1\":{\"293\":1}}],[\"表示线程池已经关闭\",{\"1\":{\"293\":1}}],[\"表示线程池处于运行状态\",{\"1\":{\"293\":1}}],[\"表示可以被序列化\",{\"1\":{\"269\":1}}],[\"表示可以随机访\",{\"1\":{\"232\":1}}],[\"表示在snapshot与current之间\",{\"1\":{\"239\":1}}],[\"表示在snapshot与current之间修改了数组\",{\"1\":{\"239\":1}}],[\"表示一个工作任务已经完成\",{\"1\":{\"190\":1}}],[\"表示采用公平策略获取锁\",{\"1\":{\"185\":1}}],[\"表示采用非公平策略获取锁\",{\"1\":{\"184\":1}}],[\"表示没有线程正在竞争该锁\",{\"1\":{\"183\":1}}],[\"表示生成一个条件\",{\"1\":{\"179\":1}}],[\"表示此节点在condition\",{\"1\":{\"173\":1}}],[\"表示无状态\",{\"1\":{\"173\":1}}],[\"表示状态为cancelled\",{\"1\":{\"173\":1}}],[\"表示当前锁空闲\",{\"1\":{\"175\":1}}],[\"表示当前只有锁的对象\",{\"1\":{\"175\":1}}],[\"表示当前场景下后续的acquireshared能够得以执行\",{\"1\":{\"168\":2}}],[\"表示当前节点在sync\",{\"1\":{\"168\":1}}],[\"表示当前节点在sync队列中\",{\"1\":{\"168\":1}}],[\"表示当前节点在等待condition\",{\"1\":{\"168\":2}}],[\"表示当前节点的后继节点包含的线程需要运行\",{\"1\":{\"168\":2}}],[\"表示当前的线程被取消\",{\"1\":{\"168\":2}}],[\"表示聚合的级别和规则标签的输出\",{\"1\":{\"115\":1}}],[\"表示小于0\",{\"1\":{\"78\":2}}],[\"表示的是当前系统文件系统中磁盘可用的字节数\",{\"1\":{\"77\":1}}],[\"该变量的值一旦被赋值\",{\"1\":{\"437\":1}}],[\"该变量的值不能被修改\",{\"1\":{\"435\":1}}],[\"该对象在实例化时\",{\"1\":{\"401\":1}}],[\"该对象既可以对文件进行读操作\",{\"1\":{\"401\":1}}],[\"该对象只能操作文件\",{\"1\":{\"401\":1}}],[\"该对象特点\",{\"1\":{\"401\":1}}],[\"该对象并不是流体系中的一员\",{\"1\":{\"401\":1}}],[\"该任务返回一个固定的整数值\",{\"1\":{\"339\":1,\"340\":1}}],[\"该异常也会被返回\",{\"1\":{\"315\":1}}],[\"该状态的线程不会接收新任务\",{\"1\":{\"309\":1}}],[\"该状态的线程池不会接收新任务\",{\"1\":{\"309\":1}}],[\"该状态的线程池会接收新任务\",{\"1\":{\"309\":1}}],[\"该参数提供了线程池中线程的创建方式\",{\"1\":{\"301\":1}}],[\"该索引的值赋值为null\",{\"1\":{\"275\":1}}],[\"该队列支持在队列已满或为空时的阻塞操作\",{\"1\":{\"264\":1}}],[\"该操作会使得触发treeifybin操作的某个桶中的所有元素进行一次重新分配\",{\"1\":{\"259\":1}}],[\"该桶为空\",{\"1\":{\"259\":1}}],[\"该无限循环可以确保成功插入数据\",{\"1\":{\"259\":1}}],[\"该table表中该结点的hash值大于0\",{\"1\":{\"259\":1}}],[\"该结点前驱为空\",{\"1\":{\"259\":1}}],[\"该结点的hash值为moved\",{\"1\":{\"259\":1}}],[\"该结点不为为空\",{\"1\":{\"173\":1}}],[\"该抽象类定义了一些基本操作\",{\"1\":{\"249\":1}}],[\"该构造函数用于创建一个具有给定的\",{\"1\":{\"271\":2}}],[\"该构造函数用于创建一个带有给定的\",{\"1\":{\"271\":1}}],[\"该构造函数用于创建一个保存给定数组的副本的列表\",{\"1\":{\"234\":1}}],[\"该构造函数用于创建一个按\",{\"1\":{\"234\":1}}],[\"该构造函数的处理流程如下\",{\"1\":{\"234\":1}}],[\"该构造函数仅仅执行了关联该cyclicbarrier的线程数量\",{\"1\":{\"211\":1}}],[\"该构造函数可以指定关联该cyclicbarrier的线程数量\",{\"1\":{\"210\":1}}],[\"该构造函数可以构造一个用给定计数初始化的countdownlatch\",{\"1\":{\"196\":1}}],[\"该执行动作由最后一个进行屏障的线程执行\",{\"1\":{\"210\":1}}],[\"该属性有一个为reentrantlock对象\",{\"1\":{\"208\":1}}],[\"该方法不能被子类重写\",{\"1\":{\"435\":1,\"437\":1}}],[\"该方法将返回\",{\"1\":{\"407\":1}}],[\"该方法将需要删除元素的位置\",{\"1\":{\"362\":1}}],[\"该方法用于判断\",{\"1\":{\"363\":1}}],[\"该方法用于删除指定的元素\",{\"1\":{\"362\":1}}],[\"该方法定义如下\",{\"1\":{\"331\":1}}],[\"该方法实现如下\",{\"1\":{\"329\":1,\"333\":1}}],[\"该方法在共享模式下释放\",{\"1\":{\"198\":1}}],[\"该方法中可能会调用到aqs的doreleaseshared方法\",{\"1\":{\"198\":1}}],[\"该方法设置头结点并且释放头结点后面的满足条件的结点\",{\"1\":{\"198\":1}}],[\"该函数的流程如下\",{\"1\":{\"239\":1}}],[\"该函数的作用就是为了释放node节点的后继结点\",{\"1\":{\"173\":1}}],[\"该函数用于添加元素\",{\"1\":{\"239\":1}}],[\"该函数只是简单的判断aqs的state是否为0\",{\"1\":{\"198\":1}}],[\"该函数完成的功能就是取消当前线程对资源的获取\",{\"1\":{\"173\":1}}],[\"该函数以独占模式获取\",{\"1\":{\"173\":1}}],[\"该图应该很容易看懂\",{\"1\":{\"152\":1}}],[\"该图主要是对上述内容的总结\",{\"1\":{\"152\":1}}],[\"该线程就会添加到sync\",{\"1\":{\"185\":1}}],[\"该线程就可以在接下来的操作中直接操作被锁定的对象\",{\"1\":{\"151\":1}}],[\"该线程必须重新获取锁\",{\"1\":{\"169\":1}}],[\"该线程即为monitor的所有者\",{\"1\":{\"147\":1}}],[\"该协议的核心思想是\",{\"1\":{\"124\":1}}],[\"该表达式的计算时间间隔为1分钟\",{\"1\":{\"116\":1}}],[\"该类不能被继承\",{\"1\":{\"437\":1}}],[\"该类使用抽象工厂模式创建不同的产品对象\",{\"1\":{\"47\":1}}],[\"该类的职责是唯一的\",{\"1\":{\"14\":1}}],[\"实际调用的是该对象的实际类型中定义的方法\",{\"1\":{\"424\":1}}],[\"实际上调用的是\",{\"1\":{\"424\":1}}],[\"实际上会调用子类中的方法\",{\"1\":{\"424\":1}}],[\"实际上是使用\",{\"1\":{\"382\":1}}],[\"实际上forkjointask\",{\"1\":{\"348\":1}}],[\"实际上都源于对可见性\",{\"1\":{\"122\":1}}],[\"实例\",{\"1\":{\"247\":1,\"407\":1}}],[\"实例数据\",{\"1\":{\"149\":1}}],[\"实战\",{\"0\":{\"116\":1}}],[\"实现接口的类必须提供所有抽象方法的具体实现\",{\"1\":{\"419\":1}}],[\"实现方式\",{\"1\":{\"419\":1}}],[\"实现方式有两种\",{\"1\":{\"96\":1}}],[\"实现高效的多路复用\",{\"1\":{\"410\":1,\"411\":1}}],[\"实现高效的数据处理\",{\"1\":{\"406\":1}}],[\"实现\",{\"1\":{\"364\":1}}],[\"实现并发和并行操作\",{\"1\":{\"343\":1}}],[\"实现如下\",{\"1\":{\"332\":1}}],[\"实现异步任务的提交和获取执行结果\",{\"1\":{\"323\":1}}],[\"实现线程安全的数据传递\",{\"1\":{\"267\":1}}],[\"实现类也可以重写接口的默认方法\",{\"1\":{\"419\":1}}],[\"实现类\",{\"1\":{\"224\":1,\"266\":1}}],[\"实现读并发性能的提升\",{\"1\":{\"220\":1}}],[\"实现更灵活的线程协作机制\",{\"1\":{\"188\":1}}],[\"实现公平锁\",{\"1\":{\"175\":1}}],[\"实现的\",{\"1\":{\"152\":1,\"382\":1}}],[\"实现代理如下\",{\"1\":{\"56\":1}}],[\"实现被代理对象的接口\",{\"1\":{\"53\":1}}],[\"实现抽象工厂类中定义的工厂方法makesofa\",{\"1\":{\"43\":1}}],[\"实现了java的跨平台特性\",{\"1\":{\"433\":1}}],[\"实现了多态性的特性\",{\"1\":{\"424\":1}}],[\"实现了代码的灵活性和扩展性\",{\"1\":{\"424\":1}}],[\"实现了零拷贝的优化功能\",{\"1\":{\"416\":1}}],[\"实现了高效的数据传输\",{\"1\":{\"404\":1}}],[\"实现了高效的并发访问\",{\"1\":{\"222\":1}}],[\"实现了动态调整数组容量\",{\"1\":{\"358\":1}}],[\"实现了\",{\"1\":{\"347\":1,\"348\":1,\"357\":1,\"419\":1}}],[\"实现了runnable接口\",{\"1\":{\"313\":1}}],[\"实现了executorservice\",{\"1\":{\"316\":1}}],[\"实现了executor\",{\"1\":{\"311\":1}}],[\"实现了生产者\",{\"1\":{\"267\":1}}],[\"实现了serializable接口表示concurrenthashmap可以被序列化\",{\"1\":{\"249\":1}}],[\"实现了公平获取原则\",{\"1\":{\"185\":1}}],[\"实现了抽象主题类\",{\"1\":{\"54\":1}}],[\"实现了抽象主题类的方法\",{\"1\":{\"53\":1}}],[\"实现了抽象接口类\",{\"1\":{\"53\":1}}],[\"实现了抽象工厂\",{\"1\":{\"47\":1}}],[\"实现了抽象工厂接口\",{\"1\":{\"46\":1}}],[\"实现了抽象产品类的属性和方法\",{\"1\":{\"40\":1,\"43\":1,\"46\":1}}],[\"实现了itypec的目标接口接口\",{\"1\":{\"26\":1}}],[\"实现了usb接口\",{\"1\":{\"25\":1}}],[\"应始终返回相同的值\",{\"1\":{\"431\":1}}],[\"应返回false\",{\"1\":{\"430\":1}}],[\"应返回true\",{\"1\":{\"430\":1}}],[\"应该属于字符流的范围\",{\"1\":{\"401\":1}}],[\"应该遵循通用的方式\",{\"1\":{\"115\":1}}],[\"应用非常的广泛\",{\"1\":{\"373\":1}}],[\"应对面试应该是足够的\",{\"1\":{\"13\":1}}],[\"命名冲突\",{\"1\":{\"420\":1}}],[\"命名规范\",{\"0\":{\"115\":1}}],[\"命令生成编译后的\",{\"1\":{\"147\":1}}],[\"命令模式\",{\"1\":{\"12\":1}}],[\"警报规则的名称必须是有效的标签值\",{\"1\":{\"113\":1}}],[\"记录为\",{\"1\":{\"392\":2}}],[\"记录完成任务的数量\",{\"1\":{\"313\":1}}],[\"记录sizectl中的大小所需要进行的偏移位数\",{\"1\":{\"256\":1}}],[\"记录加锁次数\",{\"1\":{\"175\":1}}],[\"记录规则的名称必须是有效的指标名称\",{\"1\":{\"113\":1}}],[\"记录和告警规则存在于规则组中\",{\"1\":{\"113\":1}}],[\"评估时间相同\",{\"1\":{\"113\":1}}],[\"评估等待时间\",{\"1\":{\"108\":1}}],[\"预留方法\",{\"1\":{\"319\":1}}],[\"预先估计池和队列的容量\",{\"1\":{\"300\":1}}],[\"预先启动一定数量的核心线程等\",{\"1\":{\"293\":1}}],[\"预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多\",{\"1\":{\"112\":1}}],[\"预期的结果应该是2\",{\"1\":{\"124\":1}}],[\"预测指标变化趋势\",{\"0\":{\"93\":1}}],[\"预测系统磁盘在6个小时之后的剩余情况\",{\"1\":{\"77\":1}}],[\"q\",{\"1\":{\"259\":4,\"317\":9,\"331\":9,\"333\":8}}],[\"qq\",{\"1\":{\"111\":1}}],[\"quite\",{\"1\":{\"240\":1}}],[\"queued=true\",{\"1\":{\"331\":1}}],[\"queued\",{\"1\":{\"311\":1,\"317\":3,\"331\":3}}],[\"queueisempty\",{\"1\":{\"277\":1}}],[\"queue<e>\",{\"1\":{\"265\":1}}],[\"queue队列还没有初始化\",{\"1\":{\"173\":1}}],[\"queue尾部添加结点\",{\"1\":{\"173\":1}}],[\"queue\",{\"0\":{\"226\":1},\"1\":{\"173\":1,\"187\":15,\"193\":2,\"214\":1,\"222\":1,\"267\":4,\"311\":1,\"312\":1,\"314\":1,\"331\":1,\"351\":3}}],[\"queue中的尾部\",{\"1\":{\"185\":1}}],[\"queue中的结点不断尝试获取资源\",{\"1\":{\"173\":1}}],[\"queue中\",{\"1\":{\"168\":2,\"173\":1}}],[\"querying\",{\"1\":{\"95\":1}}],[\"quantile函数进行计算\",{\"1\":{\"94\":1}}],[\"quantile函数在prometheus\",{\"1\":{\"79\":1}}],[\"quantile\",{\"1\":{\"78\":1,\"90\":2,\"94\":3,\"100\":1}}],[\"quantile=\",{\"1\":{\"68\":5,\"79\":5}}],[\"参与的线程数量小于等于0\",{\"1\":{\"210\":1}}],[\"参与的线程数量\",{\"1\":{\"208\":1}}],[\"参数的顺序也可以不同\",{\"1\":{\"418\":1}}],[\"参数的个数也可以不同\",{\"1\":{\"418\":1}}],[\"参数的类型可以不同\",{\"1\":{\"418\":1}}],[\"参数的配置会在以后的文章中讲解\",{\"1\":{\"107\":1}}],[\"参数为true表示公平策略\",{\"1\":{\"181\":1}}],[\"参考\",{\"0\":{\"216\":1,\"262\":1,\"278\":1,\"289\":1,\"320\":1,\"334\":1,\"350\":1,\"396\":1}}],[\"参考资料\",{\"0\":{\"137\":1,\"176\":1}}],[\"参考文档\",{\"0\":{\"111\":1,\"200\":1}}],[\"发起任务线程跟执行任务线程通常情况下都不会是同一个线程\",{\"1\":{\"329\":1}}],[\"发生内存泄露的场景一般存在于线程池的情况下\",{\"1\":{\"287\":1}}],[\"发生时\",{\"1\":{\"223\":1,\"229\":1}}],[\"发现某些对象不可能被其他线程访问到时\",{\"1\":{\"153\":1}}],[\"发送的告警消息的json格式如下\",{\"1\":{\"110\":1}}],[\"发布者对象可以对所有的观察者发送消息\",{\"1\":{\"51\":1}}],[\"发布者publisher\",{\"1\":{\"49\":1}}],[\"允许单个线程同时监听多个通道的事件\",{\"1\":{\"407\":1}}],[\"允许单个线程处理多个通道\",{\"1\":{\"403\":1}}],[\"允许将读取的字节推回输入流中\",{\"1\":{\"401\":1}}],[\"允许包含重复的元素\",{\"1\":{\"352\":1}}],[\"允许元素的重复\",{\"1\":{\"352\":1}}],[\"允许重复元素\",{\"1\":{\"351\":1}}],[\"允许多个线程同时获取读锁\",{\"1\":{\"218\":1}}],[\"允许同一个线程多次获取同一把锁\",{\"1\":{\"218\":1}}],[\"允许同一个线程多次获取同一把锁而不发生死锁\",{\"1\":{\"188\":1}}],[\"允许用户指定要附加到告警上的一组附加标签\",{\"1\":{\"108\":1}}],[\"允许prometheus运行\",{\"1\":{\"67\":1}}],[\"自反性\",{\"1\":{\"430\":1}}],[\"自定义异常类通常继承自exception或runtimeexception类\",{\"1\":{\"432\":1}}],[\"自定义异常\",{\"1\":{\"432\":1}}],[\"自定义反序列化逻辑\",{\"1\":{\"183\":1}}],[\"自定义同步器在实现时只需要实现共享资源\",{\"1\":{\"164\":1}}],[\"自定义标签\",{\"1\":{\"108\":1}}],[\"自旋时间spinfortimeoutthreshold\",{\"1\":{\"170\":1}}],[\"自旋时间\",{\"1\":{\"170\":1}}],[\"自旋锁会让线程在一个循环内忙等待\",{\"1\":{\"153\":1}}],[\"自旋操作可能会导致额外的开销\",{\"1\":{\"151\":1}}],[\"自适应的cas自旋\",{\"1\":{\"149\":1}}],[\"自动拆箱\",{\"1\":{\"423\":1}}],[\"自动装箱\",{\"1\":{\"423\":1}}],[\"自动插入内存屏障\",{\"1\":{\"145\":1}}],[\"自动创建hugryinstance的静态实例\",{\"1\":{\"18\":1}}],[\"$value\",{\"1\":{\"108\":1}}],[\"源代码如下\",{\"1\":{\"215\":1}}],[\"源码解析\",{\"0\":{\"384\":1}}],[\"源码可知\",{\"1\":{\"198\":1}}],[\"源码如下\",{\"1\":{\"173\":3,\"184\":1,\"185\":1,\"367\":1}}],[\"源码下载\",{\"0\":{\"24\":1,\"28\":1,\"33\":1}}],[\"源\",{\"1\":{\"107\":1}}],[\"即它成为一个常量\",{\"1\":{\"435\":1}}],[\"即它们是否指向同一个对象\",{\"1\":{\"429\":1}}],[\"即当一个类同时继承自两个具有共同父类的类时\",{\"1\":{\"420\":1}}],[\"即当前插入的节点即为头节点\",{\"1\":{\"368\":1}}],[\"即在没有数据可读或可写时并不会阻塞线程\",{\"1\":{\"404\":1}}],[\"即在开始执行之前\",{\"1\":{\"141\":1}}],[\"即覆盖原有的内容\",{\"1\":{\"401\":1}}],[\"即把bit为true的元素复制到另一个数组\",{\"1\":{\"395\":1}}],[\"即总共能表示的位的数量\",{\"1\":{\"393\":1}}],[\"即表示\",{\"1\":{\"387\":1}}],[\"即是否存在指定的元素\",{\"1\":{\"387\":1}}],[\"即达到了负载因子阈值\",{\"1\":{\"376\":1}}],[\"即\",{\"1\":{\"370\":6}}],[\"即将\",{\"1\":{\"368\":1}}],[\"即判断\",{\"1\":{\"364\":2}}],[\"即常数时间\",{\"1\":{\"358\":1}}],[\"即future可以拿到异步执行任务各种结果\",{\"1\":{\"315\":1}}],[\"即倘若线程池shutdown状态\",{\"1\":{\"311\":1}}],[\"即高3位为011\",{\"1\":{\"309\":1}}],[\"即高3位为010\",{\"1\":{\"309\":1}}],[\"即高3位为001\",{\"1\":{\"309\":1}}],[\"即高3位为000\",{\"1\":{\"309\":1}}],[\"即高3位为111\",{\"1\":{\"309\":1}}],[\"即使在try块或catch块中出现return语句\",{\"1\":{\"437\":1}}],[\"即使线程处于空闲状态也不被销毁\",{\"1\":{\"295\":1}}],[\"即使某个操作在高级语言层面看起来是单个操作\",{\"1\":{\"120\":1}}],[\"即object数组为空\",{\"1\":{\"275\":1}}],[\"即最多可以存储3个元素\",{\"1\":{\"267\":1}}],[\"即删除了e结点\",{\"1\":{\"261\":1}}],[\"即table表中的结点\",{\"1\":{\"259\":1}}],[\"即为最后一个结点\",{\"1\":{\"259\":1}}],[\"即为cancelled\",{\"1\":{\"173\":1}}],[\"即进行了结点值的更新\",{\"1\":{\"259\":1}}],[\"即内部的队列是否有容量限制\",{\"1\":{\"226\":1}}],[\"即条件队列是否为空\",{\"1\":{\"214\":1}}],[\"即唤醒所有等待线程\",{\"1\":{\"214\":1}}],[\"即生成下一个版本\",{\"1\":{\"214\":1}}],[\"即其他线程已经完成任务\",{\"1\":{\"190\":1}}],[\"即资源已经被线程占据\",{\"1\":{\"185\":1}}],[\"即设置该结点的状态为cancelled\",{\"1\":{\"173\":1}}],[\"即不为cancelled状态的结点\",{\"1\":{\"173\":1}}],[\"即禁用当前线程\",{\"1\":{\"173\":1}}],[\"即还没被初始化\",{\"1\":{\"173\":1,\"214\":1}}],[\"即还没有被初始化过\",{\"1\":{\"173\":1}}],[\"即已经被初始化过\",{\"1\":{\"173\":1,\"214\":1}}],[\"即已经被初始化\",{\"1\":{\"173\":1}}],[\"即需要子类去重写此函数完成自己的逻辑\",{\"1\":{\"173\":1}}],[\"即线程在aquire过程中\",{\"1\":{\"173\":1}}],[\"即线程创建\",{\"1\":{\"155\":1}}],[\"即返回false\",{\"1\":{\"142\":1}}],[\"即先申请资源序号较小的\",{\"1\":{\"141\":1}}],[\"即一次性申请所有所需的资源\",{\"1\":{\"141\":1}}],[\"即一个指标代表一种含义\",{\"1\":{\"74\":1}}],[\"即下面所述的死锁发生条件\",{\"1\":{\"140\":1}}],[\"即a2和a1\",{\"1\":{\"139\":1}}],[\"即alertmanager通过http接口调用来发送告警消息\",{\"1\":{\"107\":1}}],[\"即只允许一个线程执行对共享数据的操作\",{\"1\":{\"124\":1}}],[\"即多个线程并发访问共享的资源\",{\"1\":{\"119\":1}}],[\"邮箱等\",{\"1\":{\"107\":1}}],[\"微信\",{\"1\":{\"107\":1}}],[\"再次切换为读取模式\",{\"1\":{\"406\":1}}],[\"再次写入数据\",{\"1\":{\"406\":1}}],[\"再次发送通知前等待的时间\",{\"1\":{\"107\":1}}],[\"再通过\",{\"1\":{\"405\":1}}],[\"再实际的开发中\",{\"1\":{\"343\":1}}],[\"再假设这两个线程在加入阻塞队列进行阻塞等待之前任务都没有执行完成且threada和threadb都没有被中断的情况下\",{\"1\":{\"331\":1}}],[\"再从workerqueue中取task\",{\"1\":{\"313\":1}}],[\"再遍历桶\",{\"1\":{\"260\":1}}],[\"再复制index索引后的元素\",{\"1\":{\"241\":1}}],[\"再设置数组\",{\"1\":{\"239\":1}}],[\"再设置newelements\",{\"1\":{\"239\":1}}],[\"再设置当前object\",{\"1\":{\"238\":1}}],[\"再执行对账操作\",{\"1\":{\"191\":1}}],[\"再加入队列尾部\",{\"1\":{\"185\":1}}],[\"再来看acquirequeued函数的整个的逻辑\",{\"1\":{\"173\":1}}],[\"再来看一下同步方法\",{\"1\":{\"147\":1}}],[\"再看final块中的cancelacquire函数\",{\"1\":{\"173\":1}}],[\"再看parkandcheckinterrupt函数\",{\"1\":{\"173\":1}}],[\"再看一下破坏循环等待条件的例子\",{\"1\":{\"143\":1}}],[\"再重新尝试获取monitor的所有权\",{\"1\":{\"147\":1}}],[\"再获取目标账户的锁\",{\"1\":{\"143\":1}}],[\"再申请资源序号较大的\",{\"1\":{\"141\":1}}],[\"再比如\",{\"1\":{\"126\":1}}],[\"再比如下面的查询语句的可以输出结果\",{\"1\":{\"85\":1}}],[\"再简单回顾一些上一篇文章讲解的并发编程的有三个概念\",{\"1\":{\"125\":1}}],[\"再回答这个问题之前\",{\"1\":{\"118\":1}}],[\"或表达式\",{\"1\":{\"436\":1}}],[\"或接受\",{\"1\":{\"407\":1}}],[\"或直接迭代bitset中bit为true的元素iterate\",{\"1\":{\"395\":1}}],[\"或是来自于其他工作线程的队列任务\",{\"1\":{\"347\":1}}],[\"或\",{\"1\":{\"173\":2,\"295\":1,\"337\":1,\"341\":1,\"343\":1,\"424\":1}}],[\"或等待同一组告警采集更多初始告警后一起发送\",{\"1\":{\"107\":1}}],[\"或者结合两者的特点使用混合编程\",{\"1\":{\"422\":1}}],[\"或者参数的类型不同\",{\"1\":{\"418\":1}}],[\"或者从通道写入到缓冲区\",{\"1\":{\"404\":1}}],[\"或者fileinputstream\",{\"1\":{\"401\":1}}],[\"或者红黑树\",{\"1\":{\"374\":1}}],[\"或者更确切的说是返回任务的状态\",{\"1\":{\"333\":1}}],[\"或者取消任务\",{\"1\":{\"333\":1}}],[\"或者执行异常\",{\"1\":{\"332\":1}}],[\"或者已经被取消\",{\"1\":{\"329\":2}}],[\"或者由于某些原因不能取消\",{\"1\":{\"326\":1}}],[\"或者等待执行结果并获取执行结果\",{\"1\":{\"326\":1}}],[\"或者有容量限制的linkedblockingqueue\",{\"1\":{\"297\":1}}],[\"或者set失败\",{\"1\":{\"184\":1}}],[\"或者当前线程是等待队列中第一个线程\",{\"1\":{\"175\":1}}],[\"或者\",{\"1\":{\"173\":1}}],[\"或者比较设置不成功\",{\"1\":{\"173\":1}}],[\"或者是参数的顺序不同\",{\"1\":{\"418\":1}}],[\"或者是线程池已经处于关闭状态但还在处理进行中的任务\",{\"1\":{\"302\":1}}],[\"或者是0\",{\"1\":{\"173\":1}}],[\"或者是compareandsettail操作失败\",{\"1\":{\"173\":1}}],[\"或者将外部数据传输到系统内存中\",{\"1\":{\"118\":1}}],[\"或者重启的进程的时候重置为0\",{\"1\":{\"75\":1}}],[\"或者静态的配置文件\",{\"1\":{\"64\":1}}],[\"或者被称为被观察者\",{\"1\":{\"49\":1}}],[\"或者访问资源配置文件的reader\",{\"1\":{\"16\":1}}],[\"默认被\",{\"1\":{\"419\":1}}],[\"默认方法\",{\"1\":{\"419\":2}}],[\"默认会初始化容量大小为defaultcapacity\",{\"1\":{\"359\":1}}],[\"默认使用这个工厂创建工作线程\",{\"1\":{\"347\":1}}],[\"默认使用executors\",{\"1\":{\"294\":1}}],[\"默认情况下\",{\"1\":{\"301\":1}}],[\"默认情况下是一个无界队列\",{\"1\":{\"266\":1}}],[\"默认为64\",{\"1\":{\"374\":1,\"376\":1,\"395\":1}}],[\"默认为8\",{\"1\":{\"374\":1,\"376\":1}}],[\"默认为无界队列\",{\"1\":{\"266\":1,\"297\":1}}],[\"默认为独占模式\",{\"1\":{\"173\":1}}],[\"默认并发数\",{\"1\":{\"256\":1}}],[\"默认表的大小\",{\"1\":{\"256\":1}}],[\"默认非公平锁\",{\"1\":{\"219\":1,\"220\":1}}],[\"默认alertname\",{\"1\":{\"107\":1}}],[\"默认的配置文件如下\",{\"1\":{\"106\":1}}],[\"接受连接等事件\",{\"1\":{\"412\":1}}],[\"接受连接\",{\"1\":{\"411\":3}}],[\"接着通过\",{\"1\":{\"415\":1}}],[\"接着将节点\",{\"1\":{\"370\":1}}],[\"接着\",{\"1\":{\"323\":3,\"406\":1}}],[\"接着我们再看unparksuccessor函数\",{\"1\":{\"173\":1}}],[\"接下来分析下这些操作\",{\"1\":{\"329\":1}}],[\"接下来会从源码的角度来探讨几种经典的并发容器\",{\"1\":{\"227\":1}}],[\"接下来将具体分析reentrantlock的源码\",{\"1\":{\"177\":1}}],[\"接收人一般配合告警路由使用\",{\"1\":{\"106\":1}}],[\"接收人是一个抽象的概念\",{\"1\":{\"106\":1}}],[\"接收人\",{\"1\":{\"106\":1}}],[\"接口只提供方法的声明\",{\"1\":{\"419\":1}}],[\"接口也可以包含默认方法和静态方法\",{\"1\":{\"419\":1}}],[\"接口还为多重继承提供了解决方案\",{\"1\":{\"419\":1}}],[\"接口中的常量默认是静态常量\",{\"1\":{\"419\":1}}],[\"接口中的元素按照插入的顺序存储\",{\"1\":{\"352\":1}}],[\"接口animal\",{\"1\":{\"419\":1}}],[\"接口定义中可以包含常量\",{\"1\":{\"419\":1}}],[\"接口定义了常用的操作方法\",{\"1\":{\"354\":1}}],[\"接口定义了很多常用的方法\",{\"1\":{\"352\":1}}],[\"接口可以被类实现\",{\"1\":{\"419\":1}}],[\"接口使用interface关键字定义的\",{\"1\":{\"419\":1}}],[\"接口继承自\",{\"1\":{\"353\":1}}],[\"接口是集合框架中用于存储键值对\",{\"1\":{\"354\":1}}],[\"接口是\",{\"1\":{\"352\":1,\"353\":1}}],[\"接口有多个实现类\",{\"1\":{\"266\":1}}],[\"接口提供了一系列方法来支持队列的操作\",{\"1\":{\"265\":1}}],[\"接口支持条件变量\",{\"1\":{\"188\":1}}],[\"接口\",{\"0\":{\"352\":1},\"1\":{\"105\":1,\"228\":1,\"322\":2,\"348\":1,\"352\":1,\"353\":2,\"357\":2,\"364\":1,\"366\":1,\"419\":7}}],[\"接口的设计可以更好地支持代码的组织和抽象\",{\"1\":{\"420\":1}}],[\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为\",{\"1\":{\"419\":1}}],[\"接口的默认方法可以被实现该接口的类直接使用\",{\"1\":{\"419\":1}}],[\"接口的实现类有\",{\"1\":{\"354\":1}}],[\"接口的主要特点如下\",{\"1\":{\"354\":1}}],[\"接口的主要特点包括\",{\"1\":{\"352\":1,\"353\":1}}],[\"接口的子接口之一\",{\"1\":{\"353\":1}}],[\"接口的继承接口之一\",{\"1\":{\"352\":1}}],[\"接口的p90耗时\",{\"1\":{\"94\":1}}],[\"接口的数据\",{\"1\":{\"81\":1}}],[\"接口如戏\",{\"1\":{\"70\":1}}],[\"接口互相隔离\",{\"1\":{\"14\":1}}],[\"接口隔离原则\",{\"1\":{\"14\":1}}],[\"全局配置\",{\"1\":{\"106\":1}}],[\"抑制允许根据另一组警报的存在来静音一组警报\",{\"1\":{\"107\":1}}],[\"抑制规则\",{\"1\":{\"106\":1}}],[\"抑制是当某一告警已经发出\",{\"1\":{\"104\":1}}],[\"抑制\",{\"0\":{\"104\":1}}],[\"抑制和静默等核心功能\",{\"1\":{\"101\":1,\"102\":1}}],[\"路由\",{\"1\":{\"102\":1}}],[\"路由分发\",{\"1\":{\"101\":1}}],[\"则在变量初始化后\",{\"1\":{\"435\":1}}],[\"则需要特殊处理\",{\"1\":{\"431\":1}}],[\"则需要将旧的键值对重新分布到新的\",{\"1\":{\"377\":1}}],[\"则x\",{\"1\":{\"430\":2}}],[\"则y\",{\"1\":{\"430\":1}}],[\"则比较字符串内容是否相等\",{\"1\":{\"430\":1}}],[\"则比较的内容是判断两个变量的引用是否相等\",{\"1\":{\"429\":1}}],[\"则字符串内容肯定是相等\",{\"1\":{\"430\":1}}],[\"则指向一个新创建的字符串对象\",{\"1\":{\"429\":1}}],[\"则判断\",{\"1\":{\"378\":1}}],[\"则判断是否需要park当前线程\",{\"1\":{\"173\":1}}],[\"则首先检查\",{\"1\":{\"378\":1}}],[\"则按链表或红黑树的规则进行处理\",{\"1\":{\"377\":1}}],[\"则更新其对应的值为新的\",{\"1\":{\"376\":2}}],[\"则部分链表节点会转换为红黑树\",{\"1\":{\"374\":1}}],[\"则遍历该位置上的链表或红黑树进行查找操作\",{\"1\":{\"378\":1}}],[\"则遍历该位置上的链表或红黑树进行操作\",{\"1\":{\"376\":1}}],[\"则遍历\",{\"1\":{\"363\":2}}],[\"则报indexoutofboundsexception异常\",{\"1\":{\"363\":1}}],[\"则对空数组进行初始化\",{\"1\":{\"361\":1}}],[\"则对该桶中的结点进行转移\",{\"1\":{\"259\":1}}],[\"则扩容\",{\"1\":{\"360\":1}}],[\"则说明任务或者已经执行完成\",{\"1\":{\"332\":1}}],[\"则cas的把该节点加入waiters队列的首节点\",{\"1\":{\"331\":1}}],[\"则表示删除操作成功\",{\"1\":{\"388\":1}}],[\"则表示\",{\"1\":{\"377\":1}}],[\"则表示任务已经处理完成\",{\"1\":{\"331\":1}}],[\"则表示移除的是数组的最后一个元素\",{\"1\":{\"241\":1}}],[\"则删除对应节点并返回对应的状态\",{\"1\":{\"331\":1}}],[\"则先计算要等待的时间\",{\"1\":{\"331\":1}}],[\"则把thread字段置null并返回结果\",{\"1\":{\"331\":1}}],[\"则把thread显示置空\",{\"1\":{\"331\":1}}],[\"则把当前节点加入waiters首节点并替换原来waiters\",{\"1\":{\"331\":1}}],[\"则构造一个等待节点waitnode\",{\"1\":{\"331\":1}}],[\"则构造一个等待节点\",{\"1\":{\"331\":1}}],[\"则调用红黑树节点的\",{\"1\":{\"378\":1}}],[\"则调用方会阻塞直到任务执行结束返回结果为止\",{\"1\":{\"330\":1}}],[\"则调用setexception\",{\"1\":{\"329\":1}}],[\"则调用addwaiter函数\",{\"1\":{\"173\":1}}],[\"则尝试把当前执行线程保存在runner字段中\",{\"1\":{\"329\":1}}],[\"则尝试将任务排队失败\",{\"1\":{\"298\":1}}],[\"则用来保存异常原因\",{\"1\":{\"328\":1}}],[\"则用v交换操作\",{\"1\":{\"259\":1}}],[\"则无法取消\",{\"1\":{\"322\":1}}],[\"则runnablefuture接口继承了runnable接口和future接口\",{\"1\":{\"322\":1,\"327\":1}}],[\"则reject任务\",{\"1\":{\"311\":1}}],[\"则通过setexception保存异常\",{\"1\":{\"318\":1}}],[\"则通过set方法保存结果\",{\"1\":{\"318\":1}}],[\"则通过threadlocalmap的set方法设置值\",{\"1\":{\"282\":1}}],[\"则直接将键值对存储在该位置\",{\"1\":{\"376\":1}}],[\"则直接计算结果\",{\"1\":{\"349\":1}}],[\"则直接把状态从new转化为cancelled\",{\"1\":{\"332\":1}}],[\"则直接返回false\",{\"1\":{\"332\":1}}],[\"则直接返回\",{\"1\":{\"317\":1,\"329\":1}}],[\"则直接新生一个结点并赋值为之前最后一个结点的下一个结点\",{\"1\":{\"259\":1}}],[\"则抛出\",{\"1\":{\"369\":1,\"370\":1}}],[\"则抛出中断异常\",{\"1\":{\"317\":1}}],[\"则抛出异常\",{\"1\":{\"259\":1}}],[\"则创建线程\",{\"1\":{\"311\":1}}],[\"则逐一唤醒\",{\"1\":{\"277\":1}}],[\"则等待notempty条件\",{\"1\":{\"275\":1}}],[\"则等待\",{\"1\":{\"273\":1}}],[\"则从队列中删除\",{\"1\":{\"265\":1}}],[\"则触发treeifybin\",{\"1\":{\"259\":1}}],[\"则n为sc\",{\"1\":{\"259\":1}}],[\"则进行初始化\",{\"1\":{\"361\":1}}],[\"则进行线程让步等待\",{\"1\":{\"259\":1}}],[\"则进入步骤②\",{\"1\":{\"239\":1}}],[\"则进入monitor的进入数加1\",{\"1\":{\"147\":1}}],[\"则根据标识选择是否进行更新操作\",{\"1\":{\"259\":1}}],[\"则使用cas将key\",{\"1\":{\"259\":1}}],[\"则使此线程一直自旋在本方法\",{\"1\":{\"175\":1}}],[\"则初始化table表\",{\"1\":{\"259\":1}}],[\"则添加\",{\"1\":{\"239\":1}}],[\"则生成指定长度的object数组\",{\"1\":{\"237\":1}}],[\"则将链表转换为红黑树\",{\"1\":{\"376\":1}}],[\"则将新的键值对插入到链表或红黑树的头部\",{\"1\":{\"376\":1}}],[\"则将尾节点指向\",{\"1\":{\"370\":1}}],[\"则将头节点指向\",{\"1\":{\"370\":1}}],[\"则将桶中的结构转化为红黑树存储\",{\"1\":{\"259\":1}}],[\"则将elements转化为object类型的数组\",{\"1\":{\"234\":1}}],[\"则将该线程加入到等待队列的尾部\",{\"1\":{\"185\":1}}],[\"则获取锁\",{\"1\":{\"273\":1,\"275\":1}}],[\"则获取该集合类型的底层数组\",{\"1\":{\"234\":1}}],[\"则获取它\",{\"1\":{\"173\":1,\"183\":1}}],[\"则释放所有等待的线程\",{\"1\":{\"199\":1}}],[\"则释放头结点的后继结点\",{\"1\":{\"174\":1}}],[\"则唤醒此线程\",{\"1\":{\"175\":1}}],[\"则唤醒所有线程\",{\"1\":{\"169\":1,\"214\":1}}],[\"则park当前结点\",{\"1\":{\"173\":1}}],[\"则设置持有锁的线程为本线程\",{\"1\":{\"175\":1}}],[\"则设置结点为head\",{\"1\":{\"173\":1}}],[\"则设置尾结点为pred结点\",{\"1\":{\"173\":1}}],[\"则入队列\",{\"1\":{\"173\":1}}],[\"则返回被删除的值\",{\"1\":{\"388\":1}}],[\"则返回对应的节点\",{\"1\":{\"378\":1}}],[\"则返回对应的值\",{\"1\":{\"378\":1}}],[\"则返回false\",{\"1\":{\"274\":1}}],[\"则返回\",{\"1\":{\"274\":1,\"363\":1,\"378\":2,\"387\":1}}],[\"则返回null\",{\"1\":{\"259\":1,\"314\":1}}],[\"则返回true\",{\"1\":{\"173\":1}}],[\"则返回singleton\",{\"1\":{\"19\":1,\"121\":1}}],[\"则选择其中的一个唤醒\",{\"1\":{\"169\":1}}],[\"则当前线程会被阻塞\",{\"1\":{\"152\":1}}],[\"则该线程进入阻塞状态\",{\"1\":{\"147\":1}}],[\"则该线程进入monitor\",{\"1\":{\"147\":1}}],[\"则该线程将进入等待状态\",{\"1\":{\"147\":1}}],[\"则该线程成功获取锁并进入临界区\",{\"1\":{\"147\":1}}],[\"则\",{\"1\":{\"136\":1,\"332\":1}}],[\"则默认是global\",{\"1\":{\"113\":1}}],[\"则会覆盖之前try或者catch里面的return操作\",{\"1\":{\"438\":2}}],[\"则会覆盖try里面的return操作\",{\"1\":{\"438\":1}}],[\"则会进行缩容操作\",{\"1\":{\"358\":1}}],[\"则会创建一个新的更大容量的数组\",{\"1\":{\"358\":1}}],[\"则会调用awaitdone\",{\"1\":{\"330\":1}}],[\"则会立即中断执行任务的线程并返回true\",{\"1\":{\"326\":1}}],[\"则会返回true且不会中断任务执行线程\",{\"1\":{\"326\":1}}],[\"则会返回true并且异步任务不会被执行\",{\"1\":{\"326\":1}}],[\"则会返回false\",{\"1\":{\"326\":1}}],[\"则会抛出\",{\"1\":{\"322\":1}}],[\"则会被当前线程获取\",{\"1\":{\"185\":1}}],[\"则会使用enq插入队列中\",{\"1\":{\"173\":1}}],[\"则会把标签添加到新的序列中\",{\"1\":{\"113\":1}}],[\"则会出现几百上千的告警消息\",{\"1\":{\"103\":1}}],[\"则向alertmanager发送告警消息\",{\"1\":{\"101\":1}}],[\"完全可以从io\",{\"1\":{\"401\":1}}],[\"完全匹配\",{\"1\":{\"85\":1}}],[\"完成键值对的重新分布后\",{\"1\":{\"377\":1}}],[\"完成全部task就开始执行回调函数\",{\"0\":{\"342\":1}}],[\"完成后执行回调函数\",{\"1\":{\"341\":1}}],[\"完成后执行回调函数时\",{\"1\":{\"341\":1}}],[\"完成任意一个task就开始执行回调函数\",{\"0\":{\"341\":1}}],[\"完整的代码如下\",{\"1\":{\"98\":1}}],[\"统一管理线程的执行和状态\",{\"1\":{\"291\":1}}],[\"统一全局的访问点控制\",{\"1\":{\"16\":1}}],[\"统计请求的次数和请求耗时\",{\"1\":{\"98\":1}}],[\"另一种方法是资源预分配\",{\"1\":{\"141\":1}}],[\"另一种是使用prometheus的java客户端\",{\"1\":{\"96\":1}}],[\"另外在新生成的指标上添加一个新的标签region\",{\"1\":{\"116\":1}}],[\"另外如果没有配置groups的interval配置\",{\"1\":{\"113\":1}}],[\"另外一种是预计算规则recording\",{\"1\":{\"112\":1}}],[\"另外也可以筛选出handler\",{\"1\":{\"81\":1}}],[\"另外\",{\"1\":{\"78\":1,\"131\":1}}],[\"详细内容可以查看官方网站\",{\"1\":{\"95\":1}}],[\"长度为\",{\"1\":{\"377\":1}}],[\"长度为len+1\",{\"1\":{\"239\":1}}],[\"长尾问题\",{\"1\":{\"92\":2}}],[\"长期趋势分析\",{\"1\":{\"65\":1}}],[\"计算出新数组的长度\",{\"1\":{\"377\":1}}],[\"计算出键值对在\",{\"1\":{\"376\":1}}],[\"计算hash的源码如下\",{\"1\":{\"376\":1}}],[\"计算handler=\",{\"1\":{\"94\":1}}],[\"计算等待截止时间\",{\"1\":{\"331\":1}}],[\"计算结果为\",{\"1\":{\"323\":3,\"336\":1,\"339\":1,\"340\":1}}],[\"计算key的hash值\",{\"1\":{\"259\":1,\"260\":1,\"261\":1}}],[\"计算需要移动的元素个数\",{\"1\":{\"241\":1}}],[\"计算p99耗时的表达式如下\",{\"1\":{\"94\":1}}],[\"计算分位数\",{\"0\":{\"94\":1}}],[\"计算counter的增长率\",{\"0\":{\"92\":1}}],[\"计算的结果会产生一条新的时间序列\",{\"1\":{\"80\":1}}],[\"≤\",{\"1\":{\"90\":2}}],[\"φ\",{\"1\":{\"90\":2,\"94\":1}}],[\"得到的结果是\",{\"1\":{\"89\":2}}],[\"举例子讲解\",{\"1\":{\"89\":1}}],[\"举个简单的例子\",{\"1\":{\"418\":1}}],[\"举个简单的例子来说明吧\",{\"1\":{\"392\":1}}],[\"举个简单的示例\",{\"1\":{\"353\":1}}],[\"举个可见性导致程序bug的例子\",{\"1\":{\"119\":1}}],[\"举个例子演示如何使用\",{\"1\":{\"352\":1,\"354\":1}}],[\"举个例子\",{\"1\":{\"74\":1,\"124\":1,\"127\":1,\"429\":1,\"432\":1}}],[\"举个现实例子\",{\"1\":{\"25\":1}}],[\"忽略中断\",{\"1\":{\"173\":1,\"184\":1,\"185\":1}}],[\"忽略\",{\"1\":{\"88\":1}}],[\"匹配\",{\"1\":{\"88\":1}}],[\"求素数\",{\"1\":{\"395\":1}}],[\"求一个字符串包含的char\",{\"1\":{\"395\":1}}],[\"求并集\",{\"1\":{\"87\":1}}],[\"求交集\",{\"1\":{\"87\":1}}],[\"支持双向操作\",{\"1\":{\"404\":1}}],[\"支持非阻塞\",{\"1\":{\"403\":1}}],[\"支持对集合进行顺序迭代\",{\"1\":{\"364\":1}}],[\"支持快速访问\",{\"1\":{\"357\":1}}],[\"支持延时出队的阻塞队列\",{\"1\":{\"226\":1}}],[\"支持按照优先级出队的阻塞队列\",{\"1\":{\"226\":1}}],[\"支持高并发的读写操作\",{\"1\":{\"224\":2}}],[\"支持多个线程同时读\",{\"1\":{\"221\":1}}],[\"支持多种类型的采集\",{\"1\":{\"68\":1}}],[\"支持乐观读的方式\",{\"1\":{\"221\":1}}],[\"支持乐观读和悲观读\",{\"1\":{\"218\":1}}],[\"支持乐观读锁\",{\"1\":{\"218\":1}}],[\"支持读锁的共享特性\",{\"1\":{\"218\":1}}],[\"支持各种操作的精确控制\",{\"1\":{\"188\":1}}],[\"支持的逻辑运算符如下\",{\"1\":{\"87\":1}}],[\"右侧的表达式也有一个handler=\",{\"1\":{\"85\":1}}],[\"左侧的标签条目和右侧的标签条目必须要相同\",{\"1\":{\"85\":1,\"86\":1,\"87\":1}}],[\"幂运算\",{\"1\":{\"85\":1}}],[\"^\",{\"1\":{\"85\":1,\"376\":1}}],[\"取消注册或更新事件\",{\"1\":{\"407\":1}}],[\"取消任务等等操作\",{\"1\":{\"329\":1}}],[\"取消任务\",{\"1\":{\"322\":1}}],[\"取消继续获取\",{\"1\":{\"173\":1}}],[\"取值索引等于数组长度\",{\"1\":{\"275\":1}}],[\"取元素\",{\"1\":{\"275\":1}}],[\"取元素和存元素有不同的索引\",{\"1\":{\"270\":1}}],[\"取元素索引\",{\"1\":{\"270\":1,\"277\":1}}],[\"取较小者\",{\"1\":{\"239\":1}}],[\"取模\",{\"1\":{\"85\":1}}],[\"取反操作\",{\"1\":{\"81\":1}}],[\"乘\",{\"1\":{\"85\":1}}],[\"减小链表的大小\",{\"1\":{\"370\":1}}],[\"减少内存占用\",{\"1\":{\"358\":1}}],[\"减少线程数量\",{\"1\":{\"300\":1}}],[\"减少线程池中的线程数量\",{\"1\":{\"296\":1}}],[\"减少了锁竞争的影响\",{\"1\":{\"246\":1}}],[\"减少正在等待进入屏障的线程数量\",{\"1\":{\"213\":1}}],[\"减少同步创建实例的开销\",{\"1\":{\"19\":1}}],[\"减一\",{\"1\":{\"190\":1}}],[\"减为\",{\"1\":{\"190\":1}}],[\"减\",{\"1\":{\"85\":1}}],[\"数量\",{\"1\":{\"295\":1}}],[\"数组来记录数据\",{\"1\":{\"392\":1}}],[\"数组赋值给\",{\"1\":{\"377\":1,\"378\":1}}],[\"数组对应的位置\",{\"1\":{\"377\":1}}],[\"数组中查找并返回对应的节点\",{\"1\":{\"378\":1}}],[\"数组中找到对应的索引位置\",{\"1\":{\"378\":1}}],[\"数组中重新计算\",{\"1\":{\"377\":1}}],[\"数组中\",{\"1\":{\"377\":1}}],[\"数组中的索引位置\",{\"1\":{\"376\":1}}],[\"数组进行存储\",{\"1\":{\"377\":1}}],[\"数组的大小\",{\"1\":{\"393\":1}}],[\"数组的引用赋值给一个临时变量\",{\"1\":{\"377\":1}}],[\"数组的长度大于阈值\",{\"1\":{\"376\":1}}],[\"数组的长度\",{\"1\":{\"376\":2}}],[\"数组是否为\",{\"1\":{\"377\":1}}],[\"数组长度为length\",{\"1\":{\"241\":1}}],[\"数组长度\",{\"1\":{\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"377\":1}}],[\"数组\",{\"1\":{\"234\":1,\"277\":1,\"361\":1,\"377\":3,\"401\":4}}],[\"数据的读写以及关闭操作\",{\"1\":{\"411\":1}}],[\"数据的读写以及连接的关闭操作\",{\"1\":{\"410\":1}}],[\"数据库连接管理\",{\"1\":{\"283\":1}}],[\"数据交换\",{\"1\":{\"264\":1}}],[\"数据不经常更新\",{\"1\":{\"229\":1}}],[\"数据可视化\",{\"1\":{\"65\":1}}],[\"数学操作符\",{\"0\":{\"85\":1}}],[\"怎么查询呢\",{\"1\":{\"83\":1}}],[\"年龄\",{\"1\":{\"149\":1}}],[\"年\",{\"1\":{\"82\":1}}],[\"天\",{\"1\":{\"82\":1,\"392\":1}}],[\"小于链表大小的一半\",{\"1\":{\"369\":1}}],[\"小于该阈值的任务将不再细分\",{\"1\":{\"349\":1}}],[\"小于corepoolsize\",{\"1\":{\"311\":1}}],[\"小时\",{\"1\":{\"82\":1}}],[\"小结\",{\"1\":{\"81\":1}}],[\"秒\",{\"1\":{\"82\":1}}],[\"外\",{\"1\":{\"82\":1}}],[\"外观模式\",{\"1\":{\"11\":1}}],[\"范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围\",{\"1\":{\"82\":1}}],[\"范围向量查询\",{\"0\":{\"82\":1}}],[\"|=\",{\"1\":{\"395\":1}}],[\"||\",{\"1\":{\"142\":1,\"173\":2,\"175\":1,\"186\":1,\"198\":5,\"214\":1,\"259\":19,\"260\":2,\"261\":7,\"294\":5,\"312\":2,\"313\":2,\"314\":5,\"318\":1,\"329\":1,\"361\":1,\"375\":1,\"376\":2,\"377\":1,\"378\":2}}],[\"|2\",{\"1\":{\"115\":3}}],[\"|value2\",{\"1\":{\"81\":1}}],[\"|\",{\"1\":{\"81\":1,\"113\":1,\"309\":1,\"323\":3,\"336\":2,\"339\":1,\"340\":1,\"366\":24,\"393\":36,\"415\":1,\"432\":5}}],[\"~capacity\",{\"1\":{\"309\":1}}],[\"~3h\",{\"1\":{\"107\":1}}],[\"~5m\",{\"1\":{\"107\":1}}],[\"~0s\",{\"1\":{\"107\":1}}],[\"~\",{\"1\":{\"81\":3,\"107\":1,\"429\":1}}],[\"瞬时向量查询和范围向量查询的表达式中\",{\"1\":{\"83\":1}}],[\"瞬时向量查询\",{\"0\":{\"81\":1}}],[\"聚合完后的结果会生成根据聚合标签生成一个新的序列\",{\"1\":{\"90\":1}}],[\"聚合函数\",{\"0\":{\"90\":1}}],[\"聚合\",{\"1\":{\"80\":1}}],[\"过大的核心线程数量可能会占用过多的系统资源\",{\"1\":{\"295\":1}}],[\"过度切换\",{\"1\":{\"291\":1}}],[\"过程如下\",{\"1\":{\"147\":1}}],[\"过滤\",{\"1\":{\"80\":1}}],[\"过多的观察者会影响性能\",{\"1\":{\"51\":1}}],[\"函数中进行\",{\"1\":{\"361\":1}}],[\"函数\",{\"1\":{\"95\":1,\"416\":2}}],[\"函数格式为\",{\"1\":{\"94\":1}}],[\"函数的格式如下\",{\"1\":{\"93\":1}}],[\"函数的内容\",{\"1\":{\"76\":1}}],[\"函数计算出其值的分位数\",{\"1\":{\"78\":1}}],[\"6844904146856837128\",{\"1\":{\"320\":1}}],[\"6400\",{\"1\":{\"395\":1}}],[\"64\",{\"1\":{\"256\":1,\"391\":1,\"392\":1,\"393\":1}}],[\"642177775\",{\"1\":{\"176\":1}}],[\"6260652\",{\"1\":{\"234\":1}}],[\"600\",{\"1\":{\"89\":4}}],[\"60\",{\"1\":{\"78\":1,\"92\":1,\"94\":1}}],[\"6\",{\"1\":{\"77\":1,\"79\":1,\"89\":3,\"153\":2,\"256\":1,\"317\":1,\"328\":1,\"331\":2,\"349\":1,\"392\":1,\"401\":1}}],[\"除零错误\",{\"1\":{\"432\":2}}],[\"除此之外都使用字节流\",{\"1\":{\"399\":1}}],[\"除0以外\",{\"1\":{\"395\":1}}],[\"除非线程池被中断\",{\"1\":{\"313\":1}}],[\"除非线程被中断\",{\"1\":{\"198\":1}}],[\"除非显式地调用了线程池的\",{\"1\":{\"295\":1}}],[\"除非进程重启重置\",{\"1\":{\"76\":1}}],[\"除\",{\"1\":{\"85\":1}}],[\"除了成员变量threadlocals之外\",{\"1\":{\"288\":1}}],[\"除了之前提到的基本规则之外\",{\"1\":{\"136\":1}}],[\"除了使用increase函数计算增量外\",{\"1\":{\"92\":1}}],[\"除了prometheus很多组件是可选的\",{\"1\":{\"63\":1}}],[\"除了以上的solid\",{\"1\":{\"14\":1}}],[\"摘要\",{\"1\":{\"75\":1}}],[\"直接计算结果\",{\"1\":{\"349\":2}}],[\"直接把任务状态从new转化为cancelled\",{\"1\":{\"332\":1}}],[\"直接丢弃该任务\",{\"1\":{\"302\":1}}],[\"直接返回false表示执行失败\",{\"1\":{\"332\":1}}],[\"直接返回\",{\"1\":{\"239\":1,\"329\":2}}],[\"直接上代码\",{\"1\":{\"191\":1}}],[\"直接参考jvm规范中描述\",{\"1\":{\"147\":1}}],[\"直接采集的jobs和exporters\",{\"1\":{\"64\":1}}],[\"直到callable任务执行完成\",{\"1\":{\"315\":1}}],[\"直到内存耗尽\",{\"1\":{\"297\":1}}],[\"直到队列有元素可用\",{\"1\":{\"266\":2,\"267\":1}}],[\"直到队列有空间可用\",{\"1\":{\"266\":2,\"267\":1}}],[\"直到条件满足\",{\"1\":{\"264\":1,\"265\":1}}],[\"直到所有线程都到达屏障点\",{\"1\":{\"203\":1}}],[\"直到所有线程都到达屏障点才可以继续执行\",{\"1\":{\"202\":1}}],[\"直到所有线程都到达后才能继续执行后续操作\",{\"1\":{\"202\":1}}],[\"直到计数器\",{\"1\":{\"190\":1}}],[\"直到它能够获得同步器或者被中断\",{\"1\":{\"163\":1}}],[\"直到获取到锁或达到一定的等待时间\",{\"1\":{\"153\":1}}],[\"直到锁被释放\",{\"1\":{\"152\":2}}],[\"直到monitor的进入数为0\",{\"1\":{\"147\":1}}],[\"直到持有锁的线程解锁\",{\"1\":{\"147\":1}}],[\"直到t2执行完\",{\"1\":{\"119\":1}}],[\"直到t1执行完\",{\"1\":{\"119\":1}}],[\"直觉会告诉我们程序的执行结果是10000\",{\"1\":{\"119\":1}}],[\"直方图\",{\"1\":{\"75\":1}}],[\"状态如果是new\",{\"1\":{\"329\":1}}],[\"状态如果不是new\",{\"1\":{\"329\":1}}],[\"状态会从new转化为interrupting\",{\"1\":{\"328\":1}}],[\"状态会从new变更到completing\",{\"1\":{\"328\":1}}],[\"状态会从completing转换到exceptional\",{\"1\":{\"328\":1}}],[\"状态会从completing转换到normal\",{\"1\":{\"328\":1}}],[\"状态不为0\",{\"1\":{\"185\":1}}],[\"状态为0并且不成功\",{\"1\":{\"198\":1,\"199\":1}}],[\"状态为0\",{\"1\":{\"185\":1}}],[\"状态为signal\",{\"1\":{\"173\":1,\"198\":1,\"199\":1}}],[\"状态0表示锁没有被占用\",{\"1\":{\"183\":1,\"184\":1}}],[\"状态state\",{\"1\":{\"170\":1}}],[\"状态\",{\"1\":{\"170\":1}}],[\"状态变迁与线程调度\",{\"1\":{\"163\":1}}],[\"状态信息通过procted类型的getstate\",{\"1\":{\"163\":1}}],[\"状态的扭转如下图所示\",{\"1\":{\"155\":1}}],[\"状态之间的转换需要相对比较长的时间\",{\"1\":{\"148\":1}}],[\"状态标记\",{\"0\":{\"134\":1}}],[\"状态值小于0\",{\"1\":{\"173\":1}}],[\"状态值\",{\"1\":{\"75\":1}}],[\"状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",{\"1\":{\"12\":1}}],[\"状态模式\",{\"1\":{\"12\":1}}],[\"仪表盘\",{\"1\":{\"75\":1}}],[\"初始位置为\",{\"1\":{\"406\":1}}],[\"初始容量必须大于0\",{\"1\":{\"271\":1}}],[\"初始化存元素的索引\",{\"1\":{\"271\":1}}],[\"初始化等待条件\",{\"1\":{\"271\":1}}],[\"初始化可重入锁\",{\"1\":{\"271\":1}}],[\"初始化数组\",{\"1\":{\"271\":1}}],[\"初始化表\",{\"1\":{\"259\":1}}],[\"初始化状态数\",{\"1\":{\"196\":1}}],[\"初始化对象\",{\"1\":{\"19\":1,\"121\":1}}],[\"初始值设置成\",{\"1\":{\"191\":1}}],[\"初始值为一个atomicinteger对象\",{\"1\":{\"281\":1}}],[\"初始值为零\",{\"1\":{\"76\":1}}],[\"初始值为0\",{\"1\":{\"75\":1}}],[\"累加器\",{\"0\":{\"76\":1},\"1\":{\"75\":1}}],[\"值都可以容纳\",{\"1\":{\"393\":1}}],[\"值以及指向下一个\",{\"1\":{\"374\":1}}],[\"值可以重复\",{\"1\":{\"354\":1}}],[\"值得注意的是\",{\"1\":{\"259\":1}}],[\"值视图\",{\"1\":{\"253\":1}}],[\"值为0\",{\"1\":{\"168\":2,\"175\":1}}],[\"值为\",{\"1\":{\"168\":6}}],[\"值为1\",{\"1\":{\"168\":2}}],[\"值\",{\"1\":{\"74\":1,\"252\":1,\"296\":1,\"362\":1,\"376\":2,\"429\":3,\"431\":2}}],[\"值和一个或者是多个key\",{\"1\":{\"61\":1}}],[\"8之后\",{\"1\":{\"436\":1}}],[\"8之后concurrenthashmap源码变化很小\",{\"1\":{\"248\":1}}],[\"8bit\",{\"1\":{\"399\":1}}],[\"85\",{\"1\":{\"354\":3}}],[\"80\",{\"1\":{\"354\":2}}],[\"8080\",{\"1\":{\"97\":3,\"98\":1,\"107\":1,\"410\":1,\"411\":1,\"414\":1,\"415\":2}}],[\"8991824\",{\"1\":{\"334\":1}}],[\"8下\",{\"1\":{\"254\":1}}],[\"8下增加的类\",{\"1\":{\"250\":1}}],[\"8版本\",{\"1\":{\"248\":1}}],[\"8中与之前的版本的jdk作用存在很大的差别\",{\"1\":{\"254\":1}}],[\"8中的concurrenthashmap摒弃了分段锁\",{\"1\":{\"246\":1}}],[\"8中\",{\"1\":{\"246\":2}}],[\"8中引入的一种新的并发锁机制\",{\"1\":{\"221\":1}}],[\"8基于cas的concurrenthashmap\",{\"0\":{\"246\":1}}],[\"8673264195747942595l\",{\"1\":{\"233\":1}}],[\"8\",{\"1\":{\"78\":1,\"94\":1,\"218\":1,\"256\":2,\"337\":1,\"349\":1,\"361\":1,\"374\":1,\"395\":4,\"401\":1,\"414\":1,\"419\":3,\"429\":2}}],[\"817911632652898426l\",{\"1\":{\"270\":1}}],[\"817\",{\"1\":{\"74\":2}}],[\"822\",{\"1\":{\"74\":2}}],[\"82\",{\"1\":{\"74\":2}}],[\"82033736e+08\",{\"1\":{\"68\":1}}],[\"时会指定容量\",{\"1\":{\"406\":1}}],[\"时\",{\"1\":{\"107\":1,\"297\":1,\"323\":1,\"347\":1,\"386\":1,\"410\":1,\"411\":1,\"412\":1,\"431\":1}}],[\"时间复杂度为\",{\"1\":{\"358\":1}}],[\"时间位移操作\",{\"0\":{\"83\":1}}],[\"时间范围除了支持分钟\",{\"1\":{\"82\":1}}],[\"时间范围通过时间范围选择器\",{\"1\":{\"82\":1}}],[\"时间戳精度为毫秒\",{\"1\":{\"74\":1}}],[\"时间戳\",{\"1\":{\"74\":1}}],[\"时间序列\",{\"1\":{\"74\":1}}],[\"时间序列是指标\",{\"1\":{\"74\":1}}],[\"时序数据使用http协议采集\",{\"1\":{\"62\":1}}],[\"导致不确定性\",{\"1\":{\"420\":1}}],[\"导致不停的睡眠启动线程\",{\"1\":{\"175\":1}}],[\"导致彼此相互等待对方释放锁\",{\"1\":{\"138\":1}}],[\"导致报错\",{\"1\":{\"135\":1}}],[\"导致数据错误\",{\"1\":{\"120\":1}}],[\"导致告警处理者漏处理一些告警消息\",{\"1\":{\"103\":1}}],[\"导致连接它的应用的几百个实例都出现异常\",{\"1\":{\"103\":1}}],[\"导致请求耗时的平均值远大于100ms\",{\"1\":{\"78\":1}}],[\"导致工厂类的代码会随着产品类型的增多而变得越来越复杂\",{\"1\":{\"41\":1}}],[\"导入成功后\",{\"1\":{\"71\":1}}],[\"页面的导入路径如下\",{\"1\":{\"71\":1}}],[\"页面展示如下\",{\"1\":{\"67\":1}}],[\"搜索成功后\",{\"1\":{\"71\":1}}],[\"搜索地址\",{\"1\":{\"71\":1}}],[\"登陆成功后\",{\"1\":{\"71\":1}}],[\"密码为admin\",{\"1\":{\"71\":1}}],[\"地址为localhost\",{\"1\":{\"71\":1}}],[\"进一步提高系统的吞吐量\",{\"1\":{\"291\":1}}],[\"进而可能导致内存溢出\",{\"1\":{\"284\":1}}],[\"进程发送\",{\"1\":{\"105\":1}}],[\"进行资源释放或清理操作\",{\"1\":{\"437\":1}}],[\"进行连接服务器端\",{\"1\":{\"415\":1}}],[\"进行基本操作的示例代码\",{\"1\":{\"406\":1}}],[\"进行文件读写操作的基本示例\",{\"1\":{\"405\":1}}],[\"进行网络数据的读写操作\",{\"1\":{\"404\":1}}],[\"进行\",{\"1\":{\"404\":1}}],[\"进行排序\",{\"1\":{\"395\":1}}],[\"进行比较\",{\"1\":{\"388\":1}}],[\"进行阻塞等待\",{\"1\":{\"330\":1,\"331\":1}}],[\"进行扩容\",{\"1\":{\"259\":1}}],[\"进行扩容所允许的最大线程数\",{\"1\":{\"256\":1}}],[\"进行加锁操作\",{\"1\":{\"313\":1}}],[\"进行加锁\",{\"1\":{\"259\":1}}],[\"进行转化\",{\"1\":{\"259\":1}}],[\"进行结点的转移\",{\"1\":{\"259\":1}}],[\"进行序列化的属性\",{\"1\":{\"256\":1}}],[\"进行的\",{\"1\":{\"223\":1}}],[\"进行判断\",{\"1\":{\"198\":1,\"259\":1}}],[\"进行手动的释放和开启线程\",{\"1\":{\"175\":1}}],[\"进行park操作并且返回该线程是否被中断\",{\"1\":{\"173\":1}}],[\"进行i++操作\",{\"1\":{\"124\":1}}],[\"进行修改操作后再将结果从高速缓存复制回主内存\",{\"1\":{\"124\":1}}],[\"进行数据的发送和接收\",{\"1\":{\"415\":1}}],[\"进行数据的转换或者功能的增强\",{\"1\":{\"29\":1}}],[\"进行数字排序\",{\"1\":{\"395\":1}}],[\"进行数学运算和控制数据流\",{\"1\":{\"118\":1}}],[\"进行全局的计算频次的设置\",{\"1\":{\"113\":1}}],[\"进行定义\",{\"1\":{\"82\":1}}],[\"进入步骤⑥\",{\"1\":{\"259\":1}}],[\"进入步骤⑤\",{\"1\":{\"239\":3,\"259\":1}}],[\"进入步骤④\",{\"1\":{\"239\":2,\"259\":1}}],[\"进入步骤②\",{\"1\":{\"234\":1,\"238\":1,\"241\":1,\"259\":1}}],[\"进入步骤③\",{\"1\":{\"234\":2,\"238\":1,\"239\":1,\"241\":1,\"259\":1}}],[\"进入下一代\",{\"1\":{\"213\":1}}],[\"进入屏障点等待\",{\"1\":{\"203\":1}}],[\"进入循环\",{\"1\":{\"203\":1}}],[\"进入一个无限循环\",{\"1\":{\"160\":1}}],[\"进入等待状态\",{\"1\":{\"152\":1}}],[\"进入grafana的页面\",{\"1\":{\"71\":1}}],[\"进入grafana官网下载安装包\",{\"1\":{\"71\":1}}],[\"进入到grafana的安装目录\",{\"1\":{\"71\":1}}],[\"炫酷的展示数据的可视化仪表盘\",{\"1\":{\"71\":1}}],[\"95\",{\"1\":{\"100\":1,\"354\":4}}],[\"9400\",{\"1\":{\"98\":2,\"99\":1}}],[\"9999\",{\"1\":{\"395\":1}}],[\"99\",{\"1\":{\"94\":1}}],[\"9\",{\"1\":{\"74\":1,\"94\":1,\"401\":1,\"419\":1}}],[\"9100\",{\"1\":{\"69\":2}}],[\"90\",{\"1\":{\"354\":2}}],[\"909\",{\"1\":{\"108\":1}}],[\"9093\",{\"1\":{\"68\":1,\"107\":1,\"109\":1}}],[\"9090\",{\"1\":{\"67\":1,\"68\":2,\"69\":2,\"70\":1,\"90\":1,\"94\":10,\"108\":2}}],[\"9000\",{\"1\":{\"36\":2}}],[\"启动多路复用器时\",{\"1\":{\"416\":1}}],[\"启动线程后\",{\"1\":{\"323\":1}}],[\"启动线程执行任务\",{\"1\":{\"323\":1}}],[\"启动两个线程\",{\"1\":{\"267\":1}}],[\"启动另一个线程\",{\"1\":{\"136\":1}}],[\"启动alertmanager可以使用以下命令\",{\"1\":{\"106\":1}}],[\"启动命令如下\",{\"1\":{\"71\":1}}],[\"启动grafana\",{\"1\":{\"71\":1}}],[\"启动node\",{\"1\":{\"69\":1}}],[\"启动成功后\",{\"1\":{\"67\":1,\"71\":1}}],[\"磁盘\",{\"1\":{\"69\":1}}],[\"内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁\",{\"1\":{\"436\":1}}],[\"内部类和外部类其实是处于同一个级别\",{\"1\":{\"436\":1}}],[\"内部类介绍\",{\"1\":{\"347\":1}}],[\"内部的\",{\"1\":{\"385\":1}}],[\"内部定义的节点类\",{\"1\":{\"366\":1}}],[\"内部\",{\"1\":{\"358\":1}}],[\"内部存放\",{\"1\":{\"347\":1}}],[\"内部占位类\",{\"1\":{\"347\":1}}],[\"内部线程工厂接口\",{\"1\":{\"347\":1}}],[\"内部使用工作窃取算法来实现任务的并行执行\",{\"1\":{\"346\":1}}],[\"内部使用concurrentskiplistmap来实现\",{\"1\":{\"225\":1}}],[\"内部使用copyonwritearraylist来实现\",{\"1\":{\"225\":1}}],[\"内部持有的callable任务\",{\"1\":{\"328\":1}}],[\"内部通过awaitdone方法对主线程进行阻塞\",{\"1\":{\"317\":1}}],[\"内部状态的修改通过sun\",{\"1\":{\"317\":1}}],[\"内部状态\",{\"0\":{\"309\":1},\"1\":{\"317\":1}}],[\"内部采用写时复制的机制\",{\"1\":{\"223\":1}}],[\"内部维护了一个数组\",{\"1\":{\"223\":1,\"229\":1}}],[\"内部维护了一个状态变量\",{\"1\":{\"163\":1}}],[\"内部数组\",{\"1\":{\"223\":1}}],[\"内部锁等机制\",{\"1\":{\"222\":1}}],[\"内置状态变量\",{\"1\":{\"163\":1}}],[\"内存引用链路\",{\"0\":{\"285\":1}}],[\"内存泄漏以及资源的释放等问题\",{\"1\":{\"283\":1}}],[\"内存屏障效果\",{\"1\":{\"145\":1}}],[\"内存模型中定义的一个重要概念\",{\"1\":{\"136\":1}}],[\"内存的访问时间通常在纳秒数量级\",{\"1\":{\"118\":1}}],[\"内存的大小直接影响系统的运行速度和能够同时执行的任务数量\",{\"1\":{\"118\":1}}],[\"内存和i\",{\"1\":{\"118\":1}}],[\"内存\",{\"1\":{\"69\":1,\"118\":2}}],[\"内容如下\",{\"1\":{\"68\":1,\"108\":1}}],[\"700\",{\"1\":{\"395\":1}}],[\"7+8\",{\"1\":{\"349\":1}}],[\"79799267\",{\"1\":{\"320\":1}}],[\"7126708538440679460\",{\"1\":{\"289\":1}}],[\"7249069246763182397l\",{\"1\":{\"256\":1}}],[\"7中可以提供更高的并发性能\",{\"1\":{\"245\":1}}],[\"7中对concurrenthashmap进行了改进\",{\"1\":{\"245\":1}}],[\"7中\",{\"1\":{\"245\":1}}],[\"7316153563782823691l\",{\"1\":{\"184\":1}}],[\"7373984872572414699l\",{\"1\":{\"180\":1}}],[\"7373984972572414691l\",{\"1\":{\"170\":1}}],[\"75的\",{\"1\":{\"375\":1}}],[\"75f\",{\"1\":{\"256\":1,\"385\":1}}],[\"75\",{\"1\":{\"68\":1,\"79\":1}}],[\"745e\",{\"1\":{\"68\":1}}],[\"7\",{\"1\":{\"68\":1,\"97\":1,\"345\":1,\"349\":1,\"393\":2,\"395\":2,\"401\":1}}],[\"423\",{\"1\":{\"395\":1}}],[\"48\",{\"1\":{\"392\":1}}],[\"489234e+06\",{\"1\":{\"68\":1}}],[\"4c8ae8034f2c6247e9b0cfc4425463a6\",{\"1\":{\"295\":2}}],[\"4982264981922014374l\",{\"1\":{\"197\":1}}],[\"4h\",{\"1\":{\"107\":1}}],[\"44\",{\"1\":{\"98\":1}}],[\"4<\",{\"1\":{\"97\":1}}],[\"404\",{\"1\":{\"89\":4}}],[\"4\",{\"1\":{\"68\":1,\"71\":2,\"78\":1,\"94\":1,\"110\":1,\"175\":1,\"259\":1,\"317\":1,\"328\":1,\"329\":2,\"331\":1,\"332\":1,\"349\":1,\"352\":1,\"358\":1,\"401\":1,\"403\":1,\"419\":1,\"429\":2,\"438\":2}}],[\"47\",{\"1\":{\"67\":2}}],[\"周\",{\"1\":{\"82\":1}}],[\"周期性采集监控目标\",{\"1\":{\"68\":1}}],[\"周边生态非常的丰富\",{\"1\":{\"61\":1}}],[\"访问列表中的元素\",{\"1\":{\"352\":1}}],[\"访问标志是否被设置\",{\"1\":{\"147\":1}}],[\"访问alertmanager的界面\",{\"1\":{\"109\":1}}],[\"访问prometheus的告警页面界面\",{\"1\":{\"108\":1}}],[\"访问prometheus的规则文件界面\",{\"1\":{\"108\":1}}],[\"访问prometheus的网页\",{\"1\":{\"69\":1}}],[\"访问http\",{\"1\":{\"67\":1,\"69\":1}}],[\"访问者模式是以行为\",{\"1\":{\"12\":1}}],[\"访问者模式\",{\"1\":{\"12\":1}}],[\"笔者是mac\",{\"1\":{\"71\":1}}],[\"笔者是mac电脑\",{\"1\":{\"67\":1}}],[\"笔者这里下载mac版本的\",{\"1\":{\"67\":1}}],[\"笔者作为多年面试官\",{\"1\":{\"13\":1}}],[\"目前值\",{\"1\":{\"175\":1}}],[\"目前锁还没有被持有\",{\"1\":{\"175\":1}}],[\"目前支持linux系统\",{\"1\":{\"69\":1}}],[\"目前提供了linux\",{\"1\":{\"67\":1}}],[\"目标警报和源警报在相等列表中的标签名称必须具有相同的标签值\",{\"1\":{\"107\":1}}],[\"目标\",{\"1\":{\"107\":1}}],[\"目标类和适配者类是通过适配器进行交互的\",{\"1\":{\"27\":1}}],[\"目标类和适配者类各司其职\",{\"1\":{\"27\":1}}],[\"目标类target\",{\"1\":{\"25\":1}}],[\"目标接口itypec\",{\"1\":{\"26\":1}}],[\"安装prometheus\",{\"0\":{\"67\":1}}],[\"安装成功后\",{\"1\":{\"66\":1}}],[\"安全与隐私\",{\"1\":{\"67\":1}}],[\"安全\",{\"1\":{\"18\":1}}],[\"包装类的值比较应该使用equals\",{\"1\":{\"423\":1}}],[\"包装类都是不可变的\",{\"1\":{\"423\":1}}],[\"包装类还提供了许多其他功能\",{\"1\":{\"423\":1}}],[\"包实现了基于\",{\"1\":{\"415\":1}}],[\"包实现的简单的基于\",{\"1\":{\"414\":1}}],[\"包\",{\"1\":{\"401\":1}}],[\"包的结构\",{\"1\":{\"401\":1}}],[\"包中去除\",{\"1\":{\"401\":1}}],[\"包括编译器\",{\"1\":{\"433\":1}}],[\"包括文件读写\",{\"1\":{\"403\":1}}],[\"包括文件名\",{\"1\":{\"401\":1}}],[\"包括设置位\",{\"1\":{\"393\":1}}],[\"包括在链表的头部或尾部插入元素\",{\"1\":{\"371\":1}}],[\"包括了最常见的list\",{\"1\":{\"355\":1}}],[\"包括核心线程数\",{\"1\":{\"303\":1}}],[\"包括创建线程池的内部数据结构\",{\"1\":{\"293\":1}}],[\"包括以下几个阶段\",{\"1\":{\"293\":1}}],[\"包括内存分配\",{\"1\":{\"291\":1}}],[\"包括入队\",{\"1\":{\"265\":1}}],[\"包括引入了cas自旋\",{\"1\":{\"149\":1}}],[\"包括原子性\",{\"1\":{\"125\":1}}],[\"包括读取和修改\",{\"1\":{\"124\":1}}],[\"包括磁盘\",{\"1\":{\"118\":1}}],[\"包括消息的去重\",{\"1\":{\"102\":1}}],[\"包括两个标签uri\",{\"1\":{\"98\":2}}],[\"包括prometheus\",{\"1\":{\"66\":1}}],[\"包含了5种设计模式\",{\"1\":{\"10\":1}}],[\"本身\",{\"1\":{\"429\":2}}],[\"本身又是字符流\",{\"1\":{\"401\":1}}],[\"本身内部实现还是带缓冲的\",{\"1\":{\"401\":1}}],[\"本身就不应该出现在inputstream\",{\"1\":{\"401\":1}}],[\"本质上是对其它流的综合运用的一个工具而已\",{\"1\":{\"401\":1}}],[\"本质上是work\",{\"1\":{\"347\":1}}],[\"本质其实就是基于字节流读取时\",{\"1\":{\"399\":1}}],[\"本质是执行了worker的runworker方法\",{\"1\":{\"310\":1}}],[\"本线程还在睡眠\",{\"1\":{\"175\":1}}],[\"本篇文章主要讲解如何在springboot项目中使用prometheus监控\",{\"1\":{\"96\":1}}],[\"本篇文章为系列教程\",{\"1\":{\"59\":1}}],[\"本文主要介绍了nio的一些基本组件\",{\"1\":{\"408\":1}}],[\"本文的源码为jdk18\",{\"1\":{\"358\":1}}],[\"本文介绍了java中的collection框架\",{\"1\":{\"355\":1}}],[\"本文使用webhook的方式\",{\"1\":{\"107\":1}}],[\"本文快速的讲解了promql的查询\",{\"1\":{\"95\":1}}],[\"本文是prometheus环境的搭建和安装\",{\"1\":{\"66\":1}}],[\"以获得最终的哈希码\",{\"1\":{\"431\":1}}],[\"以减少哈希冲突的概率\",{\"1\":{\"431\":1}}],[\"以减轻与内存的速度差异\",{\"1\":{\"118\":1}}],[\"以确保代码的可靠性\",{\"1\":{\"437\":1}}],[\"以确保程序的正常执行\",{\"1\":{\"432\":1}}],[\"以确保程序的正确性和稳定性\",{\"1\":{\"118\":1}}],[\"以确定两个对象是否相等\",{\"1\":{\"431\":1}}],[\"以下代码演示了使用包装类实现基本类型的自动装箱和拆箱\",{\"1\":{\"423\":1}}],[\"以下是对其源码的解析\",{\"1\":{\"364\":1}}],[\"以下是一些在重写hashcode\",{\"1\":{\"431\":1}}],[\"以下是一些常见的\",{\"1\":{\"404\":1}}],[\"以下是一些常见的使用场景\",{\"1\":{\"283\":1}}],[\"以下是一些常用的\",{\"1\":{\"393\":1}}],[\"以下是一个接口的示例\",{\"1\":{\"419\":1}}],[\"以下是一个抽象类的示例\",{\"1\":{\"419\":1}}],[\"以下是一个使用\",{\"1\":{\"323\":1,\"405\":1}}],[\"以下是一个示例\",{\"1\":{\"146\":1}}],[\"以下是一个简单的使用\",{\"1\":{\"349\":1}}],[\"以下是一个简单的使用示例\",{\"1\":{\"339\":1}}],[\"以下是一个简单的示例\",{\"1\":{\"323\":2}}],[\"以下是一个简单的\",{\"1\":{\"139\":1}}],[\"以下是\",{\"1\":{\"264\":1,\"337\":1,\"343\":1}}],[\"以实现高效的\",{\"1\":{\"407\":1}}],[\"以读写模式\",{\"1\":{\"405\":1}}],[\"以后每次遇到换行时会在下一行添加一个行号\",{\"1\":{\"401\":1}}],[\"以后的版本中\",{\"1\":{\"374\":1}}],[\"以上示例演示了\",{\"1\":{\"406\":1}}],[\"以上示例演示了如何使用\",{\"1\":{\"405\":1}}],[\"以上示例代码演示了\",{\"1\":{\"393\":1}}],[\"以上是关于\",{\"1\":{\"230\":1}}],[\"以上是对java并发包中queue的分类和一些示例的说明\",{\"1\":{\"226\":1}}],[\"以此类推\",{\"1\":{\"392\":1}}],[\"以填补被删除元素的空缺\",{\"1\":{\"358\":1}}],[\"以键值对\",{\"1\":{\"351\":1}}],[\"以无序的方式存储对象的集合\",{\"1\":{\"351\":1}}],[\"以有序的方式存储对象的集合\",{\"1\":{\"351\":1}}],[\"以threada为例\",{\"1\":{\"331\":1}}],[\"以满足不同的需求\",{\"1\":{\"265\":1}}],[\"以保证读操作的线程安全性\",{\"1\":{\"223\":1}}],[\"以保证对共享资源的互斥访问\",{\"1\":{\"152\":1}}],[\"以共享模式进行释放\",{\"1\":{\"198\":1}}],[\"以独占模式获取对象\",{\"1\":{\"184\":1,\"185\":1}}],[\"以独占模式释放对象\",{\"1\":{\"174\":1}}],[\"以传递参数确定采用公平策略或者是非公平策略\",{\"1\":{\"181\":1}}],[\"以提高并发读取的性能\",{\"1\":{\"153\":1}}],[\"以避免空指针异常\",{\"1\":{\"431\":1}}],[\"以避免产生并发修改异常\",{\"1\":{\"364\":1}}],[\"以避免多个线程共享同一个缓存实例时的并发问题\",{\"1\":{\"283\":1}}],[\"以避免并发访问导致的数据不一致性\",{\"1\":{\"145\":1}}],[\"以避免出现意外的错误和不一致的状态\",{\"1\":{\"124\":1}}],[\"以更好地利用缓存\",{\"1\":{\"118\":1}}],[\"以分时复用cpu\",{\"1\":{\"118\":1}}],[\"以便更好地抽象和组织程序中可能发生的异常情况\",{\"1\":{\"432\":1}}],[\"以便方法可以在这些对象类型之间进行选择\",{\"1\":{\"423\":1}}],[\"以便在需要时进行回滚或提交\",{\"1\":{\"283\":1}}],[\"以便在处理请求的过程中使用\",{\"1\":{\"283\":1}}],[\"以便在中断期间仅发送一组互连警报中最相关的警报\",{\"1\":{\"107\":1}}],[\"以便以后可以恢复\",{\"1\":{\"12\":1}}],[\"以及优化性能\",{\"1\":{\"435\":1}}],[\"以及一些集合类\",{\"1\":{\"431\":1}}],[\"以及默认方法\",{\"1\":{\"419\":1}}],[\"以及文件操作\",{\"1\":{\"398\":1}}],[\"以及常见的实现类\",{\"1\":{\"355\":1}}],[\"以及判断\",{\"1\":{\"354\":1}}],[\"以及判断集合是否为空\",{\"1\":{\"353\":1}}],[\"以及添加\",{\"1\":{\"354\":1}}],[\"以及定义接下来的逻辑操作\",{\"1\":{\"341\":1}}],[\"以及如何进行链式操作和组合操作\",{\"1\":{\"340\":1}}],[\"以及\",{\"1\":{\"337\":1}}],[\"以及同步代码块内的操作\",{\"1\":{\"146\":1}}],[\"以及告警的接受方式可以通过alertmanager的配置文件进行配置\",{\"1\":{\"103\":1}}],[\"以及服务运行状态等直观的信息\",{\"1\":{\"65\":1}}],[\"以\",{\"1\":{\"78\":2,\"429\":1}}],[\"故障分析与定位\",{\"1\":{\"65\":1}}],[\"两个条件condition\",{\"1\":{\"270\":1}}],[\"两个或多个线程因竞争资源而陷入无限等待的状态\",{\"1\":{\"140\":1}}],[\"两个关键字来线程代码操作的有序性\",{\"1\":{\"128\":1}}],[\"两个线程交替打印奇数和偶数\",{\"0\":{\"160\":1},\"1\":{\"160\":1}}],[\"两个线程都无法继续执行\",{\"1\":{\"139\":1}}],[\"两个线程分别对共享变量进行a+=1操作\",{\"1\":{\"120\":1}}],[\"两个线程同时执行这个操作可能会产生不确定的结果\",{\"1\":{\"119\":1}}],[\"两个版本的系统运行资源使用情况的差异如何\",{\"1\":{\"65\":1}}],[\"两者都是开闭原则的具体实现规范\",{\"1\":{\"14\":1}}],[\"例如常量\",{\"1\":{\"435\":1}}],[\"例如释放资源\",{\"1\":{\"432\":1}}],[\"例如integer\",{\"1\":{\"423\":1}}],[\"例如添加键值对\",{\"1\":{\"354\":1}}],[\"例如添加元素\",{\"1\":{\"353\":1}}],[\"例如线程回收等\",{\"1\":{\"293\":1}}],[\"例如在gui应用程序中\",{\"1\":{\"150\":1}}],[\"例如mosi\",{\"1\":{\"124\":1}}],[\"例如硬盘读取时间\",{\"1\":{\"118\":1}}],[\"例如有以下的指标prometheus\",{\"1\":{\"94\":1}}],[\"例如下面的查询语句不会输出任何结果\",{\"1\":{\"85\":1}}],[\"例如go\",{\"1\":{\"79\":1}}],[\"例如0\",{\"1\":{\"78\":1}}],[\"例如prometheus的服务的\",{\"1\":{\"78\":1}}],[\"例如prometheus\",{\"1\":{\"76\":1,\"102\":1}}],[\"例如\",{\"1\":{\"65\":1,\"77\":1,\"78\":1,\"82\":1,\"92\":1,\"93\":1,\"104\":1,\"115\":1,\"120\":1,\"121\":2,\"149\":1,\"264\":1,\"297\":3,\"352\":1,\"423\":1,\"424\":1,\"429\":1}}],[\"例如代理私有方法\",{\"1\":{\"57\":1}}],[\"去查了指定的码表\",{\"1\":{\"399\":1}}],[\"去掉\",{\"1\":{\"115\":1}}],[\"去prometheus官网下载prometheus\",{\"1\":{\"67\":1}}],[\"去重\",{\"1\":{\"64\":1}}],[\"去提供获取对象的服务\",{\"1\":{\"18\":1}}],[\"健康对象包含\",{\"1\":{\"64\":1}}],[\"下图可以增强理解\",{\"1\":{\"280\":1}}],[\"下图是prometheus和它周边生态组件的架构图\",{\"1\":{\"64\":1}}],[\"下表列出了\",{\"1\":{\"266\":1}}],[\"下一项索引\",{\"1\":{\"235\":1}}],[\"下一个节点和上一个节点\",{\"1\":{\"366\":1}}],[\"下一个元素的索引\",{\"1\":{\"364\":1}}],[\"下一个表\",{\"1\":{\"256\":1}}],[\"下一个状态\",{\"1\":{\"185\":1,\"197\":1,\"199\":1}}],[\"下一个结点为空或者下一个节点的等待状态大于0\",{\"1\":{\"173\":1}}],[\"下一个等待者\",{\"1\":{\"168\":1}}],[\"下面来看一下gettask\",{\"1\":{\"314\":1}}],[\"下面我们来分析其中一个常用的构造函数\",{\"1\":{\"385\":1}}],[\"下面我们先来了解一下java中引用的分类\",{\"1\":{\"285\":1}}],[\"下面我们就来分析一下内存泄露的原因及相关设计思想\",{\"1\":{\"284\":1}}],[\"下面我们通过一个流程图来汇总一下上述流程\",{\"1\":{\"282\":1}}],[\"下面简要介绍这两个实现类的原理\",{\"1\":{\"266\":1}}],[\"下面对其中涉及到的函数进行分析\",{\"1\":{\"259\":1}}],[\"下面对其中主要的内部类进行分析和讲解\",{\"1\":{\"250\":1}}],[\"下面分别做介绍\",{\"1\":{\"167\":1}}],[\"下面是hashset的类结构图\",{\"1\":{\"381\":1}}],[\"下面是\",{\"1\":{\"370\":1,\"378\":1,\"386\":1,\"387\":1,\"388\":1}}],[\"下面是java\",{\"1\":{\"351\":1}}],[\"下面是一个简单的示例\",{\"1\":{\"281\":1}}],[\"下面是一个使用\",{\"1\":{\"267\":1,\"406\":1}}],[\"下面是一个总结了\",{\"1\":{\"224\":1}}],[\"下面是copyonwritearraylist的简单实现原理\",{\"1\":{\"223\":1}}],[\"下面是对这三个条件的反向分析\",{\"1\":{\"141\":1}}],[\"下面是懒汉模式的线程安全的\",{\"1\":{\"23\":1}}],[\"下面是最简单的懒汉模式的单列模式\",{\"1\":{\"22\":1}}],[\"下载地址\",{\"1\":{\"106\":1}}],[\"下载地址为\",{\"1\":{\"69\":1}}],[\"下载地址为https\",{\"1\":{\"67\":1}}],[\"下载并解压成功后\",{\"1\":{\"71\":1}}],[\"下载命令如下\",{\"1\":{\"71\":1}}],[\"下载完成后\",{\"1\":{\"67\":1,\"69\":1}}],[\"架构\",{\"0\":{\"64\":1}}],[\"大多数情况下不会被程序显式地捕获和处理\",{\"1\":{\"432\":1}}],[\"大多数prometheus组件都是使用go语言写的\",{\"1\":{\"63\":1}}],[\"大部分\",{\"1\":{\"403\":1}}],[\"大于\",{\"1\":{\"377\":1}}],[\"大于等于链表大小的一半\",{\"1\":{\"369\":1}}],[\"大于corepoolsize那部分线程会被销毁\",{\"1\":{\"294\":1}}],[\"大致流程如下\",{\"1\":{\"213\":1}}],[\"大脑\",{\"1\":{\"118\":1}}],[\"大量的类\",{\"1\":{\"44\":1}}],[\"静默提供了一个标签匹配的设置\",{\"1\":{\"105\":1}}],[\"静默\",{\"0\":{\"105\":1},\"1\":{\"63\":1,\"64\":1}}],[\"静态方法在接口中提供了一些与接口相关的工具方法\",{\"1\":{\"419\":1}}],[\"静态方法\",{\"1\":{\"419\":2}}],[\"静态方法用来返回其所属类的一个相同实例\",{\"1\":{\"17\":1}}],[\"静态条件经常触发\",{\"1\":{\"222\":1}}],[\"静态初始化块\",{\"1\":{\"170\":1}}],[\"静态代理的优点是简单易懂\",{\"1\":{\"53\":1}}],[\"静态代理需要手动创建一个代理类\",{\"1\":{\"53\":1}}],[\"静态代理\",{\"0\":{\"53\":1}}],[\"静态对象用来存储对象自身的属性和方法\",{\"1\":{\"17\":1}}],[\"用作其他类的基类\",{\"1\":{\"419\":1}}],[\"用户数统计等等\",{\"1\":{\"394\":1}}],[\"用户可以调用cancel\",{\"1\":{\"332\":1}}],[\"用户调用了cancel\",{\"1\":{\"328\":2}}],[\"用户级别的上下文信息\",{\"1\":{\"283\":1}}],[\"用set来存放\",{\"1\":{\"308\":1}}],[\"用给定的value值替换该结点的value值\",{\"1\":{\"259\":1}}],[\"用来读取数据\",{\"1\":{\"414\":1}}],[\"用来存储位信息\",{\"1\":{\"393\":1}}],[\"用来存放具体的元素\",{\"1\":{\"233\":1}}],[\"用来连接上一个节点和下一个节点\",{\"1\":{\"371\":1}}],[\"用来合并或返回计算结果\",{\"1\":{\"348\":1}}],[\"用来提供线程的创建方式\",{\"1\":{\"294\":1}}],[\"用来保存任务的工作队列\",{\"1\":{\"294\":1}}],[\"用来保证线程安全访问\",{\"1\":{\"233\":1}}],[\"用来执行被提交的任务\",{\"1\":{\"292\":1}}],[\"用来表示当前屏障是否被损坏\",{\"1\":{\"207\":1}}],[\"用来记录当前加锁状态\",{\"1\":{\"175\":1}}],[\"用来等待条件\",{\"1\":{\"169\":1}}],[\"用来抓取和存储时序数据的\",{\"1\":{\"63\":1}}],[\"用new关键字新建一个线程\",{\"1\":{\"156\":1}}],[\"用increase函数算出五分钟的增量\",{\"1\":{\"92\":1}}],[\"用于异常处理的最后一个代码块\",{\"1\":{\"437\":1}}],[\"用于异步执行\",{\"1\":{\"348\":1}}],[\"用于计算两个数的除法操作\",{\"1\":{\"432\":1}}],[\"用于计算是否有时间序列满足该条件\",{\"1\":{\"108\":1}}],[\"用于定义一组合同类型的操作\",{\"1\":{\"419\":1}}],[\"用于定义一些全局的公共参数\",{\"1\":{\"106\":1}}],[\"用于描述一种通用的概念\",{\"1\":{\"419\":1}}],[\"用于描述多线程环境中内存操作的顺序和可见性\",{\"1\":{\"136\":1}}],[\"用于实例化抽象类的对象\",{\"1\":{\"419\":1}}],[\"用于实现类的多态性\",{\"1\":{\"419\":2}}],[\"用于实现并行计算\",{\"1\":{\"345\":1}}],[\"用于实现多线程对共享资源的互斥访问\",{\"1\":{\"152\":1}}],[\"用于构建类的继承层级结构\",{\"1\":{\"419\":1}}],[\"用于多路复用非阻塞\",{\"1\":{\"412\":1}}],[\"用于与客户端进行通信\",{\"1\":{\"411\":1}}],[\"用于高效地进行数据读写操作\",{\"1\":{\"406\":1}}],[\"用于在同一程序中进行线程间通信\",{\"1\":{\"404\":1}}],[\"用于在运行时扩展java类和实现动态代理\",{\"1\":{\"57\":1}}],[\"用于监听和接收客户端的连接请求\",{\"1\":{\"404\":1}}],[\"用于通过\",{\"1\":{\"404\":2}}],[\"用于对文件进行读写操作\",{\"1\":{\"404\":1}}],[\"用于对数据进行读取和写入操作\",{\"1\":{\"404\":1}}],[\"用于对象之间的一对多的依赖关系\",{\"1\":{\"48\":1}}],[\"用于对象的实例化\",{\"1\":{\"10\":1}}],[\"用于提供更高效的字符写入功能\",{\"1\":{\"399\":1}}],[\"用于提供更高效的字符读取功能\",{\"1\":{\"399\":1}}],[\"用于提供更高效的字节写入功能\",{\"1\":{\"399\":1}}],[\"用于提供更高效的字节读取功能\",{\"1\":{\"399\":1}}],[\"用于将字符数据写入文件的流\",{\"1\":{\"399\":1}}],[\"用于将字符数据写入目标\",{\"1\":{\"399\":1}}],[\"用于将字节数据写入文件的流\",{\"1\":{\"399\":1}}],[\"用于将字节数据写入目标\",{\"1\":{\"399\":1}}],[\"用于从文件中读取字符数据的流\",{\"1\":{\"399\":1}}],[\"用于从文件中读取字节数据的流\",{\"1\":{\"399\":1}}],[\"用于从源中读取字符数据\",{\"1\":{\"399\":1}}],[\"用于从源中读取字节数据\",{\"1\":{\"399\":1}}],[\"用于从一个账户向另一个账户转移一定金额的资金\",{\"1\":{\"139\":1}}],[\"用于获取指定位置的元素\",{\"1\":{\"363\":1}}],[\"用于添加\",{\"1\":{\"352\":1}}],[\"用于处理不同类型的集合\",{\"1\":{\"351\":1}}],[\"用于处理资源竞争情况下的线程等待\",{\"1\":{\"158\":1}}],[\"用于把\",{\"1\":{\"348\":1}}],[\"用于替换队列中\",{\"1\":{\"347\":1}}],[\"用于创建一个空的\",{\"1\":{\"385\":1}}],[\"用于创建工作线程forkjoinworkerthread\",{\"1\":{\"347\":1}}],[\"用于创建产品对象的接口\",{\"1\":{\"43\":1}}],[\"用于不返回结果的任务\",{\"1\":{\"346\":1}}],[\"用于返回结果的任务\",{\"1\":{\"346\":1}}],[\"用于执行\",{\"1\":{\"346\":1}}],[\"用于执行具体的任务\",{\"1\":{\"323\":3,\"336\":1}}],[\"用于存储键值对\",{\"1\":{\"379\":1}}],[\"用于存储元素\",{\"1\":{\"358\":1}}],[\"用于存储不重复的元素\",{\"1\":{\"353\":1}}],[\"用于存储本地变量的\",{\"1\":{\"282\":1}}],[\"用于存放元素\",{\"1\":{\"233\":1}}],[\"用于保存元素并控制元素的插入\",{\"1\":{\"351\":1}}],[\"用于保存线程本地变量的值\",{\"1\":{\"288\":1}}],[\"用于保存此时没有获取到锁的线程\",{\"1\":{\"175\":1}}],[\"用于保护共享资源\",{\"1\":{\"145\":1}}],[\"用于加载内存偏移地址\",{\"1\":{\"170\":1}}],[\"用于表示不可变\",{\"1\":{\"435\":1}}],[\"用于表示有序的元素集合\",{\"1\":{\"352\":1}}],[\"用于表示同步器的状态\",{\"1\":{\"163\":1}}],[\"用于表示只有当触发条件持续一段时间后才发送告警\",{\"1\":{\"108\":1}}],[\"用于线程间的异步通信和协作\",{\"1\":{\"159\":1}}],[\"用于优化对同步块的访问\",{\"1\":{\"153\":1}}],[\"用于管理对该对象的同步访问\",{\"1\":{\"152\":1}}],[\"用于指定一组附加信息\",{\"1\":{\"108\":1}}],[\"用于指标数据的统计\",{\"1\":{\"98\":1}}],[\"用于等待抑制告警\",{\"1\":{\"107\":1}}],[\"用于向alertmanager发送告警消息\",{\"1\":{\"101\":1}}],[\"用于统计请求的耗时\",{\"1\":{\"98\":1}}],[\"用于统计请求的数量\",{\"1\":{\"98\":1}}],[\"用于java程序的指标暴露\",{\"1\":{\"98\":1}}],[\"用于求分位数\",{\"1\":{\"75\":1}}],[\"用于解耦对象的实例化过程\",{\"1\":{\"10\":1}}],[\"采用非公平策略\",{\"1\":{\"181\":1}}],[\"采用的数据模型是单值模型\",{\"1\":{\"74\":1}}],[\"采用装饰器模式能够快速的扩展功能\",{\"1\":{\"32\":1}}],[\"采集了node\",{\"1\":{\"72\":1}}],[\"采集node\",{\"0\":{\"69\":1},\"1\":{\"101\":1}}],[\"采集监控对象的指标\",{\"1\":{\"64\":1}}],[\"采集目标可以使用服务发现的方式\",{\"1\":{\"62\":1}}],[\"通信结束后\",{\"1\":{\"410\":1,\"411\":1}}],[\"通道是一个用于读写数据的对象\",{\"1\":{\"403\":1}}],[\"通道\",{\"1\":{\"403\":1,\"404\":1}}],[\"通道和非阻塞\",{\"1\":{\"403\":1}}],[\"通知线程2将线程的缓存的\",{\"1\":{\"132\":1}}],[\"通配符进行模糊匹配查询\",{\"1\":{\"81\":1}}],[\"通常表示系统的严重错误或问题\",{\"1\":{\"432\":1}}],[\"通常表示程序中可预见的异常情况\",{\"1\":{\"432\":1}}],[\"通常也需要重写hashcode\",{\"1\":{\"431\":1}}],[\"通常都需要重写equals\",{\"1\":{\"430\":1}}],[\"通常需要遵循以下步骤\",{\"1\":{\"410\":1,\"411\":1,\"412\":1}}],[\"通常使用线程池+runnable来实现\",{\"1\":{\"336\":1}}],[\"通常使用以下的关键字\",{\"1\":{\"89\":1}}],[\"通常不推荐\",{\"1\":{\"297\":1}}],[\"通常在使用完threadlocal后需要调用remove\",{\"1\":{\"287\":1}}],[\"通常new出来的对象就是强引用类型\",{\"1\":{\"286\":1}}],[\"通常一个容器的所有操作共用一把锁\",{\"1\":{\"222\":1}}],[\"通常只有一个事件调度线程会访问某些部件\",{\"1\":{\"150\":1}}],[\"通常设置为3小时或更长时间\",{\"1\":{\"107\":1}}],[\"通常是抽象方法\",{\"1\":{\"419\":1}}],[\"通常是将\",{\"1\":{\"377\":1}}],[\"通常是因为调用了\",{\"1\":{\"347\":1}}],[\"通常是webhook\",{\"1\":{\"101\":1}}],[\"通常是pull模式\",{\"1\":{\"62\":1}}],[\"通常情况下\",{\"1\":{\"79\":1}}],[\"通常15\",{\"1\":{\"64\":1}}],[\"通过合理地使用try\",{\"1\":{\"432\":1}}],[\"通过合理安排指令执行的顺序\",{\"1\":{\"118\":1}}],[\"通过hashcode\",{\"1\":{\"431\":1}}],[\"通过父类引用调用重写的方法时\",{\"1\":{\"424\":1}}],[\"通过关键字\",{\"1\":{\"419\":2}}],[\"通过无限循环不断调用\",{\"1\":{\"414\":1}}],[\"通过返回的\",{\"1\":{\"411\":1}}],[\"通过适当地使用这些方法\",{\"1\":{\"406\":1}}],[\"通过上界来限制读写的范围\",{\"1\":{\"406\":1}}],[\"通过内部的指针来操作字符数组中的数据\",{\"1\":{\"401\":1}}],[\"通过使用\",{\"1\":{\"389\":1,\"407\":1}}],[\"通过使用分段锁\",{\"1\":{\"245\":1}}],[\"通过调用静态的\",{\"1\":{\"410\":1,\"411\":1}}],[\"通过调用\",{\"1\":{\"386\":1,\"407\":2,\"412\":3}}],[\"通过调用lock\",{\"1\":{\"147\":1}}],[\"通过链表和红黑树的形式来解决\",{\"1\":{\"379\":1}}],[\"通过实现接口\",{\"1\":{\"419\":1}}],[\"通过实现\",{\"1\":{\"364\":1}}],[\"通过future接口提供的方法可以查看异步计算是否执行完成\",{\"1\":{\"326\":1}}],[\"通过futuretask的run方法来执行\",{\"1\":{\"317\":1}}],[\"通过执行callable任务的call方法\",{\"1\":{\"318\":1}}],[\"通过waitnode类封装当前线程\",{\"1\":{\"317\":1}}],[\"通过executor\",{\"1\":{\"316\":1}}],[\"通过submit方法提交的callable任务会被封装成了一个futuretask对象\",{\"1\":{\"316\":2}}],[\"通过unsafe设置waiters相应的waitnode为null\",{\"1\":{\"315\":1}}],[\"通过unlock方法释放锁\",{\"1\":{\"313\":1}}],[\"通过gettask方法从阻塞队列中获取等待的任务\",{\"1\":{\"310\":1,\"313\":1}}],[\"通过get方法获取变量的值\",{\"1\":{\"288\":1}}],[\"通过高3位表示线程池的运行状态\",{\"1\":{\"309\":1}}],[\"通过设置合适的\",{\"1\":{\"296\":1}}],[\"通过硬件的原子性指令来实现线程安全的更新操作\",{\"1\":{\"246\":1}}],[\"通过创建新的底层数组来实现写操作的线程安全性\",{\"1\":{\"242\":1}}],[\"通过创建新的数组来处理写操作\",{\"1\":{\"223\":1}}],[\"通过经典的在循环中调用\",{\"1\":{\"186\":1}}],[\"通过反射机制获取到unsafe类\",{\"1\":{\"175\":1}}],[\"通过反射机制获取到unsafe对象\",{\"1\":{\"175\":1}}],[\"通过该偏移地址\",{\"1\":{\"170\":1}}],[\"通过共享锁对象的wait\",{\"1\":{\"160\":1}}],[\"通过共享对象池技术\",{\"1\":{\"11\":1}}],[\"通过偏向锁\",{\"1\":{\"150\":1}}],[\"通过这两个方法\",{\"1\":{\"190\":1}}],[\"通过这两段描述\",{\"1\":{\"147\":1}}],[\"通过这种方式\",{\"1\":{\"143\":1,\"358\":1}}],[\"通过这种直方图可以很方便的统计请求耗时分布的真实状态\",{\"1\":{\"78\":1}}],[\"通过比较当前账户和目标账户的id字段\",{\"1\":{\"143\":1}}],[\"通过为资源定义线性顺序\",{\"1\":{\"141\":1}}],[\"通过信号量\",{\"1\":{\"130\":1}}],[\"通过resmanager\",{\"1\":{\"142\":1}}],[\"通过recording\",{\"1\":{\"115\":1}}],[\"通过rule\",{\"1\":{\"116\":1}}],[\"通过向alertmanager\",{\"1\":{\"105\":1}}],[\"通过配置文件去配置一些配置\",{\"1\":{\"105\":1}}],[\"通过alertmanager的配置可以忽略与该集群有关的其它告警功能\",{\"1\":{\"104\":1}}],[\"通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态\",{\"1\":{\"92\":1}}],[\"通过instant\",{\"1\":{\"82\":1}}],[\"通过以下表达式可以选择最近5分钟内的所有样本数据\",{\"1\":{\"82\":1}}],[\"通过\",{\"1\":{\"74\":1,\"146\":1,\"188\":1,\"265\":4,\"267\":2,\"281\":1,\"323\":1,\"337\":2,\"339\":1,\"340\":1,\"374\":1,\"382\":1,\"385\":1,\"405\":1,\"406\":3,\"407\":2,\"410\":3,\"411\":2}}],[\"通过拉prometheus的配置热更新接口\",{\"1\":{\"70\":1}}],[\"通过可视化仪表盘能够直接获取系统的运行状态\",{\"1\":{\"65\":1}}],[\"通过监控能够方便的对系统进行跟踪和比较\",{\"1\":{\"65\":1}}],[\"通过对不同监控监控以及历史数据的分析\",{\"1\":{\"65\":1}}],[\"通过对磁盘空间增长率的判断\",{\"1\":{\"65\":1}}],[\"通过对监控样本数据的持续收集和统计\",{\"1\":{\"65\":1}}],[\"通过prometheus建立完善的监控体系\",{\"1\":{\"65\":1}}],[\"通过了内置的告警规则计算\",{\"1\":{\"64\":1}}],[\"通过中间层push\",{\"1\":{\"62\":1}}],[\"通过包装不同的装饰器组合来满足自己的业务需求\",{\"1\":{\"32\":1}}],[\"通过复制原有的实例来创建新的实例\",{\"1\":{\"10\":1}}],[\"指令来进行加锁和解锁操作\",{\"1\":{\"153\":1}}],[\"指令执行时\",{\"1\":{\"147\":1}}],[\"指的是对共享变量的操作是不可分割的\",{\"1\":{\"120\":1}}],[\"指的是当一个线程修改了共享变量的值时\",{\"1\":{\"119\":1}}],[\"指标数据如下\",{\"1\":{\"98\":1}}],[\"指标的名称是监控样本的标识\",{\"1\":{\"80\":1}}],[\"指标的类型\",{\"0\":{\"75\":1}}],[\"指标名将会被删除\",{\"1\":{\"85\":1}}],[\"指标名和标签名的命名需要满足\",{\"1\":{\"74\":1}}],[\"指标名称的定义可以参考下面一小节\",{\"1\":{\"113\":1}}],[\"指标名称\",{\"1\":{\"74\":1}}],[\"指标是由指标名和标签组成\",{\"1\":{\"74\":1}}],[\"指标是单值模型\",{\"1\":{\"74\":1}}],[\"指标在不同时间有不同的值\",{\"1\":{\"74\":1}}],[\"指标在不同时间下的值\",{\"1\":{\"74\":1}}],[\"指标定义如下\",{\"1\":{\"74\":1}}],[\"指标\",{\"1\":{\"62\":1,\"74\":1}}],[\"指南\",{\"0\":{\"4\":1}}],[\"白盒监控\",{\"1\":{\"62\":1}}],[\"作为缓冲区\",{\"1\":{\"405\":1}}],[\"作为值存储在\",{\"1\":{\"386\":1}}],[\"作为键\",{\"1\":{\"386\":1}}],[\"作为新的\",{\"1\":{\"377\":1}}],[\"作为新一代的监控系统\",{\"1\":{\"62\":1}}],[\"作为参数\",{\"1\":{\"375\":1,\"386\":1,\"387\":1,\"388\":1}}],[\"作为扩展对象功能的出发点\",{\"1\":{\"12\":1}}],[\"云平台配合\",{\"1\":{\"61\":1}}],[\"云原生计算基金会\",{\"1\":{\"61\":1}}],[\"能通过tcp读写网络中的数据\",{\"1\":{\"403\":1}}],[\"能通过udp读写网络中的数据\",{\"1\":{\"403\":1}}],[\"能更好地与容器平台\",{\"1\":{\"61\":1}}],[\"能够更高效地处理多个连接的读写事件\",{\"1\":{\"416\":1}}],[\"能够保证即使某个连接阻塞\",{\"1\":{\"416\":1}}],[\"能够与服务器端建立连接\",{\"1\":{\"415\":1}}],[\"能够同时处理多个客户端连接\",{\"1\":{\"414\":1}}],[\"能够实现高性能的并发\",{\"1\":{\"412\":1}}],[\"能够实现不同产品族的兼容性和高度可扩展性\",{\"1\":{\"47\":1}}],[\"能够提供更好的并发性能\",{\"1\":{\"218\":1}}],[\"能够提高读操作的并发性能\",{\"1\":{\"218\":1}}],[\"能够找到并解决根源问题\",{\"1\":{\"65\":1}}],[\"能够快速的扩展现有类的功能\",{\"1\":{\"32\":1}}],[\"能够熟练使用设计模式\",{\"1\":{\"13\":1}}],[\"同步执行任务\",{\"1\":{\"349\":1}}],[\"同步执行右边的子任务\",{\"1\":{\"349\":1}}],[\"同步队列sync\",{\"1\":{\"193\":1}}],[\"同步队列\",{\"1\":{\"180\":1,\"195\":1,\"297\":1}}],[\"同步块执行速度较长\",{\"1\":{\"152\":1}}],[\"同步块执行速度非常快\",{\"1\":{\"152\":1}}],[\"同步代码块\",{\"1\":{\"146\":1}}],[\"同步方法会对整个方法进行同步\",{\"1\":{\"153\":1}}],[\"同步方法\",{\"1\":{\"146\":1}}],[\"同样的方式\",{\"1\":{\"370\":1}}],[\"同样的\",{\"1\":{\"98\":1}}],[\"同操作运算符一样\",{\"1\":{\"86\":1,\"87\":1}}],[\"同理\",{\"1\":{\"81\":1}}],[\"同年6月正式发布1\",{\"1\":{\"61\":1}}],[\"同时提供了更好的可维护性和扩展性\",{\"1\":{\"420\":1}}],[\"同时将位置设置为\",{\"1\":{\"406\":2}}],[\"同时在另一个方向上写入数据\",{\"1\":{\"404\":1}}],[\"同时更新\",{\"1\":{\"364\":1}}],[\"同时还封装了一个缓冲区\",{\"1\":{\"401\":1}}],[\"同时还实现了deque\",{\"1\":{\"366\":1}}],[\"同时还实现了\",{\"1\":{\"357\":1}}],[\"同时还可以取消执行\",{\"1\":{\"326\":1}}],[\"同时还可以减少连接的创建和销毁开销\",{\"1\":{\"283\":1}}],[\"同时还包括一个静态初始化块\",{\"1\":{\"170\":1}}],[\"同时也实现了searializable接口\",{\"1\":{\"269\":1}}],[\"同时也为java标准库中的诸如reentrantlock\",{\"1\":{\"162\":1}}],[\"同时实现了blockingqueue接口\",{\"1\":{\"269\":1}}],[\"同时实现了randomaccess接口\",{\"1\":{\"232\":1}}],[\"同时保证在迭代过程中不会抛出\",{\"1\":{\"242\":1}}],[\"同时减少了潜在的错误\",{\"1\":{\"147\":1}}],[\"同时处理i\",{\"1\":{\"118\":1}}],[\"同时prometheus读取告警规则文件\",{\"1\":{\"101\":1}}],[\"同时prometheus作为一个时序数据库\",{\"1\":{\"72\":1}}],[\"同时\",{\"1\":{\"51\":1,\"136\":1,\"227\":1,\"249\":1,\"291\":1,\"340\":1,\"358\":1,\"379\":1,\"403\":1}}],[\"同时它具有以下的缺点\",{\"1\":{\"47\":1}}],[\"同时它是线程安全的\",{\"1\":{\"19\":1}}],[\"同时有不会影响原有的公民\",{\"1\":{\"32\":1}}],[\"告警规则的名称\",{\"1\":{\"108\":1}}],[\"告警路由\",{\"1\":{\"106\":1}}],[\"告警时间间隔\",{\"1\":{\"103\":1}}],[\"告警分组\",{\"1\":{\"103\":1}}],[\"告警消息的处理程序alertmanager\",{\"1\":{\"101\":1}}],[\"告警发送\",{\"1\":{\"101\":1}}],[\"告警语句的配置\",{\"1\":{\"80\":1}}],[\"告警\",{\"1\":{\"65\":1}}],[\"告警管理等一系列工具包\",{\"1\":{\"61\":1}}],[\"告警计算\",{\"1\":{\"61\":1}}],[\"最高位仅用于表示正负\",{\"1\":{\"429\":1}}],[\"最多返回interger的软最大值\",{\"1\":{\"361\":1}}],[\"最常见的缓存行大小是64个字节\",{\"1\":{\"347\":1}}],[\"最常用的是\",{\"1\":{\"266\":1}}],[\"最大worker的数量\",{\"1\":{\"308\":1}}],[\"最大线程数\",{\"1\":{\"303\":1}}],[\"最大线程池的大小\",{\"1\":{\"294\":1}}],[\"最大数组大小\",{\"1\":{\"256\":1}}],[\"最大程度地提高计算机系统的整体性能\",{\"1\":{\"118\":1}}],[\"最新的操作函数在前\",{\"1\":{\"115\":1}}],[\"最好创建一个目录专门存储告警规则文件\",{\"1\":{\"108\":1}}],[\"最终会执行的代码块\",{\"1\":{\"437\":1}}],[\"最终等待子任务执行完成\",{\"1\":{\"349\":1}}],[\"最终结果为\",{\"1\":{\"340\":1}}],[\"最终通过locksupport的park或parknanos挂起线程\",{\"1\":{\"317\":1}}],[\"最终执行的是futuretask的run方法\",{\"1\":{\"316\":1}}],[\"最终导致结果为1而不是2\",{\"1\":{\"124\":1}}],[\"最终的执行结果是一致的\",{\"1\":{\"128\":1}}],[\"最终的结果是1\",{\"1\":{\"120\":1}}],[\"最终的技术架构如下\",{\"1\":{\"59\":1}}],[\"最终根据上面的表达式得到的指标的名称是instance\",{\"1\":{\"115\":1}}],[\"最终我的配置修改成如下\",{\"1\":{\"107\":1}}],[\"最终将消息发送给第三方组件\",{\"1\":{\"101\":1}}],[\"最后修改时间\",{\"1\":{\"401\":1}}],[\"最后返回删除节点的数据域\",{\"1\":{\"370\":1}}],[\"最后将结果合并起来得到最终结果\",{\"1\":{\"345\":1}}],[\"最后将结果再次从高速缓存区复制回主内存\",{\"1\":{\"124\":1}}],[\"最后都会调用finishcompletion\",{\"1\":{\"333\":1}}],[\"最后中断左右正在运行中的worker\",{\"1\":{\"319\":1}}],[\"最后输出变量a的值\",{\"1\":{\"119\":1}}],[\"最后使用是rate操作\",{\"1\":{\"115\":1}}],[\"最后webhook发送给告警平台\",{\"1\":{\"101\":1}}],[\"最后\",{\"1\":{\"26\":1,\"120\":1,\"259\":1,\"281\":1,\"323\":2,\"340\":1,\"362\":1,\"368\":1,\"369\":1,\"377\":1,\"405\":1,\"406\":1}}],[\"kit\",{\"1\":{\"433\":1}}],[\"k++\",{\"1\":{\"395\":1}}],[\"kobe\",{\"1\":{\"376\":1}}],[\"know\",{\"1\":{\"311\":1}}],[\"keepalivetime的时间单位\",{\"1\":{\"294\":1}}],[\"keepalivetime被销毁线程的存活时间\",{\"1\":{\"294\":1}}],[\"keepalivetime\",{\"0\":{\"296\":1},\"1\":{\"294\":5,\"296\":5,\"303\":1,\"308\":1,\"314\":2}}],[\"keyiterator\",{\"1\":{\"412\":4}}],[\"keysplitertor\",{\"1\":{\"252\":1}}],[\"keyspliterator\",{\"1\":{\"252\":1}}],[\"keysetview<k\",{\"1\":{\"256\":1}}],[\"keyset\",{\"1\":{\"247\":1,\"256\":1}}],[\"key\",{\"1\":{\"110\":1,\"219\":4,\"220\":4,\"221\":5,\"224\":2,\"247\":8,\"259\":13,\"260\":9,\"261\":6,\"351\":1,\"354\":3,\"376\":17,\"377\":1,\"378\":20,\"382\":1,\"412\":4,\"414\":21}}],[\"keyborad\",{\"1\":{\"26\":1}}],[\"keyboard\",{\"1\":{\"26\":5}}],[\"kc\",{\"1\":{\"259\":6}}],[\"k\",{\"1\":{\"90\":2,\"233\":2,\"256\":5,\"259\":14,\"260\":1,\"261\":1,\"277\":4,\"374\":1,\"376\":6,\"378\":6,\"395\":1}}],[\"kafka\",{\"1\":{\"59\":1}}],[\"旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统\",{\"1\":{\"59\":1}}],[\"拦截静态方法等\",{\"1\":{\"57\":1}}],[\"更好的做法是使用try\",{\"1\":{\"437\":1}}],[\"更加灵活和高效\",{\"1\":{\"403\":1}}],[\"更改其他线程的高速缓存中volatile关键字修饰变量状态为无效状态\",{\"1\":{\"130\":1}}],[\"更新为\",{\"1\":{\"368\":1}}],[\"更新\",{\"1\":{\"364\":1}}],[\"更新调度相关的数据结构等操作\",{\"1\":{\"120\":1}}],[\"更新计划\",{\"0\":{\"1\":1,\"2\":1}}],[\"更灵活地满足额外需求\",{\"1\":{\"57\":1}}],[\"测试cglib\",{\"1\":{\"57\":1}}],[\"测试类\",{\"1\":{\"41\":1}}],[\"结论\",{\"1\":{\"399\":1}}],[\"结构\",{\"1\":{\"374\":1}}],[\"结构型设计模式是多个对象实例的结合或者组装\",{\"1\":{\"11\":1}}],[\"结构型设计模式和行为型设计模式\",{\"1\":{\"9\":1}}],[\"结构型模式\",{\"0\":{\"11\":1}}],[\"结合使用\",{\"1\":{\"407\":1}}],[\"结合\",{\"1\":{\"323\":2}}],[\"结果\",{\"1\":{\"432\":1}}],[\"结果已经返回\",{\"1\":{\"186\":1}}],[\"结果返回时\",{\"1\":{\"186\":1}}],[\"结点的hash值与指定的hash值相等\",{\"1\":{\"261\":1}}],[\"结点的hash值相等并且key也相等\",{\"1\":{\"259\":1}}],[\"结点hash值大于0\",{\"1\":{\"261\":1}}],[\"结点hash值小于0\",{\"1\":{\"260\":1}}],[\"结点为红黑树结点类型\",{\"1\":{\"259\":1}}],[\"结点是否在共享模式下等待\",{\"1\":{\"168\":1}}],[\"结点所对应的线程\",{\"1\":{\"168\":1}}],[\"结点状态\",{\"1\":{\"168\":2}}],[\"结束cglib拦截\",{\"1\":{\"57\":2}}],[\"执行上述代码\",{\"1\":{\"432\":1}}],[\"执行上面的代码\",{\"1\":{\"157\":1}}],[\"执行上面代码输出\",{\"1\":{\"383\":1}}],[\"执行上面代码\",{\"1\":{\"156\":1,\"159\":1,\"191\":1}}],[\"执行finally块\",{\"1\":{\"432\":2}}],[\"执行futuretask类的get方法时\",{\"1\":{\"315\":1}}],[\"执行异步操作\",{\"1\":{\"340\":1}}],[\"执行异步操作并处理异步计算的结果\",{\"1\":{\"339\":1}}],[\"执行器等执行异步任务的线程配置\",{\"1\":{\"337\":1}}],[\"执行的逻辑是\",{\"1\":{\"331\":1}}],[\"执行的逻辑是q\",{\"1\":{\"331\":1}}],[\"执行过程是这样的\",{\"1\":{\"331\":1}}],[\"执行中断处理\",{\"1\":{\"329\":1}}],[\"执行afterexecute方法\",{\"1\":{\"313\":1}}],[\"执行addworker创建新线程执行command任务\",{\"1\":{\"311\":1}}],[\"执行beforeexecute\",{\"1\":{\"313\":1}}],[\"执行任务的run方法\",{\"1\":{\"313\":1}}],[\"执行任务的线程会使用调用线程来执行该任务\",{\"1\":{\"302\":1}}],[\"执行任务\",{\"1\":{\"312\":1,\"329\":2}}],[\"执行reject方法处理任务\",{\"1\":{\"311\":1}}],[\"执行具体的拒绝策略\",{\"1\":{\"308\":1}}],[\"执行时间以及系统的硬件资源等因素\",{\"1\":{\"295\":1}}],[\"执行完才能执行对账操作\",{\"1\":{\"191\":1}}],[\"执行对账操作\",{\"1\":{\"203\":1}}],[\"执行对账\",{\"1\":{\"191\":2,\"203\":1}}],[\"执行了这2个操作\",{\"1\":{\"191\":1}}],[\"执行线程将先获取monitor\",{\"1\":{\"147\":1}}],[\"执行monitorexit的线程必须是objectref所对应的monitor的所有者\",{\"1\":{\"147\":1}}],[\"执行资金转移操作\",{\"1\":{\"143\":1}}],[\"执行启动命令\",{\"1\":{\"67\":1}}],[\"执行解压\",{\"1\":{\"67\":1}}],[\"执行结果如下\",{\"1\":{\"57\":1,\"418\":1}}],[\"执行目标对象的方法\",{\"1\":{\"57\":1}}],[\"执行测试类\",{\"1\":{\"31\":1}}],[\"开发者可以实现高并发\",{\"1\":{\"407\":1}}],[\"开始执行回调函数\",{\"1\":{\"342\":1}}],[\"开始cglib拦截\",{\"1\":{\"57\":2}}],[\"开起了10个线程\",{\"1\":{\"132\":1}}],[\"开启httpserver\",{\"1\":{\"98\":1}}],[\"开闭原则\",{\"1\":{\"14\":1}}],[\"工作线程在处理自己的工作队列同时\",{\"1\":{\"347\":1}}],[\"工作线程在处理自己工作队列的任务时\",{\"1\":{\"347\":1}}],[\"工作线程在运行中产生新的任务\",{\"1\":{\"347\":1}}],[\"工作流程包括\",{\"1\":{\"101\":1}}],[\"工具类\",{\"1\":{\"57\":1}}],[\"工厂类负责了两个职责\",{\"1\":{\"41\":1}}],[\"工厂类包含了所有产品对象的创建逻辑\",{\"1\":{\"41\":1}}],[\"工厂类包含了必要的逻辑判断\",{\"1\":{\"41\":1}}],[\"工厂类根据客户端传入的参数来创建相应的产品对象\",{\"1\":{\"40\":1}}],[\"工厂类\",{\"1\":{\"40\":1,\"41\":1}}],[\"工厂模式\",{\"0\":{\"38\":1}}],[\"工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"45\":1}}],[\"工厂方法模式包含以下角色\",{\"1\":{\"43\":1}}],[\"工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题\",{\"1\":{\"42\":1}}],[\"工厂方法模式\",{\"0\":{\"42\":1},\"1\":{\"10\":1,\"13\":1,\"42\":1}}],[\"为例\",{\"1\":{\"429\":1}}],[\"为单位\",{\"1\":{\"399\":1}}],[\"为单位存储的\",{\"1\":{\"347\":1}}],[\"为尾节点\",{\"1\":{\"370\":1}}],[\"为头节点\",{\"1\":{\"370\":1}}],[\"为红黑树结点类型\",{\"1\":{\"261\":1}}],[\"为指定元素e\",{\"1\":{\"239\":1}}],[\"为newelements\",{\"1\":{\"238\":1}}],[\"为null\",{\"1\":{\"238\":1,\"239\":1}}],[\"为elements\",{\"1\":{\"234\":1}}],[\"为0则返回1\",{\"1\":{\"198\":1}}],[\"为此我们通过调用\",{\"1\":{\"191\":1}}],[\"为signal\",{\"1\":{\"173\":1}}],[\"为condition\",{\"1\":{\"173\":1}}],[\"为propagate\",{\"1\":{\"173\":1}}],[\"为1时表示已经有一个线程持有了锁\",{\"1\":{\"175\":1}}],[\"为1\",{\"1\":{\"173\":1}}],[\"为\",{\"1\":{\"173\":1,\"347\":1,\"368\":1,\"370\":2}}],[\"为了保持一致性\",{\"1\":{\"431\":1}}],[\"为了保持数组的连续性\",{\"1\":{\"358\":1}}],[\"为了避免性能问题\",{\"1\":{\"152\":1}}],[\"为了确保线程安全\",{\"1\":{\"147\":1}}],[\"为了确保多核处理器的数据一致性\",{\"1\":{\"124\":1}}],[\"为了解决缓存不一致的问题\",{\"1\":{\"124\":1}}],[\"为了解决这个问题\",{\"1\":{\"124\":1}}],[\"为了解决该问题\",{\"1\":{\"92\":1}}],[\"为了充分利用cpu的高性能\",{\"1\":{\"118\":1}}],[\"为什么会这样呢\",{\"1\":{\"436\":1}}],[\"为什么会有人把equals方法当做是比较两个内容的比较呢\",{\"1\":{\"430\":1}}],[\"为什么会有可见性\",{\"0\":{\"118\":1}}],[\"为什么内部类引用的外部变量必须用final修饰\",{\"0\":{\"436\":1}}],[\"为什么java不支持多继承\",{\"0\":{\"420\":1}}],[\"为什么需要double\",{\"1\":{\"311\":1}}],[\"为什么线程池不允许使用executors去创建\",{\"0\":{\"304\":1}}],[\"为什么我们的预期和程序时机的输出会有差异呢\",{\"1\":{\"119\":1}}],[\"为什么要使用volatile关键字来修饰静态的instance对象呢\",{\"1\":{\"121\":1}}],[\"为什么要使用观察者模式\",{\"0\":{\"51\":1}}],[\"为什么要使用责任链模式\",{\"0\":{\"37\":1}}],[\"为什么要使用装饰器模式\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"为目标对象生成代理对象\",{\"1\":{\"57\":1}}],[\"维护一个目标对象\",{\"1\":{\"57\":1}}],[\"v2\",{\"1\":{\"430\":2}}],[\"vm\",{\"1\":{\"288\":1}}],[\"v>\",{\"1\":{\"249\":3,\"256\":8,\"259\":37,\"260\":2,\"261\":6,\"376\":3,\"377\":7,\"378\":6}}],[\"vs\",{\"1\":{\"173\":1,\"399\":1}}],[\"virtual\",{\"1\":{\"433\":2}}],[\"views\",{\"1\":{\"256\":1}}],[\"via\",{\"1\":{\"256\":2}}],[\"visibility\",{\"1\":{\"119\":1,\"271\":1}}],[\"victoriametrics\",{\"1\":{\"62\":1}}],[\"victoriametrics系列\",{\"1\":{\"59\":1}}],[\"v\",{\"1\":{\"92\":1,\"93\":1,\"147\":1,\"259\":12,\"260\":1,\"261\":5,\"317\":1,\"318\":1,\"325\":1,\"326\":2,\"329\":4,\"330\":1,\"374\":1,\"378\":2}}],[\"val\",{\"1\":{\"259\":5,\"260\":3,\"261\":4,\"431\":2}}],[\"validated\",{\"1\":{\"261\":4}}],[\"validate\",{\"1\":{\"221\":1}}],[\"value为业务需要存储的object\",{\"1\":{\"285\":1}}],[\"value为null\",{\"1\":{\"261\":1}}],[\"value值添加到红黑树中\",{\"1\":{\"259\":1}}],[\"value是否为空\",{\"1\":{\"259\":1}}],[\"value放入红黑树\",{\"1\":{\"259\":1}}],[\"valuea\",{\"1\":{\"247\":2}}],[\"valuesview<k\",{\"1\":{\"256\":1}}],[\"valuesetview\",{\"1\":{\"253\":1}}],[\"valuespliterator\",{\"1\":{\"252\":2}}],[\"values\",{\"1\":{\"90\":2,\"256\":1,\"282\":1}}],[\"value1\",{\"1\":{\"81\":1}}],[\"value2\",{\"1\":{\"81\":1}}],[\"value\",{\"1\":{\"74\":3,\"81\":5,\"90\":3,\"219\":2,\"220\":2,\"221\":2,\"224\":2,\"247\":7,\"256\":4,\"259\":9,\"261\":6,\"265\":1,\"281\":3,\"282\":4,\"288\":4,\"304\":1,\"351\":1,\"354\":1,\"361\":1,\"376\":5,\"377\":1,\"378\":2,\"382\":1,\"393\":3,\"430\":4,\"431\":3,\"438\":1}}],[\"value键值对\",{\"1\":{\"61\":1}}],[\"variance\",{\"1\":{\"90\":1}}],[\"v1\",{\"1\":{\"81\":4,\"85\":1,\"430\":2}}],[\"verification=5sx1ko4m39zil01olnc4to63vx0yonq5anftinbe278\",{\"1\":{\"263\":1}}],[\"version\",{\"1\":{\"110\":2,\"185\":1}}],[\"version=\",{\"1\":{\"68\":1}}],[\"version>\",{\"1\":{\"57\":1,\"97\":1,\"98\":3}}],[\"version>3\",{\"1\":{\"57\":1}}],[\"vector\",{\"0\":{\"81\":1,\"82\":1,\"88\":1},\"1\":{\"82\":1,\"88\":2,\"90\":2,\"92\":1,\"93\":1,\"94\":1}}],[\"void\",{\"1\":{\"26\":5,\"31\":5,\"36\":6,\"41\":2,\"44\":1,\"47\":2,\"50\":7,\"54\":5,\"56\":2,\"57\":2,\"98\":3,\"119\":3,\"131\":2,\"132\":3,\"139\":4,\"142\":5,\"143\":4,\"146\":4,\"147\":2,\"156\":2,\"157\":2,\"158\":2,\"159\":2,\"160\":3,\"163\":1,\"166\":1,\"169\":4,\"173\":3,\"175\":5,\"179\":3,\"183\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":7,\"191\":6,\"198\":5,\"199\":2,\"203\":3,\"214\":3,\"215\":1,\"219\":1,\"220\":1,\"221\":1,\"230\":1,\"235\":4,\"247\":1,\"259\":2,\"265\":1,\"267\":3,\"273\":2,\"277\":1,\"281\":1,\"282\":2,\"287\":1,\"288\":2,\"311\":1,\"313\":2,\"315\":1,\"318\":1,\"319\":4,\"323\":3,\"329\":3,\"333\":1,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":1,\"352\":1,\"353\":1,\"354\":1,\"360\":2,\"362\":1,\"364\":2,\"368\":1,\"369\":1,\"370\":1,\"383\":1,\"393\":1,\"395\":3,\"405\":1,\"406\":1,\"414\":5,\"415\":2,\"418\":6,\"419\":7,\"424\":3,\"432\":1,\"435\":6,\"436\":6,\"437\":1,\"438\":3}}],[\"volatile最常见的使用场景是状态标记\",{\"1\":{\"134\":1}}],[\"volatile的使用场景\",{\"0\":{\"133\":1}}],[\"volatile保证了共享数据的可见性\",{\"1\":{\"132\":1}}],[\"volatiletest\",{\"1\":{\"132\":3}}],[\"volatile不能保证原子性\",{\"0\":{\"132\":1}}],[\"volatile能够保证可见性和防止指令重排\",{\"0\":{\"131\":1}}],[\"volatile关键字作用\",{\"0\":{\"130\":1}}],[\"volatile详解\",{\"0\":{\"129\":1}}],[\"volatile\",{\"1\":{\"19\":1,\"121\":1,\"128\":2,\"132\":1,\"134\":1,\"135\":1,\"136\":2,\"153\":3,\"163\":1,\"168\":4,\"170\":3,\"175\":1,\"233\":1,\"240\":1,\"256\":7,\"308\":4,\"313\":1,\"317\":1,\"328\":4}}],[\"功能和使用也非常相似\",{\"1\":{\"401\":1}}],[\"功能\",{\"1\":{\"266\":1}}],[\"功能强大\",{\"1\":{\"57\":1}}],[\"功能限制\",{\"1\":{\"56\":1}}],[\"功能亮点\",{\"0\":{\"5\":1}}],[\"性能较好\",{\"1\":{\"421\":1}}],[\"性能\",{\"1\":{\"421\":1}}],[\"性能比较差\",{\"1\":{\"222\":1}}],[\"性能高\",{\"1\":{\"57\":1}}],[\"性能开销\",{\"1\":{\"56\":1}}],[\"性能监控等\",{\"1\":{\"56\":1}}],[\"缺点\",{\"1\":{\"56\":1,\"152\":1}}],[\"灵活性\",{\"1\":{\"56\":1}}],[\"灵活性非常高\",{\"1\":{\"51\":1}}],[\"远程调用\",{\"1\":{\"52\":1}}],[\"此过程是非阻塞的\",{\"1\":{\"303\":1}}],[\"此策略可避免锁定\",{\"1\":{\"298\":1}}],[\"此时可以把\",{\"1\":{\"347\":2}}],[\"此时线程池会根据设置的拒绝策略来处理提交的任务\",{\"1\":{\"303\":1}}],[\"此时线程池会判断是否需要创建新的线程来执行任务\",{\"1\":{\"303\":1}}],[\"此时newelements\",{\"1\":{\"239\":1}}],[\"此时\",{\"1\":{\"238\":1,\"287\":1,\"293\":3}}],[\"此时称为该线程持有锁\",{\"1\":{\"147\":1}}],[\"此数组在迭代器的生存期内不会更改\",{\"1\":{\"235\":1}}],[\"此函数对remove函数提供支持\",{\"1\":{\"261\":1}}],[\"此函数主要完成bincount的值加1的操作\",{\"1\":{\"259\":1}}],[\"此函数返回table数组中下标为i的结点\",{\"1\":{\"259\":1}}],[\"此函数用于将桶中的数据结构转化为红黑树\",{\"1\":{\"259\":1}}],[\"此函数用于将指定的hash\",{\"1\":{\"259\":1}}],[\"此函数用于将指定元素添加到此列表的尾部\",{\"1\":{\"238\":1}}],[\"此函数用于在扩容时将table表中的结点转移到nexttable中\",{\"1\":{\"259\":1}}],[\"此函数用于比较table数组下标为i的结点是否为c\",{\"1\":{\"259\":1}}],[\"此函数用于移除此列表指定位置上的元素\",{\"1\":{\"241\":1}}],[\"此函数用于用指定的元素替代此列表指定位置上的元素\",{\"1\":{\"240\":1}}],[\"此函数也调用了aqs的signalall函数\",{\"1\":{\"215\":1}}],[\"此函数的作用是损坏当前屏障\",{\"1\":{\"215\":1}}],[\"此函数的作用就是将处于条件队列中的节点转移到同步队列中\",{\"1\":{\"214\":1}}],[\"此函数完成了结点插入同步队列的过程\",{\"1\":{\"214\":1}}],[\"此函数完成的功能是sync\",{\"1\":{\"173\":1}}],[\"此函数判断头结点是否为空\",{\"1\":{\"214\":1}}],[\"此函数在所有线程进入屏障后会被调用\",{\"1\":{\"214\":1}}],[\"此函数在共享模式下释放资源\",{\"1\":{\"199\":1}}],[\"此函数为cyclicbarrier类的核心函数\",{\"1\":{\"213\":1}}],[\"此函数会依次将条件队列中的节点转移到同步队列中\",{\"1\":{\"214\":1}}],[\"此函数会试图设置状态来反映共享模式下的一个释放\",{\"1\":{\"199\":1}}],[\"此函数会以共享模式释放对象\",{\"1\":{\"199\":1}}],[\"此函数将递减锁存器的计数\",{\"1\":{\"199\":1}}],[\"此函数将会使当前线程在锁存器倒计数至零之前一直等待\",{\"1\":{\"198\":1}}],[\"此两种方法已经重写在了jdk的locksupport类中\",{\"1\":{\"175\":1}}],[\"此方法应该查询是否允许它在共享模式下获取对象状态\",{\"1\":{\"183\":1}}],[\"此方法应该查询是否允许它在独占模式下获取对象状态\",{\"1\":{\"173\":1}}],[\"此方法在行为上等效于\",{\"1\":{\"169\":1}}],[\"此类构造函数为从抽象构造函数\",{\"1\":{\"171\":1}}],[\"此类实现了condition接口\",{\"1\":{\"169\":1}}],[\"此处是变量a\",{\"1\":{\"119\":1}}],[\"此篇文章不讲解这部分内容\",{\"1\":{\"71\":1}}],[\"此外\",{\"1\":{\"51\":1,\"152\":1,\"221\":1}}],[\"此种模式是不推荐的\",{\"1\":{\"23\":1}}],[\"主要功能包括\",{\"1\":{\"414\":1}}],[\"主要可以向其他输出流\",{\"1\":{\"401\":1}}],[\"主要因为string\",{\"1\":{\"401\":1}}],[\"主要完成从流中读取数据时\",{\"1\":{\"401\":1}}],[\"主要包括通道channel\",{\"1\":{\"408\":1}}],[\"主要包括以下几类\",{\"1\":{\"399\":1}}],[\"主要包括两个重要的方法\",{\"1\":{\"190\":1}}],[\"主要用在编译器的语法\",{\"1\":{\"401\":1}}],[\"主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务\",{\"1\":{\"348\":1}}],[\"主要用于反射获取对象相应的字段\",{\"1\":{\"256\":1}}],[\"主要问题是线程数最大数是integer\",{\"1\":{\"304\":1}}],[\"主要问题是堆积的请求处理队列可能会耗费非常大的内存\",{\"1\":{\"304\":1}}],[\"主要明白arrays\",{\"1\":{\"236\":1}}],[\"主要原因\",{\"1\":{\"32\":1}}],[\"主线程需要等待线程\",{\"1\":{\"191\":1}}],[\"主线程启动子线程之后\",{\"1\":{\"158\":1}}],[\"主线程虽然更新了ready\",{\"1\":{\"131\":1}}],[\"主线程阻塞\",{\"1\":{\"119\":2}}],[\"主内存\",{\"1\":{\"127\":1}}],[\"主题实现类\",{\"1\":{\"53\":1,\"54\":1}}],[\"主题和观察者之间松耦合\",{\"1\":{\"51\":1}}],[\"观察者收到消息后可以做出响应\",{\"1\":{\"51\":1}}],[\"观察者会执行该方法\",{\"1\":{\"49\":1}}],[\"观察者observer\",{\"1\":{\"49\":1}}],[\"观察者模式是一种实用并且简单的设计模式\",{\"1\":{\"51\":1}}],[\"观察者模式也有一些缺点\",{\"1\":{\"51\":1}}],[\"观察者模式符合开闭原则\",{\"1\":{\"51\":1}}],[\"观察者模式的核心思想是将观察者对象注册到发布者对象中\",{\"1\":{\"51\":1}}],[\"观察者模式在软件开发中有非常多的应用\",{\"1\":{\"49\":1}}],[\"观察者模式uml图\",{\"0\":{\"49\":1}}],[\"观察者模式\",{\"0\":{\"48\":1},\"1\":{\"12\":1,\"13\":1,\"48\":1}}],[\"比特表的逻辑长度\",{\"1\":{\"392\":1}}],[\"比特的逻辑索引是非负整数\",{\"1\":{\"392\":1}}],[\"比起\",{\"1\":{\"118\":1}}],[\"比较结果为\",{\"1\":{\"429\":3}}],[\"比较结点t是否为尾结点\",{\"1\":{\"173\":1,\"214\":1}}],[\"比较的就是\",{\"1\":{\"429\":1}}],[\"比较的是引用而不是值\",{\"1\":{\"423\":1}}],[\"比较sizectl的值与sc是否相等\",{\"1\":{\"259\":1}}],[\"比较并且交换值\",{\"1\":{\"259\":1}}],[\"比较并且设置成功\",{\"1\":{\"197\":1,\"199\":1}}],[\"比较并且设置结点等待状态\",{\"1\":{\"173\":1}}],[\"比较并设置状态成功\",{\"1\":{\"183\":1,\"184\":1}}],[\"比较并设置pred\",{\"1\":{\"173\":1}}],[\"比较并设置pred结点的next节点为null\",{\"1\":{\"173\":1}}],[\"比较并设置前驱结点的状态为signal\",{\"1\":{\"173\":1}}],[\"比较并交换\",{\"1\":{\"153\":1,\"259\":1}}],[\"比较pred是否为尾结点\",{\"1\":{\"173\":1}}],[\"比较操作符\",{\"0\":{\"86\":1}}],[\"比较困难\",{\"1\":{\"47\":1}}],[\"比如如哈希表\",{\"1\":{\"431\":1}}],[\"比如数学运算\",{\"1\":{\"423\":1}}],[\"比如读\",{\"1\":{\"412\":1}}],[\"比如日志分析\",{\"1\":{\"394\":1}}],[\"比如日志记录\",{\"1\":{\"56\":1}}],[\"比如第1天是交易日\",{\"1\":{\"392\":1}}],[\"比如说有这么个场景\",{\"1\":{\"392\":1}}],[\"比如抛出异常或者丢弃任务\",{\"1\":{\"303\":1}}],[\"比如在string类中\",{\"1\":{\"431\":1}}],[\"比如在string内中\",{\"1\":{\"430\":1}}],[\"比如在web请求当中\",{\"1\":{\"287\":1}}],[\"比如在以下的代码中\",{\"1\":{\"29\":1}}],[\"比如log4j的mdc\",{\"1\":{\"283\":1}}],[\"比如vector\",{\"1\":{\"222\":1}}],[\"比如执行i++操作\",{\"1\":{\"124\":1}}],[\"比如将告警消息发送给运维人员的邮箱\",{\"1\":{\"110\":1}}],[\"比如用于描述告警详细信息的文字等\",{\"1\":{\"108\":1}}],[\"比如当发生severity=critical的告警时\",{\"1\":{\"107\":1}}],[\"比如按照alertname\",{\"1\":{\"107\":1}}],[\"比如配置每分钟的请求量\",{\"1\":{\"100\":1}}],[\"比如计算最近5分钟的请求次数\",{\"1\":{\"92\":1}}],[\"比如prometheus\",{\"1\":{\"90\":1}}],[\"比如p99\",{\"1\":{\"75\":1}}],[\"比如有以下的时间序列的样本\",{\"1\":{\"89\":1}}],[\"比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算\",{\"1\":{\"88\":1}}],[\"比如查询handler为\",{\"1\":{\"81\":1}}],[\"比如\",{\"1\":{\"81\":1,\"83\":1,\"86\":1,\"103\":1,\"126\":1,\"283\":1,\"386\":1,\"388\":1,\"416\":1}}],[\"比如我们求某个请求耗时的平均值\",{\"1\":{\"78\":1}}],[\"比如我们的mac电脑需要连接usb接口的键盘\",{\"1\":{\"25\":1}}],[\"比如node\",{\"1\":{\"77\":1}}],[\"比如求最近5分钟prometheus发生了多少次请求\",{\"1\":{\"76\":1}}],[\"比如主机的cpu\",{\"1\":{\"69\":1}}],[\"比如从k8s\",{\"1\":{\"68\":1}}],[\"比如可以将指标数据展示在grafana上\",{\"1\":{\"64\":1}}],[\"比如可以先使用加密装饰器\",{\"1\":{\"31\":1}}],[\"比如email\",{\"1\":{\"64\":1}}],[\"比如对消息的去重\",{\"1\":{\"63\":1}}],[\"比如对某一次请求进行不同的规则的校验\",{\"1\":{\"34\":1}}],[\"比如虚拟机\",{\"1\":{\"63\":1}}],[\"比如k8s系统\",{\"1\":{\"62\":1}}],[\"比如int\",{\"1\":{\"423\":1}}],[\"比如influxdb\",{\"1\":{\"62\":1}}],[\"比如i=0\",{\"1\":{\"124\":1}}],[\"比如id生成器\",{\"1\":{\"16\":1}}],[\"比如访问控制\",{\"1\":{\"52\":1}}],[\"比如发布者维护的观察者对象是无顺序的\",{\"1\":{\"51\":1}}],[\"比如家具厂除了生产沙发\",{\"1\":{\"45\":1}}],[\"比如sofa的生产\",{\"1\":{\"45\":1}}],[\"比如handle\",{\"1\":{\"35\":1}}],[\"比如使用类final关键字的类\",{\"1\":{\"30\":1}}],[\"比如案例中keyboard\",{\"1\":{\"26\":1}}],[\"比如图中的键盘\",{\"1\":{\"25\":1}}],[\"比如拓展坞类实现了目标接口typec接口\",{\"1\":{\"25\":1}}],[\"比如typec接口\",{\"1\":{\"25\":1}}],[\"比如工具类\",{\"1\":{\"16\":1}}],[\"客户端打印如下\",{\"1\":{\"415\":1}}],[\"客户端代码\",{\"0\":{\"415\":1}}],[\"客户端代码与具体产品的创建实现了解耦\",{\"1\":{\"47\":1}}],[\"客户端使用socketchannel\",{\"1\":{\"413\":1}}],[\"客户端和服务器端的实现\",{\"1\":{\"410\":1}}],[\"客户端通过抽象工厂来创建产品对象\",{\"1\":{\"44\":1}}],[\"椅子\",{\"1\":{\"45\":1}}],[\"无固定顺序\",{\"1\":{\"354\":1}}],[\"无序性\",{\"1\":{\"353\":1}}],[\"无许可线程工厂\",{\"1\":{\"347\":1}}],[\"无界队列\",{\"1\":{\"297\":1}}],[\"无元素则返回null\",{\"1\":{\"265\":1}}],[\"无竞争标识\",{\"1\":{\"259\":1}}],[\"无限循环\",{\"1\":{\"173\":2,\"197\":1,\"198\":2,\"199\":2,\"213\":1,\"214\":1,\"259\":3,\"261\":2}}],[\"无参构造函数创建一个初始容量为16\",{\"1\":{\"375\":1}}],[\"无参构造函数和带初始容量和负载因子的构造函数\",{\"1\":{\"375\":1}}],[\"无参构造函数默认使用非公平策略的锁\",{\"1\":{\"181\":1}}],[\"无参构造函数\",{\"1\":{\"168\":1,\"359\":1,\"385\":1}}],[\"无视队列顺序直接去抢锁\",{\"1\":{\"164\":1}}],[\"无需进行同步操作\",{\"1\":{\"150\":1}}],[\"无需通过字节码来完成\",{\"1\":{\"147\":1}}],[\"无需依赖接口\",{\"1\":{\"57\":1}}],[\"无需修改已有代码\",{\"1\":{\"44\":1}}],[\"无法保证finalize方法的及时执行\",{\"1\":{\"437\":1}}],[\"无法准确指定唤醒那一个线程\",{\"1\":{\"175\":1}}],[\"无法成功避免死锁\",{\"1\":{\"143\":1}}],[\"无法代理实现类的方法\",{\"1\":{\"56\":1}}],[\"无法使用动态代理\",{\"1\":{\"56\":1}}],[\"无论try块中是否发生异常\",{\"1\":{\"438\":1}}],[\"无论哪种情况\",{\"1\":{\"302\":1}}],[\"无论当前内存是否足够\",{\"1\":{\"286\":1}}],[\"无论是否有匹配的catch块\",{\"1\":{\"438\":2}}],[\"无论是否发生异常\",{\"1\":{\"432\":1,\"437\":1}}],[\"无论是同步方法还是同步代码块\",{\"1\":{\"146\":1}}],[\"无论是在前期的需求分析\",{\"1\":{\"8\":1}}],[\"无论指令是否重排\",{\"1\":{\"128\":1}}],[\"无论面对什么的环境\",{\"1\":{\"8\":1}}],[\"具有以下特点\",{\"1\":{\"188\":1}}],[\"具有指定等待时间的等待状态\",{\"1\":{\"155\":1}}],[\"具有非常高的计算能力和响应速度\",{\"1\":{\"118\":1}}],[\"具备良好的扩展性\",{\"1\":{\"44\":1}}],[\"具体将任务拆成了四个子任务\",{\"1\":{\"349\":1}}],[\"具体实现上\",{\"1\":{\"245\":1}}],[\"具体实现如下\",{\"1\":{\"31\":1,\"317\":1}}],[\"具体的对象体现\",{\"1\":{\"401\":1}}],[\"具体的迭代顺序可能因实现类或元素的插入顺序而不同\",{\"1\":{\"354\":1}}],[\"具体的排列顺序可能因实现类或元素的添加顺序而不同\",{\"1\":{\"353\":1}}],[\"具体的流程在下面的示例中会进行分析\",{\"1\":{\"199\":1}}],[\"具体的流程再之后会通过一个示例给出\",{\"1\":{\"198\":1}}],[\"具体的配置介绍如下\",{\"1\":{\"68\":1}}],[\"具体状态如下\",{\"1\":{\"168\":1}}],[\"具体而言\",{\"1\":{\"145\":1,\"242\":1}}],[\"具体来说\",{\"1\":{\"136\":1,\"142\":1,\"143\":1,\"160\":1,\"296\":1,\"424\":1}}],[\"具体表达式格式如下\",{\"1\":{\"116\":1}}],[\"具体预处理生成指标的表达式\",{\"1\":{\"113\":1}}],[\"具体命令如下\",{\"1\":{\"70\":1}}],[\"具体如下\",{\"1\":{\"68\":1,\"169\":1}}],[\"具体使用java\",{\"1\":{\"56\":1}}],[\"具体代码如下\",{\"1\":{\"54\":1}}],[\"具体观察者是观察者的具体实现\",{\"1\":{\"49\":1}}],[\"具体观察者\",{\"1\":{\"49\":1}}],[\"具体主题是主题的具体实现\",{\"1\":{\"49\":1}}],[\"具体主题\",{\"1\":{\"49\":1}}],[\"具体工厂类的代码更加简洁\",{\"1\":{\"44\":1}}],[\"具体工厂\",{\"1\":{\"43\":1,\"46\":1,\"47\":1}}],[\"具体产品类\",{\"1\":{\"40\":1,\"43\":1,\"46\":1,\"47\":1}}],[\"相应的try语句一定被执行到\",{\"1\":{\"438\":1}}],[\"相等性\",{\"1\":{\"431\":1}}],[\"相等则用\",{\"1\":{\"259\":1}}],[\"相同的元素可以出现在列表的不同位置\",{\"1\":{\"352\":1}}],[\"相当于直接交接任务给具体执行的线程\",{\"1\":{\"298\":1}}],[\"相当于对原有的类进行类一个包装\",{\"1\":{\"29\":1}}],[\"相对于传统的\",{\"1\":{\"403\":1}}],[\"相对于简单工厂\",{\"1\":{\"44\":1}}],[\"相对的实例副本都可被回收\",{\"1\":{\"280\":1}}],[\"相关实现类对于\",{\"1\":{\"224\":1}}],[\"相比之下\",{\"1\":{\"422\":1}}],[\"相比\",{\"1\":{\"416\":1}}],[\"相比java动态代理而言更为复杂\",{\"1\":{\"57\":1}}],[\"相比java动态代理\",{\"1\":{\"57\":1}}],[\"相比直接调用实现类的方法\",{\"1\":{\"56\":1}}],[\"符合单一职责原则\",{\"1\":{\"44\":1}}],[\"符合开闭原则\",{\"1\":{\"37\":1,\"47\":1}}],[\"上以监听读事件\",{\"1\":{\"414\":1}}],[\"上注册的事件\",{\"1\":{\"414\":1}}],[\"上是否有对应的\",{\"1\":{\"412\":1}}],[\"上\",{\"1\":{\"407\":1,\"412\":4,\"414\":1}}],[\"上界等于最后一个写入元素的索引加一\",{\"1\":{\"406\":1}}],[\"上界等于缓冲区的容量\",{\"1\":{\"406\":1}}],[\"上界表示缓冲区中已经存储的元素数量\",{\"1\":{\"406\":1}}],[\"上界\",{\"1\":{\"406\":1}}],[\"上一个元素的索引\",{\"1\":{\"364\":1}}],[\"上一项索引\",{\"1\":{\"235\":1}}],[\"上下文切换等\",{\"1\":{\"291\":1}}],[\"上锁\",{\"1\":{\"271\":1}}],[\"上相互等待\",{\"1\":{\"202\":1}}],[\"上图给出了可能会调用到的主要方法\",{\"1\":{\"198\":1}}],[\"上图是装饰器的uml图\",{\"1\":{\"30\":1}}],[\"上面这段代码使用了cyclicbarrier来模拟多个线程之间的同步\",{\"1\":{\"203\":1}}],[\"上面两行代码如果不用volatile修饰\",{\"1\":{\"135\":1}}],[\"上面的内容可能不会被面试官问到\",{\"1\":{\"355\":1}}],[\"上面的例子演示了如何创建\",{\"1\":{\"353\":1,\"354\":1}}],[\"上面的六种状态代码了一个线程从创建\",{\"1\":{\"155\":1}}],[\"上面的代码展示了另一种避免死锁的方式\",{\"1\":{\"143\":1}}],[\"上面的代码展示了一个使用资源管理器\",{\"1\":{\"142\":1}}],[\"上面的代码展示了一个典型的死锁情况\",{\"1\":{\"139\":1}}],[\"上面的表达式rate\",{\"1\":{\"115\":1}}],[\"上面的表达式等价于\",{\"1\":{\"92\":1}}],[\"上面的语句等同于\",{\"1\":{\"81\":1}}],[\"上面的配置是采集prometheus自身的监控指标\",{\"1\":{\"68\":1}}],[\"上面的测试输出结果\",{\"1\":{\"44\":1}}],[\"返回true\",{\"1\":{\"430\":2}}],[\"返回table表\",{\"1\":{\"259\":1}}],[\"返回的值应该是固定的占位符对象\",{\"1\":{\"388\":1}}],[\"返回一个对应的\",{\"1\":{\"411\":1}}],[\"返回一个布尔值\",{\"1\":{\"386\":1}}],[\"返回一个具体的产品对象sofa\",{\"1\":{\"43\":1}}],[\"返回节点的数据域\",{\"1\":{\"369\":1}}],[\"返回其索引值\",{\"1\":{\"363\":2}}],[\"返回特定值\",{\"1\":{\"265\":2}}],[\"返回出队的元素数量\",{\"1\":{\"265\":2}}],[\"返回该队列剩余的容量\",{\"1\":{\"265\":1}}],[\"返回null\",{\"1\":{\"260\":1,\"276\":1}}],[\"返回值\",{\"1\":{\"260\":1}}],[\"返回值只会包含该时间序列的最新值的一个样本\",{\"1\":{\"82\":1}}],[\"返回旧值\",{\"1\":{\"240\":1,\"241\":2,\"259\":1}}],[\"返回下一项\",{\"1\":{\"235\":1}}],[\"返回索引\",{\"1\":{\"213\":1}}],[\"返回当前计数\",{\"1\":{\"197\":1}}],[\"返回结果\",{\"1\":{\"330\":1}}],[\"返回结果后\",{\"1\":{\"186\":1}}],[\"返回结果之前\",{\"1\":{\"186\":1}}],[\"返回状态\",{\"1\":{\"183\":1}}],[\"返回资源的占用线程\",{\"1\":{\"183\":1}}],[\"返回尾结点\",{\"1\":{\"173\":1,\"214\":1}}],[\"返回新生成的结点\",{\"1\":{\"173\":1}}],[\"返回false\",{\"1\":{\"173\":1}}],[\"返回之前\",{\"1\":{\"169\":2}}],[\"返回\",{\"1\":{\"168\":1,\"173\":2,\"238\":1,\"239\":3}}],[\"返回同步状态的当前值\",{\"1\":{\"163\":1}}],[\"返回不同类的实例对象\",{\"1\":{\"39\":1}}],[\"违反了单一职责原则\",{\"1\":{\"41\":1}}],[\"系统开销大\",{\"1\":{\"175\":1}}],[\"系统扩展性好\",{\"1\":{\"41\":1}}],[\"系统出错\",{\"1\":{\"37\":1}}],[\"运行以上代码\",{\"1\":{\"352\":1,\"353\":1,\"354\":1}}],[\"运行上面代码可以知道当调用代码\",{\"1\":{\"336\":1}}],[\"运行上面的代码\",{\"1\":{\"47\":1}}],[\"运行callable的线程\",{\"1\":{\"328\":1}}],[\"运行完毕后置空\",{\"1\":{\"328\":1}}],[\"运行阶段\",{\"1\":{\"293\":1}}],[\"运行结果\",{\"1\":{\"288\":1}}],[\"运行结果如下\",{\"1\":{\"41\":1,\"50\":1}}],[\"运行示例代码\",{\"1\":{\"281\":1}}],[\"运行的线程\",{\"1\":{\"313\":1}}],[\"运行的动作标识\",{\"1\":{\"213\":1}}],[\"运行的结果如下\",{\"1\":{\"157\":1}}],[\"运行状态的线程则表示正在cpu上执行计算任务\",{\"1\":{\"157\":1}}],[\"运行\",{\"1\":{\"155\":1,\"213\":1}}],[\"运行程序\",{\"1\":{\"119\":1}}],[\"运行时会被系统拒绝运行\",{\"1\":{\"67\":1}}],[\"运行代码输出\",{\"1\":{\"56\":1}}],[\"运行代码\",{\"1\":{\"54\":1}}],[\"运行代码处理结果如下\",{\"1\":{\"36\":1}}],[\"由1和0组成\",{\"1\":{\"392\":1}}],[\"由红黑树转化为链表的阈值\",{\"1\":{\"256\":1}}],[\"由signal函数提供支持\",{\"1\":{\"215\":1}}],[\"由最后一个进入\",{\"1\":{\"208\":1}}],[\"由上述源码可以知道\",{\"1\":{\"173\":1}}],[\"由node\",{\"1\":{\"71\":1}}],[\"由于final所修饰的值始终无法改变\",{\"1\":{\"436\":1}}],[\"由于除数为0会产生算术异常\",{\"1\":{\"432\":1}}],[\"由于动态绑定的机制\",{\"1\":{\"424\":1}}],[\"由于动态代理是在运行时动态生成代理类\",{\"1\":{\"56\":1}}],[\"由于string是不可变的\",{\"1\":{\"421\":1}}],[\"由于\",{\"1\":{\"358\":1}}],[\"由于线程池可以控制线程的数量\",{\"1\":{\"291\":1}}],[\"由于某个桶中结点数量超出了阈值\",{\"1\":{\"259\":1}}],[\"由于写操作需要复制底层数组\",{\"1\":{\"229\":1}}],[\"由于读操作不需要加锁\",{\"1\":{\"229\":1}}],[\"由于读操作无需加锁\",{\"1\":{\"223\":1}}],[\"由于是有序的\",{\"1\":{\"225\":1}}],[\"由于tryacquire默认实现是抛出异常\",{\"1\":{\"173\":1}}],[\"由于a++操作实际上包含了读取a的当前值\",{\"1\":{\"119\":1}}],[\"由于prometheus是使用周期性的采集数据\",{\"1\":{\"65\":1}}],[\"由工厂类创建的对象的抽象类或接口\",{\"1\":{\"40\":1,\"43\":1,\"46\":1}}],[\"由拓展坞去做usb或者是hdmi接口的转换\",{\"1\":{\"27\":1}}],[\"抽象方法\",{\"1\":{\"419\":1}}],[\"抽象方法必须在非抽象子类中被重写实现\",{\"1\":{\"419\":1}}],[\"抽象方法只有方法签名\",{\"1\":{\"419\":1}}],[\"抽象类和接口是java中用于实现抽象和多态性的两个关键概念\",{\"1\":{\"419\":1}}],[\"抽象类和接口的区别\",{\"0\":{\"419\":1}}],[\"抽象类vs接口\",{\"1\":{\"419\":1}}],[\"抽象类通常为其子类提供一个通用的模板\",{\"1\":{\"419\":1}}],[\"抽象类通过使用关键字\",{\"1\":{\"419\":1}}],[\"抽象类用于定义通用的属性和行为\",{\"1\":{\"419\":1}}],[\"抽象类\",{\"1\":{\"399\":4,\"419\":7}}],[\"抽象主题接口类\",{\"1\":{\"53\":1}}],[\"抽象工厂的uml图如下\",{\"1\":{\"46\":1}}],[\"抽象工厂\",{\"0\":{\"45\":1},\"1\":{\"43\":1,\"46\":1,\"47\":1}}],[\"抽象工厂模式提供了一种创建一族相关对象的方法\",{\"1\":{\"47\":1}}],[\"抽象工厂模式包含以下角色\",{\"1\":{\"46\":1}}],[\"抽象工厂模式\",{\"1\":{\"10\":1,\"13\":1,\"45\":1}}],[\"抽象产品类\",{\"1\":{\"40\":1,\"43\":1,\"46\":1,\"47\":1}}],[\"很多人会说在比较对象的时候\",{\"1\":{\"430\":1}}],[\"很明显就是一个装饰器\",{\"1\":{\"401\":1}}],[\"很有可能刚获取了线程池状态后线程池状态就改变了\",{\"1\":{\"311\":1}}],[\"很可能淹没掉一些其他的告警消息\",{\"1\":{\"103\":1}}],[\"很难去排查\",{\"1\":{\"37\":1}}],[\"很好的避免了现有类和适配者类的耦合\",{\"1\":{\"27\":1}}],[\"总的可以概括线程池的生命周期\",{\"1\":{\"293\":1}}],[\"总共有6种状态\",{\"1\":{\"155\":1}}],[\"总共有23种设计模式\",{\"1\":{\"9\":1}}],[\"总体上来说锁状态升级流程如下\",{\"1\":{\"149\":1}}],[\"总结来说\",{\"1\":{\"416\":1,\"438\":1}}],[\"总结\",{\"0\":{\"72\":1,\"95\":1,\"122\":1,\"227\":1,\"242\":1,\"343\":1,\"355\":1,\"371\":1,\"379\":1,\"389\":1,\"408\":1},\"1\":{\"418\":1}}],[\"总之\",{\"1\":{\"37\":1}}],[\"制定不同的处理流程\",{\"1\":{\"37\":1}}],[\"每隔一秒向服务器端发送一条消息\",{\"1\":{\"415\":1}}],[\"每位可对应一天的数据\",{\"1\":{\"392\":1}}],[\"每次对string进行修改时都要创建一个新的对象\",{\"1\":{\"421\":1}}],[\"每次对string进行修改操作都会创建一个新的string对象\",{\"1\":{\"421\":1}}],[\"每次读取后位置也会递增\",{\"1\":{\"406\":1}}],[\"每次写入后位置会自动递增\",{\"1\":{\"406\":1}}],[\"每次消费一个数\",{\"1\":{\"267\":1}}],[\"每次生产一个数并将其放入队列中\",{\"1\":{\"267\":1}}],[\"每次进行转移的最小值\",{\"1\":{\"256\":1}}],[\"每一次循环都会\",{\"1\":{\"331\":1}}],[\"每一次使用的cycbarrier可以当成generation的实例\",{\"1\":{\"207\":1}}],[\"每一次都尝试获取锁\",{\"1\":{\"184\":1}}],[\"每当一个线程完成了自己的任务时\",{\"1\":{\"190\":1}}],[\"每个类都可以重写finalize方法来执行对象的清理操作\",{\"1\":{\"437\":1}}],[\"每个模块都包含一系列的操作步骤\",{\"1\":{\"422\":1}}],[\"每个\",{\"1\":{\"374\":1,\"391\":1,\"393\":1}}],[\"每个节点有前向和后向两个指针\",{\"1\":{\"371\":1}}],[\"每个节点包含了一个thread类型的引用\",{\"1\":{\"168\":1}}],[\"每个键值对都是一个条目\",{\"1\":{\"354\":1}}],[\"每个键都是唯一的\",{\"1\":{\"351\":1}}],[\"每个任务都需要等待一个空闲的线程来处理\",{\"1\":{\"297\":1}}],[\"每个使用该变量的线程都会初始化一个完全独立的实例副本\",{\"1\":{\"280\":1}}],[\"每个threadlocal对象都维护了一个独立的变量副本\",{\"1\":{\"280\":1}}],[\"每个segment拥有自己的锁对象\",{\"1\":{\"245\":1}}],[\"每个segment中维护一个hashentry数组\",{\"1\":{\"245\":1}}],[\"每个段拥有自己的锁\",{\"1\":{\"245\":1}}],[\"每个线程通过\",{\"1\":{\"281\":1}}],[\"每个线程可以通过threadlocal对象来获取和设置自己的变量副本\",{\"1\":{\"280\":1}}],[\"每个线程都维护一个inheritablethreadlocalmap对象\",{\"1\":{\"288\":1}}],[\"每个线程都会在自己的threadlocalmap对象中为该threadlocal对象创建一个entry对象\",{\"1\":{\"285\":1}}],[\"每个线程都可以访问自己的副本\",{\"1\":{\"280\":1}}],[\"每个线程都必须重新获取锁\",{\"1\":{\"169\":1}}],[\"每个线程被阻塞的线程都会被封装成一个node结点\",{\"1\":{\"168\":1}}],[\"每个线程执行如下操作\",{\"1\":{\"160\":1}}],[\"每个线程在进行资金转移时都试图获取对方对象\",{\"1\":{\"139\":1}}],[\"每个对象都有自己的状态\",{\"1\":{\"422\":1}}],[\"每个对象都有一定数量的资金\",{\"1\":{\"139\":1,\"142\":1,\"143\":1}}],[\"每个对象都是某个类的实例\",{\"1\":{\"422\":1}}],[\"每个对象都会有一个对应的监视器\",{\"1\":{\"152\":1}}],[\"每个对象有一个监视器锁\",{\"1\":{\"147\":1}}],[\"每个处理器都有自己的缓存\",{\"1\":{\"124\":1}}],[\"每个recording\",{\"1\":{\"113\":1}}],[\"每个部分包含的可配置的参数很多\",{\"1\":{\"107\":1}}],[\"每个prometheus都是单节点设计的\",{\"1\":{\"65\":1}}],[\"每个方法对应一个具体产品类的创建方法\",{\"1\":{\"46\":1}}],[\"每个具体产品都需要一个具体工厂类来创建\",{\"1\":{\"44\":1}}],[\"每个逻辑单元的功能都是解藕的\",{\"1\":{\"37\":1}}],[\"每个逻辑单元组成了链中的一环\",{\"1\":{\"37\":1}}],[\"每种容器都有其特定的用途和适应场景\",{\"1\":{\"227\":1}}],[\"每种状态都是可以扭转的\",{\"1\":{\"155\":1}}],[\"每种状态代表的含义如下表所示\",{\"1\":{\"155\":1}}],[\"每种设计模式有非常多的应用\",{\"1\":{\"13\":1}}],[\"每种类型的设计模式又包含了多种设计模式\",{\"1\":{\"9\":1}}],[\"金额太大\",{\"1\":{\"36\":1}}],[\"520277367\",{\"1\":{\"396\":1}}],[\"5d\",{\"1\":{\"395\":1}}],[\"5倍\",{\"1\":{\"361\":1}}],[\"5+6\",{\"1\":{\"349\":1}}],[\"5533770\",{\"1\":{\"278\":1}}],[\"5453341\",{\"1\":{\"262\":1}}],[\"5406191\",{\"1\":{\"200\":1}}],[\"5392816\",{\"1\":{\"216\":1}}],[\"5350186\",{\"1\":{\"176\":1}}],[\"5763175\",{\"1\":{\"111\":1}}],[\"5782e\",{\"1\":{\"68\":1}}],[\"5179523762034025860l\",{\"1\":{\"183\":1}}],[\"51cto\",{\"1\":{\"111\":1}}],[\"512\",{\"1\":{\"31\":2}}],[\"5h\",{\"1\":{\"93\":1}}],[\"50\",{\"1\":{\"158\":1,\"159\":1}}],[\"501\",{\"1\":{\"89\":1}}],[\"5001\",{\"1\":{\"106\":1}}],[\"500\",{\"1\":{\"89\":5,\"191\":6,\"203\":3,\"323\":3,\"336\":1}}],[\"5000\",{\"1\":{\"36\":1,\"119\":2}}],[\"5m\",{\"1\":{\"76\":1,\"77\":1,\"82\":1,\"83\":3,\"92\":5,\"106\":2,\"107\":2,\"115\":3}}],[\"5\",{\"1\":{\"68\":1,\"79\":1,\"90\":1,\"92\":1,\"98\":3,\"153\":1,\"306\":1,\"317\":1,\"323\":1,\"328\":1,\"329\":1,\"331\":1,\"336\":2,\"349\":1,\"393\":1,\"401\":1,\"429\":2}}],[\"5<\",{\"1\":{\"57\":1}}],[\"财物权限不够\",{\"1\":{\"36\":2}}],[\"财务\",{\"1\":{\"36\":1}}],[\"审批不通过\",{\"1\":{\"36\":1}}],[\"审批通过\",{\"1\":{\"36\":1}}],[\"审批拒绝\",{\"1\":{\"36\":1}}],[\"里面调用\",{\"1\":{\"186\":2}}],[\"里面有具体的处理逻辑\",{\"1\":{\"36\":1}}],[\"里氏代换原则是继承复用的基石\",{\"1\":{\"14\":1}}],[\"里氏替换原则\",{\"1\":{\"14\":1}}],[\"和java类库\",{\"1\":{\"433\":1}}],[\"和hashcode的关系\",{\"0\":{\"431\":1}}],[\"和handler不为\",{\"1\":{\"81\":1}}],[\"和handler为\",{\"1\":{\"81\":1}}],[\"和它的两个子类\",{\"1\":{\"424\":1}}],[\"和行为\",{\"1\":{\"422\":1}}],[\"和面向对象\",{\"1\":{\"422\":1}}],[\"和静态方法\",{\"1\":{\"419\":1}}],[\"和静态代理类似\",{\"1\":{\"56\":1}}],[\"和抽象方法\",{\"1\":{\"419\":1}}],[\"和私有方法\",{\"1\":{\"419\":1}}],[\"和重写\",{\"1\":{\"418\":1}}],[\"和非阻塞\",{\"1\":{\"416\":1}}],[\"和阻塞\",{\"1\":{\"416\":1}}],[\"和高并发处理的网络服务器编程场景\",{\"1\":{\"411\":1}}],[\"和高并发处理的网络编程场景\",{\"1\":{\"410\":1}}],[\"和printstream\",{\"1\":{\"401\":1}}],[\"和system\",{\"1\":{\"401\":1}}],[\"和status\",{\"1\":{\"98\":2}}],[\"和所有filteroutputstream\",{\"1\":{\"401\":1}}],[\"和所有filterinputstream\",{\"1\":{\"401\":1}}],[\"和本地文件中写入数据\",{\"1\":{\"401\":1}}],[\"和本地文件中读取数据\",{\"1\":{\"401\":1}}],[\"和负载因子\",{\"1\":{\"375\":1,\"377\":1}}],[\"和后向节点\",{\"1\":{\"370\":1}}],[\"和reentrantlock一样\",{\"1\":{\"220\":1}}],[\"和条件队列condition\",{\"1\":{\"193\":1}}],[\"和查询派送单操作各减1\",{\"1\":{\"191\":1}}],[\"和查询派送单\",{\"1\":{\"191\":1}}],[\"和unpark\",{\"1\":{\"175\":1}}],[\"和执行非同步方法比仅存在纳秒级的差距\",{\"1\":{\"152\":1}}],[\"和解锁\",{\"1\":{\"147\":1}}],[\"和\",{\"0\":{\"428\":1},\"1\":{\"128\":1,\"140\":1,\"191\":5,\"202\":1,\"222\":1,\"224\":1,\"235\":1,\"266\":1,\"341\":1,\"342\":2,\"343\":1,\"349\":1,\"351\":5,\"354\":1,\"364\":4,\"366\":2,\"376\":1,\"382\":1,\"403\":1,\"404\":1,\"406\":1,\"407\":1,\"416\":2,\"424\":4,\"428\":1,\"429\":2}}],[\"和内存的速度相比慢了很多\",{\"1\":{\"118\":1}}],[\"和alert\",{\"1\":{\"113\":1}}],[\"和many\",{\"1\":{\"88\":1}}],[\"和maketable\",{\"1\":{\"47\":1}}],[\"和值的总和\",{\"1\":{\"78\":1}}],[\"和直方图类似\",{\"1\":{\"75\":1}}],[\"和一个具体方法showname\",{\"1\":{\"41\":1}}],[\"和持有一个aproval对象\",{\"1\":{\"36\":1}}],[\"和双重检查模式一样\",{\"1\":{\"20\":1}}],[\"经常选择使用对象的一些属性进行比较\",{\"1\":{\"431\":1}}],[\"经常需要新的项目中需要对老代码进行适配才能用\",{\"1\":{\"25\":1}}],[\"经理权限不够\",{\"1\":{\"36\":2}}],[\"经理审批通过\",{\"1\":{\"36\":1}}],[\"经历\",{\"1\":{\"36\":1}}],[\"后向节点为\",{\"1\":{\"368\":1}}],[\"后29位拿来充当当前运行worker的数量\",{\"1\":{\"308\":1}}],[\"后\",{\"1\":{\"287\":1}}],[\"后面的文章将以案例的形式介绍socketchannel\",{\"1\":{\"408\":1}}],[\"后面的元素向前移动\",{\"1\":{\"362\":1}}],[\"后面的值会覆盖前面的值\",{\"1\":{\"354\":1}}],[\"后面这个thread启动的时候\",{\"1\":{\"313\":1}}],[\"后面会进行分析\",{\"1\":{\"195\":1}}],[\"后面加一些功能\",{\"1\":{\"32\":1}}],[\"后继为空或者为共享模式\",{\"1\":{\"198\":1}}],[\"后继不为空并且后继的状态小于等于0\",{\"1\":{\"173\":1}}],[\"后继结点\",{\"1\":{\"168\":1}}],[\"后使用压缩解压装饰器\",{\"1\":{\"31\":1}}],[\"满足单一职责的原则\",{\"1\":{\"32\":1}}],[\"满足里氏替换原则\",{\"1\":{\"27\":1}}],[\"希望继承原有类的功能\",{\"1\":{\"32\":1}}],[\"达到不同的效果\",{\"1\":{\"32\":1}}],[\"解决这些冲突需要额外的语法规则和解析过程\",{\"1\":{\"420\":1}}],[\"解决资源不足的问题\",{\"1\":{\"291\":1}}],[\"解析\",{\"1\":{\"370\":1}}],[\"解锁操作\",{\"1\":{\"313\":1}}],[\"解锁方法\",{\"1\":{\"175\":1}}],[\"解释\",{\"1\":{\"155\":1}}],[\"解释器模式\",{\"1\":{\"12\":1}}],[\"解缩后的内容为\",{\"1\":{\"31\":2}}],[\"解密后\",{\"1\":{\"31\":2}}],[\"压缩后的内容为\",{\"1\":{\"31\":2}}],[\"压缩解压装饰器\",{\"1\":{\"31\":1}}],[\"+name2\",{\"1\":{\"418\":1}}],[\"+name1\",{\"1\":{\"418\":1}}],[\"+name\",{\"1\":{\"418\":1}}],[\"+newthread\",{\"1\":{\"156\":1}}],[\"+future2\",{\"1\":{\"342\":1}}],[\"+future1\",{\"1\":{\"342\":1}}],[\"+filereaderwriter\",{\"1\":{\"31\":1}}],[\"++counter\",{\"1\":{\"395\":1}}],[\"++j\",{\"1\":{\"377\":1}}],[\"++i\",{\"1\":{\"277\":1}}],[\"++takeindex\",{\"1\":{\"275\":1}}],[\"++putindex\",{\"1\":{\"273\":1}}],[\"++bincount\",{\"1\":{\"259\":1,\"376\":1}}],[\"+thread\",{\"1\":{\"158\":1}}],[\"+t\",{\"1\":{\"157\":1}}],[\"+text\",{\"1\":{\"31\":1}}],[\"+正在运行\",{\"1\":{\"155\":1}}],[\"+a\",{\"1\":{\"119\":1}}],[\"+sum\",{\"1\":{\"85\":1}}],[\"+prometheus\",{\"1\":{\"85\":1}}],[\"+inf\",{\"1\":{\"78\":1,\"98\":1}}],[\"+obj\",{\"1\":{\"50\":1}}],[\"+\",{\"1\":{\"41\":1,\"47\":1,\"56\":2,\"85\":1,\"97\":1,\"98\":1,\"139\":2,\"142\":1,\"143\":1,\"159\":1,\"160\":4,\"183\":1,\"185\":1,\"187\":13,\"238\":1,\"239\":1,\"241\":1,\"247\":4,\"256\":1,\"259\":11,\"267\":2,\"281\":2,\"288\":2,\"317\":1,\"323\":12,\"331\":1,\"336\":2,\"339\":2,\"340\":4,\"341\":1,\"349\":3,\"352\":4,\"353\":3,\"354\":9,\"359\":1,\"360\":2,\"361\":8,\"362\":1,\"364\":1,\"366\":18,\"369\":3,\"370\":3,\"375\":2,\"377\":1,\"385\":1,\"393\":19,\"395\":4,\"406\":2,\"415\":2,\"431\":1,\"432\":2,\"436\":3}}],[\"+rw\",{\"1\":{\"31\":1}}],[\"+=\",{\"1\":{\"31\":1,\"120\":1,\"187\":1,\"323\":3,\"336\":1,\"349\":1,\"395\":1}}],[\"udp\",{\"1\":{\"404\":1}}],[\"utf\",{\"1\":{\"414\":1}}],[\"utm\",{\"1\":{\"396\":1}}],[\"util\",{\"1\":{\"50\":2,\"142\":2,\"175\":2,\"187\":3,\"191\":3,\"203\":1,\"219\":3,\"221\":3,\"230\":1,\"247\":1,\"267\":1,\"281\":1,\"323\":8,\"336\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"349\":2,\"352\":2,\"353\":2,\"354\":2,\"393\":1,\"395\":3,\"414\":1,\"415\":1}}],[\"u>\",{\"1\":{\"237\":1}}],[\"u\",{\"1\":{\"175\":1,\"237\":1,\"256\":9,\"259\":8,\"295\":2}}],[\"upon\",{\"1\":{\"256\":2}}],[\"updated\",{\"1\":{\"256\":1,\"352\":4,\"353\":2,\"354\":2}}],[\"update\",{\"1\":{\"163\":2,\"175\":3}}],[\"up\",{\"1\":{\"115\":1,\"173\":1,\"214\":2}}],[\"url\",{\"1\":{\"106\":1,\"107\":1}}],[\"uri\",{\"1\":{\"98\":4,\"100\":2}}],[\"uri=request\",{\"1\":{\"98\":1}}],[\"uri=\",{\"1\":{\"97\":3,\"98\":15}}],[\"unread\",{\"1\":{\"401\":1}}],[\"unpacking\",{\"1\":{\"309\":1}}],[\"unpark\",{\"1\":{\"173\":2,\"175\":1,\"214\":1,\"333\":1}}],[\"unparksuccessor函数已经分析过\",{\"1\":{\"174\":1}}],[\"unparksuccessor\",{\"1\":{\"173\":2,\"174\":1,\"198\":1,\"199\":1}}],[\"untreeify\",{\"1\":{\"256\":1,\"261\":1}}],[\"until\",{\"1\":{\"208\":1,\"213\":1,\"313\":2,\"318\":1,\"329\":1}}],[\"uncontended\",{\"1\":{\"259\":3}}],[\"unconditional\",{\"1\":{\"173\":1}}],[\"unchecked异常不要求在代码中进行处理或声明\",{\"1\":{\"432\":1}}],[\"unchecked\",{\"1\":{\"235\":3,\"237\":1,\"259\":1,\"275\":1,\"282\":1,\"364\":1,\"432\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"235\":10}}],[\"unsplice\",{\"1\":{\"173\":1}}],[\"unsafe修改\",{\"1\":{\"317\":1}}],[\"unsafeinstance\",{\"1\":{\"175\":2}}],[\"unsafe类实例\",{\"1\":{\"170\":1}}],[\"unsafe\",{\"1\":{\"163\":1,\"170\":8,\"175\":8,\"233\":5,\"256\":3,\"317\":1,\"318\":1,\"329\":5,\"331\":1,\"332\":3,\"333\":1}}],[\"unit\",{\"1\":{\"169\":2,\"179\":1,\"265\":6,\"294\":3,\"326\":2}}],[\"union\",{\"1\":{\"87\":1}}],[\"unlink\",{\"1\":{\"333\":1,\"370\":4}}],[\"unlockroot\",{\"1\":{\"259\":1}}],[\"unlocked\",{\"1\":{\"183\":1}}],[\"unlock\",{\"1\":{\"147\":1,\"175\":1,\"179\":1,\"186\":4,\"187\":2,\"213\":1,\"219\":2,\"220\":2,\"221\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"271\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"312\":1,\"313\":2,\"319\":5}}],[\"unless\",{\"1\":{\"87\":1,\"185\":1}}],[\"unknown\",{\"1\":{\"97\":1,\"98\":1}}],[\"usable\",{\"1\":{\"256\":1}}],[\"usually\",{\"1\":{\"107\":3}}],[\"user\",{\"1\":{\"97\":1,\"98\":1}}],[\"users\",{\"1\":{\"31\":1}}],[\"used\",{\"1\":{\"68\":1,\"168\":3,\"256\":2,\"395\":4,\"438\":1}}],[\"use\",{\"1\":{\"68\":1,\"115\":1,\"173\":1,\"256\":1}}],[\"us\",{\"1\":{\"41\":1,\"173\":1}}],[\"uml图如下\",{\"1\":{\"49\":1}}],[\"uml图\",{\"0\":{\"30\":1,\"40\":1,\"43\":1,\"46\":1}}],[\"uml\",{\"1\":{\"25\":1,\"53\":1}}],[\"加入工作队列\",{\"1\":{\"303\":1}}],[\"加锁同步\",{\"1\":{\"259\":1,\"261\":1}}],[\"加锁\",{\"1\":{\"175\":1}}],[\"加锁成功\",{\"1\":{\"175\":1}}],[\"加锁和解锁不需要额外的消耗\",{\"1\":{\"152\":1}}],[\"加加\",{\"1\":{\"132\":1}}],[\"加\",{\"1\":{\"85\":1}}],[\"加密后\",{\"1\":{\"31\":2}}],[\"加密装饰器\",{\"1\":{\"31\":1}}],[\"加减密装饰器和压缩解缩的装饰器\",{\"1\":{\"31\":1}}],[\"嵌套了两个装饰器\",{\"1\":{\"31\":1}}],[\"<k\",{\"1\":{\"259\":2}}],[\"<<class>>\",{\"1\":{\"432\":3}}],[\"<<\",{\"1\":{\"256\":2,\"259\":4,\"293\":5,\"309\":11,\"377\":2,\"395\":3}}],[\"<t>\",{\"1\":{\"316\":2}}],[\"<t\",{\"1\":{\"237\":1}}],[\"<duration>\",{\"1\":{\"113\":1}}],[\"<dependency>\",{\"1\":{\"57\":1,\"97\":3,\"98\":3}}],[\"<rfc3339>\",{\"1\":{\"110\":2}}],[\"<resolved|firing>\",{\"1\":{\"110\":2}}],[\"<object>\",{\"1\":{\"110\":5}}],[\"<int>\",{\"1\":{\"110\":1}}],[\"<string>\",{\"1\":{\"110\":5}}],[\"<scope>test<\",{\"1\":{\"97\":1}}],[\"<version>1\",{\"1\":{\"97\":1,\"98\":3}}],[\"<vector\",{\"1\":{\"90\":1}}],[\"<groupid>io\",{\"1\":{\"97\":1,\"98\":3}}],[\"<groupid>org\",{\"1\":{\"97\":2}}],[\"<groupid>cglib<\",{\"1\":{\"57\":1}}],[\"<label\",{\"1\":{\"90\":1}}],[\"<artifactid>prometheus\",{\"1\":{\"98\":3}}],[\"<artifactid>micrometer\",{\"1\":{\"97\":1}}],[\"<artifactid>spring\",{\"1\":{\"97\":2}}],[\"<artifactid>cglib<\",{\"1\":{\"57\":1}}],[\"<aggr\",{\"1\":{\"90\":1}}],[\"<=\",{\"1\":{\"86\":1,\"173\":3,\"187\":1,\"210\":1,\"213\":1,\"259\":5,\"271\":1,\"294\":1,\"317\":2,\"323\":3,\"330\":2,\"331\":1,\"336\":1,\"349\":1,\"361\":2,\"375\":1}}],[\"<\",{\"1\":{\"31\":2,\"36\":2,\"50\":1,\"57\":1,\"74\":1,\"86\":1,\"93\":1,\"97\":3,\"98\":3,\"119\":2,\"132\":2,\"143\":1,\"173\":1,\"183\":1,\"185\":1,\"196\":2,\"198\":3,\"235\":2,\"239\":1,\"259\":7,\"260\":1,\"294\":3,\"311\":1,\"312\":1,\"349\":1,\"361\":2,\"362\":2,\"363\":2,\"364\":1,\"369\":3,\"370\":1,\"375\":1,\"377\":2,\"393\":1,\"395\":10,\"431\":1}}],[\"0即\",{\"1\":{\"429\":1}}],[\"03\",{\"1\":{\"262\":1}}],[\"0x7fffffff\",{\"1\":{\"256\":1}}],[\"0l\",{\"1\":{\"175\":1,\"213\":2,\"306\":1,\"317\":3,\"330\":1,\"331\":2}}],[\"025\",{\"1\":{\"98\":1}}],[\"01\",{\"1\":{\"98\":1}}],[\"0<\",{\"1\":{\"98\":3}}],[\"071374449\",{\"1\":{\"97\":1}}],[\"049234863\",{\"1\":{\"97\":1}}],[\"04\",{\"1\":{\"89\":2}}],[\"005\",{\"1\":{\"98\":1}}],[\"009242327\",{\"1\":{\"79\":1}}],[\"009608685\",{\"1\":{\"68\":1}}],[\"002707693\",{\"1\":{\"68\":1}}],[\"000421166\",{\"1\":{\"79\":1}}],[\"000194843\",{\"1\":{\"79\":1}}],[\"00013637\",{\"1\":{\"79\":1}}],[\"000123743\",{\"1\":{\"68\":1}}],[\"000251038\",{\"1\":{\"68\":1}}],[\"05\",{\"1\":{\"68\":2,\"79\":1,\"89\":3,\"98\":1}}],[\"0版本\",{\"1\":{\"61\":2,\"97\":1}}],[\"0\",{\"1\":{\"31\":3,\"50\":1,\"68\":8,\"78\":5,\"79\":9,\"89\":6,\"90\":1,\"93\":1,\"94\":5,\"97\":9,\"98\":27,\"100\":1,\"106\":2,\"107\":2,\"108\":6,\"119\":2,\"132\":3,\"146\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"169\":1,\"173\":10,\"174\":1,\"175\":5,\"183\":8,\"184\":1,\"185\":3,\"187\":4,\"190\":1,\"196\":2,\"197\":3,\"198\":9,\"199\":5,\"210\":1,\"213\":2,\"214\":2,\"221\":1,\"230\":1,\"234\":1,\"235\":1,\"237\":2,\"239\":2,\"241\":3,\"256\":3,\"259\":18,\"260\":2,\"261\":2,\"271\":3,\"273\":1,\"275\":2,\"276\":1,\"277\":4,\"293\":1,\"294\":3,\"308\":1,\"309\":3,\"311\":1,\"317\":1,\"323\":3,\"328\":1,\"336\":1,\"349\":2,\"352\":1,\"359\":3,\"361\":5,\"362\":1,\"363\":3,\"364\":2,\"369\":2,\"370\":1,\"375\":2,\"376\":2,\"377\":7,\"378\":1,\"392\":1,\"393\":1,\"395\":16,\"406\":5,\"412\":1,\"414\":2,\"415\":7,\"430\":2,\"431\":3,\"432\":1,\"438\":4}}],[\"eating\",{\"1\":{\"419\":1}}],[\"eat\",{\"1\":{\"418\":8,\"419\":3}}],[\"epoll\",{\"1\":{\"416\":1}}],[\"es\",{\"1\":{\"315\":2,\"362\":8}}],[\"establish\",{\"1\":{\"168\":1}}],[\"eh\",{\"1\":{\"260\":3}}],[\"ek\",{\"1\":{\"259\":4,\"260\":7,\"261\":4}}],[\"eq\",{\"1\":{\"239\":1}}],[\"equal\",{\"1\":{\"86\":4,\"106\":1,\"107\":2}}],[\"equals\",{\"0\":{\"428\":1,\"430\":1,\"431\":1},\"1\":{\"41\":2,\"259\":2,\"260\":2,\"261\":3,\"362\":1,\"363\":2,\"376\":2,\"378\":2,\"382\":1,\"428\":1,\"430\":12}}],[\"e>\",{\"1\":{\"234\":2,\"235\":1,\"265\":2,\"271\":2,\"359\":1,\"360\":2,\"367\":1,\"385\":1}}],[\"emptytask\",{\"1\":{\"347\":1}}],[\"empty\",{\"1\":{\"187\":3,\"259\":1,\"312\":1,\"314\":1,\"352\":2,\"353\":2,\"354\":2,\"358\":2,\"359\":6,\"361\":2}}],[\"error也是throwable的一个子类\",{\"1\":{\"432\":1}}],[\"error是不可控制的严重问题的异常类\",{\"1\":{\"432\":1}}],[\"error和throwable是一个类层次结构中的相关类\",{\"1\":{\"432\":1}}],[\"error\",{\"1\":{\"170\":1,\"183\":1,\"185\":1,\"233\":1,\"256\":2,\"313\":2,\"432\":1}}],[\"errors\",{\"1\":{\"89\":7}}],[\"elementdata的值为10\",{\"1\":{\"359\":1}}],[\"elementdata\",{\"1\":{\"358\":4,\"359\":10,\"360\":8,\"361\":7,\"362\":1,\"363\":3,\"364\":4}}],[\"elementdequeued\",{\"1\":{\"275\":1}}],[\"element\",{\"1\":{\"230\":2,\"235\":1,\"240\":3,\"256\":1,\"265\":2,\"352\":2,\"360\":3,\"366\":2,\"370\":3}}],[\"elements类型不为object\",{\"1\":{\"234\":1}}],[\"elements\",{\"1\":{\"90\":4,\"234\":8,\"235\":5,\"238\":3,\"240\":5,\"241\":6}}],[\"elimination\",{\"1\":{\"153\":1}}],[\"else\",{\"1\":{\"36\":3,\"41\":1,\"142\":1,\"143\":1,\"168\":1,\"173\":4,\"183\":1,\"184\":1,\"185\":1,\"198\":1,\"199\":1,\"213\":2,\"214\":1,\"234\":1,\"240\":1,\"241\":1,\"256\":1,\"259\":14,\"260\":1,\"261\":6,\"274\":1,\"282\":1,\"311\":2,\"312\":1,\"317\":5,\"331\":5,\"332\":1,\"349\":1,\"359\":4,\"361\":4,\"362\":1,\"363\":1,\"368\":1,\"369\":1,\"370\":2,\"376\":2,\"377\":6,\"412\":2}}],[\"ev\",{\"1\":{\"261\":5}}],[\"even\",{\"1\":{\"68\":1,\"213\":1}}],[\"evaluation\",{\"1\":{\"68\":2,\"113\":2}}],[\"ensure\",{\"1\":{\"313\":2}}],[\"ensures\",{\"1\":{\"240\":1}}],[\"enqueuing\",{\"1\":{\"311\":1}}],[\"enqueue函数用于将元素存入底层object数组中\",{\"1\":{\"273\":1}}],[\"enqueue函数源码如下\",{\"1\":{\"273\":1}}],[\"enqueue\",{\"1\":{\"273\":2,\"274\":1}}],[\"enq函数会使用无限循环来确保节点的成功插入\",{\"1\":{\"173\":1}}],[\"enq方法源码如下\",{\"1\":{\"173\":1}}],[\"enq\",{\"1\":{\"173\":4,\"214\":2}}],[\"enum\",{\"1\":{\"155\":1}}],[\"entry<string\",{\"1\":{\"354\":2}}],[\"entryset\",{\"1\":{\"256\":1,\"354\":2}}],[\"entrysetview<k\",{\"1\":{\"256\":1}}],[\"entrysetview分别表示键视图\",{\"1\":{\"253\":1}}],[\"entryspliterator则用于键\",{\"1\":{\"252\":1}}],[\"entryspliterator四个类\",{\"1\":{\"252\":1}}],[\"entry\",{\"1\":{\"208\":1,\"282\":1,\"311\":1,\"354\":7}}],[\"entity\",{\"1\":{\"110\":1}}],[\"enterprise\",{\"1\":{\"71\":3}}],[\"env\",{\"1\":{\"108\":1}}],[\"environment\",{\"1\":{\"68\":1,\"433\":1}}],[\"end\",{\"1\":{\"349\":8}}],[\"endsat\",{\"1\":{\"110\":2}}],[\"endtime\",{\"1\":{\"98\":2}}],[\"endpoints\",{\"1\":{\"97\":1}}],[\"enable\",{\"1\":{\"70\":2}}],[\"en\",{\"1\":{\"57\":4}}],[\"enhancer\",{\"1\":{\"57\":2}}],[\"encodetostring\",{\"1\":{\"31\":2}}],[\"encode\",{\"1\":{\"31\":2}}],[\"encryptionfilereaderwriter\",{\"1\":{\"31\":3}}],[\"encryptionfilereaderwriter是一个装饰器\",{\"1\":{\"31\":1}}],[\"executed\",{\"1\":{\"438\":6}}],[\"execute方法提交futuretask到线程池中等待被执行\",{\"1\":{\"316\":1}}],[\"execute方法都会调用其rejectedexecutionhandler的rejectedexecution方法\",{\"1\":{\"302\":1}}],[\"execute\",{\"0\":{\"311\":1},\"1\":{\"306\":1,\"310\":1,\"311\":3,\"316\":1}}],[\"executor\",{\"1\":{\"323\":7,\"336\":3,\"350\":1}}],[\"executor线程池顶级接口\",{\"1\":{\"292\":1}}],[\"executors各个方法的弊端\",{\"1\":{\"304\":1}}],[\"executors\",{\"1\":{\"191\":2,\"203\":1,\"301\":1,\"315\":1,\"323\":3,\"336\":1}}],[\"executorservice继承并扩展了executor接口\",{\"1\":{\"292\":1}}],[\"executorservice\",{\"1\":{\"191\":5,\"203\":4,\"305\":1,\"306\":1,\"315\":1,\"323\":11,\"336\":1}}],[\"executionexception\",{\"1\":{\"317\":1,\"323\":3,\"326\":2,\"330\":1,\"336\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":3}}],[\"execution\",{\"1\":{\"213\":1}}],[\"excute\",{\"1\":{\"306\":1}}],[\"exceeded\",{\"1\":{\"183\":1,\"185\":1}}],[\"except\",{\"1\":{\"175\":3}}],[\"exceptionexample\",{\"1\":{\"432\":1}}],[\"exception又分为两种类型\",{\"1\":{\"432\":1}}],[\"exception是可控制的异常类\",{\"1\":{\"432\":1}}],[\"exception和error\",{\"1\":{\"432\":1}}],[\"exceptionnode\",{\"1\":{\"348\":1}}],[\"exceptionally\",{\"1\":{\"340\":2,\"343\":1}}],[\"exceptional\",{\"1\":{\"317\":2,\"328\":2,\"329\":1}}],[\"exception\",{\"1\":{\"98\":4,\"170\":1,\"175\":1,\"233\":1,\"256\":1,\"315\":2,\"323\":1,\"325\":1,\"405\":1,\"432\":2,\"437\":1}}],[\"exception=\",{\"1\":{\"97\":3}}],[\"exclusiveownerthread\",{\"1\":{\"166\":3}}],[\"exclusive\",{\"1\":{\"164\":1,\"168\":1,\"173\":1}}],[\"exclusion\",{\"1\":{\"140\":1,\"219\":1,\"271\":1}}],[\"externalurl\",{\"1\":{\"110\":2}}],[\"extends\",{\"1\":{\"36\":3,\"41\":2,\"47\":1,\"98\":1,\"131\":1,\"166\":1,\"170\":1,\"183\":1,\"184\":1,\"185\":1,\"197\":1,\"234\":2,\"237\":1,\"249\":1,\"256\":1,\"265\":1,\"269\":1,\"270\":1,\"271\":2,\"313\":1,\"349\":1,\"358\":1,\"359\":1,\"360\":2,\"367\":1,\"385\":1,\"418\":2,\"419\":1,\"424\":2,\"435\":1}}],[\"ex\",{\"1\":{\"98\":1,\"170\":2,\"271\":1,\"318\":2,\"329\":2,\"364\":1}}],[\"example\",{\"1\":{\"98\":4,\"113\":1,\"230\":1,\"305\":1}}],[\"existing\",{\"1\":{\"311\":1}}],[\"exist\",{\"1\":{\"68\":1,\"173\":1}}],[\"exit\",{\"1\":{\"31\":1,\"438\":2}}],[\"expectedmodcount\",{\"1\":{\"364\":7}}],[\"expect\",{\"1\":{\"163\":2}}],[\"expr执行后生成新的指标的名称\",{\"1\":{\"113\":1}}],[\"expr\",{\"1\":{\"108\":2,\"113\":2,\"115\":5,\"116\":1}}],[\"expression>\",{\"1\":{\"90\":1}}],[\"exposure\",{\"1\":{\"97\":1}}],[\"exponentiation\",{\"1\":{\"85\":1}}],[\"expoter的指标时序\",{\"1\":{\"72\":1}}],[\"exporter暴露的端口指标\",{\"1\":{\"69\":1}}],[\"exporter的dashboard\",{\"1\":{\"71\":1}}],[\"exporter的面板\",{\"1\":{\"71\":1}}],[\"exporter的任务\",{\"1\":{\"69\":1}}],[\"exporter的端口为9100\",{\"1\":{\"69\":1}}],[\"exporter的指标了\",{\"1\":{\"69\":1}}],[\"exporter的指标\",{\"0\":{\"69\":1},\"1\":{\"66\":1,\"72\":1}}],[\"exporter是prometheus生态的一员\",{\"1\":{\"69\":1}}],[\"exporter采集的指标中\",{\"1\":{\"77\":1}}],[\"exporter采集的指标生产\",{\"1\":{\"71\":1}}],[\"exporter采集的指标\",{\"1\":{\"66\":1}}],[\"exporters是用来暴露或者导出被监控对象的指标的\",{\"1\":{\"63\":1}}],[\"exporter\",{\"1\":{\"59\":1,\"66\":1,\"69\":3,\"98\":2,\"101\":1}}],[\"expansiondockadapter并持有需要被适配的iusb接口\",{\"1\":{\"26\":1}}],[\"expansiondockadapter\",{\"1\":{\"26\":5}}],[\"e\",{\"0\":{\"368\":2},\"1\":{\"31\":14,\"110\":1,\"139\":4,\"142\":2,\"143\":2,\"158\":2,\"159\":6,\"160\":10,\"173\":1,\"175\":4,\"187\":4,\"191\":8,\"203\":10,\"233\":2,\"234\":2,\"235\":12,\"238\":3,\"239\":5,\"240\":3,\"241\":2,\"256\":2,\"259\":15,\"260\":11,\"261\":10,\"265\":15,\"267\":4,\"271\":4,\"273\":5,\"274\":4,\"275\":4,\"276\":1,\"282\":3,\"315\":4,\"323\":6,\"336\":2,\"339\":4,\"340\":4,\"341\":8,\"342\":12,\"360\":7,\"363\":1,\"364\":2,\"366\":3,\"368\":15,\"369\":1,\"370\":3,\"376\":7,\"377\":16,\"378\":13,\"386\":5,\"405\":2,\"406\":1,\"414\":4,\"415\":6,\"432\":2,\"437\":1,\"438\":2}}],[\"wt\",{\"1\":{\"313\":4}}],[\"woof\",{\"1\":{\"424\":2}}],[\"would\",{\"1\":{\"311\":1}}],[\"worker自己本身实现了aqs同步框架\",{\"1\":{\"319\":1}}],[\"worker执行firsttask或从workqueue中获取任务\",{\"1\":{\"313\":1}}],[\"worker类的runworker方法\",{\"0\":{\"313\":1}}],[\"worker\",{\"1\":{\"312\":3,\"313\":4,\"319\":2}}],[\"workeradded\",{\"1\":{\"312\":3}}],[\"workercount\",{\"1\":{\"311\":1,\"312\":1}}],[\"workercountof获取线程池的当前线程数\",{\"1\":{\"311\":1}}],[\"workercountof\",{\"1\":{\"309\":1,\"311\":2,\"312\":1,\"314\":1}}],[\"workerstarted\",{\"1\":{\"312\":4}}],[\"workers\",{\"1\":{\"308\":1,\"312\":2,\"314\":1,\"319\":2}}],[\"worker的集合\",{\"1\":{\"308\":1}}],[\"workqueue\",{\"0\":{\"297\":1},\"1\":{\"294\":5,\"297\":3,\"303\":2,\"308\":1,\"311\":1,\"312\":1,\"314\":8,\"347\":3}}],[\"wordsinuse\",{\"1\":{\"393\":2}}],[\"words\",{\"1\":{\"393\":3}}],[\"word\",{\"1\":{\"149\":1}}],[\"world\",{\"1\":{\"147\":1}}],[\"wc\",{\"1\":{\"309\":2,\"312\":3,\"314\":5}}],[\"wrong\",{\"1\":{\"214\":1}}],[\"writer\",{\"1\":{\"399\":1,\"401\":1}}],[\"writes\",{\"1\":{\"328\":1}}],[\"writelock\",{\"1\":{\"220\":4,\"221\":1}}],[\"write\",{\"1\":{\"31\":10,\"173\":1,\"221\":2,\"223\":1,\"240\":1,\"405\":2,\"407\":1,\"410\":2,\"411\":1,\"412\":1,\"414\":4,\"415\":1}}],[\"whether\",{\"1\":{\"311\":1}}],[\"when\",{\"1\":{\"197\":1,\"199\":1,\"208\":1,\"256\":5,\"259\":1,\"311\":1}}],[\"which\",{\"1\":{\"107\":2,\"173\":2,\"214\":1,\"256\":1}}],[\"while\",{\"1\":{\"31\":2,\"131\":1,\"134\":1,\"135\":1,\"142\":1,\"160\":2,\"173\":2,\"183\":1,\"186\":1,\"187\":4,\"191\":2,\"203\":1,\"214\":1,\"256\":1,\"259\":3,\"260\":1,\"267\":2,\"273\":1,\"275\":1,\"277\":1,\"312\":1,\"313\":2,\"377\":1,\"378\":1,\"405\":2,\"406\":3,\"410\":1,\"411\":1,\"412\":2,\"414\":5,\"415\":2,\"430\":1}}],[\"ws\",{\"1\":{\"173\":11,\"198\":3,\"199\":3,\"214\":3}}],[\"we\",{\"1\":{\"115\":1,\"173\":4,\"183\":2,\"213\":2,\"311\":7}}],[\"webmvcconfigurer\",{\"1\":{\"98\":1}}],[\"webconfig\",{\"1\":{\"98\":1}}],[\"web\",{\"1\":{\"70\":2,\"97\":1,\"98\":2,\"106\":2,\"107\":2}}],[\"webhook\",{\"0\":{\"110\":1},\"1\":{\"64\":1,\"106\":1,\"107\":2,\"110\":7}}],[\"www\",{\"1\":{\"111\":1,\"137\":1,\"176\":1,\"200\":1,\"216\":1,\"262\":1,\"278\":1,\"320\":1,\"334\":1}}],[\"wuhan\",{\"1\":{\"108\":1,\"116\":1}}],[\"wangwu\",{\"1\":{\"418\":1}}],[\"wake\",{\"1\":{\"173\":1,\"214\":1}}],[\"was\",{\"1\":{\"173\":1}}],[\"warning\",{\"1\":{\"106\":1,\"107\":2}}],[\"waitnode\",{\"1\":{\"317\":2,\"328\":1,\"331\":2,\"333\":2}}],[\"waitersoffset\",{\"1\":{\"317\":1,\"331\":1,\"333\":1}}],[\"waiters\",{\"1\":{\"175\":6,\"185\":1,\"317\":1,\"328\":1,\"331\":1,\"333\":1}}],[\"waitstatusoffset\",{\"1\":{\"170\":2}}],[\"waitstatus\",{\"1\":{\"168\":4,\"170\":1,\"173\":10,\"174\":1,\"198\":3,\"199\":1,\"214\":5}}],[\"waiting\",{\"1\":{\"155\":4,\"173\":1,\"213\":1,\"214\":1}}],[\"wait\",{\"0\":{\"159\":1},\"1\":{\"106\":1,\"107\":6,\"140\":2,\"141\":2,\"159\":1,\"160\":2,\"175\":1,\"208\":1}}],[\"w\",{\"1\":{\"82\":1,\"295\":1,\"312\":5,\"313\":8,\"319\":6,\"406\":1}}],[\"will\",{\"1\":{\"173\":3}}],[\"windows系统和mac系统\",{\"1\":{\"69\":1}}],[\"windows\",{\"1\":{\"67\":1}}],[\"withinitial\",{\"1\":{\"281\":1}}],[\"without\",{\"1\":{\"90\":1,\"115\":4}}],[\"without|by\",{\"1\":{\"90\":1}}],[\"with\",{\"1\":{\"31\":1,\"90\":1,\"311\":1,\"313\":1,\"358\":1,\"359\":1}}],[\"也返回true\",{\"1\":{\"430\":1}}],[\"也应返回true\",{\"1\":{\"430\":2}}],[\"也能进行写操作\",{\"1\":{\"401\":1}}],[\"也能作为future用来得到callable的计算结果\",{\"1\":{\"322\":1,\"327\":1}}],[\"也保存了链表在添加和删除元素时效率快的特点\",{\"1\":{\"382\":1}}],[\"也支持动态扩容和再散列\",{\"1\":{\"379\":1}}],[\"也会返回true\",{\"1\":{\"326\":1}}],[\"也不会影响其他连接的数据已就绪的读写事件\",{\"1\":{\"416\":1}}],[\"也不会处理阻塞队列中的任务\",{\"1\":{\"309\":1}}],[\"也不会频繁创建对象\",{\"1\":{\"20\":1}}],[\"也不再执行已提交的任务\",{\"1\":{\"293\":1}}],[\"也就发生了内存泄漏\",{\"1\":{\"287\":1}}],[\"也就是把新生成的节点添加到waiters链表的首节点\",{\"1\":{\"331\":1}}],[\"也就是执行worker的run方法\",{\"1\":{\"313\":1}}],[\"也就是说linkedlist可以被当做队列使用\",{\"1\":{\"366\":1}}],[\"也就是说还没有任何一个线程调用get\",{\"1\":{\"331\":1}}],[\"也就是说\",{\"1\":{\"302\":1,\"424\":1}}],[\"也就是说不是所有的写操作都被阻塞\",{\"1\":{\"221\":1}}],[\"也就是当前threadlocal对象\",{\"1\":{\"282\":1}}],[\"也就是在condition\",{\"1\":{\"168\":1}}],[\"也就是在condition队列中\",{\"1\":{\"168\":1}}],[\"也就是unpark\",{\"1\":{\"168\":1}}],[\"也就是可以打印出a的值为0\",{\"1\":{\"131\":1}}],[\"也就是线程i值被修改\",{\"1\":{\"127\":1}}],[\"也就是能够根据需求\",{\"1\":{\"32\":1}}],[\"也实现了concurrentmap接口\",{\"1\":{\"249\":1}}],[\"也是基于数组的复制来实现的\",{\"1\":{\"240\":1}}],[\"也从下标0开始\",{\"1\":{\"237\":1}}],[\"也使用到了反射机制和cas来保证原子性的修改lock域\",{\"1\":{\"233\":1}}],[\"也称为独占模式的锁\",{\"1\":{\"219\":1}}],[\"也称为静态工厂方法模式\",{\"1\":{\"39\":1}}],[\"也很好理解\",{\"1\":{\"214\":1}}],[\"也查询handler不为\",{\"1\":{\"81\":1}}],[\"也适合高度动态的面向服务的体系结构的监视\",{\"1\":{\"65\":1}}],[\"也让代码扩展变得非常困难\",{\"1\":{\"51\":1}}],[\"也有可能影响系统的性能\",{\"1\":{\"37\":1}}],[\"也可以在构造函数中赋值\",{\"1\":{\"435\":1}}],[\"也可以在队首进行出队操作\",{\"1\":{\"226\":1}}],[\"也可以认为是一个辅助工具\",{\"1\":{\"401\":1}}],[\"也可以从尾结点遍历到头结点\",{\"1\":{\"366\":1}}],[\"也可以指定超时时间\",{\"1\":{\"337\":1}}],[\"也可以直接提交给thread类执行\",{\"1\":{\"322\":1}}],[\"也可以定义实现类重写拒绝策略\",{\"1\":{\"302\":1}}],[\"也可以通过指定容量来创建有界队列\",{\"1\":{\"266\":1}}],[\"也可以通过静态的配置去发现采集目标\",{\"1\":{\"62\":1}}],[\"也可以设置容量\",{\"1\":{\"266\":1}}],[\"也可以解决上面的问题\",{\"1\":{\"191\":1}}],[\"也可以进行模糊匹配\",{\"1\":{\"81\":1}}],[\"也可以配置静态采集任务\",{\"1\":{\"68\":1}}],[\"也可以是consul\",{\"1\":{\"64\":1}}],[\"也可以是短生命周期的任务推送到pushgateway的指标\",{\"1\":{\"64\":1}}],[\"也可以是一个抽象类\",{\"1\":{\"35\":1}}],[\"也可以使用thread+runnable来实现\",{\"1\":{\"336\":1}}],[\"也可以使用下面的公式去确定核心线程数可以参考以下公式\",{\"1\":{\"295\":1}}],[\"也可以使用\",{\"1\":{\"81\":1}}],[\"也可以使用多个标签值进行进行查询\",{\"1\":{\"81\":1}}],[\"也可以使用push模式\",{\"1\":{\"62\":1}}],[\"也可以使用第三方时序数据去存储\",{\"1\":{\"62\":1}}],[\"也可以深入到进程内部关键点的监控\",{\"1\":{\"62\":1}}],[\"也可以用它来向观察者发送消息\",{\"1\":{\"50\":1}}],[\"也可以根据需求快速的删除一些逻辑单元\",{\"1\":{\"37\":1}}],[\"也可以读取文件的字符\",{\"1\":{\"31\":1}}],[\"也可以把他们的顺序对调\",{\"1\":{\"31\":1}}],[\"做下面的增强功能\",{\"1\":{\"31\":1}}],[\"什么是futuretask\",{\"0\":{\"322\":1}}],[\"什么是threadlocal\",{\"0\":{\"280\":1}}],[\"什么是time\",{\"0\":{\"74\":1}}],[\"什么是blockingqueue\",{\"0\":{\"264\":1}}],[\"什么是prometheus\",{\"0\":{\"61\":1}}],[\"什么是单例模式\",{\"0\":{\"16\":1}}],[\"什么时候使用装饰器模式\",{\"1\":{\"30\":1}}],[\"组内的规则以固定的时间间隔按顺序运行\",{\"1\":{\"113\":1}}],[\"组成了链式的执行顺序\",{\"1\":{\"34\":1}}],[\"组件\",{\"0\":{\"63\":1}}],[\"组件实现类componentimpl\",{\"1\":{\"30\":1}}],[\"组件component\",{\"1\":{\"30\":1}}],[\"组合多个\",{\"1\":{\"337\":1}}],[\"组合操作\",{\"1\":{\"337\":1,\"343\":1}}],[\"组合优先原则\",{\"1\":{\"14\":1}}],[\"组合模式\",{\"1\":{\"11\":1}}],[\"blue\",{\"1\":{\"419\":1}}],[\"block\",{\"1\":{\"438\":6}}],[\"blockingqueue<runnable>\",{\"1\":{\"294\":1,\"308\":1}}],[\"blockingqueue<e>\",{\"1\":{\"265\":1,\"269\":1,\"270\":1}}],[\"blockingqueue表示阻塞型的队列\",{\"1\":{\"269\":1}}],[\"blockingqueue实现\",{\"0\":{\"266\":1}}],[\"blockingqueue接口继承了queue接口\",{\"1\":{\"265\":1}}],[\"blockingqueue接口定义\",{\"0\":{\"265\":1}}],[\"blockingqueue允许线程安全地进行队列操作\",{\"1\":{\"264\":1}}],[\"blockingqueue\",{\"1\":{\"264\":5,\"265\":1,\"266\":2}}],[\"blockingqueue详解\",{\"0\":{\"263\":1}}],[\"blockingq\",{\"1\":{\"187\":8}}],[\"blocker\",{\"1\":{\"175\":2}}],[\"blocked\",{\"0\":{\"158\":1},\"1\":{\"155\":2,\"158\":1}}],[\"blocks\",{\"1\":{\"146\":1}}],[\"blog\",{\"1\":{\"111\":2,\"262\":1,\"320\":1}}],[\"broken\",{\"1\":{\"207\":1,\"213\":4,\"215\":1}}],[\"brokenbarrierexception\",{\"1\":{\"203\":3,\"213\":3}}],[\"breakbarrier函数\",{\"0\":{\"215\":1}}],[\"breakbarrier\",{\"1\":{\"213\":4,\"215\":1}}],[\"break\",{\"1\":{\"186\":1,\"198\":1,\"199\":1,\"259\":10,\"261\":4,\"312\":1,\"319\":1,\"333\":2,\"362\":2,\"376\":2}}],[\"bfart\",{\"1\":{\"191\":1}}],[\"bio\",{\"1\":{\"416\":1}}],[\"bitlen\",{\"1\":{\"395\":2}}],[\"bitlen=bitset\",{\"1\":{\"395\":1}}],[\"bit\",{\"1\":{\"393\":5,\"395\":1}}],[\"bitindex\",{\"1\":{\"393\":4}}],[\"bitset2bytearray\",{\"1\":{\"395\":1}}],[\"bitsetdemo\",{\"1\":{\"395\":1}}],[\"bitsetexample\",{\"1\":{\"393\":1}}],[\"bitset在设计上是非线程安全\",{\"1\":{\"392\":1}}],[\"bitset是可增长比特向量的一个实现\",{\"1\":{\"392\":1}}],[\"bitset是采用一个long型的数组来实现位图的\",{\"1\":{\"391\":1}}],[\"bitset顶部有一些关于其设计上的注释\",{\"1\":{\"392\":1}}],[\"bitset中底层的存储结构选用了long数组\",{\"1\":{\"392\":1}}],[\"bitset\",{\"1\":{\"392\":2,\"393\":25,\"395\":29}}],[\"bitset的简单使用\",{\"0\":{\"393\":1}}],[\"bitset的size属性与其实现有关\",{\"1\":{\"392\":1}}],[\"bitset的所有比特的初始化值为false\",{\"1\":{\"392\":1}}],[\"bitset的优点就是省内存\",{\"1\":{\"392\":1}}],[\"bitset的继承关系结构图如下\",{\"1\":{\"391\":1}}],[\"bitset介绍\",{\"0\":{\"392\":1}}],[\"bitset实现了serializable接口\",{\"1\":{\"391\":1}}],[\"bitset实现了cloneable接口\",{\"1\":{\"391\":1}}],[\"bitset使用讲解\",{\"0\":{\"390\":1}}],[\"bits\",{\"1\":{\"256\":5,\"293\":5,\"309\":13,\"395\":2}}],[\"biased\",{\"1\":{\"153\":1}}],[\"bind\",{\"1\":{\"411\":2,\"414\":1}}],[\"bincount不为0\",{\"1\":{\"259\":1}}],[\"bincount赋值为2\",{\"1\":{\"259\":1}}],[\"bincount赋值为1\",{\"1\":{\"259\":1}}],[\"bincount\",{\"1\":{\"259\":6,\"376\":3}}],[\"bin\",{\"1\":{\"71\":1,\"259\":1}}],[\"b=2\",{\"1\":{\"121\":2}}],[\"because\",{\"1\":{\"311\":1,\"361\":1}}],[\"being\",{\"1\":{\"256\":1}}],[\"belong\",{\"1\":{\"213\":1}}],[\"below\",{\"1\":{\"173\":1,\"198\":1}}],[\"be\",{\"1\":{\"173\":1,\"214\":1,\"235\":1,\"311\":1,\"318\":2,\"329\":2}}],[\"been\",{\"1\":{\"107\":2,\"110\":1,\"213\":1,\"214\":1}}],[\"bean\",{\"1\":{\"98\":1}}],[\"beforeexecute\",{\"1\":{\"313\":1}}],[\"before\",{\"0\":{\"136\":1},\"1\":{\"54\":2,\"56\":2,\"107\":2,\"136\":16,\"173\":2,\"183\":1,\"187\":2,\"312\":1}}],[\"bob\",{\"1\":{\"353\":7,\"354\":10}}],[\"bounds\",{\"1\":{\"256\":1}}],[\"bout\",{\"1\":{\"31\":8}}],[\"book\",{\"1\":{\"111\":1}}],[\"boolean\",{\"1\":{\"98\":1,\"131\":1,\"134\":1,\"135\":1,\"142\":1,\"163\":1,\"168\":1,\"169\":2,\"173\":5,\"174\":1,\"175\":2,\"179\":2,\"181\":1,\"183\":5,\"184\":1,\"185\":1,\"186\":1,\"191\":2,\"197\":1,\"198\":1,\"199\":2,\"203\":1,\"207\":1,\"213\":2,\"214\":1,\"235\":2,\"238\":1,\"239\":1,\"259\":4,\"261\":1,\"265\":5,\"271\":4,\"274\":1,\"288\":1,\"295\":1,\"312\":4,\"313\":1,\"314\":3,\"317\":2,\"318\":1,\"319\":1,\"326\":4,\"329\":1,\"331\":2,\"332\":3,\"352\":1,\"353\":1,\"354\":1,\"360\":4,\"362\":1,\"363\":1,\"364\":1,\"368\":1,\"369\":1,\"370\":1,\"386\":1,\"387\":1,\"388\":1,\"393\":3,\"429\":1,\"430\":2}}],[\"boot<\",{\"1\":{\"97\":2}}],[\"boot\",{\"0\":{\"97\":1},\"1\":{\"96\":1,\"97\":3}}],[\"bottomk\",{\"1\":{\"90\":1}}],[\"by\",{\"1\":{\"68\":1,\"85\":2,\"90\":4,\"94\":2,\"100\":2,\"106\":1,\"107\":3,\"113\":1,\"116\":1,\"168\":2,\"173\":1,\"235\":4,\"282\":1,\"311\":1,\"328\":1,\"432\":1}}],[\"bytebuffer\",{\"1\":{\"403\":1,\"405\":4,\"406\":7,\"410\":2,\"411\":2,\"414\":8,\"415\":4}}],[\"bytesread\",{\"1\":{\"405\":3,\"410\":1,\"411\":1,\"414\":4}}],[\"bytes的差值\",{\"1\":{\"77\":1}}],[\"bytes\",{\"1\":{\"68\":12,\"69\":1,\"77\":2,\"395\":8,\"415\":3}}],[\"bytearray2bitset\",{\"1\":{\"395\":1}}],[\"bytearrayinputstream\",{\"1\":{\"31\":1,\"401\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"31\":4,\"401\":1}}],[\"byte\",{\"1\":{\"31\":6,\"395\":4,\"399\":1,\"403\":1,\"406\":10,\"415\":2,\"429\":9}}],[\"buf\",{\"1\":{\"414\":19}}],[\"bufferexample\",{\"1\":{\"406\":1}}],[\"bufferedoutputstream\",{\"1\":{\"399\":1,\"401\":1}}],[\"bufferedinputstream\",{\"1\":{\"399\":1,\"401\":1}}],[\"buffered\",{\"1\":{\"399\":1}}],[\"bufferedwriter\",{\"1\":{\"31\":8,\"399\":1,\"401\":1}}],[\"bufferedreader\",{\"1\":{\"29\":2,\"31\":7,\"399\":1,\"401\":1}}],[\"bufferedreader和filereader都是使用到包装器模式\",{\"1\":{\"29\":1}}],[\"buffer\",{\"0\":{\"406\":1},\"1\":{\"403\":2,\"405\":11,\"406\":33,\"410\":7,\"411\":7,\"415\":13}}],[\"but\",{\"1\":{\"173\":2,\"256\":1}}],[\"bug\",{\"1\":{\"122\":1,\"123\":1}}],[\"build\",{\"1\":{\"305\":1,\"306\":1}}],[\"buildandstart\",{\"1\":{\"98\":1}}],[\"builder\",{\"1\":{\"98\":3,\"305\":1}}],[\"bucket指标去统计\",{\"1\":{\"78\":1}}],[\"bucket\",{\"1\":{\"68\":1,\"78\":10,\"94\":13,\"98\":12,\"100\":1}}],[\"buck\",{\"1\":{\"68\":3}}],[\"b\",{\"1\":{\"31\":3,\"94\":1,\"136\":4,\"230\":1,\"247\":2,\"259\":9,\"429\":2}}],[\"banana\",{\"1\":{\"352\":2}}],[\"balanceinsertion\",{\"1\":{\"259\":1}}],[\"back\",{\"1\":{\"311\":1,\"312\":1}}],[\"backwards\",{\"1\":{\"173\":1}}],[\"backup\",{\"1\":{\"173\":1}}],[\"backlink\",{\"1\":{\"110\":1}}],[\"base位\",{\"1\":{\"347\":1}}],[\"basecount值减一\",{\"1\":{\"261\":1}}],[\"basecount\",{\"1\":{\"256\":4,\"259\":2}}],[\"base\",{\"1\":{\"256\":1}}],[\"baseiterator用于遍历操作\",{\"1\":{\"252\":1}}],[\"base64\",{\"1\":{\"31\":4}}],[\"basicthreadfactory\",{\"1\":{\"305\":1}}],[\"basic\",{\"1\":{\"119\":1}}],[\"basiccontroller\",{\"1\":{\"97\":1}}],[\"basics\",{\"1\":{\"95\":1}}],[\"baz\",{\"1\":{\"6\":1}}],[\"bark\",{\"1\":{\"419\":1}}],[\"barrieraction\",{\"1\":{\"210\":2}}],[\"barriercommand\",{\"1\":{\"208\":1,\"210\":1,\"213\":1}}],[\"barrier\",{\"1\":{\"145\":1,\"202\":1,\"208\":2}}],[\"bar\",{\"0\":{\"6\":1}}],[\"拓展新的适配者类功能\",{\"1\":{\"27\":1}}],[\"拓展坞将typec接口转换成usb接口\",{\"1\":{\"26\":1}}],[\"拓展坞适配器\",{\"1\":{\"26\":1}}],[\"难以维护\",{\"1\":{\"27\":1}}],[\"是终止java虚拟机jvm的\",{\"1\":{\"438\":1}}],[\"是不可以被更改的\",{\"1\":{\"436\":1}}],[\"是不能改变原有的基础功能\",{\"1\":{\"30\":1}}],[\"是在目标机器上运行java应用程序所需的最小环境\",{\"1\":{\"433\":1}}],[\"是程序的稳定性和健壮性的一种保护机制\",{\"1\":{\"432\":1}}],[\"是因为在string\",{\"1\":{\"430\":1}}],[\"是因为其本身包含\",{\"1\":{\"128\":1}}],[\"是比较对象的内容\",{\"1\":{\"430\":1}}],[\"是两种不同的编程范式\",{\"1\":{\"422\":1}}],[\"是两种基本的介质流\",{\"1\":{\"401\":3}}],[\"是其子类\",{\"1\":{\"419\":1}}],[\"是java平台的核心部分\",{\"1\":{\"433\":1}}],[\"是java虚拟机\",{\"1\":{\"433\":1}}],[\"是java运行时环境\",{\"1\":{\"433\":1}}],[\"是java开发工具包\",{\"1\":{\"433\":1}}],[\"是java语言中的两个重要概念\",{\"1\":{\"418\":1}}],[\"是java中用于异步编程的工具类\",{\"1\":{\"343\":1}}],[\"是连接数据源和目标的管道\",{\"1\":{\"404\":1}}],[\"是outputstream\",{\"1\":{\"401\":1}}],[\"是所有自定义具体装饰流的父类\",{\"1\":{\"401\":1}}],[\"是所有的输入字节流的父类\",{\"1\":{\"401\":1}}],[\"是向与其它线程共用的管道中写入数据\",{\"1\":{\"401\":2}}],[\"是从与其它线程共用的管道中读取数据\",{\"1\":{\"401\":2}}],[\"是三种基本的介质流\",{\"1\":{\"401\":1}}],[\"是非阻塞模式下的特性\",{\"1\":{\"407\":1}}],[\"是非线程安全的\",{\"1\":{\"389\":1}}],[\"是非原子操作\",{\"1\":{\"311\":1}}],[\"是线程安全的\",{\"1\":{\"382\":1}}],[\"是线程池中用于存放待执行任务的队列\",{\"1\":{\"297\":1}}],[\"是线程池中的核心线程数量\",{\"1\":{\"295\":1}}],[\"是通过双向链表实现的数据结构\",{\"1\":{\"371\":1}}],[\"是通过内部类\",{\"1\":{\"364\":1}}],[\"是通过基于数组的方式实现的动态数组\",{\"1\":{\"358\":1}}],[\"是元素的数量\",{\"1\":{\"358\":1}}],[\"是用于存储单列数据的容器\",{\"1\":{\"366\":1}}],[\"是用于存储任务执行期间的异常信息的单向链表\",{\"1\":{\"348\":1}}],[\"是用来开发应用指标的工具包\",{\"1\":{\"63\":1}}],[\"是主运行方法\",{\"1\":{\"348\":1}}],[\"是abstractexecutorservice\",{\"1\":{\"316\":1}}],[\"是指线程在空闲状态下的存活时间\",{\"1\":{\"296\":1}}],[\"是指代码执行的有序性\",{\"1\":{\"128\":1}}],[\"是期望的cpu利用率\",{\"1\":{\"295\":1}}],[\"是处理器的核数目\",{\"1\":{\"295\":1}}],[\"是延时执行类任务的主要实现\",{\"1\":{\"292\":1}}],[\"是如何做到的呢\",{\"1\":{\"288\":1}}],[\"是可以获取到父线程的\",{\"1\":{\"288\":1}}],[\"是基于跳表的线程安全的有序映射实现\",{\"1\":{\"224\":1}}],[\"是允许一个线程获取写锁的\",{\"1\":{\"221\":1}}],[\"是读写锁的扩展\",{\"1\":{\"218\":1}}],[\"是否可读\",{\"1\":{\"401\":1}}],[\"是否包含该对象\",{\"1\":{\"387\":1}}],[\"是否包含指定的元素\",{\"1\":{\"363\":1}}],[\"是否小于\",{\"1\":{\"364\":1}}],[\"是否等于\",{\"1\":{\"364\":2}}],[\"是否被修改过\",{\"1\":{\"364\":6}}],[\"是否有上一项\",{\"1\":{\"235\":1}}],[\"是否有等待时间更长的线程\",{\"1\":{\"185\":1}}],[\"是否还有下一项\",{\"1\":{\"235\":1}}],[\"是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为signal\",{\"1\":{\"173\":1}}],[\"是则将尾结点设置为node\",{\"1\":{\"173\":1}}],[\"是\",{\"1\":{\"136\":1,\"145\":1,\"188\":1,\"190\":1,\"202\":1,\"218\":1,\"228\":1,\"244\":1,\"264\":1,\"322\":2,\"337\":1,\"345\":1,\"348\":1,\"351\":1,\"357\":1,\"373\":1,\"379\":1,\"381\":1,\"398\":1,\"401\":3,\"403\":1,\"406\":1,\"410\":1,\"411\":1,\"412\":1}}],[\"是计算机用来临时存储数据和程序的地方\",{\"1\":{\"118\":1}}],[\"是计算机中的核心部件\",{\"1\":{\"118\":1}}],[\"是应用于指标的操作函数列表\",{\"1\":{\"115\":1}}],[\"是和预聚合前的名称保存一致\",{\"1\":{\"115\":1}}],[\"是单调递增的\",{\"1\":{\"76\":1}}],[\"是全局配置默认采集时间间隔\",{\"1\":{\"68\":1}}],[\"是一个装饰器为writer\",{\"1\":{\"401\":1}}],[\"是一个连接字节流和字符流的桥梁\",{\"1\":{\"401\":1}}],[\"是一个适用于插入和删除操作频繁的数据结构\",{\"1\":{\"371\":1}}],[\"是一个抽象类\",{\"1\":{\"346\":1}}],[\"是一个线程池\",{\"1\":{\"346\":1}}],[\"是一个线程安全且高效的哈希表实现\",{\"1\":{\"224\":1}}],[\"是一个用于构建锁和同步器的框架\",{\"1\":{\"162\":1}}],[\"是一个强大的高性能的代码生成库\",{\"1\":{\"57\":1}}],[\"是一种多路复用的机制\",{\"1\":{\"407\":1}}],[\"是一种无序\",{\"1\":{\"389\":1}}],[\"是一种独占锁\",{\"1\":{\"218\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"48\":1}}],[\"是一种创建型设计模式\",{\"1\":{\"42\":1,\"45\":1}}],[\"是会经常使用到的一个设计模式\",{\"1\":{\"34\":1}}],[\"是为了保持简单性\",{\"1\":{\"27\":1}}],[\"是作为适配的中间类\",{\"1\":{\"25\":1}}],[\"首先打开一个\",{\"1\":{\"414\":1}}],[\"首先通过\",{\"1\":{\"405\":1}}],[\"首先将\",{\"1\":{\"378\":1}}],[\"首先我们先创建一个hashmap对象\",{\"1\":{\"376\":1}}],[\"首先保存节点\",{\"1\":{\"370\":1}}],[\"首先检查\",{\"1\":{\"364\":1}}],[\"首先调用\",{\"1\":{\"364\":1}}],[\"首先调用tryacquire函数\",{\"1\":{\"173\":1}}],[\"首先引入\",{\"1\":{\"305\":1,\"306\":1}}],[\"首先获取当前线程对象\",{\"1\":{\"282\":1}}],[\"首先获取当前节点的前驱节点\",{\"1\":{\"173\":1}}],[\"首先创建一个\",{\"1\":{\"415\":1}}],[\"首先创建一个容量为\",{\"1\":{\"406\":1}}],[\"首先创建一个新的节点\",{\"1\":{\"368\":1}}],[\"首先创建一个审批抽象类aproval\",{\"1\":{\"36\":1}}],[\"首先创建了一个threadlocal对象\",{\"1\":{\"281\":1}}],[\"首先分析addwaiter函数\",{\"1\":{\"173\":1}}],[\"首先会检查当前的\",{\"1\":{\"377\":1}}],[\"首先会cas的把当前的状态从new变更为completing状态\",{\"1\":{\"329\":2}}],[\"首先会尝试获取锁\",{\"1\":{\"147\":1}}],[\"首先会将数据从主内存复制到线程的高速缓存中\",{\"1\":{\"124\":1}}],[\"首先用一段代码测试下\",{\"1\":{\"132\":1}}],[\"首先它需要读取i=0\",{\"1\":{\"126\":1}}],[\"首先需要深刻理解并发程序可能出现的问题\",{\"1\":{\"122\":1}}],[\"首先\",{\"1\":{\"27\":1,\"31\":1,\"120\":1,\"173\":1,\"303\":1,\"362\":1,\"376\":1,\"378\":1,\"436\":1}}],[\"新数组已经将就数据拷贝\",{\"1\":{\"361\":1}}],[\"新版并发容器通过使用同步控制变量\",{\"1\":{\"222\":1}}],[\"新版并发容器在设计上采用了更加细粒度的锁机制和无锁算法\",{\"1\":{\"222\":1}}],[\"新引入的锁机制\",{\"1\":{\"218\":1}}],[\"新生结点数组\",{\"1\":{\"259\":1}}],[\"新生数组\",{\"1\":{\"241\":1}}],[\"新生一个treenode结点\",{\"1\":{\"259\":1}}],[\"新生一个结点并且赋值给next域\",{\"1\":{\"259\":1}}],[\"新生一个条件\",{\"1\":{\"183\":1}}],[\"新生一代\",{\"1\":{\"214\":1}}],[\"新生成一个结点\",{\"1\":{\"173\":1}}],[\"新建状态的线程会转换为就绪状态\",{\"1\":{\"157\":1}}],[\"新建状态\",{\"0\":{\"156\":1}}],[\"新建一个recoding\",{\"1\":{\"116\":1}}],[\"新建一个springboot项目\",{\"1\":{\"97\":1}}],[\"新增产品族\",{\"1\":{\"47\":1}}],[\"新增一族产品时\",{\"1\":{\"47\":1}}],[\"新增一个逻辑功能\",{\"1\":{\"37\":1}}],[\"新写一个方法就可以将需要适配的类进行转换\",{\"1\":{\"27\":1}}],[\"新的任务会放入栈顶\",{\"1\":{\"347\":1}}],[\"新的序列名称为record中的值\",{\"1\":{\"113\":1}}],[\"新的软件开发模式\",{\"1\":{\"8\":1}}],[\"新的工具\",{\"1\":{\"8\":1}}],[\"新的框架\",{\"1\":{\"8\":1}}],[\"ak\",{\"1\":{\"256\":3}}],[\"attachment\",{\"1\":{\"414\":2}}],[\"attempt\",{\"1\":{\"214\":1}}],[\"at\",{\"1\":{\"320\":1,\"393\":3}}],[\"atomically\",{\"1\":{\"311\":1}}],[\"atomicinteger\",{\"1\":{\"281\":3,\"308\":2,\"309\":2}}],[\"atomicity\",{\"1\":{\"120\":1}}],[\"atomic\",{\"1\":{\"173\":1,\"281\":1}}],[\"awaitdone方法\",{\"0\":{\"331\":1}}],[\"awaitdone\",{\"1\":{\"317\":2,\"330\":1,\"331\":3}}],[\"await函数\",{\"0\":{\"198\":1}}],[\"awaituntil\",{\"1\":{\"169\":1}}],[\"awaituninterruptibly\",{\"1\":{\"169\":1}}],[\"awaitnanos\",{\"1\":{\"169\":2,\"213\":1}}],[\"await\",{\"1\":{\"169\":4,\"186\":2,\"187\":6,\"190\":2,\"191\":1,\"198\":1,\"203\":5,\"213\":1,\"273\":1,\"275\":1}}],[\"aqs的doreleaseshared的源码如下\",{\"1\":{\"199\":1}}],[\"aqs的设计使得开发者能够相对轻松地实现自定义的同步器\",{\"1\":{\"162\":1}}],[\"aqs对countdownlatch提供支持\",{\"1\":{\"197\":1}}],[\"aqs源码解析\",{\"0\":{\"165\":1}}],[\"aqs已经在上层已经帮我们实现好了\",{\"1\":{\"164\":1}}],[\"aqs定义两种资源共享方式\",{\"1\":{\"164\":1}}],[\"aqs核心思想\",{\"0\":{\"163\":1}}],[\"aqs\",{\"0\":{\"164\":1},\"1\":{\"162\":1,\"163\":5,\"175\":3}}],[\"aqs简介\",{\"0\":{\"162\":1}}],[\"a2\",{\"1\":{\"139\":4,\"142\":3,\"143\":3}}],[\"a1和a2\",{\"1\":{\"139\":1,\"142\":1,\"143\":1}}],[\"a1\",{\"1\":{\"139\":4,\"142\":3,\"143\":3}}],[\"active\",{\"1\":{\"256\":1}}],[\"action\",{\"1\":{\"173\":1,\"235\":3}}],[\"actual\",{\"1\":{\"173\":1}}],[\"actuator<\",{\"1\":{\"97\":1}}],[\"actuator的依赖包中\",{\"1\":{\"97\":1}}],[\"actuator\",{\"0\":{\"97\":1},\"1\":{\"96\":1,\"97\":1}}],[\"acquired\",{\"1\":{\"312\":1}}],[\"acquiresharedinterruptibly又调用了countdownlatch的内部类sync的tryacquireshared和aqs的doacquiresharedinterruptibly函数\",{\"1\":{\"198\":1}}],[\"acquiresharedinterruptibly源码如下\",{\"1\":{\"198\":1}}],[\"acquiresharedinterruptibly\",{\"1\":{\"198\":2}}],[\"acquires\",{\"1\":{\"183\":3,\"184\":2,\"185\":3,\"197\":1,\"198\":1}}],[\"acquirequeued\",{\"1\":{\"173\":2}}],[\"acquire\",{\"1\":{\"173\":2,\"175\":3,\"184\":1,\"185\":1}}],[\"acquire函数\",{\"0\":{\"173\":1}}],[\"accept\",{\"1\":{\"235\":1,\"407\":1,\"411\":2,\"414\":3}}],[\"accesscontroller\",{\"1\":{\"294\":1}}],[\"accesscontrolcontext\",{\"1\":{\"288\":1}}],[\"access\",{\"1\":{\"185\":1}}],[\"acc\",{\"1\":{\"147\":1,\"288\":1,\"294\":1}}],[\"account2\",{\"1\":{\"143\":4}}],[\"account1\",{\"1\":{\"143\":4}}],[\"account类包含一个方法fundtransfer\",{\"1\":{\"139\":1}}],[\"account\",{\"1\":{\"139\":14,\"142\":18,\"143\":15}}],[\"a=3\",{\"1\":{\"438\":1}}],[\"a=2\",{\"1\":{\"438\":2}}],[\"a=1\",{\"1\":{\"121\":2,\"438\":2}}],[\"a=7128\",{\"1\":{\"119\":1}}],[\"a=\",{\"1\":{\"119\":1}}],[\"a++\",{\"1\":{\"119\":2}}],[\"assigned\",{\"1\":{\"438\":1}}],[\"assert\",{\"1\":{\"259\":1,\"273\":2,\"275\":2,\"333\":1,\"361\":2}}],[\"ashift\",{\"1\":{\"256\":2,\"259\":2}}],[\"asheep=true\",{\"1\":{\"134\":1}}],[\"asheep\",{\"1\":{\"134\":1}}],[\"asking\",{\"1\":{\"173\":1}}],[\"asleep\",{\"1\":{\"134\":1}}],[\"as\",{\"1\":{\"115\":1,\"256\":1,\"259\":5,\"311\":1}}],[\"age\",{\"1\":{\"435\":8}}],[\"aggregate\",{\"1\":{\"115\":1}}],[\"again\",{\"1\":{\"107\":1}}],[\"anobject\",{\"1\":{\"430\":4}}],[\"anotherstring\",{\"1\":{\"430\":3}}],[\"anotherbitset\",{\"1\":{\"393\":4}}],[\"another\",{\"1\":{\"173\":1,\"239\":1}}],[\"animal2\",{\"1\":{\"424\":3}}],[\"animal1\",{\"1\":{\"424\":3}}],[\"animaldemo\",{\"1\":{\"419\":1}}],[\"animal\",{\"1\":{\"418\":7,\"419\":7,\"424\":8}}],[\"anyof\",{\"1\":{\"337\":1,\"341\":3,\"343\":1}}],[\"anticipation\",{\"1\":{\"173\":1}}],[\"annotations的内容在告警产生时会一同作为参数发送到alertmanager\",{\"1\":{\"108\":1}}],[\"annotations\",{\"1\":{\"108\":2,\"110\":2}}],[\"an\",{\"1\":{\"107\":3}}],[\"and\",{\"1\":{\"68\":1,\"87\":1,\"88\":1,\"115\":1,\"140\":1,\"141\":1,\"173\":1,\"214\":2,\"222\":1,\"246\":1,\"256\":2,\"309\":1,\"311\":5,\"393\":1}}],[\"avi等\",{\"1\":{\"399\":1}}],[\"average\",{\"1\":{\"90\":1}}],[\"avg\",{\"1\":{\"90\":1}}],[\"availableprocessors\",{\"1\":{\"256\":1,\"295\":1}}],[\"avail\",{\"1\":{\"77\":3}}],[\"alicescore\",{\"1\":{\"354\":2}}],[\"alice\",{\"1\":{\"353\":3,\"354\":6}}],[\"alarms\",{\"1\":{\"311\":1}}],[\"also\",{\"1\":{\"256\":1}}],[\"always\",{\"1\":{\"235\":6}}],[\"already\",{\"1\":{\"107\":2,\"173\":1}}],[\"allfutures\",{\"1\":{\"342\":4}}],[\"allof\",{\"1\":{\"337\":1,\"342\":3,\"343\":1}}],[\"allow\",{\"1\":{\"313\":1}}],[\"allowcorethreadtimeout为false\",{\"1\":{\"314\":1}}],[\"allowcorethreadtimeout\",{\"1\":{\"295\":1,\"314\":2}}],[\"allows\",{\"1\":{\"107\":1}}],[\"allocate\",{\"1\":{\"405\":1,\"406\":1,\"410\":1,\"411\":1,\"415\":1}}],[\"allocatedirect\",{\"1\":{\"414\":1}}],[\"allocated\",{\"1\":{\"68\":2}}],[\"alloc\",{\"1\":{\"68\":6}}],[\"all\",{\"1\":{\"90\":1}}],[\"alert\",{\"1\":{\"107\":2,\"108\":2,\"110\":3,\"111\":2}}],[\"alerts\",{\"1\":{\"107\":5,\"108\":1,\"109\":1,\"110\":5}}],[\"alertname\",{\"1\":{\"106\":2,\"107\":3}}],[\"alerting\",{\"1\":{\"68\":2,\"108\":1,\"110\":1}}],[\"alertmanager收到告警消息后\",{\"1\":{\"110\":1}}],[\"alertmanager查看告警消息\",{\"0\":{\"109\":1}}],[\"alertmanager持续多长时间未接收到告警后标记告警状态为resolved\",{\"1\":{\"107\":1}}],[\"alertmanager会启动它的告警恢复逻辑\",{\"1\":{\"107\":1}}],[\"alertmanager安装\",{\"0\":{\"106\":1}}],[\"alertmanager则不会发送消息到下游\",{\"1\":{\"105\":1}}],[\"alertmanager处理来自客户端的告警消息\",{\"1\":{\"102\":1}}],[\"alertmanager介绍\",{\"0\":{\"102\":1}}],[\"alertmanager作为告警收敛的组件\",{\"1\":{\"101\":1}}],[\"alertmanager的主要功能包括告警消息的分组\",{\"1\":{\"101\":1}}],[\"alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",{\"1\":{\"68\":1}}],[\"alertmanagers是配置alertmanagers的地址的\",{\"1\":{\"68\":1}}],[\"alertmanagers\",{\"1\":{\"68\":1,\"108\":1}}],[\"alertmanager提供了对告警消息的管理\",{\"1\":{\"64\":1}}],[\"alertmanager是用来管理告警消息的\",{\"1\":{\"63\":1}}],[\"alertmanager\",{\"1\":{\"59\":1,\"68\":2,\"105\":2,\"106\":1,\"110\":1}}],[\"abortpolicy\",{\"1\":{\"302\":1,\"306\":1}}],[\"about\",{\"1\":{\"68\":1,\"107\":1,\"213\":1}}],[\"abase\",{\"1\":{\"256\":2,\"259\":2}}],[\"abc\",{\"1\":{\"126\":1,\"429\":3}}],[\"abstractlist<e>\",{\"1\":{\"358\":1}}],[\"abstractlist\",{\"1\":{\"357\":1}}],[\"abstractexecutorservice\",{\"1\":{\"316\":1}}],[\"abstractqueue定义了对队列的基本操作\",{\"1\":{\"269\":1}}],[\"abstractqueue<e>\",{\"1\":{\"269\":1,\"270\":1}}],[\"abstractqueuedsynchronizer中的数据结构\",{\"1\":{\"185\":1}}],[\"abstractqueuedsynchronizer类有两个内部类\",{\"1\":{\"167\":1}}],[\"abstractqueuedsynchronizer继承自abstractownablesynchronizer抽象类\",{\"1\":{\"166\":1}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"162\":1,\"163\":1,\"166\":1,\"170\":4,\"171\":1,\"176\":1,\"183\":1,\"197\":1,\"313\":1}}],[\"abstractmap<k\",{\"1\":{\"249\":1,\"256\":1}}],[\"abstractownablesynchronizer抽象类中\",{\"1\":{\"166\":1}}],[\"abstractownablesynchronizer\",{\"1\":{\"166\":3,\"170\":1}}],[\"abstract\",{\"1\":{\"36\":2,\"41\":2,\"45\":1,\"47\":2,\"166\":2,\"170\":1,\"183\":2,\"419\":4,\"424\":2,\"436\":2}}],[\"a\",{\"1\":{\"68\":1,\"74\":2,\"79\":1,\"107\":5,\"119\":1,\"131\":4,\"136\":4,\"173\":2,\"183\":1,\"230\":1,\"240\":1,\"247\":5,\"256\":3,\"259\":4,\"311\":5,\"313\":1,\"359\":4,\"361\":1,\"395\":2,\"429\":2,\"438\":8}}],[\"afterexecute\",{\"1\":{\"313\":1}}],[\"aftercompletion\",{\"1\":{\"98\":1}}],[\"after\",{\"1\":{\"54\":2,\"56\":2,\"173\":1,\"187\":2,\"256\":1,\"318\":1,\"329\":1,\"352\":2,\"354\":2,\"395\":1}}],[\"aop\",{\"1\":{\"52\":1,\"98\":1}}],[\"advancerunstate\",{\"1\":{\"319\":2}}],[\"adaptive\",{\"1\":{\"153\":1}}],[\"adapter\",{\"1\":{\"26\":2}}],[\"adaptee\",{\"1\":{\"25\":1}}],[\"addall\",{\"1\":{\"352\":1,\"360\":2,\"367\":1,\"385\":1}}],[\"addworkerfailed\",{\"1\":{\"312\":1}}],[\"addworker主要负责创建新的线程并执行任务\",{\"1\":{\"312\":1}}],[\"addworker方法\",{\"0\":{\"312\":1}}],[\"addworker\",{\"1\":{\"310\":1,\"311\":4,\"312\":1}}],[\"addwaiter函数使用快速添加的方式往sync\",{\"1\":{\"173\":1}}],[\"addwaiter函数完成的功能是将调用此方法的线程封装成为一个结点并放入sync\",{\"1\":{\"173\":1}}],[\"addwaiter\",{\"1\":{\"168\":1,\"173\":2,\"198\":1}}],[\"addcount函数源码如下\",{\"1\":{\"259\":1}}],[\"addcount函数\",{\"1\":{\"259\":1}}],[\"addcount\",{\"1\":{\"259\":2,\"261\":1}}],[\"addxxx\",{\"1\":{\"239\":1}}],[\"add函数\",{\"0\":{\"238\":1}}],[\"added\",{\"1\":{\"107\":1,\"311\":1}}],[\"adding\",{\"1\":{\"259\":1}}],[\"addinterceptor\",{\"1\":{\"98\":1}}],[\"addinterceptors\",{\"1\":{\"98\":1}}],[\"addifabsent\",{\"0\":{\"239\":1},\"1\":{\"239\":1}}],[\"addition\",{\"1\":{\"85\":1}}],[\"add\",{\"0\":{\"368\":1},\"1\":{\"50\":1,\"142\":2,\"175\":1,\"230\":3,\"235\":3,\"238\":1,\"265\":3,\"311\":2,\"312\":1,\"352\":5,\"353\":4,\"360\":5,\"366\":2,\"368\":4,\"383\":5,\"386\":4}}],[\"arithmeticexception\",{\"1\":{\"432\":2,\"438\":6}}],[\"arg\",{\"1\":{\"173\":5,\"174\":2,\"198\":5,\"199\":2}}],[\"args\",{\"1\":{\"26\":1,\"31\":1,\"36\":1,\"41\":1,\"44\":1,\"47\":1,\"50\":1,\"54\":1,\"56\":3,\"57\":3,\"119\":1,\"131\":1,\"132\":1,\"139\":1,\"142\":1,\"143\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"187\":1,\"191\":2,\"203\":1,\"230\":1,\"247\":1,\"267\":1,\"281\":1,\"288\":1,\"315\":1,\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":1,\"352\":1,\"353\":1,\"354\":1,\"383\":1,\"393\":1,\"405\":1,\"406\":1,\"414\":1,\"415\":1,\"418\":2,\"419\":2,\"432\":1,\"435\":1,\"436\":1,\"438\":3}}],[\"article\",{\"1\":{\"111\":1,\"289\":1,\"320\":1}}],[\"artifactid>\",{\"1\":{\"57\":1,\"97\":3,\"98\":3}}],[\"arrayindexoutofboundsexception\",{\"1\":{\"271\":1}}],[\"arrayindexscale\",{\"1\":{\"256\":1}}],[\"arraybaseoffset\",{\"1\":{\"256\":1}}],[\"arrayblockingqueue是通过数组实现的有界队列\",{\"1\":{\"300\":1}}],[\"arrayblockingqueue源码实现\",{\"0\":{\"268\":1}}],[\"arrayblockingqueue<e>\",{\"1\":{\"269\":1,\"270\":1}}],[\"arrayblockingqueue<>\",{\"1\":{\"267\":1}}],[\"arrayblockingqueue<integer>\",{\"1\":{\"267\":1}}],[\"arrayblockingqueue使用介绍\",{\"0\":{\"267\":1}}],[\"arrayblockingqueue\",{\"0\":{\"300\":1},\"1\":{\"226\":1,\"266\":3,\"267\":7,\"271\":9,\"297\":1}}],[\"arraycopy\",{\"1\":{\"237\":1,\"241\":2,\"360\":1,\"362\":1}}],[\"arrays=null\",{\"1\":{\"435\":1}}],[\"arrays=new\",{\"1\":{\"435\":1}}],[\"arrayssupport\",{\"1\":{\"361\":1}}],[\"arrays\",{\"1\":{\"234\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"359\":1,\"361\":1,\"395\":1}}],[\"array\",{\"1\":{\"223\":2,\"229\":1,\"233\":1,\"235\":1,\"237\":1,\"256\":1,\"349\":10,\"359\":1,\"361\":5,\"395\":3,\"415\":1}}],[\"arraylist有三种构造函数\",{\"1\":{\"359\":1}}],[\"arraylist会在构造函数执行的时候初始化\",{\"1\":{\"359\":1}}],[\"arraylist的初始化\",{\"0\":{\"359\":1}}],[\"arraylist的容量就是这个数组缓冲区的长度\",{\"1\":{\"358\":1}}],[\"arraylist的底层使用数组实现的源码如下\",{\"1\":{\"358\":1}}],[\"arraylist的类结构图\",{\"0\":{\"357\":1}}],[\"arraylist底层是如何实现的\",{\"0\":{\"358\":1}}],[\"arraylist底层基于数组实现\",{\"1\":{\"357\":1}}],[\"arraylist实现了serializable接口\",{\"1\":{\"357\":1}}],[\"arraylist实现了cloneable接口\",{\"1\":{\"357\":1}}],[\"arraylist实现了randomaccess接口\",{\"1\":{\"357\":1}}],[\"arraylist继承了abstractlist类并实现类list接口\",{\"1\":{\"357\":1}}],[\"arraylist源码解析\",{\"0\":{\"356\":1}}],[\"arraylist<e>\",{\"1\":{\"358\":1}}],[\"arraylist<alert>\",{\"1\":{\"110\":1}}],[\"arraylist<>\",{\"1\":{\"50\":1,\"142\":1,\"352\":1}}],[\"arraylist\",{\"1\":{\"50\":1,\"142\":1,\"351\":1,\"352\":1,\"357\":1,\"358\":11,\"359\":4,\"362\":2,\"363\":3,\"364\":13}}],[\"arrive\",{\"1\":{\"107\":1}}],[\"are\",{\"1\":{\"90\":1,\"107\":2,\"173\":2,\"311\":3,\"314\":1}}],[\"architecture\",{\"1\":{\"64\":1}}],[\"amd64\",{\"1\":{\"67\":2,\"71\":2}}],[\"america\",{\"1\":{\"41\":1}}],[\"americasofafactory\",{\"1\":{\"44\":1}}],[\"americasofa\",{\"1\":{\"41\":2,\"44\":1}}],[\"americasofa类实现了抽象产品类\",{\"1\":{\"41\":1}}],[\"amount<1000\",{\"1\":{\"36\":1}}],[\"amount\",{\"1\":{\"36\":12}}],[\"apple\",{\"1\":{\"352\":8}}],[\"apply方法用于申请资源\",{\"1\":{\"142\":1}}],[\"apply\",{\"1\":{\"142\":3}}],[\"apparently\",{\"1\":{\"173\":1}}],[\"apparent\",{\"1\":{\"173\":1}}],[\"append\",{\"1\":{\"31\":1,\"395\":3}}],[\"apistatinterceptor\",{\"1\":{\"98\":2}}],[\"api\",{\"1\":{\"81\":4,\"85\":1,\"403\":1}}],[\"aproval\",{\"1\":{\"36\":7}}],[\"tcp\",{\"1\":{\"404\":1,\"410\":3,\"411\":2}}],[\"tl\",{\"1\":{\"259\":4}}],[\"tidying\",{\"1\":{\"293\":2,\"309\":2}}],[\"tid\",{\"1\":{\"288\":1}}],[\"tiebreakorder\",{\"1\":{\"259\":1}}],[\"timeunit\",{\"1\":{\"169\":1,\"179\":1,\"265\":2,\"294\":1,\"306\":1,\"314\":2,\"315\":1,\"323\":1,\"326\":2,\"336\":2,\"415\":2}}],[\"timedout\",{\"1\":{\"314\":4}}],[\"timed\",{\"1\":{\"155\":2,\"213\":4,\"314\":5,\"317\":3,\"331\":3}}],[\"timeoutexception\",{\"1\":{\"186\":1,\"213\":2,\"322\":1,\"323\":1,\"326\":1,\"336\":1}}],[\"timeout对于prometheus的告警消息是不生效的\",{\"1\":{\"107\":1}}],[\"timeout\",{\"1\":{\"106\":1,\"107\":2,\"186\":3,\"265\":2,\"326\":2,\"414\":2}}],[\"timeseries格式如下\",{\"1\":{\"90\":1}}],[\"timestamp\",{\"1\":{\"74\":3}}],[\"time\",{\"1\":{\"74\":1,\"169\":2,\"179\":1,\"265\":4,\"314\":1,\"317\":1,\"331\":1}}],[\"two\",{\"1\":{\"256\":1}}],[\"t=new\",{\"1\":{\"157\":1}}],[\"t2\",{\"1\":{\"119\":2,\"139\":3,\"140\":2,\"142\":3,\"143\":3,\"160\":3,\"191\":7}}],[\"t2=new\",{\"1\":{\"119\":1,\"191\":1}}],[\"t1线程获取了a1对象的锁\",{\"1\":{\"139\":1}}],[\"t1线程调用a1\",{\"1\":{\"139\":1}}],[\"t1和t2\",{\"1\":{\"139\":1,\"142\":1,\"143\":1}}],[\"t1\",{\"1\":{\"119\":2,\"139\":3,\"140\":4,\"142\":3,\"143\":3,\"160\":3,\"191\":7}}],[\"t1=new\",{\"1\":{\"119\":1,\"191\":1}}],[\"t\",{\"1\":{\"93\":1,\"157\":1,\"173\":15,\"175\":3,\"183\":1,\"185\":1,\"214\":6,\"237\":5,\"261\":4,\"282\":14,\"311\":1,\"312\":5,\"316\":1,\"319\":3,\"329\":2,\"332\":3,\"333\":3,\"395\":2}}],[\"task2\",{\"1\":{\"436\":1}}],[\"task1\",{\"1\":{\"436\":1}}],[\"taskname+\",{\"1\":{\"436\":1}}],[\"taskname=\",{\"1\":{\"436\":2}}],[\"taskname\",{\"1\":{\"436\":3}}],[\"task完成后回调使用回调函数thenapply\",{\"1\":{\"340\":1}}],[\"task异步完成后使用回调函数\",{\"0\":{\"340\":1}}],[\"tasks\",{\"1\":{\"319\":3}}],[\"task\",{\"1\":{\"311\":6,\"313\":7,\"316\":6,\"317\":1,\"323\":8,\"336\":2,\"436\":6}}],[\"take方法返回任务\",{\"1\":{\"314\":1}}],[\"take任务\",{\"1\":{\"314\":1}}],[\"take会调用dequeue函数\",{\"1\":{\"275\":1}}],[\"take函数用于从arrayblockingqueue中获取一个元素\",{\"1\":{\"275\":1}}],[\"take函数\",{\"0\":{\"275\":1}}],[\"takeindex\",{\"1\":{\"270\":1,\"275\":4,\"277\":2}}],[\"take\",{\"1\":{\"264\":1,\"265\":3,\"267\":1,\"275\":1,\"314\":2}}],[\"tabat函数源码如下\",{\"1\":{\"259\":1}}],[\"tabat\",{\"1\":{\"259\":6,\"260\":1,\"261\":2}}],[\"tab\",{\"1\":{\"259\":36,\"260\":4,\"261\":9,\"376\":5,\"377\":3,\"378\":5}}],[\"tablesizefor\",{\"1\":{\"375\":3}}],[\"table表为空或者表长度为0或者key所对应的桶为空\",{\"1\":{\"261\":1}}],[\"table表为空或者大小为0\",{\"1\":{\"259\":1}}],[\"table表的长度小于最小的长度\",{\"1\":{\"259\":1}}],[\"table表不为空并且结点类型使forwardingnode类型\",{\"1\":{\"259\":1}}],[\"table=\",{\"1\":{\"47\":1}}],[\"table\",{\"1\":{\"46\":1,\"47\":9,\"68\":1,\"256\":9,\"259\":7,\"260\":1,\"261\":1,\"376\":5,\"377\":12,\"378\":4}}],[\"tail内存偏移地址\",{\"1\":{\"170\":1}}],[\"tailoffset\",{\"1\":{\"170\":2}}],[\"tail\",{\"1\":{\"170\":2,\"173\":7,\"198\":1,\"199\":1,\"214\":2}}],[\"tar\",{\"1\":{\"67\":2,\"71\":3}}],[\"targets\",{\"1\":{\"68\":2,\"69\":2,\"99\":1,\"108\":1}}],[\"target\",{\"1\":{\"57\":6,\"106\":1,\"107\":2,\"288\":1}}],[\"th\",{\"1\":{\"415\":5}}],[\"threshold\",{\"1\":{\"256\":2,\"259\":1,\"349\":2,\"375\":2,\"376\":2,\"377\":3}}],[\"threadfactorybuilder\",{\"1\":{\"306\":1}}],[\"threadfactory\",{\"0\":{\"301\":1},\"1\":{\"294\":6,\"306\":1,\"312\":1}}],[\"threadgroup\",{\"1\":{\"288\":1}}],[\"thread类的init方法中\",{\"1\":{\"288\":1}}],[\"thread生命周期比较长\",{\"1\":{\"287\":1}}],[\"thread3\",{\"1\":{\"281\":2}}],[\"thread2\",{\"1\":{\"281\":2}}],[\"thread1\",{\"1\":{\"281\":2}}],[\"threadlocal<>\",{\"1\":{\"288\":1}}],[\"threadlocal<string>\",{\"1\":{\"288\":1}}],[\"threadlocal<atomicinteger>\",{\"1\":{\"281\":1}}],[\"threadlocal变量通常在一个线程内部使用\",{\"1\":{\"288\":1}}],[\"threadlocal使用不当可能会出现内存泄露\",{\"1\":{\"284\":1}}],[\"threadlocal内存泄露\",{\"0\":{\"284\":1}}],[\"threadlocal可以用于保存每个线程的缓存实例\",{\"1\":{\"283\":1}}],[\"threadlocal可以用于保存用户的上下文信息\",{\"1\":{\"283\":1}}],[\"threadlocal在多线程编程中有各种使用场景\",{\"1\":{\"283\":1}}],[\"threadlocal的使用场景\",{\"0\":{\"283\":1}}],[\"threadlocal的使用示例\",{\"0\":{\"281\":1}}],[\"threadlocals引用一直存在\",{\"1\":{\"287\":1}}],[\"threadlocals指向的threadlocalmap实例也随之变为垃圾\",{\"1\":{\"287\":1}}],[\"threadlocals\",{\"1\":{\"282\":3,\"288\":1}}],[\"threadlocals的key需要是threadlocal对象\",{\"1\":{\"282\":1}}],[\"threadlocalmap是由threadlocal维护的静态内部类\",{\"1\":{\"282\":1}}],[\"threadlocalmap\",{\"1\":{\"282\":6,\"288\":5}}],[\"threadlocalmap对象\",{\"1\":{\"282\":1}}],[\"threadlocal原理分析\",{\"0\":{\"282\":1}}],[\"threadlocalexample\",{\"1\":{\"281\":1}}],[\"threadlocal\",{\"1\":{\"280\":2,\"281\":7,\"282\":3,\"288\":7}}],[\"threadlocal是线程本地变量\",{\"1\":{\"280\":1}}],[\"threadlocal详解\",{\"0\":{\"279\":1}}],[\"threadlocalrandom\",{\"1\":{\"259\":1}}],[\"threadpoolexecutor源码详解\",{\"0\":{\"307\":1}}],[\"threadpoolexecutor的构造函数包含了7个核心参数\",{\"1\":{\"294\":1}}],[\"threadpoolexecutor的构造函数如下\",{\"1\":{\"294\":1}}],[\"threadpoolexecutor\",{\"1\":{\"294\":1,\"306\":2,\"311\":1}}],[\"threadpoolexecutor构造函数\",{\"0\":{\"294\":1}}],[\"threadpoolexecutor线程池的生命周期\",{\"0\":{\"293\":1}}],[\"threadpoolexecutor是线程池的核心实现类\",{\"1\":{\"292\":1}}],[\"threadpoolexecutor类图\",{\"0\":{\"292\":1}}],[\"threadpoolexecutor详解\",{\"0\":{\"290\":1}}],[\"threadpool\",{\"1\":{\"191\":2,\"336\":1,\"341\":1,\"342\":1,\"349\":1}}],[\"threads\",{\"1\":{\"173\":1,\"256\":1,\"311\":2}}],[\"threadstatetest3\",{\"1\":{\"159\":1}}],[\"threadstatetest2\",{\"1\":{\"158\":3}}],[\"threaddemo4\",{\"1\":{\"160\":1}}],[\"thread=new\",{\"1\":{\"158\":1}}],[\"thread状态\",{\"0\":{\"154\":1,\"155\":1}}],[\"thread\",{\"1\":{\"119\":4,\"131\":3,\"132\":2,\"139\":6,\"142\":5,\"143\":5,\"156\":3,\"157\":4,\"158\":8,\"159\":12,\"160\":9,\"166\":5,\"168\":10,\"173\":7,\"175\":15,\"176\":2,\"183\":6,\"184\":1,\"185\":2,\"187\":8,\"191\":10,\"198\":1,\"203\":3,\"213\":2,\"214\":2,\"259\":1,\"267\":6,\"281\":7,\"282\":7,\"287\":1,\"288\":6,\"295\":2,\"306\":2,\"311\":4,\"312\":3,\"313\":9,\"317\":3,\"318\":1,\"319\":2,\"323\":9,\"328\":1,\"329\":1,\"331\":3,\"332\":1,\"333\":3,\"336\":2,\"339\":1,\"340\":1,\"341\":3,\"342\":3,\"350\":2}}],[\"thrown\",{\"1\":{\"313\":5}}],[\"throw\",{\"1\":{\"168\":1,\"170\":1,\"175\":1,\"183\":2,\"185\":1,\"186\":1,\"196\":1,\"198\":2,\"210\":1,\"213\":5,\"214\":1,\"233\":1,\"235\":5,\"256\":2,\"259\":1,\"271\":2,\"294\":2,\"311\":1,\"312\":1,\"313\":3,\"316\":1,\"317\":1,\"331\":1,\"359\":1,\"361\":1,\"364\":5,\"369\":1,\"370\":1,\"375\":2}}],[\"throwable有两个重要的子类\",{\"1\":{\"432\":1}}],[\"throwable是所有异常类的根类\",{\"1\":{\"432\":1}}],[\"throwable\",{\"1\":{\"56\":1,\"57\":1,\"313\":2,\"318\":1,\"329\":2,\"340\":2,\"432\":1,\"437\":1}}],[\"throws\",{\"1\":{\"56\":1,\"57\":1,\"98\":4,\"119\":1,\"131\":1,\"132\":1,\"139\":1,\"142\":1,\"143\":1,\"168\":1,\"169\":4,\"179\":2,\"183\":1,\"191\":2,\"198\":3,\"203\":1,\"213\":1,\"235\":6,\"265\":4,\"273\":1,\"275\":1,\"315\":1,\"317\":2,\"325\":1,\"326\":2,\"330\":1,\"331\":1,\"414\":3,\"415\":1,\"437\":1}}],[\"than\",{\"1\":{\"86\":2,\"311\":1}}],[\"thanos\",{\"1\":{\"62\":1}}],[\"that\",{\"1\":{\"68\":1,\"107\":1,\"110\":1,\"173\":1,\"183\":1,\"214\":1,\"311\":2,\"312\":1}}],[\"there\",{\"1\":{\"256\":1,\"311\":1}}],[\"theunsafe\",{\"1\":{\"175\":1}}],[\"thenrun\",{\"1\":{\"342\":1}}],[\"thencombine\",{\"1\":{\"337\":2,\"343\":1}}],[\"thencompose\",{\"1\":{\"337\":2,\"343\":1}}],[\"thencomposeasync\",{\"1\":{\"337\":1}}],[\"thenacceptasync\",{\"1\":{\"340\":2,\"341\":1}}],[\"thenacceptboth\",{\"1\":{\"337\":1}}],[\"thenaccept\",{\"1\":{\"337\":1,\"343\":1}}],[\"thenapply\",{\"1\":{\"337\":1,\"340\":2,\"343\":1}}],[\"thenapplyasync\",{\"1\":{\"337\":1}}],[\"then\",{\"1\":{\"115\":1,\"311\":2}}],[\"the\",{\"1\":{\"68\":3,\"79\":1,\"90\":4,\"107\":2,\"110\":5,\"115\":1,\"173\":5,\"183\":1,\"208\":4,\"214\":2,\"235\":1,\"256\":6,\"282\":1,\"288\":2,\"309\":1,\"311\":5,\"314\":1,\"317\":1,\"395\":2,\"438\":1}}],[\"this\",{\"1\":{\"26\":1,\"31\":3,\"36\":1,\"50\":1,\"54\":1,\"56\":1,\"57\":2,\"139\":8,\"142\":8,\"143\":7,\"147\":1,\"163\":1,\"168\":4,\"173\":4,\"175\":3,\"187\":3,\"196\":1,\"210\":3,\"211\":1,\"213\":2,\"235\":3,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"259\":5,\"271\":4,\"273\":2,\"274\":1,\"275\":2,\"276\":1,\"277\":3,\"282\":5,\"288\":2,\"294\":7,\"311\":1,\"312\":1,\"313\":8,\"317\":4,\"318\":1,\"319\":4,\"329\":5,\"331\":3,\"332\":3,\"333\":1,\"349\":3,\"359\":3,\"360\":1,\"362\":1,\"364\":3,\"367\":1,\"375\":2,\"376\":1,\"377\":1,\"419\":2,\"430\":2,\"435\":3}}],[\"type\",{\"1\":{\"41\":3,\"68\":6,\"74\":1,\"75\":1,\"79\":1,\"97\":2,\"98\":2,\"256\":3}}],[\"txt\",{\"1\":{\"31\":1,\"405\":1}}],[\"tech\",{\"1\":{\"176\":1,\"350\":1}}],[\"terminated\",{\"1\":{\"155\":2,\"293\":2,\"309\":3}}],[\"test2\",{\"1\":{\"435\":1}}],[\"test<\",{\"1\":{\"97\":1}}],[\"testcglibproxy\",{\"1\":{\"57\":2}}],[\"testjdkproxy\",{\"1\":{\"56\":2}}],[\"teststatic\",{\"1\":{\"54\":2}}],[\"test\",{\"1\":{\"31\":1,\"108\":2,\"132\":3,\"315\":1,\"405\":1,\"435\":4}}],[\"text\",{\"1\":{\"31\":2}}],[\"too\",{\"1\":{\"361\":1}}],[\"top\",{\"1\":{\"347\":1}}],[\"topk\",{\"1\":{\"90\":2}}],[\"tocopyin\",{\"1\":{\"234\":3}}],[\"toarray方法可能不会返回object类型的数组\",{\"1\":{\"234\":1}}],[\"toarray\",{\"1\":{\"234\":2,\"359\":1}}],[\"tonanos\",{\"1\":{\"169\":1,\"294\":1}}],[\"together\",{\"1\":{\"107\":1}}],[\"to\",{\"1\":{\"88\":3,\"89\":2,\"107\":8,\"110\":4,\"115\":1,\"168\":1,\"173\":10,\"183\":3,\"197\":1,\"198\":1,\"199\":2,\"208\":2,\"213\":3,\"214\":4,\"235\":2,\"239\":1,\"256\":4,\"259\":1,\"282\":1,\"311\":4,\"312\":1,\"313\":2,\"314\":1,\"318\":3,\"329\":3,\"333\":2,\"414\":1,\"438\":1}}],[\"total的后缀\",{\"1\":{\"115\":1}}],[\"total和http\",{\"1\":{\"98\":1}}],[\"total这个指标有4个标签\",{\"1\":{\"90\":1}}],[\"total指标的不同标签维度的所有指标\",{\"1\":{\"81\":1}}],[\"total都会累积1\",{\"1\":{\"76\":1}}],[\"total表示prometheus服务的http请求的数量\",{\"1\":{\"76\":1}}],[\"total结尾\",{\"1\":{\"76\":1}}],[\"total\",{\"1\":{\"68\":4,\"74\":11,\"75\":3,\"76\":1,\"81\":7,\"82\":1,\"83\":4,\"85\":3,\"90\":5,\"92\":5,\"98\":5,\"100\":1,\"108\":1,\"115\":4,\"116\":1}}],[\"tobytearray\",{\"1\":{\"31\":2,\"393\":1}}],[\"tostring\",{\"1\":{\"31\":1,\"50\":1,\"110\":1,\"393\":1,\"395\":1}}],[\"trip\",{\"1\":{\"208\":1,\"213\":2,\"214\":1,\"215\":1}}],[\"tripped\",{\"1\":{\"208\":2,\"213\":1}}],[\"traverser类主要用于遍历操作\",{\"1\":{\"252\":1}}],[\"traverser类\",{\"0\":{\"252\":1}}],[\"traverse\",{\"1\":{\"173\":1}}],[\"transferindex\",{\"1\":{\"256\":4,\"259\":2}}],[\"transfer\",{\"1\":{\"256\":1,\"259\":3}}],[\"transferforsignal\",{\"1\":{\"214\":2}}],[\"transfermoney\",{\"1\":{\"139\":5,\"142\":3,\"143\":3}}],[\"transitions\",{\"1\":{\"317\":1}}],[\"transition\",{\"1\":{\"197\":1,\"199\":1}}],[\"transiently\",{\"1\":{\"214\":1}}],[\"transient\",{\"1\":{\"166\":1,\"170\":2,\"233\":2,\"256\":11,\"270\":1,\"358\":1}}],[\"truncated\",{\"1\":{\"110\":1}}],[\"truncatedalerts\",{\"1\":{\"110\":2}}],[\"true\",{\"1\":{\"1\":1,\"2\":1,\"98\":1,\"131\":2,\"135\":1,\"142\":1,\"160\":2,\"173\":3,\"174\":1,\"175\":2,\"183\":3,\"185\":2,\"191\":1,\"198\":1,\"199\":1,\"203\":1,\"213\":1,\"214\":1,\"215\":1,\"238\":1,\"239\":1,\"259\":3,\"261\":2,\"267\":2,\"274\":1,\"305\":1,\"311\":1,\"312\":2,\"313\":1,\"314\":2,\"318\":1,\"328\":1,\"329\":1,\"332\":1,\"352\":2,\"353\":2,\"354\":2,\"360\":1,\"362\":1,\"368\":2,\"387\":1,\"393\":1,\"395\":3,\"412\":1,\"414\":2,\"415\":1,\"429\":5,\"430\":2}}],[\"try语句没有被执行到\",{\"1\":{\"438\":1}}],[\"try块用于包裹可能发生异常的代码片段\",{\"1\":{\"432\":1}}],[\"try块\",{\"1\":{\"432\":1}}],[\"tryterminate\",{\"1\":{\"319\":2}}],[\"trypresize\",{\"1\":{\"259\":1}}],[\"tryreadlock\",{\"1\":{\"221\":1}}],[\"tryreleaseshared源码如下\",{\"1\":{\"199\":1}}],[\"tryreleaseshared\",{\"1\":{\"197\":1,\"199\":2}}],[\"tryrelease的默认实现是抛出异常\",{\"1\":{\"174\":1}}],[\"tryrelease\",{\"1\":{\"174\":1,\"183\":1}}],[\"tryoptimisticread\",{\"1\":{\"221\":1}}],[\"trylock\",{\"1\":{\"179\":2,\"319\":2}}],[\"tryacquireshared函数的源码如下\",{\"1\":{\"198\":1}}],[\"tryacquireshared\",{\"1\":{\"197\":1,\"198\":3}}],[\"tryacquire\",{\"1\":{\"173\":2,\"184\":1,\"185\":2}}],[\"try\",{\"1\":{\"31\":6,\"139\":2,\"142\":2,\"143\":1,\"158\":1,\"159\":3,\"160\":5,\"170\":1,\"173\":4,\"175\":2,\"186\":2,\"187\":2,\"191\":4,\"198\":1,\"203\":3,\"213\":3,\"214\":1,\"219\":2,\"220\":2,\"221\":2,\"233\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"256\":1,\"259\":2,\"267\":2,\"271\":2,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"287\":1,\"311\":2,\"312\":2,\"313\":3,\"314\":1,\"315\":2,\"318\":2,\"319\":5,\"323\":3,\"329\":2,\"336\":1,\"339\":2,\"340\":2,\"341\":3,\"342\":4,\"364\":1,\"405\":1,\"414\":2,\"415\":3,\"432\":1,\"437\":1,\"438\":3}}],[\"treenode\",{\"1\":{\"374\":1,\"376\":1,\"377\":1,\"378\":1}}],[\"treenode<k\",{\"1\":{\"259\":10,\"261\":1,\"376\":1,\"377\":1,\"378\":1}}],[\"treenode和treebin四个子类\",{\"1\":{\"251\":1}}],[\"treeset\",{\"1\":{\"351\":1}}],[\"trees\",{\"1\":{\"256\":1}}],[\"treebin<k\",{\"1\":{\"259\":2,\"261\":2}}],[\"treebin\",{\"1\":{\"256\":1,\"259\":1,\"261\":1}}],[\"treeifybin函数源码如下\",{\"1\":{\"259\":1}}],[\"treeifybin\",{\"1\":{\"259\":3,\"376\":2}}],[\"treeify\",{\"1\":{\"256\":2,\"259\":2,\"376\":2}}],[\"treemap\",{\"1\":{\"224\":1,\"351\":1,\"354\":1}}],[\"tree\",{\"1\":{\"24\":1}}],[\"才会抛出内存溢出异常\",{\"1\":{\"286\":1}}],[\"才会继续执行\",{\"1\":{\"203\":1}}],[\"才会初始化内部类\",{\"1\":{\"20\":1}}],[\"才执行主线程的对账操作\",{\"1\":{\"191\":1}}],[\"才可以对该结点所封装的线程进行park操作\",{\"1\":{\"173\":1}}],[\"才能继续执行\",{\"1\":{\"190\":1}}],[\"才能将等待状态的线程转换为就绪状态\",{\"1\":{\"159\":1}}],[\"才能执行同步代码块内部的操作\",{\"1\":{\"146\":1}}],[\"才能够理解并诊断许多并发\",{\"1\":{\"122\":1}}],[\"才能够找到解决方案\",{\"1\":{\"122\":1}}],[\"才能进行适配工作\",{\"1\":{\"26\":1}}],[\"zero\",{\"1\":{\"197\":1,\"199\":1,\"432\":1}}],[\"zhihu\",{\"1\":{\"176\":1,\"396\":1}}],[\"zhuanlan\",{\"1\":{\"176\":1,\"396\":1}}],[\"z0\",{\"1\":{\"74\":1}}],[\"za\",{\"1\":{\"74\":2}}],[\"zxvf\",{\"1\":{\"67\":1,\"71\":1}}],[\"zkt5tvq5eu1zoxnktuzrt1q6zu17ddlhqkvfsennot4=\",{\"1\":{\"31\":1}}],[\"z\",{\"1\":{\"26\":2,\"74\":1,\"430\":2}}],[\"y和z\",{\"1\":{\"430\":1}}],[\"yuque\",{\"1\":{\"295\":2}}],[\"yunlzheng\",{\"1\":{\"111\":1}}],[\"yet\",{\"1\":{\"173\":1,\"317\":1,\"331\":1}}],[\"yield\",{\"1\":{\"131\":1,\"175\":1,\"259\":1,\"317\":1,\"331\":1}}],[\"yml去配置所有的告警规则文件\",{\"1\":{\"108\":1}}],[\"yml的文件\",{\"1\":{\"108\":1,\"116\":1}}],[\"yml中\",{\"1\":{\"69\":1}}],[\"yml\",{\"1\":{\"68\":3,\"106\":1,\"108\":1,\"116\":2}}],[\"y\",{\"1\":{\"26\":5,\"82\":1,\"140\":2,\"430\":3}}],[\"xor\",{\"1\":{\"393\":1}}],[\"xp\",{\"1\":{\"259\":5}}],[\"xpost\",{\"1\":{\"70\":1}}],[\"x\",{\"1\":{\"26\":5,\"140\":3,\"176\":1,\"259\":11,\"273\":2,\"275\":2,\"313\":9,\"350\":1,\"369\":8,\"370\":25,\"430\":4}}],[\"持有适配者的类keyboard\",{\"1\":{\"25\":1}}],[\"从父类继承过来的方法\",{\"1\":{\"424\":1}}],[\"从缓冲区重新读取数据\",{\"1\":{\"406\":1}}],[\"从缓冲区读取剩余数据\",{\"1\":{\"406\":1}}],[\"从缓冲区读取部分数据\",{\"1\":{\"406\":1}}],[\"从缓冲区读取数据\",{\"1\":{\"406\":2}}],[\"从文件中读取数据\",{\"1\":{\"405\":1}}],[\"从文件中读取数据到缓冲区\",{\"1\":{\"405\":1}}],[\"从文件中读写数据\",{\"1\":{\"403\":1}}],[\"从尾节点开始向前遍历\",{\"1\":{\"369\":2}}],[\"从尾结点开始从后往前开始遍历\",{\"1\":{\"173\":1}}],[\"从头节点开始向后遍历\",{\"1\":{\"369\":2}}],[\"从集合中删除元素\",{\"1\":{\"353\":1}}],[\"从get\",{\"1\":{\"328\":1}}],[\"从这个方法我们可以看出线程池是怎么让超过corepoolsize的那部分worker销毁的\",{\"1\":{\"314\":1}}],[\"从方法execute的实现可以看出\",{\"1\":{\"312\":1}}],[\"从woker类的构造方法实现可以发现\",{\"1\":{\"310\":1}}],[\"从类的属性中可以清楚的看到其底层的结构是object类型的数组\",{\"1\":{\"270\":1}}],[\"从类继承关系可知\",{\"1\":{\"166\":1}}],[\"从队列中取出数据\",{\"1\":{\"267\":1}}],[\"从aqs继承而来\",{\"1\":{\"199\":1}}],[\"从aqs继承的方法\",{\"1\":{\"198\":1}}],[\"从源码中可知\",{\"1\":{\"198\":1}}],[\"从源码可知\",{\"1\":{\"193\":1}}],[\"从lock方法的源码可知\",{\"1\":{\"184\":1}}],[\"从jdk6开始\",{\"1\":{\"149\":1}}],[\"从反编译的结果来看\",{\"1\":{\"147\":1}}],[\"从而触发异常处理机制\",{\"1\":{\"432\":1}}],[\"从而使得一个实现类有不同接口的多态性\",{\"1\":{\"419\":1}}],[\"从而降低了开销\",{\"1\":{\"291\":1}}],[\"从而在读多写少的场景下提供了较好的性能\",{\"1\":{\"223\":1}}],[\"从而提供了更好的并发性能\",{\"1\":{\"222\":1}}],[\"从而提高了系统的吞吐量和响应速度\",{\"1\":{\"403\":1}}],[\"从而提高并发性能\",{\"1\":{\"245\":1}}],[\"从而提高系统的效率\",{\"1\":{\"120\":1}}],[\"从而提高整个系统的性能\",{\"1\":{\"16\":1}}],[\"从而实现了读操作的线程安全性\",{\"1\":{\"223\":1}}],[\"从而实现了多个线程的同步\",{\"1\":{\"202\":1}}],[\"从而实现线程的调度和协作\",{\"1\":{\"163\":1}}],[\"从而执行之后的对账\",{\"1\":{\"191\":1}}],[\"从而减少锁竞争的次数\",{\"1\":{\"153\":1}}],[\"从而减少锁的竞争\",{\"1\":{\"153\":1}}],[\"从而减少了不必要的锁竞争\",{\"1\":{\"153\":1}}],[\"从而减少了不必要的上下文切换和线程阻塞时间\",{\"1\":{\"151\":1}}],[\"从而减少了不必要的开销\",{\"1\":{\"150\":1}}],[\"从而减少对内存的频繁访问\",{\"1\":{\"118\":1}}],[\"从而保证其他线程读取到最新的值\",{\"1\":{\"145\":1}}],[\"从而避免多线程并发访问时的线程安全问题\",{\"1\":{\"283\":1}}],[\"从而避免多个线程同时访问临界资源导致的数据竞争\",{\"1\":{\"145\":1}}],[\"从而避免了写操作对读操作的影响\",{\"1\":{\"223\":1,\"225\":1}}],[\"从而避免了死锁的发生\",{\"1\":{\"143\":1}}],[\"从而达到类似多继承的效果\",{\"1\":{\"420\":1}}],[\"从而达到交替打印奇偶输的目的\",{\"1\":{\"160\":1}}],[\"从而达到更高的性能\",{\"1\":{\"124\":1}}],[\"从而达到以下目的\",{\"1\":{\"65\":1}}],[\"从而充分利用系统资源并提高系统的整体吞吐量\",{\"1\":{\"120\":1}}],[\"从而导致程序的有序性问题\",{\"1\":{\"121\":1}}],[\"从而导致程序的输出不确定\",{\"1\":{\"119\":1}}],[\"从而导致一些系统问题\",{\"1\":{\"103\":1}}],[\"从而引发bug\",{\"1\":{\"119\":1}}],[\"从而平衡cpu与i\",{\"1\":{\"118\":1}}],[\"从而能够对问题进行快速的处理或者提前预防问题的发生\",{\"1\":{\"65\":1}}],[\"从2012年开始由前google工程师以开源软件的形式进行研发\",{\"1\":{\"61\":1}}],[\"从uml图上可以得出\",{\"1\":{\"49\":1}}],[\"从上面的图中可以看出java\",{\"1\":{\"401\":1}}],[\"从上面的\",{\"1\":{\"53\":1}}],[\"从上面的分析原因我们可以得出\",{\"1\":{\"37\":1}}],[\"从上面的使用场景\",{\"1\":{\"37\":1}}],[\"从该uml中中\",{\"1\":{\"35\":1}}],[\"从\",{\"1\":{\"25\":1}}],[\"给键盘使用\",{\"1\":{\"25\":1}}],[\"给用于定义语言的语法规则表示\",{\"1\":{\"12\":1}}],[\"jdb\",{\"1\":{\"433\":1}}],[\"jdk包含jre\",{\"1\":{\"433\":1}}],[\"jdk还提供了各种开发文档和示例代码\",{\"1\":{\"433\":1}}],[\"jdk1\",{\"1\":{\"254\":1,\"436\":1}}],[\"jdk中的方法体\",{\"1\":{\"175\":1}}],[\"jdk中对synchronized做的种种优化\",{\"1\":{\"148\":1}}],[\"jdk\",{\"0\":{\"433\":1},\"1\":{\"153\":4,\"374\":1,\"403\":1,\"433\":1}}],[\"jdk动态代理\",{\"1\":{\"56\":1}}],[\"jre包含jvm\",{\"1\":{\"433\":1}}],[\"jre只提供了java应用程序的运行环境\",{\"1\":{\"433\":1}}],[\"jre\",{\"0\":{\"433\":1},\"1\":{\"433\":1}}],[\"jar\",{\"1\":{\"433\":1}}],[\"james\",{\"1\":{\"376\":2}}],[\"java会将这个变量复制一份作为成员变量内置于内部类中\",{\"1\":{\"436\":1}}],[\"java会自动调用相应的包装类方法\",{\"1\":{\"423\":1}}],[\"javac\",{\"1\":{\"433\":1}}],[\"java语言中提供了一些列的异常处理关键字和处理模板\",{\"1\":{\"432\":1}}],[\"java允许开发者自定义异常类\",{\"1\":{\"432\":1}}],[\"java不允许在方法中使用同名的不同类型的参数\",{\"1\":{\"423\":1}}],[\"java不支持多继承是为了避免多继承带来的上述问题\",{\"1\":{\"420\":1}}],[\"java是一种面向对象的语言\",{\"1\":{\"423\":1}}],[\"java基础高频面试题2\",{\"0\":{\"427\":1}}],[\"java基础高频面试题1\",{\"0\":{\"417\":1}}],[\"java基本类型\",{\"1\":{\"423\":1}}],[\"java基本类型为什么需要包装类\",{\"0\":{\"423\":1}}],[\"java的异常处理机制是java程序设计中非常重要的一个方面\",{\"1\":{\"432\":1}}],[\"java的泛型不支持基本类型\",{\"1\":{\"423\":1}}],[\"java的设计理念是\",{\"1\":{\"420\":1}}],[\"java的线程状态总共有六种\",{\"1\":{\"155\":1}}],[\"java选择了单继承并使用了接口\",{\"1\":{\"420\":1}}],[\"java支持多实现\",{\"1\":{\"419\":1}}],[\"java只支持单继承\",{\"1\":{\"419\":1}}],[\"javabasiclab\",{\"1\":{\"414\":1,\"415\":1,\"438\":1}}],[\"javaio的类图结构如下\",{\"1\":{\"400\":1}}],[\"javainterview\",{\"1\":{\"262\":1}}],[\"java流类图结构\",{\"0\":{\"400\":1}}],[\"java提供了对应的包装类来对基本类型进行包装\",{\"1\":{\"423\":1}}],[\"java提供了bitset来实现位图\",{\"1\":{\"391\":1}}],[\"java提供了java\",{\"1\":{\"56\":1}}],[\"java8引入的\",{\"1\":{\"336\":1}}],[\"java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况\",{\"1\":{\"432\":1}}],[\"java中的异常处理机制\",{\"0\":{\"432\":1}}],[\"java中的引用\",{\"0\":{\"286\":1}}],[\"java中通常会存在以下类型的引用\",{\"1\":{\"286\":1}}],[\"java中提供了一些其他的同步机制\",{\"1\":{\"152\":1}}],[\"java7\",{\"0\":{\"245\":1}}],[\"java并发包中的线程池\",{\"1\":{\"292\":1}}],[\"java并发包中的queue是一类相对复杂的并发容器\",{\"1\":{\"226\":1}}],[\"java并发包的线程池\",{\"0\":{\"290\":1}}],[\"java并发包里有很多内容都是并发容器的内容\",{\"1\":{\"222\":1}}],[\"java并发技术aqs详解\",{\"0\":{\"161\":1}}],[\"java死锁示例\",{\"0\":{\"139\":1}}],[\"java死锁详解\",{\"0\":{\"138\":1}}],[\"java内存模型\",{\"0\":{\"124\":1}}],[\"java内存模式以及volatile详解\",{\"0\":{\"123\":1}}],[\"java就在多线程方面处于领先地位\",{\"1\":{\"123\":1}}],[\"javax\",{\"1\":{\"98\":2}}],[\"java动态代理不需要任何依赖\",{\"1\":{\"56\":1}}],[\"java动态代理是基于反射生产的一个代理类\",{\"1\":{\"56\":1}}],[\"java\",{\"0\":{\"56\":1,\"144\":1,\"246\":1,\"351\":1,\"397\":1,\"401\":1,\"402\":1,\"409\":1},\"1\":{\"24\":3,\"36\":2,\"50\":7,\"55\":1,\"56\":3,\"128\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"142\":2,\"145\":1,\"146\":1,\"147\":2,\"166\":2,\"170\":1,\"175\":3,\"176\":2,\"179\":1,\"180\":1,\"183\":2,\"187\":3,\"188\":1,\"190\":1,\"191\":4,\"202\":1,\"203\":1,\"218\":1,\"219\":3,\"221\":3,\"228\":1,\"230\":1,\"232\":1,\"233\":1,\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"264\":1,\"267\":1,\"269\":1,\"270\":1,\"281\":1,\"322\":2,\"323\":8,\"334\":1,\"336\":1,\"337\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"345\":2,\"346\":1,\"349\":2,\"350\":2,\"351\":4,\"352\":3,\"353\":2,\"354\":2,\"357\":1,\"358\":1,\"373\":1,\"379\":1,\"381\":1,\"393\":1,\"395\":2,\"398\":3,\"399\":1,\"401\":3,\"403\":13,\"404\":2,\"405\":3,\"406\":3,\"410\":1,\"411\":1,\"412\":1,\"414\":11,\"415\":7,\"419\":4,\"424\":3,\"428\":1,\"433\":4}}],[\"juc\",{\"1\":{\"350\":1}}],[\"juejin\",{\"1\":{\"289\":1,\"320\":1}}],[\"just\",{\"1\":{\"173\":1,\"259\":1}}],[\"j++\",{\"1\":{\"132\":1}}],[\"j\",{\"1\":{\"132\":2,\"377\":7,\"395\":9,\"423\":1}}],[\"j=i\",{\"1\":{\"127\":1}}],[\"jmm内存模型\",{\"1\":{\"124\":1}}],[\"join的运行流程大致如下所示\",{\"1\":{\"345\":1}}],[\"join使用详解\",{\"0\":{\"344\":1}}],[\"joindemo\",{\"1\":{\"191\":1}}],[\"join\",{\"1\":{\"119\":2,\"139\":2,\"142\":2,\"143\":2,\"159\":2,\"160\":2,\"191\":6,\"345\":1,\"346\":4,\"347\":1,\"348\":1,\"349\":3}}],[\"job=\",{\"1\":{\"77\":1,\"90\":1,\"93\":1,\"94\":10,\"115\":9}}],[\"job\",{\"1\":{\"68\":1,\"69\":2,\"90\":2,\"99\":1,\"113\":2,\"115\":2}}],[\"jieshao\",{\"1\":{\"416\":1}}],[\"ji\",{\"1\":{\"111\":1}}],[\"jianshu\",{\"1\":{\"111\":1}}],[\"jvm解析java字节码\",{\"1\":{\"433\":1}}],[\"jvm的区别和联系\",{\"0\":{\"433\":1}}],[\"jvm规范没有明确规定其所占的空间大小\",{\"1\":{\"429\":1}}],[\"jvm避免了每次加锁和解锁时都需要竞争的情况\",{\"1\":{\"150\":1}}],[\"jvm会将这个锁标记为偏向锁\",{\"1\":{\"150\":1}}],[\"jvm\",{\"1\":{\"149\":1,\"153\":2,\"432\":1,\"433\":1}}],[\"jvm就是根据该标示符来实现方法的同步的\",{\"1\":{\"147\":1}}],[\"jvm是用于暴露jvm相关的指标\",{\"1\":{\"98\":1}}],[\"jvm<\",{\"1\":{\"98\":1}}],[\"jvm在执行类的初始化的时候\",{\"1\":{\"20\":1}}],[\"given\",{\"1\":{\"311\":1}}],[\"gitbook\",{\"1\":{\"111\":1}}],[\"github\",{\"1\":{\"24\":2,\"36\":2,\"50\":5,\"69\":1,\"98\":1,\"119\":1,\"139\":1,\"142\":1,\"147\":1,\"159\":1,\"160\":1,\"175\":1,\"187\":1,\"191\":2,\"203\":1,\"219\":1,\"221\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1,\"414\":1,\"415\":1,\"438\":1}}],[\"guava包\",{\"1\":{\"306\":1}}],[\"guarding\",{\"1\":{\"208\":1}}],[\"g\",{\"1\":{\"110\":1,\"213\":6,\"288\":1}}],[\"gloabl配置\",{\"1\":{\"107\":1}}],[\"global\",{\"1\":{\"68\":4,\"106\":2,\"107\":1,\"113\":1}}],[\"gauge类型的指标主要反映的是当前的状态\",{\"1\":{\"77\":1}}],[\"gauge仪表盘\",{\"0\":{\"77\":1}}],[\"gauge\",{\"1\":{\"68\":4,\"75\":1,\"97\":1}}],[\"garbage\",{\"1\":{\"68\":1,\"79\":1}}],[\"gateway是用来短暂存储push类型指标的\",{\"1\":{\"63\":1}}],[\"gateway\",{\"1\":{\"62\":1}}],[\"gc\",{\"1\":{\"68\":9,\"79\":10,\"149\":1,\"173\":2,\"198\":1,\"333\":1}}],[\"google\",{\"1\":{\"263\":1,\"306\":1}}],[\"go1\",{\"1\":{\"68\":1}}],[\"goroutines\",{\"1\":{\"68\":4}}],[\"go\",{\"1\":{\"68\":25,\"79\":9}}],[\"gz\",{\"1\":{\"67\":1,\"71\":2}}],[\"greeting\",{\"1\":{\"418\":4}}],[\"greater\",{\"1\":{\"86\":2}}],[\"growth\",{\"1\":{\"361\":2}}],[\"grow\",{\"1\":{\"360\":1,\"361\":3}}],[\"group执行的时间间隔\",{\"1\":{\"113\":1}}],[\"group的名称\",{\"1\":{\"113\":1}}],[\"group可以配置两个参数\",{\"1\":{\"113\":1}}],[\"grouplabels\",{\"1\":{\"110\":2}}],[\"groupkey\",{\"1\":{\"110\":2}}],[\"groups\",{\"1\":{\"108\":1,\"113\":2,\"116\":1}}],[\"grouped\",{\"1\":{\"107\":1}}],[\"group\",{\"0\":{\"89\":1},\"1\":{\"89\":3,\"90\":1,\"106\":3,\"107\":9,\"110\":1}}],[\"groupid>\",{\"1\":{\"57\":1,\"97\":3,\"98\":3}}],[\"grass\",{\"1\":{\"418\":2}}],[\"grapes\",{\"1\":{\"352\":3}}],[\"graph\",{\"1\":{\"69\":1}}],[\"gracefully\",{\"1\":{\"306\":1}}],[\"grant\",{\"1\":{\"185\":1}}],[\"grafna的安装\",{\"1\":{\"66\":1}}],[\"grafana作为数据展示前端\",{\"1\":{\"72\":1}}],[\"grafana的默认登陆用户名admin\",{\"1\":{\"71\":1}}],[\"grafana有很多配置项在conf目录下default\",{\"1\":{\"71\":1}}],[\"grafana可以完美的和prometheus结合\",{\"1\":{\"71\":1}}],[\"grafana是一个开源的\",{\"1\":{\"71\":1}}],[\"grafana安装\",{\"0\":{\"71\":1}}],[\"grafana\",{\"1\":{\"59\":1,\"71\":6}}],[\"general\",{\"1\":{\"183\":1}}],[\"generatorurl\",{\"1\":{\"110\":2}}],[\"generation类有一个属性broken\",{\"1\":{\"207\":1}}],[\"generation\",{\"1\":{\"57\":1,\"207\":1,\"208\":4,\"213\":4,\"214\":4,\"215\":1}}],[\"getvalue\",{\"1\":{\"354\":2}}],[\"getkey\",{\"1\":{\"354\":2}}],[\"getmessage\",{\"1\":{\"323\":3,\"336\":1,\"339\":1,\"340\":2,\"432\":1}}],[\"getmap\",{\"1\":{\"282\":3}}],[\"get方法\",{\"0\":{\"330\":1},\"1\":{\"317\":1}}],[\"get方法会导致主线程阻塞\",{\"1\":{\"315\":1}}],[\"gettreenode\",{\"1\":{\"378\":2}}],[\"getthreadfactory\",{\"1\":{\"313\":2}}],[\"gettask方法\",{\"0\":{\"314\":1}}],[\"gettask方法会被阻塞并挂起\",{\"1\":{\"310\":1,\"313\":1}}],[\"gettask\",{\"1\":{\"310\":1,\"313\":2,\"314\":1}}],[\"get函数根据key的hash值来计算在哪个桶中\",{\"1\":{\"260\":1}}],[\"get函数\",{\"0\":{\"260\":1}}],[\"getprobe\",{\"1\":{\"259\":1}}],[\"getproxyinstance\",{\"1\":{\"57\":2}}],[\"getobjectvolatile的第二项参数为下标为i的偏移地址\",{\"1\":{\"259\":1}}],[\"getobjectvolatile\",{\"1\":{\"259\":1}}],[\"getowner\",{\"1\":{\"183\":1}}],[\"getruntime\",{\"1\":{\"256\":1,\"295\":1}}],[\"getrequesturi\",{\"1\":{\"98\":1}}],[\"getage\",{\"1\":{\"435\":1}}],[\"getarea\",{\"1\":{\"419\":4}}],[\"getarray\",{\"1\":{\"234\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1}}],[\"getattribute\",{\"1\":{\"98\":1}}],[\"getchannel\",{\"1\":{\"405\":2}}],[\"getcontext\",{\"1\":{\"294\":1}}],[\"getcomponenttype\",{\"1\":{\"237\":1}}],[\"getcount\",{\"1\":{\"197\":1}}],[\"getclassloader\",{\"1\":{\"56\":1}}],[\"getclass\",{\"1\":{\"56\":2,\"57\":1,\"234\":2,\"359\":1}}],[\"getholdcount\",{\"1\":{\"183\":1,\"273\":1,\"275\":1}}],[\"getlocalholder\",{\"1\":{\"175\":1}}],[\"getdeclaredfield\",{\"1\":{\"170\":5,\"175\":2,\"233\":1,\"256\":5}}],[\"getdecoder\",{\"1\":{\"31\":2}}],[\"getunsafe\",{\"1\":{\"170\":1,\"233\":1,\"256\":1}}],[\"getentry\",{\"1\":{\"282\":1}}],[\"getencoder\",{\"1\":{\"31\":2}}],[\"getexclusiveownerthread\",{\"1\":{\"166\":1,\"183\":4,\"185\":1}}],[\"getsecuritymanager\",{\"1\":{\"294\":1}}],[\"getstate\",{\"1\":{\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"163\":1,\"175\":3,\"183\":5,\"185\":1,\"197\":3,\"198\":1,\"199\":1}}],[\"getsingleton\",{\"1\":{\"20\":1}}],[\"getinterfaces\",{\"1\":{\"56\":1}}],[\"getinstance\",{\"1\":{\"18\":1,\"19\":1,\"22\":1,\"23\":1,\"121\":1}}],[\"get\",{\"0\":{\"369\":1},\"1\":{\"50\":1,\"89\":6,\"97\":3,\"115\":1,\"173\":1,\"175\":1,\"186\":1,\"219\":2,\"220\":2,\"221\":3,\"240\":1,\"241\":1,\"247\":2,\"260\":1,\"281\":3,\"282\":1,\"288\":2,\"311\":4,\"312\":3,\"313\":2,\"314\":1,\"315\":1,\"317\":1,\"322\":3,\"323\":6,\"326\":4,\"330\":3,\"336\":2,\"337\":1,\"339\":2,\"340\":2,\"341\":1,\"342\":3,\"343\":1,\"352\":2,\"354\":2,\"363\":2,\"366\":2,\"369\":4,\"378\":3,\"393\":4,\"395\":4,\"405\":1,\"406\":8,\"414\":1,\"415\":1}}],[\"getnode\",{\"1\":{\"378\":4}}],[\"getname\",{\"1\":{\"41\":4,\"47\":3,\"56\":2,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"281\":1,\"306\":1,\"435\":1}}],[\"getnextapproval\",{\"1\":{\"36\":3}}],[\"getbytes\",{\"1\":{\"31\":2,\"405\":1,\"410\":1,\"411\":1,\"414\":2,\"415\":1}}],[\"get­instance\",{\"1\":{\"17\":1}}],[\"懒汉模式\",{\"0\":{\"22\":1,\"23\":1}}],[\"会通过位置来确定当前要操作的数据元素\",{\"1\":{\"406\":1}}],[\"会通过一个示例给出详细的分析\",{\"1\":{\"198\":1,\"199\":1}}],[\"会从头开始写\",{\"1\":{\"401\":1}}],[\"会从等待队列中选取一个线程唤醒\",{\"1\":{\"163\":1}}],[\"会自动创建\",{\"1\":{\"401\":1}}],[\"会增加一个行号\",{\"1\":{\"401\":1}}],[\"会得到相应的行号\",{\"1\":{\"401\":1}}],[\"会去除掉重复的值\",{\"1\":{\"385\":1}}],[\"会判断是否需要缩小数组容量\",{\"1\":{\"358\":1}}],[\"会将新的\",{\"1\":{\"377\":1}}],[\"会将collection的元素copy到elementdata成员变量中\",{\"1\":{\"359\":1}}],[\"会将删除位置后面的元素向前移动一个位置\",{\"1\":{\"358\":1}}],[\"会将计算结果输出到新的向量上\",{\"1\":{\"85\":1}}],[\"会检查当前数组容量是否足够\",{\"1\":{\"358\":1}}],[\"会根据异常类型在catch块中进行匹配\",{\"1\":{\"438\":2}}],[\"会根据当前的\",{\"1\":{\"377\":1}}],[\"会根据需要自动进行扩容\",{\"1\":{\"358\":1}}],[\"会根据sizectl的大小设置table大小\",{\"1\":{\"259\":1}}],[\"会根据sizectl的值进行设置\",{\"1\":{\"259\":1}}],[\"会初始化一个初始容量的数组\",{\"1\":{\"358\":1}}],[\"会尝试窃取一个任务\",{\"1\":{\"347\":1}}],[\"会\",{\"1\":{\"330\":1}}],[\"会先进行加锁\",{\"1\":{\"319\":1}}],[\"会把主线程封装成waitnode节点并保存在waiters链表中\",{\"1\":{\"315\":1}}],[\"会使用\",{\"1\":{\"301\":1}}],[\"会使得cpu切换更加频繁\",{\"1\":{\"300\":1}}],[\"会在短时间内提升cpu使用率\",{\"1\":{\"300\":1}}],[\"会在程序的类的加载过程中\",{\"1\":{\"18\":1}}],[\"会造成频繁的gc\",{\"1\":{\"291\":1}}],[\"会间接的调用到offer函数\",{\"1\":{\"274\":1}}],[\"会阻塞一直等待\",{\"1\":{\"273\":1,\"275\":1}}],[\"会抛出异常\",{\"1\":{\"271\":1}}],[\"会创建一个threadlocalmap并赋值给thread\",{\"1\":{\"282\":1}}],[\"会创建一个底层数组的副本\",{\"1\":{\"242\":1}}],[\"会创建一个新的数组来完成写操作\",{\"1\":{\"225\":1}}],[\"会创建一个新的数组\",{\"1\":{\"223\":1,\"229\":1}}],[\"会创建新的底层数组\",{\"1\":{\"230\":2}}],[\"会唤醒所有在屏障中的线程\",{\"1\":{\"215\":1}}],[\"会调用的拒绝策略\",{\"1\":{\"294\":1}}],[\"会调用enqueue函数\",{\"1\":{\"274\":1}}],[\"会调用到transferforsignal函数\",{\"1\":{\"214\":1}}],[\"会调用\",{\"1\":{\"186\":1,\"362\":1,\"377\":1}}],[\"会进行一次扩容操作\",{\"1\":{\"259\":1}}],[\"会进行锁消除的优化\",{\"1\":{\"153\":1}}],[\"会进行加锁初始化\",{\"1\":{\"20\":1}}],[\"会带来额外的锁撤销的消耗\",{\"1\":{\"152\":1}}],[\"会带来一定的性能开销\",{\"1\":{\"56\":1}}],[\"会重新读取最新的主存的数据\",{\"1\":{\"127\":1}}],[\"会重新从主内存中读取\",{\"1\":{\"124\":1}}],[\"会发出信号通知其他处理器将高速缓存中的该数据设置为无效状态\",{\"1\":{\"124\":1}}],[\"会采取一些优化策略\",{\"1\":{\"118\":1}}],[\"会屏蔽掉severity=warning的告警\",{\"1\":{\"107\":1}}],[\"会统计当前指标的记录总数\",{\"1\":{\"78\":1}}],[\"会周期性的去采集指标\",{\"1\":{\"64\":1}}],[\"会导致一些并发问题\",{\"1\":{\"379\":1}}],[\"会导致一定的资源开销和性能下降\",{\"1\":{\"23\":1}}],[\"会导致类的数量增加\",{\"1\":{\"44\":1}}],[\"有animal的父类\",{\"1\":{\"418\":1}}],[\"有无限个\",{\"1\":{\"395\":1}}],[\"有8\",{\"1\":{\"392\":1}}],[\"有一点需要注意的是\",{\"1\":{\"328\":1}}],[\"有一段初始化设置\",{\"1\":{\"288\":1}}],[\"有一个eat的方法\",{\"1\":{\"418\":1}}],[\"有一个对象数组\",{\"1\":{\"358\":1}}],[\"有一个可重入锁reentrantlock\",{\"1\":{\"270\":1}}],[\"有一个为condition对象\",{\"1\":{\"208\":1}}],[\"有一个核心的抽象处理方法handle\",{\"1\":{\"36\":1}}],[\"有界队列在与有限的maximumpoolsizes一起使用时有助于防止资源耗尽\",{\"1\":{\"300\":1}}],[\"有界队列\",{\"1\":{\"266\":1,\"297\":1}}],[\"有参构造函数\",{\"1\":{\"181\":1}}],[\"有较低的开销\",{\"1\":{\"153\":1}}],[\"有可能造成系统创建大量同类线程而导致消耗内存或者\",{\"1\":{\"291\":1}}],[\"有可能\",{\"1\":{\"131\":1}}],[\"有可能发生线程切换\",{\"1\":{\"120\":1}}],[\"有两种构造函数\",{\"1\":{\"375\":1}}],[\"有两种解决方案\",{\"1\":{\"124\":1}}],[\"有两个greeting方法\",{\"1\":{\"418\":1}}],[\"有两个标签分别是instance和path\",{\"1\":{\"115\":1}}],[\"有两个目标\",{\"1\":{\"8\":1}}],[\"有时会重新排列代码中语句的执行顺序\",{\"1\":{\"121\":1}}],[\"有序性指的是程序按照代码的先后顺序执行\",{\"1\":{\"121\":1}}],[\"有序性的问题\",{\"0\":{\"118\":1}}],[\"有序性\",{\"0\":{\"117\":1,\"128\":1},\"1\":{\"125\":1,\"352\":1}}],[\"有1828个请求\",{\"1\":{\"78\":1}}],[\"有1827个请求\",{\"1\":{\"78\":1}}],[\"有相同指标名和标签构成的\",{\"1\":{\"74\":1}}],[\"有着非常大的创新\",{\"1\":{\"62\":1}}],[\"有以下的角色\",{\"1\":{\"49\":1}}],[\"有以下的优点在\",{\"1\":{\"20\":1}}],[\"有很多同类型的产品生产\",{\"1\":{\"45\":1}}],[\"当发生异常时\",{\"1\":{\"438\":2}}],[\"当发布者发布消息\",{\"1\":{\"49\":1}}],[\"当没有发生异常时\",{\"1\":{\"438\":1}}],[\"当变量被声明为final时\",{\"1\":{\"435\":1,\"437\":1}}],[\"当方法被声明为final时\",{\"1\":{\"435\":1,\"437\":1}}],[\"当方法调用时\",{\"1\":{\"147\":1}}],[\"当类被声明为final时\",{\"1\":{\"435\":1,\"437\":1}}],[\"当用户在目标机器上运行java应用程序时\",{\"1\":{\"433\":1}}],[\"当我们在重写equals\",{\"1\":{\"431\":1}}],[\"当我们在多线程环境下对共享变量a进行a+=1操作时\",{\"1\":{\"120\":1}}],[\"当我们重写equals\",{\"1\":{\"430\":1,\"431\":1}}],[\"当字符串不需要修改时\",{\"1\":{\"421\":1}}],[\"当字节和字符之间有转换动作时\",{\"1\":{\"401\":1}}],[\"当需要对字符串进行频繁的修改时\",{\"1\":{\"421\":1}}],[\"当需要频繁修改字符串时会产生大量的垃圾对象\",{\"1\":{\"421\":1}}],[\"当需要扩展新的功能\",{\"1\":{\"37\":1}}],[\"当返回值不为\",{\"1\":{\"386\":1}}],[\"当调用一个对象的方法时\",{\"1\":{\"424\":1}}],[\"当调用\",{\"1\":{\"386\":1,\"388\":1,\"416\":1,\"424\":1}}],[\"当调用get\",{\"1\":{\"331\":1}}],[\"当添加元素时\",{\"1\":{\"358\":1}}],[\"当创建\",{\"1\":{\"358\":1}}],[\"当多线程修改互相独立的变量时\",{\"1\":{\"347\":1}}],[\"当多个线程访问不同的段时\",{\"1\":{\"245\":1}}],[\"当多个线程竞争同一个锁对象时\",{\"1\":{\"152\":1}}],[\"当多个线程同时进行这样的操作时\",{\"1\":{\"124\":1}}],[\"当系统变量中有系统安全管理相关属性时\",{\"1\":{\"347\":1}}],[\"当系统出现或者即将出现故障时\",{\"1\":{\"65\":1}}],[\"当你想要在所有的\",{\"1\":{\"342\":1}}],[\"当你想要在任意一个\",{\"1\":{\"341\":1}}],[\"当一个类从多个父类继承相同名称的属性或方法时\",{\"1\":{\"420\":1}}],[\"当一个worker刚创建的时候\",{\"1\":{\"313\":1}}],[\"当一个线程创建子线程时\",{\"1\":{\"288\":1}}],[\"当一个线程创建了一个子线程时\",{\"1\":{\"288\":1}}],[\"当一个线程结束时\",{\"1\":{\"280\":1}}],[\"当一个线程获取写锁时\",{\"1\":{\"220\":1}}],[\"当一个线程调用\",{\"1\":{\"190\":1}}],[\"当一个线程调用acquire时\",{\"1\":{\"173\":1}}],[\"当一个线程释放同步器时\",{\"1\":{\"163\":1}}],[\"当一个线程尝试获取锁时\",{\"1\":{\"153\":1}}],[\"当一个线程请求锁时\",{\"1\":{\"151\":1,\"152\":1}}],[\"当一个线程进入\",{\"1\":{\"145\":1}}],[\"当执行start方法启动线程thread时\",{\"1\":{\"310\":1}}],[\"当执行完未对账订单\",{\"1\":{\"191\":1}}],[\"当有新连接到来时\",{\"1\":{\"414\":1}}],[\"当有通道有感兴趣的事件发生时\",{\"1\":{\"407\":1}}],[\"当有任务需要执行时\",{\"1\":{\"303\":1}}],[\"当有写操作发生时\",{\"1\":{\"242\":1}}],[\"当有写操作\",{\"1\":{\"223\":1,\"229\":1}}],[\"当所有corepoolsize线程都在处理任务时\",{\"1\":{\"299\":1}}],[\"当所有线程都到达屏障点后\",{\"1\":{\"202\":1}}],[\"当任务提交的平均到达速度快于线程处理速度时\",{\"1\":{\"298\":1}}],[\"当任务队列中有任务时\",{\"1\":{\"293\":1}}],[\"当不再需要线程池时\",{\"1\":{\"293\":1}}],[\"当parent的inheritablethreadlocals不为null时\",{\"1\":{\"288\":1}}],[\"当其存放的threadlocal被回收\",{\"1\":{\"287\":1}}],[\"当其他线程调用某个线程的join\",{\"1\":{\"157\":1}}],[\"当其他线程请求被当前线程持有的资源时\",{\"1\":{\"141\":1}}],[\"当try块中的代码发生异常时\",{\"1\":{\"432\":1}}],[\"当thread执行完会被销毁\",{\"1\":{\"287\":1}}],[\"当table的长度未达到阈值时\",{\"1\":{\"259\":1}}],[\"当元素个数为0是\",{\"1\":{\"276\":1}}],[\"当底层object数组已满时\",{\"1\":{\"274\":1}}],[\"当初始化容量小于传入集合的大小时\",{\"1\":{\"271\":1}}],[\"当队列中有任务加入时\",{\"1\":{\"314\":1}}],[\"当队列满了并且worker的数量达到maxsize的时候\",{\"1\":{\"308\":1}}],[\"当队列为空时\",{\"1\":{\"267\":1}}],[\"当队列为空时进行出队操作也会被阻塞\",{\"1\":{\"266\":1}}],[\"当队列已空时\",{\"1\":{\"226\":2}}],[\"当队列已满时进行入队操作将会阻塞\",{\"1\":{\"266\":1}}],[\"当队列已满时\",{\"1\":{\"226\":2,\"267\":1}}],[\"当容器数据量达到一定规模和读写量达到一定规模的时候\",{\"1\":{\"222\":1}}],[\"当两个任务提交完成后\",{\"1\":{\"203\":1}}],[\"当\",{\"1\":{\"186\":3,\"191\":1,\"416\":1}}],[\"当资源空闲时\",{\"1\":{\"185\":1}}],[\"当前主线程是阻塞状态\",{\"1\":{\"336\":1}}],[\"当前提交的任务firsttask作为参数传入worker的构造方法\",{\"1\":{\"313\":1}}],[\"当前运行的worker数量以及线程池状态的\",{\"1\":{\"308\":1}}],[\"当前结点的下一个结点为空\",{\"1\":{\"259\":1}}],[\"当前数组的元素与快照的元素不相等并且e与当前元素相等\",{\"1\":{\"239\":1}}],[\"当前代\",{\"1\":{\"208\":1}}],[\"当前锁空闲后\",{\"1\":{\"175\":1}}],[\"当前线程将中断\",{\"1\":{\"313\":1}}],[\"当前线程不为独占线程\",{\"1\":{\"183\":1}}],[\"当前线程拥有该锁\",{\"1\":{\"183\":1}}],[\"当前线程\",{\"1\":{\"175\":2,\"183\":1}}],[\"当前线程是否已被中断\",{\"1\":{\"173\":1}}],[\"当前线程在接到信号\",{\"1\":{\"169\":3}}],[\"当前线程在接到信号之前一直处于等待状态\",{\"1\":{\"169\":1}}],[\"当前线程在接到信号或被中断之前一直处于等待状态\",{\"1\":{\"169\":1}}],[\"当前线程会被挂起等待\",{\"1\":{\"314\":1}}],[\"当前线程会尝试通过自旋来获取锁\",{\"1\":{\"151\":1}}],[\"当前线程会将锁的对象头记录下来\",{\"1\":{\"151\":1}}],[\"当获取不成功\",{\"1\":{\"185\":1}}],[\"当获取\",{\"1\":{\"173\":1}}],[\"当某个线程无法获取到同步器时\",{\"1\":{\"163\":1}}],[\"当某个处理器写入变量数据时\",{\"1\":{\"124\":1}}],[\"当阻塞式io操作的结果返回时\",{\"1\":{\"157\":1}}],[\"当竞争不激烈时\",{\"1\":{\"151\":1}}],[\"当该线程再次请求这个锁时\",{\"1\":{\"150\":1}}],[\"当monitor被占用时就会处于锁定状态\",{\"1\":{\"147\":1}}],[\"当使用父类引用指向子类对象时\",{\"1\":{\"424\":1}}],[\"当使用futuretask结合thread时\",{\"1\":{\"323\":1}}],[\"当使用\",{\"1\":{\"146\":1,\"323\":1}}],[\"当以上四个条件同时满足时\",{\"1\":{\"140\":1}}],[\"当然输出部分也没有必要需要它了\",{\"1\":{\"401\":1}}],[\"当然\",{\"1\":{\"233\":1}}],[\"当然不是\",{\"1\":{\"126\":1}}],[\"当然actuator有很多内置的指标\",{\"1\":{\"97\":1}}],[\"当线程池无法接受新的任务时\",{\"1\":{\"302\":4}}],[\"当线程池中的线程数量达到核心线程数\",{\"1\":{\"297\":1}}],[\"当线程池中的线程数量超过\",{\"1\":{\"296\":1}}],[\"当线程池中的线程数量超过核心线程数时\",{\"1\":{\"296\":1}}],[\"当线程池中线程数大于corepoolsize\",{\"1\":{\"294\":1}}],[\"当线程池所处理的任务数超过其可以处理的容量时\",{\"1\":{\"294\":1}}],[\"当线程要获取锁时\",{\"1\":{\"164\":1}}],[\"当线程拥有对象的锁时\",{\"1\":{\"157\":1}}],[\"当线程调用sleep\",{\"1\":{\"157\":1}}],[\"当线程调用start\",{\"1\":{\"157\":1}}],[\"当线程访问同步块时首先需要获得锁并把相关信息存储在对象头中\",{\"1\":{\"149\":1}}],[\"当线程不能获取锁的时候\",{\"1\":{\"148\":1}}],[\"当线程想要进入临界区时\",{\"1\":{\"147\":1}}],[\"当线程1读取了inc的值\",{\"1\":{\"132\":1}}],[\"当线程1在执行上面伪代码时\",{\"1\":{\"19\":1,\"121\":1}}],[\"当线程对共享数据进行修改时\",{\"1\":{\"124\":1}}],[\"当对指标用作除法\",{\"1\":{\"115\":1}}],[\"当对counter类型使用rate或者是irate操作\",{\"1\":{\"115\":1}}],[\"当对象发生改变时\",{\"1\":{\"48\":1}}],[\"当存在与另一组匹配器匹配的警报\",{\"1\":{\"107\":1}}],[\"当启动告警恢复逻辑时\",{\"1\":{\"107\":1}}],[\"当告警消息没有endts这个时间戳参数时\",{\"1\":{\"107\":1}}],[\"当集群不可用访问出发了告警\",{\"1\":{\"104\":1}}],[\"当中\",{\"1\":{\"92\":1}}],[\"当比较运算符左右与两个瞬时向量之间\",{\"1\":{\"86\":1,\"87\":1}}],[\"当问题发生后\",{\"1\":{\"65\":1}}],[\"当借款金额大于10000元\",{\"1\":{\"36\":1}}],[\"当借款金额大于1000元小于5000元\",{\"1\":{\"36\":1}}],[\"当借款金额大于5000元小于10000元\",{\"1\":{\"36\":1}}],[\"当借款金额小于1000元\",{\"1\":{\"36\":1}}],[\"当声明对象的引用为volatile后\",{\"1\":{\"19\":1,\"121\":1}}],[\"线程被唤醒\",{\"1\":{\"314\":1}}],[\"线程被中断\",{\"1\":{\"213\":1}}],[\"线程即使空闲也不会被销毁\",{\"1\":{\"314\":1}}],[\"线程存在无限增长的可能性\",{\"1\":{\"298\":1}}],[\"线程工厂在创建线程thread时\",{\"1\":{\"310\":1}}],[\"线程工厂\",{\"1\":{\"294\":1}}],[\"线程池重入锁\",{\"1\":{\"312\":1}}],[\"线程池创建新线程执行任务时\",{\"1\":{\"312\":1}}],[\"线程池处于running状态\",{\"1\":{\"311\":2}}],[\"线程池不允许使用executors去创建\",{\"1\":{\"304\":1}}],[\"线程池就会创建一个新的线程来执行任务\",{\"1\":{\"303\":1}}],[\"线程池会创建一个新的线程来执行任务\",{\"1\":{\"303\":1}}],[\"线程池会将任务放入\",{\"1\":{\"303\":1}}],[\"线程池会根据核心线程数来判断是否需要创建新的线程来执行任务\",{\"1\":{\"303\":1}}],[\"线程池会从任务队列中获取任务\",{\"1\":{\"293\":1}}],[\"线程池中提供了四个预定义的处理程序策略\",{\"1\":{\"302\":1}}],[\"线程池中的线程处于就绪状态\",{\"1\":{\"291\":1}}],[\"线程池拒绝策略\",{\"1\":{\"294\":1}}],[\"线程池被认为是终止状态\",{\"1\":{\"293\":1}}],[\"线程池被创建\",{\"1\":{\"293\":1}}],[\"线程池的状态时刻在变化\",{\"1\":{\"311\":1}}],[\"线程池的状态已经结束\",{\"1\":{\"293\":1}}],[\"线程池的工作线程通过woker类实现\",{\"1\":{\"310\":1}}],[\"线程池的工作流程如下如下图所示\",{\"1\":{\"303\":1}}],[\"线程池的工作流程\",{\"0\":{\"303\":1}}],[\"线程池的线程会一直存活\",{\"1\":{\"295\":1}}],[\"线程池的所有任务都已经执行完毕\",{\"1\":{\"293\":1}}],[\"线程池进入这个状态后\",{\"1\":{\"319\":1}}],[\"线程池进入终止状态\",{\"1\":{\"293\":1}}],[\"线程池进入了运行状态\",{\"1\":{\"293\":1}}],[\"线程池将不再接受新的任务\",{\"1\":{\"293\":1}}],[\"线程池可以接受任务\",{\"1\":{\"293\":1}}],[\"线程池提供了统一的管理和监控机制\",{\"1\":{\"291\":1}}],[\"线程资源必须通过线程池提供\",{\"1\":{\"291\":1}}],[\"线程退出时\",{\"1\":{\"191\":1}}],[\"线程执行了特定的等待操作\",{\"1\":{\"159\":1}}],[\"线程执行synchronized同步方法或者synchronized同步代码块时\",{\"1\":{\"158\":1}}],[\"线程执行monitorenter指令时尝试获取monitor的所有权\",{\"1\":{\"147\":1}}],[\"线程的创建和销毁是有一定开销的\",{\"1\":{\"291\":1}}],[\"线程的就绪和运行是两种不同的状态\",{\"1\":{\"157\":1}}],[\"线程的任意操作\",{\"1\":{\"136\":1}}],[\"线程完成执行\",{\"1\":{\"155\":1}}],[\"线程状态会受到操作系统的调度和资源限制\",{\"1\":{\"157\":1}}],[\"线程状态\",{\"1\":{\"155\":1}}],[\"线程阻塞\",{\"1\":{\"152\":1}}],[\"线程竞争不使用自旋\",{\"1\":{\"152\":1}}],[\"线程会一直循环等待直到资源可用\",{\"1\":{\"142\":1}}],[\"线程在申请资源时必须按照相同的顺序申请\",{\"1\":{\"141\":1}}],[\"线程一次性获取它所需的所有资源\",{\"1\":{\"141\":1}}],[\"线程必须成功地获取所有需要的资源\",{\"1\":{\"141\":1}}],[\"线程\",{\"1\":{\"140\":3}}],[\"线程先获取当前对象\",{\"1\":{\"139\":1}}],[\"线程终结规则\",{\"1\":{\"136\":1}}],[\"线程中断规则\",{\"1\":{\"136\":1}}],[\"线程启动之后\",{\"1\":{\"313\":1}}],[\"线程启动\",{\"1\":{\"312\":1}}],[\"线程启动操作的\",{\"1\":{\"136\":1}}],[\"线程启动规则\",{\"1\":{\"136\":1}}],[\"线程1修改完了\",{\"1\":{\"132\":1}}],[\"线程1修改了inc变量线程2会重新从主内存中重新读\",{\"1\":{\"132\":1}}],[\"线程1修改了i值\",{\"1\":{\"127\":1}}],[\"线程1\",{\"1\":{\"127\":1,\"134\":1,\"135\":1}}],[\"线程1读取主内存的i=0后\",{\"1\":{\"124\":1}}],[\"线程1执行到第3步时\",{\"1\":{\"19\":1,\"121\":1}}],[\"线程首先从主内存读取i的值\",{\"1\":{\"124\":1}}],[\"线程切换也可能带来原子性问题\",{\"1\":{\"120\":1}}],[\"线程切换的过程可能包括保存当前线程的上下文信息\",{\"1\":{\"120\":1}}],[\"线程切换的目的是实现多任务并发执行\",{\"1\":{\"120\":1}}],[\"线程切换还可能涉及将线程从一个处理器核心迁移到另一个核心\",{\"1\":{\"120\":1}}],[\"线程切换是指操作系统在多任务环境下\",{\"1\":{\"120\":1}}],[\"线程切换带来的原子问题\",{\"0\":{\"120\":1}}],[\"线程对共享变量的操作是不可见的\",{\"1\":{\"119\":1}}],[\"线程不安全\",{\"0\":{\"22\":1,\"23\":1}}],[\"线程2也读取了\",{\"1\":{\"132\":1}}],[\"线程2也读取i=0进行i++操作\",{\"1\":{\"124\":1}}],[\"线程2读取了i\",{\"1\":{\"127\":1}}],[\"线程2读取i的值\",{\"1\":{\"127\":1}}],[\"线程2\",{\"1\":{\"127\":1,\"134\":1,\"135\":1}}],[\"线程2访问的将是个还没初始化完毕的对象\",{\"1\":{\"19\":1,\"121\":1}}],[\"线程2调用getsingleton方法\",{\"1\":{\"19\":1,\"121\":1}}],[\"线程安全等需要不可变性的情况\",{\"1\":{\"435\":1}}],[\"线程安全性\",{\"1\":{\"421\":1}}],[\"线程安全的对象\",{\"1\":{\"283\":1}}],[\"线程安全\",{\"0\":{\"18\":1,\"19\":1,\"20\":1},\"1\":{\"20\":1,\"229\":1,\"264\":1}}],[\">>\",{\"1\":{\"361\":1,\"369\":1,\"395\":1}}],[\">>>\",{\"1\":{\"259\":3,\"349\":1,\"376\":1}}],[\">runworker\",{\"1\":{\"310\":1}}],[\">=\",{\"1\":{\"86\":1,\"187\":1,\"198\":1,\"239\":1,\"259\":5,\"261\":1,\"312\":3,\"314\":2,\"318\":1,\"329\":1,\"361\":1,\"363\":1,\"364\":2,\"369\":1,\"370\":1,\"376\":2,\"377\":2,\"395\":3}}],[\">\",{\"1\":{\"74\":1,\"86\":1,\"108\":1,\"132\":1,\"169\":1,\"173\":4,\"186\":1,\"187\":4,\"198\":1,\"213\":1,\"214\":1,\"233\":1,\"234\":1,\"235\":1,\"237\":1,\"256\":3,\"259\":4,\"260\":1,\"277\":2,\"281\":1,\"288\":1,\"306\":1,\"310\":1,\"312\":1,\"314\":4,\"316\":2,\"317\":8,\"323\":3,\"331\":1,\"333\":1,\"336\":1,\"339\":1,\"340\":4,\"341\":3,\"342\":3,\"359\":1,\"361\":2,\"362\":1,\"369\":1,\"375\":1,\"377\":1,\"378\":1,\"414\":1,\"431\":1}}],[\"><\",{\"1\":{\"74\":2}}],[\">2\",{\"1\":{\"19\":1,\"121\":1}}],[\">3\",{\"1\":{\"19\":1,\"121\":1}}],[\"步骤变为1\",{\"1\":{\"19\":1,\"121\":1}}],[\"还被广泛应用于大数据处理\",{\"1\":{\"403\":1}}],[\"还完全不影响io\",{\"1\":{\"401\":1}}],[\"还允许它存在只是为了保持版本的向下兼容而已\",{\"1\":{\"401\":1}}],[\"还未进行过初始化操作\",{\"1\":{\"377\":1}}],[\"还未调用start方法\",{\"1\":{\"155\":1}}],[\"还支持快复制\",{\"1\":{\"366\":1}}],[\"还没有足够的内存\",{\"1\":{\"286\":1}}],[\"还没有修改\",{\"1\":{\"132\":1}}],[\"还要好\",{\"1\":{\"221\":1}}],[\"还会在进入和退出\",{\"1\":{\"145\":1}}],[\"还提供了可见性\",{\"1\":{\"145\":1}}],[\"还涉及到一些具体的应用场景和含义\",{\"1\":{\"136\":1}}],[\"还还支持\",{\"1\":{\"82\":1}}],[\"还可以使用predict\",{\"1\":{\"77\":1}}],[\"还可以提升性能\",{\"1\":{\"19\":1,\"121\":1}}],[\"还有另一个成员变量\",{\"1\":{\"288\":1}}],[\"还有一些需要注意的点\",{\"1\":{\"423\":1}}],[\"还有一个object类型的数组\",{\"1\":{\"233\":1}}],[\"还有一系列其他的组件\",{\"1\":{\"63\":1}}],[\"还有abstractqueuedsynchronizer抽象的属性在内存中的偏移地址\",{\"1\":{\"170\":1}}],[\"还有其他的写法\",{\"1\":{\"21\":1}}],[\"还生产桌子\",{\"1\":{\"45\":1}}],[\"还是自己自己做的一些开源项目中\",{\"1\":{\"8\":1}}],[\"设计目的\",{\"1\":{\"419\":1}}],[\"设计上每个比特都是一个布尔值\",{\"1\":{\"392\":1}}],[\"设计模式的几种原则\",{\"0\":{\"14\":1}}],[\"设计模式有23种\",{\"1\":{\"13\":1}}],[\"设计模式有哪些类型\",{\"0\":{\"9\":1}}],[\"设计模式可以分为三种类型\",{\"1\":{\"9\":1}}],[\"设计模式是软件开发的一种指导思想\",{\"1\":{\"8\":1}}],[\"设计模式面试概述\",{\"0\":{\"8\":1}}],[\"设备的响应时间\",{\"1\":{\"118\":1}}],[\"设备三者相互协作\",{\"1\":{\"118\":1}}],[\"设备\",{\"1\":{\"118\":2}}],[\"设置位\",{\"1\":{\"393\":1}}],[\"设置阈值\",{\"1\":{\"349\":1}}],[\"设置任务的超时时间\",{\"1\":{\"343\":1}}],[\"设置线程池状态\",{\"1\":{\"319\":1}}],[\"设置aqs的state为0\",{\"1\":{\"313\":1}}],[\"设置threadlocal变量\",{\"1\":{\"287\":1}}],[\"设置table表中下标为index的值为e\",{\"1\":{\"261\":1}}],[\"设置table表中下标为index的值为hd\",{\"1\":{\"259\":1}}],[\"设置结点value值\",{\"1\":{\"261\":1}}],[\"设置p为头结点\",{\"1\":{\"259\":1}}],[\"设置parties\",{\"1\":{\"210\":1}}],[\"设置sizectl的值\",{\"1\":{\"259\":1}}],[\"设置singleton指向刚分配的内存空间\",{\"1\":{\"19\":1,\"121\":1}}],[\"设置索引\",{\"1\":{\"241\":1}}],[\"设置为\",{\"1\":{\"368\":2}}],[\"设置为元素e\",{\"1\":{\"238\":1}}],[\"设置为0\",{\"1\":{\"173\":1}}],[\"设置当前copyonwritearraylist的object\",{\"1\":{\"234\":1}}],[\"设置当前线程独占\",{\"1\":{\"183\":1,\"185\":1}}],[\"设置数组\",{\"1\":{\"234\":2,\"238\":1,\"239\":1,\"240\":2}}],[\"设置first结点的nextwaiter域为空\",{\"1\":{\"214\":1}}],[\"设置了等待时间\",{\"1\":{\"213\":2}}],[\"设置ranaction状态\",{\"1\":{\"213\":1}}],[\"设置barriercommand\",{\"1\":{\"210\":1}}],[\"设置count\",{\"1\":{\"210\":1}}],[\"设置节点next域\",{\"1\":{\"198\":1}}],[\"设置标识\",{\"1\":{\"183\":1}}],[\"设置标志\",{\"1\":{\"173\":1}}],[\"设置状态\",{\"1\":{\"183\":1,\"185\":1,\"215\":1}}],[\"设置时常小之后\",{\"1\":{\"175\":1}}],[\"设置时常大之后\",{\"1\":{\"175\":1}}],[\"设置node结点的状态为cancelled\",{\"1\":{\"173\":1}}],[\"设置node结点的thread为空\",{\"1\":{\"173\":1}}],[\"设置头结点并进行繁殖\",{\"1\":{\"198\":1}}],[\"设置头结点为当前节点\",{\"1\":{\"173\":1}}],[\"设置头结点\",{\"1\":{\"173\":1,\"198\":1}}],[\"设置尾结点的next域为node\",{\"1\":{\"173\":2,\"214\":1}}],[\"设置独占线程\",{\"1\":{\"166\":1}}],[\"设置同步状态的值\",{\"1\":{\"163\":1}}],[\"设置回调函数\",{\"1\":{\"57\":1}}],[\"设置父类\",{\"1\":{\"57\":1}}],[\"365\",{\"1\":{\"392\":3}}],[\"3600\",{\"1\":{\"77\":1,\"93\":1}}],[\"3+4\",{\"1\":{\"349\":1}}],[\"3dn\",{\"1\":{\"295\":2}}],[\"31\",{\"1\":{\"256\":1,\"431\":1}}],[\"3920373\",{\"1\":{\"137\":1}}],[\"3737899427754241961l\",{\"1\":{\"166\":1}}],[\"37843943\",{\"1\":{\"111\":1}}],[\"3776\",{\"1\":{\"94\":6}}],[\"3775\",{\"1\":{\"94\":1}}],[\"3773\",{\"1\":{\"94\":1}}],[\"3769\",{\"1\":{\"94\":1}}],[\"3767\",{\"1\":{\"94\":1}}],[\"34\",{\"1\":{\"89\":1}}],[\"3884e\",{\"1\":{\"79\":1}}],[\"300\",{\"1\":{\"187\":3}}],[\"3000897897090466540l\",{\"1\":{\"185\":1}}],[\"3000\",{\"1\":{\"132\":1,\"341\":1,\"342\":1,\"414\":1}}],[\"30\",{\"1\":{\"89\":2,\"256\":1}}],[\"3030\",{\"1\":{\"71\":1}}],[\"30s\",{\"1\":{\"64\":1,\"106\":1,\"107\":2}}],[\"32\",{\"1\":{\"68\":1,\"131\":2,\"256\":2}}],[\"356\",{\"1\":{\"395\":1}}],[\"35\",{\"1\":{\"68\":1}}],[\"3的重排序在多线程中将被禁止\",{\"1\":{\"19\":1,\"121\":1}}],[\"3\",{\"1\":{\"19\":1,\"26\":1,\"68\":1,\"78\":1,\"89\":1,\"94\":1,\"121\":1,\"143\":1,\"147\":1,\"168\":3,\"173\":2,\"175\":1,\"203\":1,\"247\":2,\"256\":1,\"259\":1,\"267\":1,\"293\":1,\"309\":3,\"311\":2,\"317\":1,\"328\":1,\"329\":1,\"331\":1,\"332\":2,\"340\":1,\"349\":1,\"353\":1,\"354\":1,\"383\":3,\"393\":7,\"395\":1,\"401\":1,\"415\":1,\"435\":1}}],[\"2^7\",{\"1\":{\"429\":2}}],[\"23\",{\"1\":{\"419\":1}}],[\"2323\",{\"1\":{\"395\":1}}],[\"2fc\",{\"1\":{\"295\":2}}],[\"2bw\",{\"1\":{\"295\":2}}],[\"2+1\",{\"1\":{\"295\":1}}],[\"2时\",{\"1\":{\"173\":1}}],[\"24\",{\"1\":{\"89\":3,\"93\":1}}],[\"296\",{\"1\":{\"79\":1}}],[\"2s\",{\"1\":{\"78\":1}}],[\"21\",{\"1\":{\"68\":1,\"89\":2}}],[\"256个字节\",{\"1\":{\"347\":1}}],[\"2591416\",{\"1\":{\"289\":1}}],[\"25\",{\"1\":{\"68\":1,\"79\":1,\"98\":1}}],[\"20240121211859054\",{\"1\":{\"349\":1}}],[\"20240121201736740\",{\"1\":{\"345\":1}}],[\"20240108205738858\",{\"1\":{\"337\":1}}],[\"20240106124807435\",{\"1\":{\"285\":1}}],[\"20240106122058598\",{\"1\":{\"282\":1}}],[\"20240106113729346\",{\"1\":{\"280\":1}}],[\"20240101105106318\",{\"1\":{\"223\":1,\"229\":1}}],[\"20240101105046850\",{\"1\":{\"223\":1,\"229\":1}}],[\"20230830224136440\",{\"1\":{\"59\":1}}],[\"20231204151718877\",{\"1\":{\"400\":1}}],[\"20231209160829989\",{\"1\":{\"120\":1}}],[\"20231209115348572\",{\"1\":{\"119\":1}}],[\"20231223200719658\",{\"1\":{\"218\":1}}],[\"20231217172210727\",{\"1\":{\"163\":1}}],[\"20231217171236598\",{\"1\":{\"163\":1}}],[\"20231211225833220\",{\"1\":{\"155\":1}}],[\"20231210110738038\",{\"1\":{\"147\":1}}],[\"20231023210926364\",{\"1\":{\"116\":1}}],[\"20231021174948512\",{\"1\":{\"109\":1}}],[\"20231021174854220\",{\"1\":{\"108\":1}}],[\"20231021174512876\",{\"1\":{\"108\":1}}],[\"20231021170507878\",{\"1\":{\"101\":1}}],[\"20231021115611700\",{\"1\":{\"100\":1}}],[\"20231021115719027\",{\"1\":{\"100\":1}}],[\"20231014211256244\",{\"1\":{\"82\":1}}],[\"20231014210912914\",{\"1\":{\"81\":1}}],[\"20231014210829763\",{\"1\":{\"81\":1}}],[\"20231012215203283\",{\"1\":{\"74\":1}}],[\"20231010201727866\",{\"1\":{\"71\":1}}],[\"20231009220040376\",{\"1\":{\"71\":1}}],[\"20231008231356066\",{\"1\":{\"69\":1}}],[\"20231008084050835\",{\"1\":{\"67\":1}}],[\"20231008083006727\",{\"1\":{\"67\":1}}],[\"20231030213851667\",{\"1\":{\"17\":1}}],[\"20231107230028268\",{\"1\":{\"49\":1}}],[\"20231105210628018\",{\"1\":{\"43\":1}}],[\"20231102232111957\",{\"1\":{\"30\":1}}],[\"20231112200737983\",{\"1\":{\"9\":1}}],[\"20\",{\"1\":{\"78\":1,\"94\":1}}],[\"20ms的请求又多少个\",{\"1\":{\"78\":1}}],[\"2000\",{\"1\":{\"267\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1}}],[\"200\",{\"1\":{\"74\":9,\"75\":1,\"90\":1,\"92\":5,\"97\":3,\"187\":2,\"306\":1}}],[\"2019\",{\"1\":{\"262\":1}}],[\"2017年底发布了基于全新存储层的2\",{\"1\":{\"61\":1}}],[\"2016年5月继kubernetes之后成为第二个正式加入cncf\",{\"1\":{\"61\":1}}],[\"2和3可能会发生重排序\",{\"1\":{\"19\":1,\"121\":1}}],[\"2\",{\"0\":{\"306\":1},\"1\":{\"19\":1,\"26\":1,\"57\":1,\"67\":2,\"68\":1,\"78\":2,\"94\":1,\"98\":4,\"121\":1,\"130\":1,\"147\":1,\"160\":2,\"168\":3,\"173\":1,\"175\":2,\"191\":3,\"203\":1,\"224\":2,\"230\":1,\"247\":1,\"256\":2,\"259\":3,\"293\":1,\"309\":2,\"311\":1,\"315\":1,\"317\":1,\"328\":1,\"329\":1,\"331\":1,\"332\":5,\"340\":2,\"349\":1,\"352\":1,\"375\":1,\"383\":2,\"392\":1,\"395\":9,\"401\":1,\"406\":1,\"415\":1,\"429\":2,\"435\":2,\"438\":3}}],[\"circle=new\",{\"1\":{\"419\":1}}],[\"circle\",{\"1\":{\"419\":6}}],[\"circular\",{\"1\":{\"140\":1,\"141\":1}}],[\"culling\",{\"1\":{\"314\":1}}],[\"cursor++\",{\"1\":{\"235\":1}}],[\"cursor\",{\"1\":{\"235\":9,\"364\":10}}],[\"cur\",{\"1\":{\"186\":1}}],[\"cur=system\",{\"1\":{\"186\":1}}],[\"current长度为len\",{\"1\":{\"239\":1}}],[\"current==waiters\",{\"1\":{\"175\":1}}],[\"current\",{\"1\":{\"175\":7,\"183\":4,\"185\":3,\"208\":1,\"239\":7}}],[\"currentthread\",{\"1\":{\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"173\":1,\"175\":4,\"183\":3,\"184\":1,\"185\":1,\"187\":4,\"213\":1,\"281\":1,\"282\":2,\"306\":1,\"313\":1,\"318\":1,\"329\":1}}],[\"currenttimemillis\",{\"1\":{\"98\":2}}],[\"currently\",{\"1\":{\"68\":1}}],[\"curl\",{\"1\":{\"70\":1,\"71\":1}}],[\"ctlof\",{\"1\":{\"308\":1,\"309\":2}}],[\"ctl\",{\"1\":{\"308\":1,\"309\":2,\"311\":3,\"312\":4,\"313\":2,\"314\":1}}],[\"ctorinstance\",{\"1\":{\"19\":1,\"121\":1}}],[\"c是等待时间与计算时间的比率\",{\"1\":{\"295\":1}}],[\"cv为空或者与结点value相等或者不为空并且相等\",{\"1\":{\"261\":2}}],[\"cv\",{\"1\":{\"261\":7}}],[\"ck\",{\"1\":{\"256\":2}}],[\"cellvalue\",{\"1\":{\"256\":2,\"259\":1}}],[\"cells\",{\"1\":{\"256\":1}}],[\"cellsbusy\",{\"1\":{\"256\":4}}],[\"cyclicbarrier类对外提供的await函数在底层都是调用该了doawait函数\",{\"1\":{\"213\":1}}],[\"cyclicbarrier类存在一个内部类generation\",{\"1\":{\"207\":1}}],[\"cyclicbarrier的数据结构也依托于aqs的数据结构\",{\"1\":{\"205\":1}}],[\"cyclicbarrier底层是基于reentrantlock和abstractqueuedsynchronizer来实现的\",{\"1\":{\"205\":1}}],[\"cyclicbarrier数据结构\",{\"0\":{\"205\":1}}],[\"cyclicbarrierdemo2\",{\"1\":{\"203\":1}}],[\"cyclicbarrier使用示例\",{\"0\":{\"203\":1}}],[\"cyclicbarrier简介\",{\"0\":{\"202\":1}}],[\"cyclicbarrier源码解析\",{\"0\":{\"201\":1,\"204\":1}}],[\"cyclicbarrier\",{\"0\":{\"210\":1,\"211\":1},\"1\":{\"164\":1,\"202\":6,\"203\":7,\"206\":1,\"208\":1,\"210\":1,\"211\":1}}],[\"cycles\",{\"1\":{\"68\":1,\"79\":1}}],[\"c\",{\"1\":{\"136\":2,\"147\":1,\"175\":2,\"183\":6,\"185\":3,\"197\":4,\"199\":4,\"230\":1,\"234\":5,\"247\":2,\"259\":2,\"265\":2,\"271\":2,\"309\":4,\"311\":5,\"312\":6,\"314\":4,\"318\":3,\"329\":3,\"359\":3,\"360\":2,\"367\":2,\"385\":4}}],[\"cpus\",{\"1\":{\"256\":1}}],[\"cpu厂商引入了高速缓存\",{\"1\":{\"124\":1}}],[\"cpu已经远远超越了主内存读取数据的速度\",{\"1\":{\"124\":1}}],[\"cpu能够保证的原子操作是cpu指令级别的\",{\"1\":{\"120\":1}}],[\"cpu增加了缓存\",{\"1\":{\"118\":1}}],[\"cpu是整个计算机系统的\",{\"1\":{\"118\":1}}],[\"cpu\",{\"1\":{\"118\":6,\"295\":4}}],[\"c661e8050434\",{\"1\":{\"111\":1}}],[\"csdn\",{\"1\":{\"111\":1,\"320\":1}}],[\"creating\",{\"1\":{\"256\":1}}],[\"creation\",{\"1\":{\"256\":1}}],[\"createinheritedmap\",{\"1\":{\"288\":2}}],[\"createmap\",{\"1\":{\"282\":2}}],[\"createhttpserver\",{\"1\":{\"98\":1}}],[\"create\",{\"1\":{\"57\":1}}],[\"createsofa\",{\"1\":{\"41\":1,\"44\":4}}],[\"createcoffee\",{\"1\":{\"41\":1}}],[\"critical\",{\"1\":{\"106\":1,\"107\":2}}],[\"caught\",{\"1\":{\"438\":4}}],[\"caused\",{\"1\":{\"110\":1}}],[\"cat\",{\"1\":{\"424\":6}}],[\"catch语句中使用\",{\"1\":{\"437\":1}}],[\"catch语句对可能发生异常的代码块进行了包裹\",{\"1\":{\"432\":1}}],[\"catch块可以捕获多个异常类型\",{\"1\":{\"432\":1}}],[\"catch块用于捕获并处理指定类型的异常\",{\"1\":{\"432\":1}}],[\"catch块\",{\"1\":{\"432\":1}}],[\"catch\",{\"1\":{\"31\":7,\"139\":2,\"142\":1,\"143\":1,\"158\":1,\"159\":3,\"160\":5,\"170\":1,\"175\":2,\"187\":2,\"191\":4,\"203\":5,\"213\":1,\"233\":1,\"256\":1,\"267\":2,\"271\":1,\"313\":3,\"314\":1,\"315\":2,\"318\":1,\"319\":1,\"323\":3,\"329\":1,\"336\":1,\"339\":2,\"340\":2,\"341\":4,\"342\":6,\"364\":1,\"405\":1,\"414\":2,\"415\":3,\"432\":4,\"437\":1,\"438\":2}}],[\"cardinality\",{\"1\":{\"393\":1,\"395\":1}}],[\"card=math\",{\"1\":{\"295\":2}}],[\"cares\",{\"1\":{\"288\":1}}],[\"cache\",{\"1\":{\"219\":3,\"220\":3,\"221\":4,\"347\":1}}],[\"capacity\",{\"1\":{\"187\":7,\"256\":3,\"259\":3,\"271\":8,\"309\":2,\"312\":1,\"358\":1,\"359\":1,\"361\":2,\"375\":4,\"377\":3,\"406\":1}}],[\"calls\",{\"1\":{\"318\":1,\"329\":1}}],[\"callable接口和runnable接口很像\",{\"1\":{\"325\":1}}],[\"callable接口定义如下\",{\"1\":{\"325\":1}}],[\"callable接口\",{\"0\":{\"325\":1}}],[\"callable接口类似于runnable\",{\"1\":{\"315\":1}}],[\"callable\",{\"1\":{\"318\":1,\"323\":10,\"328\":1,\"329\":1,\"333\":1,\"336\":2,\"348\":2}}],[\"callable<integer>\",{\"1\":{\"323\":3,\"336\":1}}],[\"callable<v>\",{\"1\":{\"318\":1,\"325\":1,\"328\":1,\"329\":1}}],[\"callable<t>\",{\"1\":{\"316\":1}}],[\"callable<string>\",{\"1\":{\"315\":1}}],[\"callable任务除了返回正常结果之外\",{\"1\":{\"315\":1}}],[\"callable负责产生结果\",{\"1\":{\"315\":1}}],[\"call\",{\"1\":{\"185\":1,\"235\":1,\"311\":1,\"315\":1,\"318\":1,\"325\":1,\"329\":1}}],[\"callerrunspolicy\",{\"1\":{\"302\":1}}],[\"caller\",{\"1\":{\"173\":1}}],[\"calculate\",{\"1\":{\"90\":5}}],[\"cannot\",{\"1\":{\"173\":1,\"214\":1,\"311\":1,\"317\":1,\"331\":1}}],[\"can\",{\"1\":{\"173\":3,\"214\":1,\"311\":1}}],[\"cancel方法\",{\"0\":{\"332\":1}}],[\"cancel\",{\"1\":{\"173\":1,\"322\":1,\"326\":3,\"332\":3}}],[\"cancelacquire\",{\"1\":{\"173\":2,\"198\":1}}],[\"cancelled\",{\"1\":{\"168\":3,\"173\":5,\"214\":2,\"317\":2,\"328\":2,\"332\":1}}],[\"cas的把当前任务状态从completing变更为normal\",{\"1\":{\"329\":1}}],[\"cas的把当前任务状态从completing变更为exceptional\",{\"1\":{\"329\":1}}],[\"cas更新线程池数量\",{\"1\":{\"312\":1}}],[\"castabat函数源码如下\",{\"1\":{\"259\":1}}],[\"castabat\",{\"1\":{\"259\":3}}],[\"cas比较与交换算法\",{\"1\":{\"175\":1}}],[\"case\",{\"1\":{\"173\":1,\"214\":1,\"288\":1,\"313\":1}}],[\"cases\",{\"1\":{\"173\":1,\"198\":1,\"199\":1}}],[\"cas操作\",{\"1\":{\"163\":1}}],[\"cas\",{\"1\":{\"153\":1,\"173\":1,\"198\":1,\"199\":1,\"222\":1,\"256\":2,\"312\":1}}],[\"cdn\",{\"1\":{\"295\":2}}],[\"cd\",{\"1\":{\"67\":1}}],[\"cglib无法从代理对象中调用自身的方法\",{\"1\":{\"57\":1}}],[\"cglib无法代理final方法和final类\",{\"1\":{\"57\":1}}],[\"cglib能够代理普通类和接口类\",{\"1\":{\"57\":1}}],[\"cglib动态代理需要引入额外的库\",{\"1\":{\"57\":1}}],[\"cglib动态代理的缺点\",{\"1\":{\"57\":1}}],[\"cglib动态代理的优点\",{\"1\":{\"57\":1}}],[\"cglib动态代理可以代理没有实现任何接口的类\",{\"1\":{\"57\":1}}],[\"cglib动态代理通常能够提供更好的性能\",{\"1\":{\"57\":1}}],[\"cglib可以代理非接口类型的类\",{\"1\":{\"57\":1}}],[\"cglib\",{\"1\":{\"57\":1}}],[\"cglibproxyfactory\",{\"1\":{\"57\":3}}],[\"cglib代码模式需要实现methodinterceptor\",{\"1\":{\"57\":1}}],[\"cglib代码\",{\"0\":{\"57\":1}}],[\"cnblogs\",{\"1\":{\"137\":1,\"176\":1,\"200\":1,\"216\":1,\"262\":1,\"278\":1,\"320\":1,\"334\":1}}],[\"cn\",{\"1\":{\"41\":2,\"289\":2,\"320\":1}}],[\"ch\",{\"1\":{\"259\":5}}],[\"checkelementindex\",{\"1\":{\"369\":3,\"370\":3}}],[\"checked异常需要在代码中进行处理或声明\",{\"1\":{\"432\":1}}],[\"checked异常和unchecked异常\",{\"1\":{\"432\":1}}],[\"checked\",{\"1\":{\"361\":1,\"432\":1}}],[\"checkforcomodification\",{\"1\":{\"364\":7}}],[\"check线程池的状态\",{\"1\":{\"311\":1}}],[\"checkindex\",{\"1\":{\"363\":1}}],[\"checking\",{\"1\":{\"311\":1}}],[\"checkinvariants\",{\"1\":{\"259\":1}}],[\"checkshutdownaccess\",{\"1\":{\"319\":2}}],[\"checks\",{\"1\":{\"311\":1}}],[\"checknotnull\",{\"1\":{\"271\":1,\"273\":1,\"274\":1}}],[\"check\",{\"1\":{\"183\":1,\"198\":1,\"259\":3,\"311\":3,\"312\":1,\"314\":1}}],[\"channel2\",{\"1\":{\"412\":1}}],[\"channel1\",{\"1\":{\"412\":1}}],[\"channels\",{\"1\":{\"405\":1,\"414\":4,\"415\":1}}],[\"channel\",{\"0\":{\"404\":1},\"1\":{\"403\":1,\"404\":6,\"405\":5,\"412\":10,\"414\":5}}],[\"change\",{\"1\":{\"214\":1,\"312\":1}}],[\"changed\",{\"1\":{\"173\":1}}],[\"charset\",{\"1\":{\"414\":1}}],[\"charbuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"chararraywriter\",{\"1\":{\"401\":1}}],[\"chararrayreader\",{\"1\":{\"401\":1}}],[\"character\",{\"1\":{\"399\":1,\"423\":1}}],[\"charat\",{\"1\":{\"395\":1}}],[\"char\",{\"1\":{\"395\":2,\"403\":1,\"405\":1,\"406\":5,\"414\":1,\"423\":1,\"429\":1,\"430\":2,\"431\":1}}],[\"charlie\",{\"1\":{\"353\":3,\"354\":5}}],[\"chain\",{\"1\":{\"36\":2,\"287\":1}}],[\"chu\",{\"1\":{\"111\":1}}],[\"china\",{\"1\":{\"41\":2,\"44\":1,\"47\":3}}],[\"chinesetable\",{\"1\":{\"46\":1,\"47\":3}}],[\"chinesesofafactory\",{\"1\":{\"43\":1,\"44\":2}}],[\"chinesesofa\",{\"1\":{\"41\":2,\"44\":1,\"47\":1}}],[\"chinesesofa类实现了抽象产品类\",{\"1\":{\"41\":1}}],[\"chinese\",{\"1\":{\"40\":1,\"43\":1}}],[\"cfo审批通过\",{\"1\":{\"36\":2}}],[\"cfo\",{\"1\":{\"36\":5}}],[\"cfo继承了aproval\",{\"1\":{\"36\":1}}],[\"cfo三个角色\",{\"1\":{\"36\":1}}],[\"color\",{\"1\":{\"419\":6}}],[\"cold\",{\"1\":{\"361\":1}}],[\"collect\",{\"1\":{\"107\":1}}],[\"collection的手写实现两个维度来讲解常见的集合类的具体实现\",{\"1\":{\"355\":1}}],[\"collection的实现还是经常被问到\",{\"1\":{\"355\":1}}],[\"collection概述\",{\"0\":{\"351\":1}}],[\"collectionview抽象类主要定义了视图操作\",{\"1\":{\"253\":1}}],[\"collectionview类\",{\"0\":{\"253\":1}}],[\"collection<\",{\"1\":{\"234\":2,\"265\":2,\"271\":2,\"359\":1,\"360\":2,\"367\":1,\"385\":1}}],[\"collection\",{\"1\":{\"68\":1,\"79\":1,\"234\":2,\"271\":2,\"351\":5,\"352\":1,\"353\":2}}],[\"cowiterator表示迭代器\",{\"1\":{\"235\":1}}],[\"cowiterator\",{\"1\":{\"235\":1}}],[\"cowiterator<e>\",{\"1\":{\"235\":1}}],[\"cowiterator类\",{\"1\":{\"235\":1}}],[\"copyof函数\",{\"0\":{\"237\":1}}],[\"copyof方法即可理解copyonwritearraylist其他函数的意义\",{\"1\":{\"236\":1}}],[\"copyof\",{\"1\":{\"234\":2,\"237\":1,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"359\":1,\"361\":1}}],[\"copyonwritearrayset\",{\"1\":{\"225\":1}}],[\"copyonwritearraylist实现了list接口\",{\"1\":{\"232\":1}}],[\"copyonwritearraylist<\",{\"1\":{\"234\":1}}],[\"copyonwritearraylist<e>\",{\"1\":{\"232\":1,\"233\":1}}],[\"copyonwritearraylist<>\",{\"1\":{\"230\":1}}],[\"copyonwritearraylist<string>\",{\"1\":{\"230\":1}}],[\"copyonwritearraylist使用示例\",{\"0\":{\"230\":1}}],[\"copyonwritearraylist介绍\",{\"0\":{\"229\":1}}],[\"copyonwritearraylist源码解析\",{\"0\":{\"228\":1,\"231\":1}}],[\"copyonwritearraylist\",{\"1\":{\"223\":4,\"228\":2,\"229\":5,\"230\":2,\"233\":1,\"234\":7,\"242\":2}}],[\"copy\",{\"1\":{\"223\":1,\"237\":3}}],[\"coarsening\",{\"1\":{\"153\":1}}],[\"corepoolsize\",{\"0\":{\"295\":1},\"1\":{\"294\":6,\"295\":1,\"296\":1,\"297\":1,\"308\":1,\"311\":2,\"312\":1,\"314\":2}}],[\"core\",{\"1\":{\"98\":2,\"312\":2}}],[\"core包是指标的关键包\",{\"1\":{\"98\":1}}],[\"core<\",{\"1\":{\"98\":1}}],[\"countdown函数\",{\"0\":{\"199\":1}}],[\"countdown\",{\"1\":{\"190\":2,\"191\":2,\"199\":1}}],[\"countdownlatch类存在一个内部类sync\",{\"1\":{\"197\":1}}],[\"countdownlatch数据结构\",{\"0\":{\"193\":1}}],[\"countdownlatchdemo2\",{\"1\":{\"191\":1}}],[\"countdownlatch使用示例\",{\"0\":{\"191\":1}}],[\"countdownlatch简介\",{\"0\":{\"190\":1}}],[\"countdownlatch源码解析\",{\"0\":{\"189\":1,\"192\":1}}],[\"countdownlatch\",{\"1\":{\"164\":2,\"190\":2,\"191\":3,\"194\":1,\"195\":1,\"196\":2,\"202\":2}}],[\"count++\",{\"1\":{\"146\":1,\"267\":1,\"273\":1}}],[\"countsheep\",{\"1\":{\"134\":1}}],[\"count作为后缀\",{\"1\":{\"78\":1}}],[\"countercell表\",{\"1\":{\"256\":1}}],[\"countercells不为空或者比较交换失败\",{\"1\":{\"259\":1}}],[\"countercells\",{\"1\":{\"256\":2,\"259\":1}}],[\"countercell类主要用于对basecount的计数\",{\"1\":{\"255\":1}}],[\"countercell\",{\"0\":{\"255\":1},\"1\":{\"256\":2,\"259\":2}}],[\"counter类型的http\",{\"1\":{\"98\":1}}],[\"counter类型的指标和计数器一样\",{\"1\":{\"76\":1}}],[\"counter\",{\"0\":{\"76\":1},\"1\":{\"68\":1,\"74\":2,\"75\":3,\"98\":10,\"256\":2,\"395\":1}}],[\"count\",{\"1\":{\"68\":1,\"78\":1,\"79\":1,\"85\":1,\"90\":4,\"97\":2,\"98\":26,\"100\":2,\"146\":2,\"183\":1,\"185\":1,\"190\":2,\"196\":4,\"197\":3,\"199\":1,\"208\":1,\"210\":1,\"213\":1,\"214\":1,\"215\":1,\"256\":1,\"267\":3,\"270\":1,\"271\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":1,\"277\":2,\"293\":5,\"309\":12}}],[\"code的的请求总数\",{\"1\":{\"90\":1}}],[\"code=n\",{\"1\":{\"295\":2}}],[\"code=\",{\"1\":{\"74\":6,\"75\":1,\"89\":10,\"90\":1,\"92\":5}}],[\"code\",{\"1\":{\"31\":1,\"57\":1,\"74\":1,\"89\":9,\"90\":2,\"116\":2,\"235\":3,\"361\":1}}],[\"consume\",{\"1\":{\"187\":7}}],[\"consumerthread\",{\"1\":{\"267\":2}}],[\"consumer<\",{\"1\":{\"235\":1}}],[\"consumer\",{\"1\":{\"187\":4,\"267\":2}}],[\"consul\",{\"1\":{\"62\":1,\"68\":1}}],[\"condition队列的头结点尾结点都设置为空\",{\"1\":{\"214\":1}}],[\"conditionobject\",{\"1\":{\"183\":2}}],[\"conditionobject类\",{\"0\":{\"169\":1}}],[\"condition接口中定义了await\",{\"1\":{\"169\":1}}],[\"condition接口定义了条件操作规范\",{\"1\":{\"169\":1}}],[\"condition\",{\"1\":{\"119\":1,\"168\":4,\"169\":1,\"173\":1,\"179\":1,\"186\":1,\"187\":3,\"188\":1,\"208\":2,\"214\":1,\"270\":2}}],[\"concurrency\",{\"1\":{\"256\":1}}],[\"concurrenthashset\",{\"1\":{\"389\":1}}],[\"concurrenthashmap的属性很多\",{\"1\":{\"256\":1}}],[\"concurrenthashmap的内部类非常的庞大\",{\"1\":{\"250\":1}}],[\"concurrenthashmap的实现发生了重大变化\",{\"1\":{\"246\":1}}],[\"concurrenthashmap包含了很多内部类\",{\"1\":{\"250\":1}}],[\"concurrenthashmap继承了abstractmap抽象类\",{\"1\":{\"249\":1}}],[\"concurrenthashmap<k\",{\"1\":{\"249\":1,\"256\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"247\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"247\":1}}],[\"concurrenthashmapexample\",{\"1\":{\"247\":1}}],[\"concurrenthashmap使用示例\",{\"0\":{\"247\":1}}],[\"concurrenthashmap使用cas操作来保证线程安全\",{\"1\":{\"246\":1}}],[\"concurrenthashmap使用了node和treenode来表示哈希表中的节点\",{\"1\":{\"246\":1}}],[\"concurrenthashmap在java\",{\"1\":{\"245\":1}}],[\"concurrenthashmap中使用了一个segment数组\",{\"1\":{\"245\":1}}],[\"concurrenthashmap实现了基于分段锁的并发访问机制\",{\"1\":{\"245\":1}}],[\"concurrenthashmap介绍\",{\"0\":{\"244\":1}}],[\"concurrenthashmap源码解析\",{\"0\":{\"243\":1,\"248\":1}}],[\"concurrenthashmap\",{\"1\":{\"224\":2,\"244\":1,\"247\":2,\"256\":1,\"257\":2,\"262\":1}}],[\"concurrentmap接口也定义了一系列操作\",{\"1\":{\"249\":1}}],[\"concurrentmap<k\",{\"1\":{\"249\":1,\"256\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"235\":1,\"242\":1,\"364\":3}}],[\"concurrentskiplistset\",{\"1\":{\"225\":1}}],[\"concurrentskiplistmap\",{\"1\":{\"224\":2}}],[\"concurrentlinkeddeque\",{\"1\":{\"226\":1}}],[\"concurrentlinkedqueue<>\",{\"1\":{\"175\":1}}],[\"concurrentlinkedqueue<thread>\",{\"1\":{\"175\":1}}],[\"concurrentlinkedqueue\",{\"1\":{\"175\":1,\"226\":1}}],[\"concurrentlab\",{\"1\":{\"119\":1,\"139\":1,\"142\":1,\"147\":1,\"159\":1,\"160\":1,\"175\":1,\"187\":1,\"191\":2,\"203\":1,\"219\":1,\"221\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1}}],[\"concurrent\",{\"1\":{\"175\":2,\"187\":3,\"191\":3,\"203\":1,\"219\":1,\"221\":1,\"230\":1,\"247\":1,\"267\":1,\"281\":1,\"318\":1,\"323\":8,\"329\":1,\"336\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"349\":2,\"415\":1}}],[\"concrete\",{\"1\":{\"49\":2}}],[\"containchars\",{\"1\":{\"395\":1}}],[\"containskey\",{\"1\":{\"354\":3,\"387\":4}}],[\"containsbob\",{\"1\":{\"353\":2}}],[\"containsapple\",{\"1\":{\"352\":2}}],[\"contains\",{\"1\":{\"142\":2,\"265\":1,\"352\":3,\"353\":3,\"354\":2,\"363\":3,\"387\":5}}],[\"control\",{\"1\":{\"256\":1}}],[\"controller\",{\"1\":{\"97\":1}}],[\"continue\",{\"1\":{\"198\":2,\"199\":2,\"312\":1,\"314\":1,\"412\":1,\"414\":1}}],[\"context\",{\"1\":{\"135\":2}}],[\"contented\",{\"1\":{\"347\":1}}],[\"contention\",{\"1\":{\"256\":1}}],[\"content\",{\"1\":{\"31\":7}}],[\"configureblocking\",{\"1\":{\"410\":2,\"411\":2,\"414\":2,\"415\":1}}],[\"configuration\",{\"1\":{\"68\":1,\"98\":1,\"110\":1}}],[\"configs是配置采集任务的\",{\"1\":{\"68\":1}}],[\"configs\",{\"1\":{\"68\":3,\"69\":3,\"99\":2,\"106\":1,\"107\":1,\"108\":1}}],[\"config\",{\"1\":{\"68\":1,\"106\":1,\"110\":1}}],[\"connect\",{\"1\":{\"26\":6,\"407\":1,\"410\":2,\"415\":2}}],[\"command\",{\"1\":{\"208\":1,\"213\":3,\"311\":10}}],[\"commons\",{\"1\":{\"305\":1}}],[\"common\",{\"1\":{\"239\":3,\"306\":1}}],[\"commonannotations\",{\"1\":{\"110\":2}}],[\"commonlabels\",{\"1\":{\"110\":2}}],[\"composition\",{\"1\":{\"420\":1}}],[\"componentimpl提供基本的实现方法\",{\"1\":{\"30\":1}}],[\"componentdecoratora\",{\"1\":{\"30\":1}}],[\"componentdecoratorb和componentdecoratora分别对componentimpl进行了增强\",{\"1\":{\"30\":1}}],[\"componentdecoratorb\",{\"1\":{\"30\":1}}],[\"computeprime\",{\"1\":{\"395\":1}}],[\"compute\",{\"1\":{\"346\":2,\"349\":3}}],[\"compact\",{\"1\":{\"406\":4,\"414\":1}}],[\"comparableclassfor\",{\"1\":{\"259\":1}}],[\"compareanddecrementworkercount\",{\"1\":{\"314\":1}}],[\"compareandincrementworkercount\",{\"1\":{\"312\":1}}],[\"compareandswaplong\",{\"1\":{\"259\":2}}],[\"compareandswapobject\",{\"1\":{\"259\":1,\"317\":1,\"318\":1,\"329\":1,\"331\":1,\"333\":1}}],[\"compareandswapstate\",{\"1\":{\"175\":3}}],[\"compareandswapint\",{\"1\":{\"163\":1,\"175\":1,\"259\":4,\"329\":2,\"332\":2}}],[\"compareandsetnext\",{\"1\":{\"173\":2}}],[\"compareandsetwaitstatus\",{\"1\":{\"173\":3,\"198\":2,\"199\":2,\"214\":2}}],[\"compareandsethead\",{\"1\":{\"173\":1,\"214\":1}}],[\"compareandsettail\",{\"1\":{\"173\":3,\"214\":1}}],[\"compareandsetstate\",{\"1\":{\"163\":1,\"183\":1,\"184\":1,\"185\":1,\"197\":1,\"199\":1}}],[\"compareandsetstate进行操作\",{\"1\":{\"163\":1}}],[\"comparecomparables\",{\"1\":{\"259\":1}}],[\"compare\",{\"1\":{\"222\":1,\"246\":1}}],[\"compatibility\",{\"1\":{\"256\":1}}],[\"completeontimeout\",{\"1\":{\"343\":1}}],[\"completedabruptly\",{\"1\":{\"313\":3}}],[\"completedtasks++\",{\"1\":{\"313\":1}}],[\"completedtasks\",{\"1\":{\"313\":1}}],[\"completablefutureallofexample\",{\"1\":{\"342\":1}}],[\"completablefutureanyofexample\",{\"1\":{\"341\":1}}],[\"completablefuture<void>\",{\"1\":{\"342\":1}}],[\"completablefuture<object>\",{\"1\":{\"341\":1}}],[\"completablefuture<string>\",{\"1\":{\"341\":1,\"342\":1}}],[\"completablefuture<integer>\",{\"1\":{\"339\":1,\"340\":1,\"341\":1,\"342\":1}}],[\"completablefutureexample\",{\"1\":{\"339\":1,\"340\":1}}],[\"completablefuture具有future的功能\",{\"0\":{\"339\":1}}],[\"completablefuture使用示例\",{\"0\":{\"338\":1}}],[\"completablefuture使用详解\",{\"0\":{\"335\":1}}],[\"completablefuture介绍\",{\"0\":{\"337\":1}}],[\"completablefuture\",{\"1\":{\"336\":1,\"337\":11,\"339\":4,\"340\":4,\"341\":8,\"342\":8,\"343\":4}}],[\"completing状态是任务是否执行完成的临界状态\",{\"1\":{\"330\":1}}],[\"completing是否成立\",{\"1\":{\"330\":1}}],[\"completing\",{\"1\":{\"317\":6,\"328\":2,\"329\":2,\"330\":1,\"331\":2,\"333\":1}}],[\"completion\",{\"1\":{\"214\":1}}],[\"complement\",{\"1\":{\"87\":1}}],[\"compress\",{\"1\":{\"31\":2}}],[\"compressionfilereaderwriter\",{\"1\":{\"31\":3}}],[\"compressionfilereaderwriter是一个装饰器\",{\"1\":{\"31\":1}}],[\"com\",{\"1\":{\"24\":1,\"31\":3,\"50\":3,\"69\":1,\"71\":2,\"111\":2,\"137\":1,\"176\":2,\"200\":1,\"216\":1,\"262\":2,\"278\":1,\"295\":2,\"306\":1,\"320\":1,\"334\":1,\"396\":1}}],[\"cloneable\",{\"1\":{\"232\":1,\"233\":1,\"357\":1,\"358\":1,\"366\":1}}],[\"close\",{\"1\":{\"31\":9,\"405\":2,\"410\":2,\"411\":2,\"414\":3,\"415\":1}}],[\"closed\",{\"1\":{\"14\":1}}],[\"clearing\",{\"1\":{\"313\":1}}],[\"clear函数用于清空arrayblockingqueue\",{\"1\":{\"277\":1}}],[\"clear函数\",{\"0\":{\"277\":1}}],[\"clear\",{\"1\":{\"173\":1,\"277\":1,\"352\":1,\"353\":1,\"354\":1,\"393\":2,\"395\":1,\"405\":2,\"406\":4,\"410\":1,\"411\":1,\"414\":2,\"415\":3}}],[\"clientconnect\",{\"1\":{\"415\":1}}],[\"clienta不关闭不断发送数据给服务端\",{\"1\":{\"413\":1}}],[\"client的数据\",{\"1\":{\"101\":1}}],[\"client\",{\"1\":{\"31\":1,\"36\":1,\"41\":1,\"44\":1,\"47\":1,\"50\":1,\"54\":1,\"56\":1,\"57\":1,\"63\":1,\"411\":1,\"414\":3,\"415\":8}}],[\"class转化为object类型\",{\"1\":{\"237\":1}}],[\"class<\",{\"1\":{\"233\":1,\"237\":1,\"256\":3,\"259\":1}}],[\"classnotfoundexception\",{\"1\":{\"183\":1}}],[\"class\",{\"1\":{\"18\":1,\"19\":2,\"20\":2,\"22\":1,\"23\":1,\"26\":3,\"31\":4,\"36\":5,\"41\":5,\"44\":3,\"47\":4,\"50\":3,\"54\":3,\"56\":2,\"57\":2,\"97\":1,\"98\":2,\"110\":2,\"119\":1,\"121\":2,\"131\":2,\"132\":1,\"139\":2,\"142\":3,\"143\":2,\"146\":1,\"147\":4,\"158\":3,\"159\":1,\"160\":1,\"166\":2,\"168\":1,\"170\":6,\"175\":4,\"179\":1,\"180\":1,\"183\":2,\"184\":1,\"185\":1,\"187\":4,\"191\":2,\"194\":1,\"195\":1,\"197\":1,\"203\":1,\"206\":1,\"207\":1,\"208\":1,\"219\":1,\"220\":1,\"221\":1,\"230\":1,\"232\":1,\"233\":2,\"234\":4,\"235\":1,\"237\":1,\"247\":1,\"249\":1,\"256\":5,\"267\":3,\"269\":1,\"270\":1,\"281\":1,\"282\":1,\"288\":2,\"313\":1,\"315\":1,\"317\":1,\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":2,\"352\":1,\"353\":1,\"354\":1,\"358\":1,\"359\":2,\"364\":1,\"393\":1,\"395\":1,\"405\":1,\"406\":1,\"414\":1,\"415\":1,\"418\":5,\"419\":5,\"424\":3,\"432\":1,\"435\":5,\"436\":2,\"438\":3}}],[\"分布均匀性\",{\"1\":{\"431\":1}}],[\"分布式系统和高性能计算等领域\",{\"1\":{\"403\":1}}],[\"分为两个子类\",{\"1\":{\"346\":1}}],[\"分为共享与独占\",{\"1\":{\"168\":1}}],[\"分而治之\",{\"1\":{\"345\":1}}],[\"分段锁的基本思想是将整个数据结构分成多个段\",{\"1\":{\"245\":1}}],[\"分析源码可以知道\",{\"1\":{\"205\":1}}],[\"分析acquirequeue函数\",{\"1\":{\"173\":1}}],[\"分组是\",{\"1\":{\"103\":1}}],[\"分组是将同一组多个的相同的告警消息合并成一个高级消息\",{\"1\":{\"103\":1}}],[\"分组\",{\"0\":{\"103\":1},\"1\":{\"102\":1}}],[\"分组修改器可以一边的标签组赋值给另一边的查询结构\",{\"1\":{\"89\":1}}],[\"分组修改器可以实现many\",{\"1\":{\"89\":1}}],[\"分组修改器\",{\"0\":{\"89\":1}}],[\"分别引用了\",{\"1\":{\"424\":1}}],[\"分别表示节点的数据\",{\"1\":{\"366\":1}}],[\"分别表示链表的大小\",{\"1\":{\"366\":1}}],[\"分别执行两个账户之间的资金转移\",{\"1\":{\"139\":1,\"142\":1,\"143\":1}}],[\"分别为node类与conditionobject类\",{\"1\":{\"167\":1}}],[\"分别为setexclusiveownerthread与getexclusiveownerthread方法\",{\"1\":{\"166\":1}}],[\"分别为\",{\"1\":{\"97\":1,\"359\":1}}],[\"分别是list\",{\"1\":{\"222\":1}}],[\"分别是reentrantlock\",{\"1\":{\"218\":1}}],[\"分别是\",{\"1\":{\"106\":1}}],[\"分别是code\",{\"1\":{\"90\":1}}],[\"分别是员工\",{\"1\":{\"36\":1}}],[\"分别是创建性型设计模式\",{\"1\":{\"9\":1}}],[\"分钟\",{\"1\":{\"82\":1}}],[\"分发\",{\"1\":{\"64\":1}}],[\"分成多个小的逻辑单元\",{\"1\":{\"37\":1}}],[\"分配内存空间\",{\"1\":{\"19\":1,\"121\":1}}],[\"13\",{\"1\":{\"395\":1}}],[\"1363728e+07\",{\"1\":{\"68\":1}}],[\"1460\",{\"1\":{\"392\":1}}],[\"1+2\",{\"1\":{\"349\":1}}],[\"1之间\",{\"1\":{\"295\":1}}],[\"1替换\",{\"1\":{\"259\":1}}],[\"1l\",{\"1\":{\"259\":1,\"261\":1}}],[\"16220051\",{\"1\":{\"320\":1}}],[\"16\",{\"1\":{\"256\":4,\"376\":1,\"385\":1,\"393\":2}}],[\"1696984033\",{\"1\":{\"74\":2}}],[\"1696984153\",{\"1\":{\"74\":2}}],[\"1696984318\",{\"1\":{\"74\":2}}],[\"1m\",{\"1\":{\"94\":2,\"100\":2,\"108\":2,\"113\":1,\"116\":2}}],[\"175\",{\"1\":{\"89\":1}}],[\"171390910999984\",{\"1\":{\"78\":1}}],[\"1d\",{\"1\":{\"83\":1}}],[\"128\",{\"1\":{\"429\":1}}],[\"123\",{\"1\":{\"288\":3}}],[\"127\",{\"1\":{\"97\":3,\"98\":1,\"106\":1,\"107\":1,\"108\":3,\"415\":2}}],[\"1255515\",{\"1\":{\"79\":1}}],[\"120665690\",{\"1\":{\"111\":1}}],[\"120\",{\"1\":{\"78\":1,\"89\":4,\"94\":1}}],[\"1205\",{\"1\":{\"74\":3,\"75\":1}}],[\"15\",{\"1\":{\"78\":1,\"395\":1}}],[\"15s\",{\"1\":{\"68\":2}}],[\"1st\",{\"1\":{\"376\":2}}],[\"1s\",{\"1\":{\"78\":1}}],[\"18\",{\"1\":{\"262\":1}}],[\"1831\",{\"1\":{\"78\":7}}],[\"1830\",{\"1\":{\"78\":1}}],[\"1829\",{\"1\":{\"78\":1}}],[\"1828\",{\"1\":{\"78\":1}}],[\"1827\",{\"1\":{\"78\":1}}],[\"1h\",{\"1\":{\"77\":1,\"106\":1,\"107\":1}}],[\"11\",{\"1\":{\"97\":1}}],[\"1186\",{\"1\":{\"74\":2}}],[\"1194\",{\"1\":{\"74\":2}}],[\"1024\",{\"1\":{\"306\":1,\"395\":1,\"405\":1,\"410\":1,\"411\":1,\"414\":1,\"415\":1}}],[\"1000l\",{\"1\":{\"170\":1}}],[\"1000\",{\"1\":{\"132\":1,\"160\":2,\"175\":1,\"267\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1}}],[\"10000\",{\"1\":{\"36\":1}}],[\"100\",{\"1\":{\"131\":1,\"139\":4,\"142\":3,\"143\":3}}],[\"10s\",{\"1\":{\"107\":1}}],[\"10ms\",{\"1\":{\"78\":1}}],[\"10ms的请求有多少个\",{\"1\":{\"78\":1}}],[\"10\",{\"1\":{\"71\":2,\"98\":1,\"132\":1,\"139\":4,\"142\":2,\"143\":2,\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"361\":1,\"406\":2,\"423\":1,\"432\":1,\"438\":2}}],[\"1\",{\"0\":{\"305\":1},\"1\":{\"19\":1,\"26\":1,\"31\":3,\"67\":2,\"68\":4,\"71\":2,\"78\":3,\"79\":1,\"90\":2,\"94\":2,\"97\":3,\"98\":4,\"106\":1,\"107\":1,\"108\":4,\"120\":1,\"121\":1,\"130\":1,\"143\":1,\"147\":2,\"160\":1,\"168\":4,\"173\":2,\"175\":4,\"184\":2,\"185\":1,\"197\":3,\"198\":4,\"199\":2,\"224\":2,\"235\":1,\"238\":1,\"239\":1,\"241\":6,\"247\":3,\"248\":2,\"256\":7,\"259\":12,\"260\":1,\"261\":2,\"267\":1,\"273\":1,\"275\":1,\"293\":2,\"295\":2,\"305\":1,\"309\":6,\"311\":1,\"313\":2,\"314\":1,\"317\":1,\"323\":6,\"328\":1,\"329\":1,\"331\":1,\"332\":2,\"336\":1,\"340\":1,\"349\":2,\"352\":1,\"358\":2,\"360\":2,\"361\":2,\"362\":2,\"363\":3,\"364\":3,\"369\":2,\"376\":10,\"377\":3,\"378\":2,\"382\":1,\"383\":3,\"385\":1,\"392\":2,\"393\":1,\"395\":7,\"401\":1,\"403\":1,\"405\":1,\"414\":1,\"415\":4,\"429\":3,\"435\":2,\"438\":2}}],[\"md\",{\"1\":{\"176\":1,\"350\":1}}],[\"mutable\",{\"1\":{\"421\":1}}],[\"mutual\",{\"1\":{\"140\":1,\"219\":1,\"271\":1}}],[\"must\",{\"1\":{\"173\":1,\"183\":1,\"318\":2,\"329\":2}}],[\"multiplication\",{\"1\":{\"85\":1}}],[\"moved\",{\"1\":{\"256\":1,\"259\":1,\"261\":1}}],[\"monitor的进入数减1\",{\"1\":{\"147\":1}}],[\"monitorexit\",{\"1\":{\"147\":1}}],[\"monitorenter\",{\"1\":{\"147\":1}}],[\"monitor\",{\"1\":{\"147\":2,\"148\":1,\"152\":1}}],[\"more\",{\"1\":{\"107\":3}}],[\"modcount\",{\"1\":{\"364\":6}}],[\"modcount++\",{\"1\":{\"360\":2,\"362\":1}}],[\"mode\",{\"1\":{\"168\":2,\"173\":2}}],[\"modelandview\",{\"1\":{\"98\":3}}],[\"modifiers\",{\"0\":{\"89\":1}}],[\"modulo\",{\"1\":{\"85\":1}}],[\"mid\",{\"1\":{\"349\":3}}],[\"milliseconds\",{\"1\":{\"306\":1}}],[\"might\",{\"1\":{\"234\":1,\"361\":1}}],[\"misc\",{\"1\":{\"175\":1,\"233\":2,\"256\":2,\"317\":1}}],[\"micrometer<\",{\"1\":{\"97\":1}}],[\"minlength\",{\"1\":{\"361\":4}}],[\"mingrowth\",{\"1\":{\"361\":7}}],[\"mincapacity\",{\"1\":{\"361\":3}}],[\"minutes\",{\"1\":{\"107\":1}}],[\"minimum\",{\"1\":{\"90\":1,\"361\":1}}],[\"min\",{\"1\":{\"90\":1,\"237\":1,\"239\":1,\"256\":2,\"259\":1}}],[\"m\",{\"1\":{\"82\":2,\"259\":3,\"415\":5}}],[\"mymethod\",{\"1\":{\"438\":6}}],[\"myjob\",{\"1\":{\"115\":9}}],[\"my\",{\"1\":{\"68\":1}}],[\"mysql等\",{\"1\":{\"63\":1}}],[\"meow\",{\"1\":{\"424\":2}}],[\"mechanics\",{\"1\":{\"256\":1}}],[\"memory\",{\"1\":{\"145\":1}}],[\"memory=allocate\",{\"1\":{\"19\":1,\"121\":1}}],[\"memstats\",{\"1\":{\"68\":9}}],[\"metric\",{\"1\":{\"74\":1,\"81\":1,\"115\":2}}],[\"metrics|\",{\"1\":{\"81\":2}}],[\"metrics接口耗时\",{\"1\":{\"78\":1}}],[\"metrics接口来获取自身的数据\",{\"1\":{\"74\":1}}],[\"metrics接口暴露\",{\"1\":{\"74\":1}}],[\"metrics\",{\"1\":{\"68\":1,\"69\":1,\"74\":9,\"75\":1,\"78\":12,\"81\":6,\"82\":1,\"85\":5,\"90\":1,\"92\":5,\"94\":13,\"98\":11,\"108\":1,\"116\":2}}],[\"methodname\",{\"1\":{\"146\":2}}],[\"methods\",{\"1\":{\"146\":1,\"183\":1}}],[\"method=\",{\"1\":{\"89\":14,\"97\":3}}],[\"methodproxy\",{\"1\":{\"57\":2}}],[\"methodinterceptor\",{\"1\":{\"57\":1}}],[\"method\",{\"1\":{\"42\":1,\"56\":5,\"57\":3,\"89\":12,\"147\":3,\"311\":1,\"361\":1}}],[\"mcclient\",{\"1\":{\"26\":1}}],[\"mark\",{\"1\":{\"406\":2}}],[\"marker\",{\"1\":{\"168\":1}}],[\"mayinterruptifrunning\",{\"1\":{\"326\":1,\"332\":2}}],[\"map=new\",{\"1\":{\"376\":1}}],[\"map接口\",{\"0\":{\"354\":1}}],[\"map等\",{\"1\":{\"351\":1}}],[\"map\",{\"0\":{\"224\":1},\"1\":{\"219\":1,\"221\":1,\"222\":1,\"224\":1,\"247\":8,\"282\":7,\"351\":1,\"354\":10,\"376\":4,\"385\":3,\"386\":1,\"387\":1,\"388\":1}}],[\"map<string\",{\"1\":{\"110\":5,\"219\":1,\"220\":1,\"221\":1,\"354\":1,\"376\":1}}],[\"maxelements\",{\"1\":{\"265\":1}}],[\"maximumpoolsize\",{\"1\":{\"294\":6,\"308\":1,\"312\":1,\"314\":1}}],[\"maximum\",{\"1\":{\"90\":1,\"183\":1,\"185\":1,\"256\":1,\"259\":1,\"375\":2,\"377\":2}}],[\"max\",{\"1\":{\"90\":1,\"97\":4,\"110\":1,\"256\":3,\"259\":2,\"265\":1,\"304\":1,\"361\":7,\"377\":1,\"385\":1}}],[\"mango\",{\"1\":{\"352\":4}}],[\"managedblocker\",{\"1\":{\"347\":1}}],[\"management\",{\"1\":{\"97\":1}}],[\"manager\",{\"1\":{\"36\":6}}],[\"manager继承了aproval\",{\"1\":{\"36\":1}}],[\"many的向量匹配\",{\"1\":{\"89\":1}}],[\"many\",{\"1\":{\"88\":1,\"110\":1}}],[\"math\",{\"1\":{\"237\":1,\"239\":1,\"361\":2,\"385\":1,\"395\":1,\"419\":1}}],[\"match\",{\"1\":{\"106\":2,\"107\":4}}],[\"matches\",{\"1\":{\"88\":2}}],[\"matching\",{\"0\":{\"88\":1},\"1\":{\"88\":1}}],[\"matter\",{\"1\":{\"1\":1,\"2\":1}}],[\"machine\",{\"1\":{\"433\":2}}],[\"mac的版本\",{\"1\":{\"67\":1}}],[\"mac连接typec\",{\"1\":{\"26\":1}}],[\"makesound\",{\"1\":{\"419\":5,\"424\":9}}],[\"makesofa\",{\"1\":{\"47\":3}}],[\"make\",{\"1\":{\"173\":1}}],[\"maketable\",{\"1\":{\"47\":3}}],[\"mainlock\",{\"1\":{\"312\":5,\"319\":16}}],[\"mainly\",{\"1\":{\"256\":1}}],[\"maintained\",{\"1\":{\"282\":1}}],[\"main\",{\"1\":{\"24\":2,\"26\":1,\"31\":1,\"36\":1,\"41\":1,\"44\":1,\"47\":1,\"50\":1,\"54\":1,\"56\":1,\"57\":1,\"119\":1,\"131\":1,\"132\":1,\"139\":1,\"142\":1,\"143\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"187\":1,\"191\":2,\"203\":1,\"230\":1,\"247\":1,\"267\":1,\"281\":1,\"288\":1,\"313\":1,\"315\":1,\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":1,\"352\":1,\"353\":1,\"354\":1,\"383\":1,\"393\":1,\"405\":1,\"406\":1,\"414\":1,\"415\":1,\"418\":2,\"419\":2,\"432\":1,\"435\":1,\"436\":1,\"438\":3}}],[\"需要先安装jre\",{\"1\":{\"433\":1}}],[\"需要遵循以下几个规则\",{\"1\":{\"430\":1}}],[\"需要包装类的原因有以下几个方面\",{\"1\":{\"423\":1}}],[\"需要取消注册或更新感兴趣的事件\",{\"1\":{\"407\":1}}],[\"需要进行同步处理或使用线程安全的替代品\",{\"1\":{\"389\":1}}],[\"需要进行扩容操作\",{\"1\":{\"376\":1}}],[\"需要进行unpark操作\",{\"1\":{\"168\":1}}],[\"需要\",{\"1\":{\"312\":1}}],[\"需要综合考虑任务的类型\",{\"1\":{\"295\":1}}],[\"需要频繁的创建线程和销毁线程\",{\"1\":{\"291\":1}}],[\"需要大约2mb的内存\",{\"1\":{\"291\":1}}],[\"需要将父类引用的变量进行转换成子类的类型\",{\"1\":{\"424\":1}}],[\"需要将某些用户级别的上下文信息在同一个线程中共享\",{\"1\":{\"283\":1}}],[\"需要将变量count从内存加载到cpu的寄存器\",{\"1\":{\"120\":1}}],[\"需要在多个方法之间共享事务状态\",{\"1\":{\"283\":1}}],[\"需要指定队列的容量\",{\"1\":{\"297\":1}}],[\"需要指定队列的长度\",{\"1\":{\"266\":1}}],[\"需要指定长度\",{\"1\":{\"266\":1}}],[\"需要移动的元素个数\",{\"1\":{\"241\":1}}],[\"需要根据具体需求选择适合的队列类型\",{\"1\":{\"226\":1}}],[\"需要特别注意的是\",{\"1\":{\"226\":1}}],[\"需要特别注意并发编程中的可见性\",{\"1\":{\"118\":1}}],[\"需要使用validate方法进行数据验证\",{\"1\":{\"221\":1}}],[\"需要使用validate方法验证数据是否被其他线程修改\",{\"1\":{\"221\":1}}],[\"需要使用锁机制来保护临界区\",{\"1\":{\"147\":1}}],[\"需要条件等待的场景\",{\"1\":{\"218\":1}}],[\"需要查询订单和派单的数量\",{\"1\":{\"191\":1}}],[\"需要调用\",{\"1\":{\"190\":1}}],[\"需要具体的子类实现\",{\"1\":{\"174\":1}}],[\"需要其他线程显式地调用相应的唤醒操作\",{\"1\":{\"159\":1}}],[\"需要其他线程通过唤醒操作才能继续执行\",{\"1\":{\"159\":1}}],[\"需要线程同步的代码块\",{\"1\":{\"146\":1}}],[\"需要合理地设计资源分配策略\",{\"1\":{\"140\":1}}],[\"需要程序员重点掌握\",{\"1\":{\"136\":1}}],[\"需要引入多处理器数据一致性协议\",{\"1\":{\"124\":1}}],[\"需要注意线程安全性\",{\"1\":{\"283\":1}}],[\"需要注意的是在使用父类引用的变量去调用方法时\",{\"1\":{\"424\":1}}],[\"需要注意的是虽然抽象类shape具有构造函数\",{\"1\":{\"419\":1}}],[\"需要注意的是\",{\"1\":{\"143\":1,\"283\":1,\"288\":1,\"326\":1,\"364\":1,\"379\":1,\"407\":1,\"419\":1,\"437\":1}}],[\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率\",{\"1\":{\"92\":1}}],[\"需要注意尽量减少不必要的线程切换\",{\"1\":{\"120\":1}}],[\"需要全局唯一\",{\"1\":{\"113\":1}}],[\"需要修改alertmanager的配置文件\",{\"1\":{\"106\":1}}],[\"需要修改抽象工厂的接口和具体工厂类\",{\"1\":{\"47\":1}}],[\"需要创建两个指标\",{\"1\":{\"98\":1}}],[\"需要为grafana配置prometheus的数据源\",{\"1\":{\"71\":1}}],[\"需要打开系统偏好设置\",{\"1\":{\"67\":1}}],[\"需要对问题进行调查和处理\",{\"1\":{\"65\":1}}],[\"需要对真实的代理对象的功能需要做一下加强\",{\"1\":{\"56\":1}}],[\"需要额外依赖\",{\"1\":{\"57\":1}}],[\"需要做性能测试\",{\"1\":{\"51\":1}}],[\"需要做更多的工作\",{\"1\":{\"51\":1}}],[\"需要权衡一下利弊\",{\"1\":{\"37\":1}}],[\"需要总裁审批\",{\"1\":{\"36\":2}}],[\"需要cfo审批\",{\"1\":{\"36\":1}}],[\"需要经理审批\",{\"1\":{\"36\":3}}],[\"需要不同的审批角色\",{\"1\":{\"36\":1}}],[\"需要扩展功能的时候\",{\"1\":{\"32\":1}}],[\"需要被适配的接口的实现类\",{\"1\":{\"26\":1}}],[\"需要被适配的接口usb接口\",{\"1\":{\"26\":1}}],[\"需要被适配器转换的对象\",{\"1\":{\"25\":1}}],[\"需要把typec接口转换成usb接口\",{\"1\":{\"25\":1}}],[\"需要第一次调用getsingleton\",{\"1\":{\"20\":1}}],[\"需要如下几步\",{\"1\":{\"19\":1,\"121\":1}}],[\"需要表示全局唯一的对象\",{\"1\":{\"16\":1}}],[\"nio的特点是由底层原理决定的\",{\"1\":{\"416\":1}}],[\"nio底层原理\",{\"0\":{\"416\":1}}],[\"nio案列实战\",{\"0\":{\"409\":1}}],[\"nio中的一些主要channel的实现\",{\"1\":{\"403\":1}}],[\"nio\",{\"1\":{\"403\":10,\"404\":2,\"405\":2,\"406\":3,\"407\":1,\"410\":1,\"411\":1,\"412\":1,\"414\":10,\"415\":6,\"416\":5}}],[\"nio学习总结\",{\"0\":{\"402\":1}}],[\"nlark\",{\"1\":{\"295\":2}}],[\"nt\",{\"1\":{\"259\":5}}],[\"n为默认初始容量\",{\"1\":{\"259\":1}}],[\"n\",{\"1\":{\"259\":13,\"260\":3,\"261\":3,\"358\":2,\"376\":1,\"377\":2,\"378\":4,\"430\":3}}],[\"ncpu\",{\"1\":{\"256\":1}}],[\"namingpattern\",{\"1\":{\"305\":1}}],[\"name2\",{\"1\":{\"418\":1}}],[\"name1\",{\"1\":{\"418\":1}}],[\"names\",{\"1\":{\"353\":14}}],[\"namedthreadfactory\",{\"1\":{\"306\":2}}],[\"name=lisi\",{\"1\":{\"97\":2,\"98\":1}}],[\"name+\",{\"1\":{\"50\":1}}],[\"name\",{\"1\":{\"50\":4,\"68\":1,\"69\":2,\"74\":1,\"97\":4,\"98\":6,\"99\":1,\"106\":1,\"107\":1,\"108\":1,\"113\":2,\"116\":1,\"288\":1,\"353\":4,\"354\":4,\"418\":1,\"435\":8}}],[\"nanoseconds\",{\"1\":{\"314\":2}}],[\"nanos\",{\"1\":{\"213\":5,\"317\":5,\"331\":5}}],[\"nanostimeout\",{\"1\":{\"169\":1}}],[\"nanotime\",{\"1\":{\"186\":2,\"317\":2,\"331\":2}}],[\"nul\",{\"1\":{\"368\":1}}],[\"null赋值\",{\"1\":{\"423\":1}}],[\"nulling\",{\"1\":{\"318\":1,\"329\":1}}],[\"nullpointerexception\",{\"1\":{\"168\":2,\"259\":1,\"294\":1,\"311\":1,\"316\":1}}],[\"null\",{\"1\":{\"19\":2,\"22\":1,\"23\":1,\"31\":11,\"41\":1,\"56\":1,\"121\":2,\"168\":2,\"173\":13,\"174\":1,\"175\":5,\"183\":2,\"186\":2,\"198\":5,\"199\":1,\"211\":1,\"213\":1,\"214\":5,\"256\":2,\"259\":45,\"260\":8,\"261\":19,\"270\":1,\"273\":1,\"275\":3,\"276\":1,\"277\":2,\"282\":4,\"288\":4,\"294\":5,\"311\":2,\"312\":4,\"313\":5,\"314\":3,\"316\":2,\"317\":4,\"318\":5,\"329\":5,\"331\":5,\"332\":1,\"333\":7,\"340\":1,\"362\":4,\"363\":5,\"368\":4,\"370\":12,\"376\":7,\"377\":19,\"378\":14,\"386\":3,\"388\":1,\"414\":4,\"415\":2,\"430\":1}}],[\"num2\",{\"1\":{\"432\":2}}],[\"num1\",{\"1\":{\"432\":2}}],[\"nummoved\",{\"1\":{\"241\":3}}],[\"num\",{\"1\":{\"187\":2}}],[\"numerator\",{\"1\":{\"115\":1}}],[\"numberofleadingzeros\",{\"1\":{\"256\":1}}],[\"number\",{\"1\":{\"68\":4,\"90\":2,\"208\":1,\"256\":2}}],[\"nginx\",{\"1\":{\"63\":1}}],[\"noblocking\",{\"1\":{\"416\":1}}],[\"normal\",{\"1\":{\"256\":1,\"317\":2,\"328\":2,\"329\":1}}],[\"normally\",{\"1\":{\"173\":1}}],[\"nosuchelementexception\",{\"1\":{\"235\":2,\"364\":1}}],[\"nosuchfieldexception\",{\"1\":{\"175\":1}}],[\"nonfair每一次都会尝试去获取资源\",{\"1\":{\"185\":1}}],[\"nonfairtryacquire\",{\"1\":{\"183\":1,\"184\":1}}],[\"nonfairsync类继承了sync类\",{\"1\":{\"184\":1}}],[\"nonfairsync类\",{\"0\":{\"184\":1}}],[\"nonfairsync\",{\"1\":{\"181\":2,\"184\":1}}],[\"non\",{\"1\":{\"173\":1,\"256\":1,\"318\":1,\"328\":1,\"329\":1}}],[\"none\",{\"1\":{\"97\":3,\"311\":1}}],[\"novisibility\",{\"1\":{\"131\":1}}],[\"no\",{\"1\":{\"115\":1,\"140\":1,\"141\":1,\"173\":1,\"185\":1,\"187\":8,\"240\":1,\"256\":1,\"259\":1}}],[\"notfull\",{\"1\":{\"270\":1,\"271\":1,\"273\":1,\"275\":1,\"277\":2}}],[\"notempty\",{\"1\":{\"270\":1,\"271\":1,\"273\":1,\"275\":1}}],[\"notification\",{\"1\":{\"107\":4}}],[\"notifyall\",{\"1\":{\"159\":1,\"160\":3}}],[\"notify等方法\",{\"1\":{\"147\":1}}],[\"notify等方法也依赖于monitor对象\",{\"1\":{\"147\":1}}],[\"notify\",{\"1\":{\"50\":7,\"159\":1}}],[\"not\",{\"1\":{\"86\":1,\"173\":1,\"175\":1,\"213\":1,\"234\":1,\"235\":6,\"240\":1,\"256\":1,\"271\":1,\"313\":2,\"361\":1}}],[\"node<>\",{\"1\":{\"368\":1}}],[\"node<e>\",{\"1\":{\"368\":1,\"369\":3,\"370\":4}}],[\"node<\",{\"1\":{\"259\":1}}],[\"node<k\",{\"1\":{\"256\":2,\"259\":22,\"260\":2,\"261\":3,\"376\":2,\"377\":6,\"378\":5}}],[\"node结点不为尾结点\",{\"1\":{\"173\":1}}],[\"node结点为尾结点\",{\"1\":{\"173\":1}}],[\"nodes\",{\"1\":{\"173\":1,\"256\":1}}],[\"node为空\",{\"1\":{\"173\":1}}],[\"node类主要用于存储具体键值对\",{\"1\":{\"251\":1}}],[\"node类\",{\"0\":{\"168\":1,\"251\":1}}],[\"node\",{\"1\":{\"59\":1,\"66\":1,\"69\":4,\"77\":4,\"93\":2,\"168\":13,\"170\":4,\"173\":66,\"174\":1,\"198\":18,\"199\":4,\"214\":20,\"256\":2,\"366\":7,\"369\":4,\"370\":2,\"374\":4,\"377\":2}}],[\"never\",{\"1\":{\"438\":1}}],[\"negative\",{\"1\":{\"173\":1,\"256\":1}}],[\"necessary\",{\"1\":{\"173\":1,\"311\":2,\"312\":1,\"314\":1}}],[\"needing\",{\"1\":{\"173\":1}}],[\"needs\",{\"1\":{\"173\":1}}],[\"need\",{\"1\":{\"173\":2,\"183\":1,\"311\":1}}],[\"nextsetbit\",{\"1\":{\"395\":4}}],[\"next指向当前节点后一个节点\",{\"1\":{\"366\":1}}],[\"nextthreadid\",{\"1\":{\"288\":1}}],[\"nexttab\",{\"1\":{\"259\":5}}],[\"nexttable\",{\"1\":{\"256\":1,\"259\":3}}],[\"nextindex\",{\"1\":{\"235\":1}}],[\"next项\",{\"1\":{\"235\":1}}],[\"nextgeneration函数\",{\"0\":{\"214\":1}}],[\"nextgeneration\",{\"1\":{\"213\":1,\"214\":1}}],[\"nextc\",{\"1\":{\"183\":3,\"185\":3,\"197\":3,\"199\":3}}],[\"nextoffset\",{\"1\":{\"170\":2}}],[\"next内存偏移地址\",{\"1\":{\"170\":1}}],[\"nextwaiter\",{\"1\":{\"168\":3,\"214\":2}}],[\"next\",{\"1\":{\"168\":1,\"170\":1,\"173\":16,\"198\":2,\"214\":4,\"235\":2,\"256\":2,\"259\":4,\"260\":1,\"261\":5,\"317\":1,\"331\":1,\"333\":5,\"364\":3,\"366\":2,\"368\":2,\"369\":1,\"370\":18,\"376\":2,\"377\":9,\"378\":2,\"412\":1,\"414\":1}}],[\"nextapproval\",{\"1\":{\"36\":5}}],[\"net\",{\"1\":{\"111\":1,\"320\":1,\"414\":1,\"415\":1}}],[\"newnode\",{\"1\":{\"368\":9,\"376\":2}}],[\"newsize实际上是减一了\",{\"1\":{\"362\":1}}],[\"newsize\",{\"1\":{\"362\":4}}],[\"newsinglethreadexecutor\",{\"1\":{\"323\":1,\"336\":1}}],[\"newstate\",{\"1\":{\"163\":2}}],[\"newcap\",{\"1\":{\"377\":6}}],[\"newcapacity\",{\"1\":{\"361\":2}}],[\"newcachedthreadpool\",{\"1\":{\"315\":1}}],[\"newcachedthreadpool和newscheduledthreadpool\",{\"1\":{\"304\":1}}],[\"newcondition\",{\"1\":{\"179\":1,\"183\":1,\"186\":1,\"187\":2,\"208\":1,\"271\":2}}],[\"newelements\",{\"1\":{\"238\":4,\"239\":3,\"240\":3,\"241\":4}}],[\"newinstance\",{\"1\":{\"237\":1}}],[\"newtab\",{\"1\":{\"377\":6}}],[\"newtaskfor\",{\"1\":{\"316\":1}}],[\"newthr\",{\"1\":{\"377\":2}}],[\"newthread\",{\"1\":{\"156\":2,\"157\":2,\"313\":2}}],[\"newthread=new\",{\"1\":{\"156\":1}}],[\"newtype\",{\"1\":{\"237\":3}}],[\"newlength\",{\"1\":{\"237\":4,\"361\":2}}],[\"newgeneration函数的主要方法的调用如下\",{\"1\":{\"214\":1}}],[\"newfixedthreadpool和newsinglethreadexecutor\",{\"1\":{\"304\":1}}],[\"newfixedthreadpool\",{\"1\":{\"191\":1,\"203\":1,\"323\":1}}],[\"newproxyinstance\",{\"1\":{\"56\":1}}],[\"new\",{\"0\":{\"156\":1},\"1\":{\"18\":1,\"19\":1,\"20\":1,\"22\":1,\"23\":1,\"26\":2,\"29\":2,\"31\":18,\"36\":3,\"41\":3,\"44\":2,\"47\":3,\"50\":3,\"54\":2,\"56\":2,\"57\":3,\"98\":1,\"107\":1,\"119\":2,\"121\":1,\"131\":1,\"132\":2,\"139\":6,\"142\":8,\"143\":6,\"146\":1,\"155\":2,\"156\":2,\"157\":1,\"158\":1,\"159\":3,\"160\":5,\"168\":2,\"170\":1,\"173\":2,\"175\":2,\"181\":3,\"183\":3,\"185\":1,\"186\":2,\"187\":10,\"191\":4,\"196\":2,\"198\":2,\"203\":2,\"208\":2,\"210\":1,\"213\":4,\"214\":3,\"219\":2,\"220\":2,\"221\":2,\"230\":1,\"233\":2,\"234\":1,\"235\":5,\"237\":1,\"241\":1,\"247\":1,\"256\":5,\"259\":8,\"267\":5,\"271\":4,\"281\":4,\"282\":1,\"288\":4,\"294\":2,\"305\":2,\"306\":4,\"308\":2,\"309\":1,\"311\":4,\"312\":3,\"313\":1,\"315\":1,\"316\":1,\"317\":8,\"318\":2,\"323\":3,\"328\":2,\"329\":4,\"331\":2,\"332\":3,\"336\":1,\"349\":4,\"352\":1,\"353\":1,\"354\":1,\"359\":2,\"361\":2,\"364\":5,\"368\":1,\"369\":1,\"370\":1,\"375\":2,\"377\":1,\"385\":3,\"393\":2,\"395\":8,\"403\":1,\"405\":1,\"410\":1,\"411\":1,\"414\":2,\"415\":6,\"419\":1,\"424\":2,\"429\":1,\"436\":3}}],[\"可变性\",{\"1\":{\"421\":1}}],[\"可变大小\",{\"1\":{\"352\":1}}],[\"可维护性和可扩展性\",{\"1\":{\"420\":1}}],[\"可对读取到的字符数据经过指定编码转换成字节\",{\"1\":{\"401\":1}}],[\"可对读取到的字节数据经过指定编码转换成字符\",{\"1\":{\"401\":1}}],[\"可重复性\",{\"1\":{\"352\":1}}],[\"可重入锁\",{\"1\":{\"208\":1,\"218\":1,\"233\":1,\"238\":1,\"240\":1,\"241\":1,\"270\":1,\"271\":1,\"274\":1,\"275\":1,\"277\":1}}],[\"可重入锁等\",{\"1\":{\"152\":1}}],[\"可重入性\",{\"1\":{\"188\":1,\"218\":1,\"220\":1}}],[\"可方便地对异步计算结果进行后续处理\",{\"1\":{\"337\":1}}],[\"可为null\",{\"1\":{\"224\":5}}],[\"可为什么没有得到我们预期的结果呢\",{\"1\":{\"132\":1}}],[\"可知其父类是object\",{\"1\":{\"194\":1,\"206\":1}}],[\"可这时它不需要读取inc\",{\"1\":{\"132\":1}}],[\"可见性和顺序性保证\",{\"1\":{\"145\":1}}],[\"可见性是指共享数据的时候\",{\"1\":{\"127\":1}}],[\"可见性\",{\"0\":{\"127\":1},\"1\":{\"119\":1,\"123\":1,\"125\":1,\"145\":1}}],[\"可选参数\",{\"1\":{\"108\":1}}],[\"可选\",{\"1\":{\"98\":2}}],[\"可用通过prometheus的内置函数计算最近5分钟node\",{\"1\":{\"77\":1}}],[\"可增可减\",{\"1\":{\"75\":1}}],[\"可拓展性\",{\"1\":{\"56\":1}}],[\"可扩展性和易维护性\",{\"1\":{\"424\":1}}],[\"可扩展性和重用性\",{\"1\":{\"422\":1}}],[\"可扩展性很强\",{\"1\":{\"51\":1}}],[\"可扩展和可维护的链式处理的机制\",{\"1\":{\"37\":1}}],[\"可复用\",{\"1\":{\"27\":1}}],[\"可能在继承链中得到两个相同的父类实例\",{\"1\":{\"420\":1}}],[\"可能在某一时刻访问量突增\",{\"1\":{\"92\":1}}],[\"可能需要移动大量元素\",{\"1\":{\"358\":1}}],[\"可能是来自于刚刚提交到\",{\"1\":{\"347\":1}}],[\"可能进行了set操作\",{\"1\":{\"239\":1}}],[\"可能有这样的疑问\",{\"1\":{\"132\":1}}],[\"可能有很多人比较疑惑\",{\"1\":{\"27\":1}}],[\"可能会发生异常的代码\",{\"1\":{\"437\":1}}],[\"可能会发生指令重排\",{\"1\":{\"135\":1}}],[\"可能会产生命名冲突\",{\"1\":{\"420\":1}}],[\"可能会创建数量非常多的线程\",{\"1\":{\"304\":1}}],[\"可能会遇到更大的调度开销\",{\"1\":{\"300\":1}}],[\"可能会导致系统中的线程数量过度膨胀\",{\"1\":{\"291\":1}}],[\"可能会导致获取锁的顺序不一致\",{\"1\":{\"143\":1}}],[\"可能会导致共享数据出现意外的错误\",{\"1\":{\"124\":1}}],[\"可能会同时存在多个实例的创建\",{\"1\":{\"22\":1}}],[\"可能通过cpu缓存而不是直接写入内存\",{\"1\":{\"120\":1}}],[\"可能问的少一些\",{\"1\":{\"19\":1}}],[\"可以对其进行修改\",{\"1\":{\"421\":1}}],[\"可以对时间序列提供丰富的查询\",{\"1\":{\"80\":1}}],[\"可以被捕获并进行相应处理\",{\"1\":{\"432\":1}}],[\"可以被多个线程同时访问而不会导致错误\",{\"1\":{\"421\":1}}],[\"可以被类实现\",{\"1\":{\"419\":1}}],[\"可以被继承\",{\"1\":{\"419\":1}}],[\"可以被重置并再次使用\",{\"1\":{\"202\":1}}],[\"可以包含普通方法的实现\",{\"1\":{\"419\":1}}],[\"可以包含普通方法和抽象方法\",{\"1\":{\"419\":1}}],[\"可以包含抽象方法\",{\"1\":{\"419\":1}}],[\"可以直接通过接口名调用\",{\"1\":{\"419\":1}}],[\"可以直接通过接口名直接访问\",{\"1\":{\"419\":1}}],[\"可以直接将数据从缓冲区读取到通道\",{\"1\":{\"404\":1}}],[\"可以与选择器\",{\"1\":{\"411\":1}}],[\"可以有构造方法\",{\"1\":{\"419\":1}}],[\"可以有实例变量和构造方法\",{\"1\":{\"419\":1}}],[\"可以有效地管理缓冲区的状态\",{\"1\":{\"406\":1}}],[\"可以有以下几个配置项\",{\"1\":{\"113\":1}}],[\"可以存储不同类型的数据\",{\"1\":{\"406\":1}}],[\"可以同时处理多个通道的\",{\"1\":{\"404\":1}}],[\"可以以非阻塞的方式进行读写操作\",{\"1\":{\"404\":1}}],[\"可以监听新进来的tcp连接\",{\"1\":{\"403\":1}}],[\"可以非阻塞地进行读写操作\",{\"1\":{\"403\":1}}],[\"可以说是一个达到此功能\",{\"1\":{\"401\":1}}],[\"可以认为是一个工具类\",{\"1\":{\"401\":1}}],[\"可以处理二进制和文本数据\",{\"1\":{\"398\":1}}],[\"可以从头结点遍历到尾结点\",{\"1\":{\"366\":1}}],[\"可以添加或删除元素\",{\"1\":{\"352\":1}}],[\"可以提高代码的性能和可读性\",{\"1\":{\"343\":1}}],[\"可以简化异步编程的复杂性\",{\"1\":{\"337\":1}}],[\"可以利用\",{\"1\":{\"337\":1}}],[\"可以利用发布者向所有的观察者发送消息\",{\"1\":{\"51\":1}}],[\"可以等待异步操作的完成并获取计算结果\",{\"1\":{\"337\":1}}],[\"可以解决上面的问题\",{\"1\":{\"336\":1}}],[\"可以设置超时时间\",{\"1\":{\"323\":2,\"336\":1}}],[\"可以设置独占资源线程和获取独占资源线程\",{\"1\":{\"166\":1}}],[\"可以手动创建一个线程来执行futuretask\",{\"1\":{\"323\":1}}],[\"可以实现在单个线程中处理多个通道的\",{\"1\":{\"407\":1}}],[\"可以实现异步提交任务\",{\"1\":{\"323\":1}}],[\"可以实现线程之间的协调和同步\",{\"1\":{\"190\":1}}],[\"可以获取执行完的返回值\",{\"1\":{\"316\":1}}],[\"可以获取和设置该属性的值\",{\"1\":{\"170\":1}}],[\"可以方便的实现工作线程的中止操作\",{\"1\":{\"313\":1}}],[\"可以方便地创建出不同的产品对象\",{\"1\":{\"44\":1}}],[\"可以最大限度地减少cpu使用率\",{\"1\":{\"300\":1}}],[\"可以控制线程池中线程的数量\",{\"1\":{\"296\":1}}],[\"可以调用线程池的关闭方法进行关闭操作\",{\"1\":{\"293\":1}}],[\"可以调用客户端对它们调用\",{\"1\":{\"26\":1}}],[\"可以接收新的任务并执行\",{\"1\":{\"293\":1}}],[\"可以更好地适应业务需求\",{\"1\":{\"291\":1}}],[\"可以更方便地管理线程的执行状态\",{\"1\":{\"291\":1}}],[\"可以立即执行任务\",{\"1\":{\"291\":1}}],[\"可以发现\",{\"1\":{\"288\":2}}],[\"可以为每个线程创建独立的变量副本\",{\"1\":{\"280\":1}}],[\"可以保证多线程环境下不会重复添加元素\",{\"1\":{\"239\":1}}],[\"可以把它们分为四类\",{\"1\":{\"222\":1}}],[\"可以选择是否使用公平策略\",{\"1\":{\"220\":1}}],[\"可以进行服务器的初始化\",{\"1\":{\"411\":1}}],[\"可以进行连接的建立\",{\"1\":{\"410\":1}}],[\"可以进行park操作\",{\"1\":{\"173\":1}}],[\"可以进行序列化\",{\"1\":{\"166\":1}}],[\"可以看出只要资源被其他线程占用\",{\"1\":{\"185\":1}}],[\"可以看前面的文章\",{\"1\":{\"178\":1}}],[\"可以看成是组合式\",{\"1\":{\"164\":1}}],[\"可以看到每个线程都有自己独立的变量副本\",{\"1\":{\"281\":1}}],[\"可以看到arrayblockingqueue继承了abstractqueue抽象类\",{\"1\":{\"269\":1}}],[\"可以看到alertmanager的界面\",{\"1\":{\"107\":1}}],[\"可以看到是通过unsafe对象通过反射获取的\",{\"1\":{\"259\":1}}],[\"可以看到\",{\"1\":{\"215\":1,\"250\":1}}],[\"可以看到callable是个泛型接口\",{\"1\":{\"325\":1}}],[\"可以看到cyclicbarrier没有显示继承哪个父类或者实现哪个父接口\",{\"1\":{\"206\":1}}],[\"可以看到countdownlatch类的内部只有一个sync类型的属性\",{\"1\":{\"195\":1}}],[\"可以看到countdownlatch没有显示继承哪个父类或者实现哪个父接口\",{\"1\":{\"194\":1}}],[\"可以看到已经有一条告警消息已经发送给alertmanager\",{\"1\":{\"108\":1}}],[\"可以看到的规则状态如下\",{\"1\":{\"108\":1}}],[\"可以看到有两个指标http\",{\"1\":{\"98\":1}}],[\"可以将多个\",{\"1\":{\"412\":1}}],[\"可以将多个连续的加锁与解锁操作合并成一个更大的同步代码块\",{\"1\":{\"153\":1}}],[\"可以将缓冲区中未读完的数据移到缓冲区的开头\",{\"1\":{\"406\":1}}],[\"可以将集合中的数据全部添加到新创建的hashset集合中\",{\"1\":{\"385\":1}}],[\"可以将hashset以流的形式通过objesctinputstream\",{\"1\":{\"381\":1,\"391\":1}}],[\"可以将hashmap以流的形式通过objectinputstream\",{\"1\":{\"373\":1}}],[\"可以将arraylist以流的形式通过objectinputstream\",{\"1\":{\"357\":1}}],[\"可以将futuretask提交至线程池中等待被执行\",{\"1\":{\"317\":1}}],[\"可以将自身作为一个任务在工作线程中执行\",{\"1\":{\"313\":1}}],[\"可以将queue细分为四大类\",{\"1\":{\"226\":1}}],[\"可以将上面的结果除以300\",{\"1\":{\"92\":1}}],[\"可以考虑使用自旋锁来减少线程阻塞和切换的开销\",{\"1\":{\"153\":1}}],[\"可以考虑使用\",{\"1\":{\"153\":1}}],[\"可以考虑使用读写锁来替代传统的\",{\"1\":{\"153\":1}}],[\"可以减少实际写入操作对底层资源的访问\",{\"1\":{\"401\":1}}],[\"可以减少实际读取操作对底层资源的访问\",{\"1\":{\"401\":1}}],[\"可以减少对共享资源的访问次数\",{\"1\":{\"153\":1}}],[\"可以减少缓存未命中的次数\",{\"1\":{\"118\":1}}],[\"可以尽量缩小\",{\"1\":{\"153\":1}}],[\"可以大幅度提高性能\",{\"1\":{\"151\":1}}],[\"可以禁止在\",{\"1\":{\"145\":1}}],[\"可以避免循环等待\",{\"1\":{\"141\":1}}],[\"可以防止上述两种不正常的情况的发生\",{\"1\":{\"131\":1}}],[\"可以达到毫秒甚至更长的时间\",{\"1\":{\"118\":1}}],[\"可以在代码块中赋值\",{\"1\":{\"435\":1}}],[\"可以在不同的操作系统上运行java程序\",{\"1\":{\"433\":1}}],[\"可以在原有对象的基础上进行修改\",{\"1\":{\"421\":1}}],[\"可以在等待\",{\"1\":{\"403\":1}}],[\"可以在后台执行一个任务\",{\"1\":{\"322\":1}}],[\"可以在纳秒级别完成一条指令的处理\",{\"1\":{\"118\":1}}],[\"可以在新生成的指标上额外加一些标签\",{\"1\":{\"113\":1}}],[\"可以在运行时重新加载其配置\",{\"1\":{\"105\":1}}],[\"可以在grafana上查询\",{\"1\":{\"81\":1}}],[\"可以停止重复发送由此告警引发的其它告警的机制\",{\"1\":{\"104\":1}}],[\"可以得到\",{\"1\":{\"97\":1}}],[\"可以得到prometheus的监控指标\",{\"1\":{\"68\":1}}],[\"可以用单线程处理多个\",{\"1\":{\"412\":1}}],[\"可以用于读取和写入数据\",{\"1\":{\"404\":1}}],[\"可以用于构建高并发\",{\"1\":{\"403\":1}}],[\"可以用于多线程下载或多个线程同时写数据到文件\",{\"1\":{\"401\":1}}],[\"可以用于提交给线程池执行\",{\"1\":{\"322\":2}}],[\"可以用来修饰类\",{\"1\":{\"437\":1}}],[\"可以用来进行线程间的数据交换\",{\"1\":{\"264\":1}}],[\"可以用来聚合耽搁瞬时向量\",{\"1\":{\"90\":1}}],[\"可以用topk函数\",{\"1\":{\"90\":1}}],[\"可以应用于one\",{\"1\":{\"88\":1}}],[\"可以使用throw语句在程序中主动抛出异常\",{\"1\":{\"432\":1}}],[\"可以使用threadlocal来保存每个请求的用户身份信息\",{\"1\":{\"283\":1}}],[\"可以使用stringbuilder来获得更好的性能\",{\"1\":{\"421\":1}}],[\"可以使用string\",{\"1\":{\"421\":1}}],[\"可以使用\",{\"1\":{\"115\":1,\"419\":1}}],[\"可以使用如下表达式\",{\"1\":{\"93\":1}}],[\"可以使用rate函数计算速率\",{\"1\":{\"92\":1}}],[\"可以使用以下的表达式进行计算\",{\"1\":{\"92\":1}}],[\"可以使用increase函数计算增量数据\",{\"1\":{\"92\":1}}],[\"可以使用范围矢量查询\",{\"1\":{\"82\":1}}],[\"可以使用完全匹配\",{\"1\":{\"81\":1}}],[\"可以使用通配符\",{\"1\":{\"68\":1}}],[\"可以筛选出handler=\",{\"1\":{\"81\":1}}],[\"可以很容易一段时间的增量数据\",{\"1\":{\"76\":1}}],[\"可以让开发者轻松的实现监控大盘\",{\"1\":{\"71\":1}}],[\"可以访问prometheus自身的监控指标的暴露端点\",{\"1\":{\"68\":1}}],[\"可以配置多种分发方式\",{\"1\":{\"64\":1}}],[\"可以是不同类型的队列\",{\"1\":{\"297\":1}}],[\"可以是布尔值或异常\",{\"1\":{\"226\":1}}],[\"可以是k8s的集群的服务发现\",{\"1\":{\"64\":1}}],[\"可以是一个接口\",{\"1\":{\"35\":1}}],[\"可以和开源组件grafana无缝对接\",{\"1\":{\"62\":1}}],[\"可以通过以下几个方面来理解\",{\"1\":{\"424\":1}}],[\"可以通过以下两个维度进行分类\",{\"1\":{\"226\":1}}],[\"可以通过以下两种方式来实现线程同步\",{\"1\":{\"146\":1}}],[\"可以通过抽象类的引用变量来指向它的实现类的实例\",{\"1\":{\"419\":1}}],[\"可以通过调用\",{\"1\":{\"407\":1}}],[\"可以通过对象的思想来操作文件和文件夹\",{\"1\":{\"401\":1}}],[\"可以通过重载的\",{\"1\":{\"322\":1}}],[\"可以通过\",{\"1\":{\"322\":3,\"337\":3,\"406\":1,\"410\":1,\"411\":1}}],[\"可以通过runtime\",{\"1\":{\"295\":1}}],[\"可以通过set方法设置变量的值\",{\"1\":{\"288\":1}}],[\"可以通过查阅具体容器的api文档来了解它们的用法和详细说明\",{\"1\":{\"227\":1}}],[\"可以通过动态代理实现一些横切关注点\",{\"1\":{\"56\":1}}],[\"可以通过顺序组合包装的方式来附加扩张功能\",{\"1\":{\"31\":1}}],[\"可以动态地添加和删除观察者\",{\"1\":{\"51\":1}}],[\"可以动态的扩展责任链中的逻辑单元\",{\"1\":{\"37\":1}}],[\"可以向它注册观察者对象\",{\"1\":{\"50\":1}}],[\"可以创建一系列相关的产品对象\",{\"1\":{\"47\":1}}],[\"可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法\",{\"1\":{\"422\":1}}],[\"可以根据系统负载动态调整线程数量\",{\"1\":{\"291\":1}}],[\"可以根据具体需求选择合适的锁机制来优化性能\",{\"1\":{\"152\":1}}],[\"可以根据客户端的需求\",{\"1\":{\"41\":1}}],[\"可以根据不同的需求\",{\"1\":{\"37\":1}}],[\"可以灵活的控制责任链中逻辑单元的处理顺序\",{\"1\":{\"37\":1}}],[\"可以写一个handler即可\",{\"1\":{\"37\":1}}],[\"可以快速判断一个元素是否存在于集合中\",{\"1\":{\"353\":1}}],[\"可以快速的装载和卸载逻辑单元\",{\"1\":{\"37\":1}}],[\"可以快速组合\",{\"1\":{\"32\":1}}],[\"可以快速装载和卸载增强功能\",{\"1\":{\"32\":1}}],[\"可以增加新的装饰器\",{\"1\":{\"32\":1}}],[\"可以按照需要使用不同装饰器组合\",{\"1\":{\"30\":1}}],[\"可以按照方法去构造对象\",{\"1\":{\"10\":1}}],[\"可以做到移植可复用\",{\"1\":{\"27\":1}}],[\"可以节约系统的资源\",{\"1\":{\"16\":1}}],[\"可以极大程度的提高我们写代码的质量\",{\"1\":{\"13\":1}}],[\"近几年由于八股文泛滥\",{\"1\":{\"19\":1}}],[\"=new\",{\"1\":{\"203\":1}}],[\"=null\",{\"1\":{\"175\":1}}],[\"=localholder\",{\"1\":{\"175\":1}}],[\"=waiting\",{\"1\":{\"159\":1}}],[\"=blocked\",{\"1\":{\"158\":1}}],[\"=~\",{\"1\":{\"81\":2}}],[\"=>\",{\"1\":{\"74\":3}}],[\"=factory\",{\"1\":{\"44\":1}}],[\"==比较结果为\",{\"1\":{\"429\":1}}],[\"==\",{\"0\":{\"428\":1,\"429\":1},\"1\":{\"19\":2,\"22\":1,\"23\":1,\"86\":1,\"121\":2,\"160\":2,\"168\":2,\"173\":7,\"175\":3,\"183\":5,\"185\":2,\"197\":3,\"198\":8,\"199\":5,\"213\":2,\"214\":1,\"234\":1,\"237\":1,\"241\":1,\"259\":31,\"260\":4,\"261\":13,\"271\":1,\"273\":4,\"274\":1,\"275\":3,\"276\":1,\"277\":1,\"294\":4,\"311\":2,\"312\":4,\"314\":2,\"316\":1,\"317\":2,\"318\":1,\"329\":1,\"331\":3,\"333\":1,\"358\":1,\"359\":2,\"360\":1,\"362\":2,\"363\":2,\"368\":1,\"370\":2,\"376\":7,\"377\":7,\"378\":6,\"386\":1,\"388\":1,\"395\":2,\"412\":1,\"414\":3,\"415\":1,\"428\":1,\"429\":7,\"430\":4,\"431\":1}}],[\"=\",{\"1\":{\"18\":1,\"19\":1,\"20\":1,\"22\":1,\"23\":1,\"26\":3,\"29\":2,\"31\":36,\"36\":4,\"41\":5,\"47\":1,\"50\":3,\"54\":2,\"56\":4,\"57\":5,\"81\":4,\"86\":1,\"97\":2,\"98\":8,\"113\":1,\"119\":2,\"121\":1,\"131\":4,\"132\":4,\"135\":3,\"139\":9,\"142\":10,\"143\":12,\"146\":2,\"158\":1,\"159\":3,\"160\":4,\"163\":1,\"166\":2,\"168\":11,\"170\":8,\"173\":41,\"174\":3,\"175\":14,\"180\":1,\"181\":2,\"183\":9,\"184\":1,\"185\":4,\"186\":6,\"187\":17,\"191\":2,\"196\":1,\"197\":3,\"198\":13,\"199\":6,\"203\":2,\"207\":1,\"208\":3,\"210\":3,\"213\":9,\"214\":16,\"215\":2,\"219\":2,\"220\":4,\"221\":8,\"230\":1,\"233\":5,\"234\":4,\"235\":7,\"237\":1,\"238\":5,\"239\":9,\"240\":7,\"241\":6,\"247\":3,\"256\":32,\"259\":106,\"260\":15,\"261\":35,\"267\":5,\"270\":2,\"271\":9,\"273\":4,\"274\":1,\"275\":7,\"276\":1,\"277\":11,\"281\":6,\"282\":11,\"288\":9,\"293\":5,\"294\":7,\"305\":1,\"306\":2,\"308\":2,\"309\":8,\"311\":3,\"312\":18,\"313\":17,\"314\":11,\"315\":3,\"316\":1,\"317\":19,\"318\":9,\"319\":6,\"323\":18,\"328\":7,\"329\":11,\"330\":2,\"331\":10,\"332\":3,\"333\":9,\"336\":7,\"339\":2,\"340\":2,\"341\":3,\"342\":3,\"349\":14,\"352\":4,\"353\":3,\"354\":8,\"359\":9,\"360\":5,\"361\":8,\"362\":6,\"363\":2,\"364\":11,\"368\":4,\"369\":6,\"370\":14,\"375\":5,\"376\":14,\"377\":37,\"378\":15,\"385\":2,\"393\":5,\"395\":32,\"405\":7,\"406\":1,\"410\":4,\"411\":5,\"412\":5,\"414\":21,\"415\":8,\"419\":4,\"423\":2,\"424\":2,\"429\":5,\"430\":7,\"431\":5,\"432\":1,\"435\":5,\"436\":2,\"438\":4}}],[\"hugelength\",{\"1\":{\"361\":2}}],[\"hugryinstance\",{\"1\":{\"18\":7}}],[\"hd\",{\"1\":{\"259\":3}}],[\"height=19\",{\"1\":{\"295\":2}}],[\"heapdump\",{\"1\":{\"289\":1}}],[\"headoffset\",{\"1\":{\"170\":2}}],[\"head内存偏移地址\",{\"1\":{\"170\":1}}],[\"head\",{\"1\":{\"168\":1,\"170\":2,\"173\":3,\"174\":1,\"198\":6,\"199\":2,\"214\":1}}],[\"here\",{\"1\":{\"173\":1}}],[\"held\",{\"1\":{\"173\":1}}],[\"hello接口相关的指标\",{\"1\":{\"97\":1}}],[\"hello\",{\"1\":{\"97\":8,\"98\":19,\"147\":1,\"341\":1,\"342\":1,\"405\":1,\"410\":1,\"411\":1,\"414\":2,\"418\":3}}],[\"helptransfer函数源码如下\",{\"1\":{\"259\":1}}],[\"helptransfer\",{\"1\":{\"259\":2,\"261\":1}}],[\"help\",{\"1\":{\"68\":6,\"74\":1,\"75\":1,\"79\":1,\"97\":2,\"98\":4,\"173\":2,\"198\":1,\"333\":1}}],[\"html\",{\"1\":{\"137\":1,\"176\":2,\"200\":1,\"216\":1,\"262\":2,\"278\":1,\"320\":1,\"334\":1,\"350\":1}}],[\"http\",{\"1\":{\"68\":1,\"69\":1,\"70\":1,\"74\":12,\"75\":4,\"76\":3,\"78\":13,\"81\":8,\"82\":1,\"83\":4,\"85\":4,\"89\":12,\"90\":6,\"92\":5,\"94\":13,\"97\":11,\"98\":23,\"100\":2,\"106\":1,\"107\":1,\"108\":3,\"109\":1,\"113\":2,\"116\":2,\"137\":1,\"262\":1}}],[\"httpservletresponse\",{\"1\":{\"98\":4}}],[\"httpservletrequest\",{\"1\":{\"98\":4}}],[\"httpserver\",{\"1\":{\"98\":3}}],[\"httpserver是用于导出指标的服务\",{\"1\":{\"98\":1}}],[\"httpserver<\",{\"1\":{\"98\":1}}],[\"https\",{\"1\":{\"24\":1,\"69\":1,\"71\":2,\"95\":1,\"106\":1,\"110\":1,\"111\":4,\"176\":3,\"200\":1,\"216\":1,\"262\":1,\"278\":1,\"289\":2,\"295\":2,\"320\":3,\"334\":1,\"350\":1,\"396\":1}}],[\"hitail\",{\"1\":{\"377\":6}}],[\"hihead\",{\"1\":{\"377\":3}}],[\"high\",{\"1\":{\"309\":1}}],[\"highqps\",{\"1\":{\"108\":2}}],[\"histogram类型的http\",{\"1\":{\"98\":1}}],[\"histogram类型的指标可以使用histogram\",{\"1\":{\"94\":1}}],[\"histogram和summary的区别在于\",{\"1\":{\"79\":1}}],[\"histogram的指标\",{\"1\":{\"78\":1}}],[\"histogram直方图可以解决上面的问题\",{\"1\":{\"78\":1}}],[\"histogram直方图是用来统计和分析样本的分布情况\",{\"1\":{\"78\":1}}],[\"histogram直方图\",{\"0\":{\"78\":1}}],[\"histogram\",{\"1\":{\"75\":1,\"94\":3,\"98\":6,\"100\":1}}],[\"holding\",{\"1\":{\"312\":1}}],[\"holds\",{\"1\":{\"256\":2}}],[\"hold\",{\"1\":{\"140\":1,\"141\":1}}],[\"how\",{\"1\":{\"107\":3,\"110\":1}}],[\"hook\",{\"1\":{\"106\":2,\"107\":2,\"319\":1}}],[\"home\",{\"1\":{\"1\":1,\"2\":1}}],[\"h\",{\"1\":{\"82\":1,\"174\":4,\"198\":13,\"199\":8,\"259\":7,\"260\":5,\"376\":3,\"406\":1,\"431\":6}}],[\"harmlessly\",{\"1\":{\"214\":1}}],[\"had\",{\"1\":{\"213\":1}}],[\"happens\",{\"0\":{\"136\":1},\"1\":{\"136\":16}}],[\"have\",{\"1\":{\"110\":1,\"311\":1}}],[\"hasremaining\",{\"1\":{\"405\":1,\"406\":3,\"410\":1,\"411\":1,\"414\":2,\"415\":1}}],[\"haswaiters\",{\"1\":{\"277\":1}}],[\"hasprevious\",{\"1\":{\"235\":2}}],[\"hasnext\",{\"1\":{\"235\":2,\"364\":3,\"412\":1,\"414\":1}}],[\"hasorder\",{\"1\":{\"191\":3,\"203\":3}}],[\"hasorder=true\",{\"1\":{\"191\":1}}],[\"hasqueuedpredecessors\",{\"1\":{\"185\":1}}],[\"has\",{\"1\":{\"107\":2,\"173\":1,\"214\":1}}],[\"hashset使用hashmap作为底层存储数据的结构\",{\"1\":{\"382\":1}}],[\"hashset实现了serializable接口\",{\"1\":{\"381\":1}}],[\"hashset实现了cloneable接口\",{\"1\":{\"381\":1}}],[\"hashset继承了abstractset类并实现类set接口\",{\"1\":{\"381\":1}}],[\"hashset存储的元素不会重复\",{\"1\":{\"381\":1}}],[\"hashset原理解析\",{\"0\":{\"380\":1}}],[\"hashset<>\",{\"1\":{\"353\":1,\"383\":1}}],[\"hashset<worker>\",{\"1\":{\"308\":2}}],[\"hashset\",{\"1\":{\"351\":1,\"353\":1,\"381\":1,\"382\":7,\"385\":6,\"386\":3,\"387\":5,\"388\":3,\"389\":3}}],[\"hash值生成的结点放入桶中\",{\"1\":{\"259\":1}}],[\"hashtable\",{\"1\":{\"222\":1,\"224\":1}}],[\"hashmap不是线程安全的\",{\"1\":{\"379\":1}}],[\"hashmap的底层数据结构\",{\"0\":{\"374\":1}}],[\"hashmap的类结构图如下\",{\"1\":{\"373\":1}}],[\"hashmap的类结构图\",{\"0\":{\"373\":1}}],[\"hashmap实现了serializable接口\",{\"1\":{\"373\":1}}],[\"hashmap实现了cloneable接口\",{\"1\":{\"373\":1}}],[\"hashmap继承了abstractmap类并实现类map接口\",{\"1\":{\"373\":1}}],[\"hashmap原理解析\",{\"0\":{\"372\":1}}],[\"hashmapexample\",{\"1\":{\"354\":1}}],[\"hashmap<>\",{\"1\":{\"219\":1,\"220\":1,\"221\":1,\"354\":1,\"376\":1,\"385\":3}}],[\"hashmap\",{\"1\":{\"219\":1,\"221\":1,\"224\":1,\"351\":1,\"354\":15,\"373\":1,\"374\":3,\"375\":5,\"376\":1,\"377\":3,\"378\":1,\"379\":3,\"382\":5,\"385\":3,\"386\":5,\"387\":5,\"388\":5,\"389\":1,\"431\":1}}],[\"hashcode\",{\"1\":{\"149\":1,\"259\":1,\"260\":1,\"261\":1,\"376\":1,\"382\":1,\"431\":3}}],[\"hash\",{\"1\":{\"68\":4,\"256\":5,\"259\":11,\"260\":2,\"261\":6,\"376\":13,\"377\":2,\"378\":13,\"431\":2}}],[\"handlewrite\",{\"1\":{\"414\":3}}],[\"handleaccept\",{\"1\":{\"414\":3}}],[\"handlepossiblecancellationinterrupt\",{\"1\":{\"318\":1,\"329\":1}}],[\"handle\",{\"1\":{\"36\":7,\"337\":1}}],[\"handleread\",{\"1\":{\"414\":3}}],[\"handlerinterceptoradapter\",{\"1\":{\"98\":2}}],[\"handler=~\",{\"1\":{\"81\":2}}],[\"handler=\",{\"1\":{\"74\":6,\"75\":1,\"78\":12,\"81\":1,\"82\":1,\"85\":4,\"90\":1,\"92\":5,\"94\":12,\"108\":1,\"116\":1}}],[\"handler\",{\"0\":{\"302\":1},\"1\":{\"56\":3,\"74\":1,\"81\":2,\"85\":2,\"90\":3,\"94\":2,\"98\":4,\"116\":2,\"294\":5,\"308\":1}}],[\"handlerc\",{\"1\":{\"35\":1}}],[\"handlerb\",{\"1\":{\"35\":1}}],[\"pi\",{\"1\":{\"419\":1}}],[\"pipe\",{\"1\":{\"404\":2}}],[\"pipedwriter\",{\"1\":{\"401\":1}}],[\"pipedreader\",{\"1\":{\"401\":1}}],[\"pipedoutputstream\",{\"1\":{\"401\":1}}],[\"pipedinputstream\",{\"1\":{\"401\":1}}],[\"pv\",{\"1\":{\"261\":5}}],[\"pk\",{\"1\":{\"259\":6}}],[\"phase\",{\"1\":{\"347\":1}}],[\"phaser\",{\"1\":{\"347\":1}}],[\"ph\",{\"1\":{\"259\":3}}],[\"plus\",{\"1\":{\"256\":1}}],[\"place\",{\"1\":{\"256\":1}}],[\"plcmt=topnav\",{\"1\":{\"71\":1}}],[\"pdai\",{\"1\":{\"176\":1,\"350\":1}}],[\"peek\",{\"1\":{\"175\":3,\"265\":2}}],[\"person=null\",{\"1\":{\"435\":1}}],[\"person=new\",{\"1\":{\"435\":1}}],[\"person\",{\"1\":{\"435\":5}}],[\"pertaining\",{\"1\":{\"282\":1}}],[\"per\",{\"1\":{\"115\":4}}],[\"png\",{\"1\":{\"124\":1,\"406\":1}}],[\"p\",{\"1\":{\"111\":1,\"137\":1,\"168\":3,\"173\":4,\"176\":2,\"198\":4,\"200\":1,\"214\":3,\"216\":1,\"259\":20,\"260\":3,\"261\":5,\"262\":1,\"278\":1,\"320\":1,\"334\":1,\"376\":9,\"396\":1}}],[\"pool\",{\"1\":{\"305\":1,\"306\":5,\"311\":1,\"313\":1,\"347\":1}}],[\"point\",{\"1\":{\"202\":1}}],[\"poll任务\",{\"1\":{\"314\":1}}],[\"poll函数用于获取元素\",{\"1\":{\"276\":1}}],[\"poll函数\",{\"0\":{\"276\":1}}],[\"poll\",{\"1\":{\"175\":1,\"264\":1,\"265\":5,\"276\":1,\"314\":3}}],[\"position\",{\"1\":{\"406\":1}}],[\"possible\",{\"1\":{\"317\":1}}],[\"possibly\",{\"1\":{\"173\":1}}],[\"postmapping\",{\"1\":{\"110\":1}}],[\"post请求\",{\"1\":{\"105\":1}}],[\"posthandle\",{\"1\":{\"98\":1}}],[\"post\",{\"1\":{\"89\":6,\"289\":1,\"320\":1}}],[\"port\",{\"1\":{\"98\":1,\"414\":2}}],[\"population\",{\"1\":{\"90\":2}}],[\"power\",{\"1\":{\"85\":1,\"256\":2}}],[\"pg=community\",{\"1\":{\"71\":1}}],[\"putorderedint\",{\"1\":{\"329\":2,\"332\":1}}],[\"put会调用enqueue函数\",{\"1\":{\"273\":1}}],[\"put函数用于存放元素\",{\"1\":{\"273\":1}}],[\"put函数\",{\"0\":{\"273\":1}}],[\"put函数底层调用了putval进行数据的插入\",{\"1\":{\"259\":1}}],[\"putindex\",{\"1\":{\"270\":1,\"271\":1,\"273\":3,\"277\":4}}],[\"puttreeval函数源码如下\",{\"1\":{\"259\":1}}],[\"puttreeval\",{\"1\":{\"259\":3,\"376\":1}}],[\"putval\",{\"1\":{\"259\":1}}],[\"putval函数\",{\"0\":{\"259\":1}}],[\"put\",{\"1\":{\"89\":1,\"219\":2,\"220\":2,\"221\":1,\"247\":3,\"264\":1,\"265\":3,\"267\":1,\"273\":1,\"354\":4,\"361\":1,\"376\":4,\"386\":5,\"405\":1,\"406\":13,\"410\":1,\"411\":1,\"414\":2,\"415\":1}}],[\"pushbackinputstream\",{\"1\":{\"401\":2}}],[\"push\",{\"1\":{\"63\":1}}],[\"publisher=new\",{\"1\":{\"50\":1}}],[\"publisherimpl\",{\"1\":{\"50\":2}}],[\"publisher接口的实现类publisherimpl\",{\"1\":{\"50\":1}}],[\"publisher\",{\"1\":{\"50\":6}}],[\"public和abstract\",{\"1\":{\"419\":1}}],[\"public\",{\"1\":{\"18\":2,\"19\":2,\"20\":2,\"22\":2,\"23\":2,\"26\":9,\"31\":15,\"36\":12,\"41\":8,\"44\":7,\"47\":9,\"50\":10,\"54\":9,\"56\":6,\"57\":7,\"97\":2,\"98\":8,\"110\":20,\"119\":4,\"121\":2,\"131\":3,\"132\":5,\"139\":5,\"142\":5,\"143\":5,\"146\":5,\"147\":4,\"155\":1,\"156\":2,\"157\":2,\"158\":3,\"159\":3,\"160\":4,\"166\":2,\"169\":1,\"170\":1,\"173\":1,\"174\":1,\"175\":11,\"179\":2,\"180\":1,\"181\":2,\"187\":11,\"191\":8,\"194\":1,\"195\":1,\"196\":1,\"198\":2,\"199\":2,\"203\":4,\"206\":1,\"208\":1,\"210\":1,\"211\":1,\"214\":1,\"219\":3,\"220\":3,\"221\":3,\"230\":2,\"232\":1,\"233\":1,\"234\":3,\"235\":10,\"237\":1,\"238\":1,\"240\":1,\"241\":1,\"247\":2,\"249\":1,\"256\":1,\"257\":1,\"260\":1,\"265\":2,\"267\":4,\"269\":1,\"270\":1,\"271\":3,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"281\":2,\"282\":2,\"287\":1,\"288\":3,\"294\":1,\"311\":1,\"313\":1,\"315\":3,\"316\":1,\"317\":2,\"318\":1,\"319\":2,\"323\":6,\"325\":1,\"326\":1,\"329\":1,\"330\":1,\"332\":1,\"336\":2,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"349\":3,\"352\":2,\"353\":2,\"354\":2,\"358\":1,\"359\":3,\"360\":6,\"361\":1,\"362\":1,\"363\":3,\"364\":3,\"367\":2,\"368\":1,\"369\":1,\"370\":1,\"375\":2,\"378\":2,\"383\":1,\"385\":2,\"386\":1,\"387\":1,\"388\":1,\"393\":2,\"395\":6,\"405\":2,\"406\":2,\"414\":6,\"415\":3,\"418\":11,\"419\":12,\"424\":3,\"430\":2,\"431\":1,\"432\":3,\"435\":13,\"436\":8,\"438\":9}}],[\"packing\",{\"1\":{\"309\":1}}],[\"package\",{\"1\":{\"36\":2,\"50\":5,\"98\":1,\"119\":1,\"139\":1,\"142\":1,\"147\":1,\"159\":1,\"160\":1,\"175\":1,\"187\":1,\"191\":1,\"203\":1,\"219\":1,\"221\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1,\"395\":1,\"414\":1,\"415\":1,\"438\":1}}],[\"past\",{\"1\":{\"173\":1}}],[\"path\",{\"1\":{\"115\":15,\"173\":1}}],[\"pattern\",{\"1\":{\"24\":1,\"39\":1,\"42\":1,\"45\":1,\"48\":1}}],[\"parentmap\",{\"1\":{\"288\":2}}],[\"parent\",{\"1\":{\"288\":2}}],[\"param\",{\"1\":{\"175\":2,\"385\":1,\"395\":2}}],[\"parameter\",{\"1\":{\"90\":1}}],[\"parknanos\",{\"1\":{\"317\":1,\"331\":1}}],[\"parking\",{\"1\":{\"173\":1}}],[\"park\",{\"1\":{\"173\":3,\"175\":3,\"317\":1,\"331\":1,\"333\":1}}],[\"parkandcheckinterrupt函数里的逻辑是首先执行park操作\",{\"1\":{\"173\":1}}],[\"parkandcheckinterrupt\",{\"1\":{\"173\":2,\"198\":1}}],[\"parties\",{\"1\":{\"208\":2,\"210\":5,\"211\":2,\"214\":1,\"215\":1}}],[\"parti\",{\"1\":{\"111\":1}}],[\"page\",{\"1\":{\"108\":1}}],[\"pause\",{\"1\":{\"68\":1,\"79\":1}}],[\"present\",{\"1\":{\"386\":2,\"388\":3}}],[\"preserve\",{\"1\":{\"377\":1}}],[\"preconditions\",{\"1\":{\"361\":1}}],[\"precheck\",{\"1\":{\"312\":1}}],[\"prefer\",{\"1\":{\"420\":1}}],[\"preferred\",{\"1\":{\"361\":1}}],[\"preflength\",{\"1\":{\"361\":4}}],[\"prefgrowth\",{\"1\":{\"361\":2}}],[\"pred结点状态小于等于0\",{\"1\":{\"173\":1}}],[\"pred结点不为头结点\",{\"1\":{\"173\":1}}],[\"prednext\",{\"1\":{\"173\":4}}],[\"pred\",{\"1\":{\"173\":25,\"259\":2,\"261\":4}}],[\"predecessors\",{\"1\":{\"173\":2}}],[\"predecessor\",{\"1\":{\"168\":1,\"173\":2,\"198\":1,\"214\":1}}],[\"predict\",{\"1\":{\"77\":1,\"93\":3}}],[\"prev指向当前节点前一个节点\",{\"1\":{\"366\":1}}],[\"prevent\",{\"1\":{\"318\":2,\"329\":2}}],[\"prevents\",{\"1\":{\"311\":1}}],[\"previousindex\",{\"1\":{\"235\":1}}],[\"previous\",{\"1\":{\"235\":1}}],[\"prev\",{\"1\":{\"168\":2,\"173\":8,\"214\":1,\"259\":2,\"366\":2,\"369\":1,\"370\":18}}],[\"preemption\",{\"1\":{\"140\":1,\"141\":1}}],[\"prehandle\",{\"1\":{\"98\":1}}],[\"programming\",{\"1\":{\"422\":2}}],[\"programmer\",{\"1\":{\"320\":1}}],[\"procedural\",{\"1\":{\"422\":1}}],[\"proceed\",{\"1\":{\"311\":1}}],[\"processworkerexit\",{\"1\":{\"313\":1}}],[\"process\",{\"1\":{\"31\":1}}],[\"probably\",{\"1\":{\"214\":1}}],[\"produce\",{\"1\":{\"187\":7}}],[\"producerthread\",{\"1\":{\"267\":2}}],[\"producerconsumerexample\",{\"1\":{\"267\":1}}],[\"producer\",{\"1\":{\"187\":4,\"267\":2}}],[\"propagate\",{\"1\":{\"168\":3,\"173\":3,\"198\":3,\"199\":1}}],[\"properties中开启prometheus的暴露接口\",{\"1\":{\"97\":1}}],[\"protected\",{\"1\":{\"163\":3,\"166\":3,\"171\":1,\"183\":2,\"184\":1,\"185\":1,\"197\":2,\"198\":1,\"199\":1,\"328\":1,\"329\":2,\"349\":1,\"437\":1}}],[\"profiling\",{\"1\":{\"68\":1}}],[\"promql提供了另外一个灵敏度更高的函数irate\",{\"1\":{\"92\":1}}],[\"promql提供了两个向量匹配符号\",{\"1\":{\"88\":1}}],[\"promql还支持常见的比较运算符\",{\"1\":{\"86\":1}}],[\"promql支持常见的逻辑和数学操作符\",{\"1\":{\"85\":1}}],[\"promql被广泛应用于指标视图的配置\",{\"1\":{\"80\":1}}],[\"promql是prometheus提供的数据查询语言\",{\"1\":{\"80\":1}}],[\"promql快速入门\",{\"0\":{\"80\":1}}],[\"promql非常的强大和灵活\",{\"1\":{\"62\":1}}],[\"prometheus会定时的根据拉取expr定时表达式的数据\",{\"1\":{\"113\":1}}],[\"prometheus支持两种规则表达式\",{\"1\":{\"112\":1}}],[\"prometheus预处理计算\",{\"0\":{\"112\":1}}],[\"prometheus作为存储端\",{\"1\":{\"101\":1}}],[\"prometheus作为采集端\",{\"1\":{\"101\":1}}],[\"prometheus作为一个采集组件\",{\"1\":{\"72\":1}}],[\"prometheus告警与alertmanager实战\",{\"0\":{\"101\":1}}],[\"prometheuslab\",{\"1\":{\"98\":1}}],[\"prometheus官方提供了java客户端\",{\"1\":{\"98\":1}}],[\"prometheus依赖是将micrometer的指标转换成prometheus格式的指标\",{\"1\":{\"97\":1}}],[\"prometheus<\",{\"1\":{\"97\":1,\"98\":3}}],[\"prometheus的告警分为两部分内容\",{\"1\":{\"101\":1}}],[\"prometheus的时间序列是通过指标名和一组标签来唯一定义\",{\"1\":{\"80\":1}}],[\"prometheus的数据模型\",{\"0\":{\"73\":1}}],[\"prometheus每发生一个请求\",{\"1\":{\"76\":1}}],[\"prometheus定义来四种类型的指标\",{\"1\":{\"75\":1}}],[\"prometheus可以通过调用\",{\"1\":{\"74\":1}}],[\"prometheus可以很好地记录任何纯粹的数字时间序列\",{\"1\":{\"65\":1}}],[\"prometheus配置文件热更新\",{\"0\":{\"70\":1}}],[\"prometheus配置文件讲解\",{\"0\":{\"68\":1}}],[\"prometheus环境搭建\",{\"0\":{\"66\":1}}],[\"prometheus是为可靠性而设计的\",{\"1\":{\"65\":1}}],[\"prometheus是一个开源的监控系统\",{\"1\":{\"61\":1}}],[\"prometheus适用的场景\",{\"0\":{\"65\":1}}],[\"prometheus发现到监控目标后\",{\"1\":{\"64\":1}}],[\"prometheus通过时间序列来存储所有的数据的\",{\"1\":{\"74\":1}}],[\"prometheus通过时序数据来收集和存储指标\",{\"1\":{\"61\":1}}],[\"prometheus通过pull的方式去周期性\",{\"1\":{\"64\":1}}],[\"prometheus生态包含了一系列组件\",{\"1\":{\"63\":1}}],[\"prometheus提供非常的多的聚合函数\",{\"1\":{\"90\":1}}],[\"prometheus提供了http接口的方式让外部第三方访问数据\",{\"1\":{\"64\":1}}],[\"prometheus提供一些关键的特性\",{\"1\":{\"62\":1}}],[\"prometheus提供的特性\",{\"0\":{\"62\":1}}],[\"prometheus让监控从传统的黑盒子监控提升到了白盒监控\",{\"1\":{\"62\":1}}],[\"prometheus和传统的监控系统相比\",{\"1\":{\"62\":1}}],[\"prometheus受启发于google的brogmon监控系统\",{\"1\":{\"61\":1}}],[\"prometheus概述\",{\"0\":{\"60\":1}}],[\"prometheus\",{\"1\":{\"59\":1,\"63\":1,\"64\":1,\"67\":4,\"68\":1,\"69\":3,\"70\":1,\"74\":10,\"75\":3,\"76\":2,\"78\":12,\"81\":7,\"82\":1,\"83\":4,\"85\":3,\"90\":6,\"92\":4,\"94\":22,\"95\":2,\"97\":1,\"98\":4,\"101\":1,\"106\":1,\"108\":1,\"110\":1,\"111\":3,\"116\":2}}],[\"prometheus教程介绍\",{\"0\":{\"59\":1}}],[\"proxy\",{\"1\":{\"56\":2,\"57\":2}}],[\"proxyhandler\",{\"1\":{\"56\":4}}],[\"proxy类和java\",{\"1\":{\"56\":1}}],[\"priorityqueue\",{\"1\":{\"351\":1}}],[\"priority优先级和非守护进程状态\",{\"1\":{\"301\":1}}],[\"priorityblockingqueue\",{\"1\":{\"226\":1,\"266\":1}}],[\"printwriter\",{\"1\":{\"401\":1}}],[\"printstream\",{\"1\":{\"401\":1}}],[\"printstacktrace\",{\"1\":{\"31\":7,\"139\":2,\"142\":1,\"143\":1,\"158\":1,\"159\":3,\"160\":5,\"175\":2,\"187\":2,\"191\":4,\"203\":5,\"267\":2,\"315\":2,\"339\":1,\"340\":1,\"341\":4,\"342\":6,\"405\":1,\"414\":2,\"415\":3}}],[\"print\",{\"1\":{\"395\":2,\"405\":1,\"406\":3,\"414\":1}}],[\"printf\",{\"1\":{\"395\":1}}],[\"println\",{\"1\":{\"26\":3,\"31\":3,\"36\":6,\"41\":1,\"47\":1,\"50\":1,\"54\":3,\"56\":2,\"57\":2,\"119\":1,\"131\":1,\"132\":1,\"142\":1,\"143\":1,\"147\":2,\"156\":2,\"157\":2,\"158\":2,\"159\":2,\"160\":2,\"187\":6,\"191\":8,\"203\":4,\"230\":1,\"247\":2,\"267\":2,\"281\":1,\"288\":2,\"306\":1,\"315\":1,\"323\":9,\"336\":3,\"339\":2,\"340\":4,\"341\":2,\"342\":4,\"349\":1,\"352\":10,\"353\":7,\"354\":9,\"383\":1,\"393\":3,\"395\":8,\"406\":5,\"414\":4,\"415\":2,\"418\":5,\"419\":5,\"424\":2,\"429\":3,\"432\":3,\"435\":3,\"436\":2,\"438\":8}}],[\"principle\",{\"1\":{\"14\":5}}],[\"private\",{\"1\":{\"18\":2,\"19\":2,\"20\":3,\"22\":2,\"23\":2,\"26\":1,\"31\":7,\"36\":1,\"50\":2,\"54\":1,\"56\":1,\"57\":1,\"121\":2,\"131\":3,\"134\":1,\"139\":1,\"142\":2,\"143\":3,\"146\":2,\"163\":1,\"166\":2,\"170\":10,\"173\":6,\"175\":5,\"180\":2,\"183\":2,\"184\":1,\"185\":1,\"186\":3,\"187\":2,\"195\":1,\"197\":2,\"198\":3,\"199\":1,\"207\":1,\"208\":6,\"213\":1,\"214\":3,\"215\":1,\"219\":2,\"220\":2,\"221\":1,\"233\":4,\"235\":3,\"239\":1,\"256\":27,\"259\":3,\"267\":1,\"270\":3,\"273\":1,\"275\":1,\"281\":1,\"288\":1,\"293\":5,\"308\":8,\"309\":11,\"312\":2,\"313\":1,\"314\":1,\"317\":9,\"319\":3,\"328\":12,\"331\":1,\"333\":1,\"349\":4,\"361\":3,\"362\":1,\"364\":1,\"368\":1,\"369\":3,\"370\":3,\"414\":3,\"419\":3,\"435\":5}}],[\"但不能修改其实现\",{\"1\":{\"435\":1}}],[\"但不会引起冲突\",{\"1\":{\"221\":1}}],[\"但它也带来了一些问题\",{\"1\":{\"420\":1}}],[\"但它具有较强的功能和稳定性\",{\"1\":{\"152\":1}}],[\"但也有一些区别\",{\"1\":{\"419\":1}}],[\"但尽量在构造时指定估算大小\",{\"1\":{\"395\":1}}],[\"但在\",{\"1\":{\"386\":1}}],[\"但同时hashset和hashmap一样\",{\"1\":{\"382\":1}}],[\"但对于随机访问和占用内存方面可能存在劣势\",{\"1\":{\"371\":1}}],[\"但会处理阻塞队列中的任务\",{\"1\":{\"309\":1}}],[\"但会执行已经提交的任务\",{\"1\":{\"293\":1}}],[\"但有新的任务到达\",{\"1\":{\"303\":1}}],[\"但可能会影响提交任务线程的性能\",{\"1\":{\"302\":1}}],[\"但可能会导致吞吐量降低\",{\"1\":{\"300\":1}}],[\"但可能更难以调整和控制\",{\"1\":{\"300\":1}}],[\"但value值不会被回收\",{\"1\":{\"287\":1}}],[\"但并不是说所有的情况都适合使用threadlocal\",{\"1\":{\"283\":1}}],[\"但并发程序仍会面临一些挑战\",{\"1\":{\"118\":1}}],[\"但更关键的是能够正确地选择和使用适合的容器\",{\"1\":{\"227\":1}}],[\"但使用时需要注意乐观读操作可能会发生写冲突\",{\"1\":{\"221\":1}}],[\"但只允许一个写线程获取写锁\",{\"1\":{\"220\":1}}],[\"但只允许一个线程获取写锁\",{\"1\":{\"218\":1}}],[\"但最终结果并不受影响\",{\"1\":{\"121\":1}}],[\"但发生上图线程切换的时候\",{\"1\":{\"120\":1}}],[\"但缺点是对于一些无法实现接口的类\",{\"1\":{\"56\":1}}],[\"但缺点是需要手动创建代理类\",{\"1\":{\"53\":1}}],[\"但现实生活中\",{\"1\":{\"45\":1}}],[\"但需要防止责任链模式有过多的处理逻辑单元\",{\"1\":{\"37\":1}}],[\"但又不方便继承\",{\"1\":{\"32\":1}}],[\"但是变量的值是可以被修改的\",{\"1\":{\"435\":1}}],[\"但是它们之间有一些区别\",{\"1\":{\"428\":1}}],[\"但是它们之间有一个核心矛盾\",{\"1\":{\"118\":1}}],[\"但是它是不能给被实例化的\",{\"1\":{\"419\":1}}],[\"但是参数的个数不同\",{\"1\":{\"418\":1}}],[\"但是java集合的源码或者手写java\",{\"1\":{\"355\":1}}],[\"但是这种方式没有返回值\",{\"1\":{\"336\":1}}],[\"但是这个状态会时间会比较短\",{\"1\":{\"328\":1}}],[\"但是执行结果或者异常原因还没有保存到outcome字段中\",{\"1\":{\"331\":1}}],[\"但是任务执行结果或者异常原因还没有保存到outcome字段\",{\"1\":{\"328\":1}}],[\"但是正如前面所说的\",{\"1\":{\"325\":1}}],[\"但是没有实现\",{\"1\":{\"419\":1}}],[\"但是没有线程\",{\"1\":{\"311\":1}}],[\"但是没有将i值复制到主内存中\",{\"1\":{\"127\":1}}],[\"但是并没有容量\",{\"1\":{\"298\":1}}],[\"但是数据从父线程那里来的\",{\"1\":{\"288\":1}}],[\"但是不同的返回结果不能作为方法重载的定义\",{\"1\":{\"418\":1}}],[\"但是不能返回结果的类型来定义方法的重载\",{\"1\":{\"418\":1}}],[\"但是不能获取到\",{\"1\":{\"288\":1}}],[\"但是不太推荐\",{\"1\":{\"21\":1}}],[\"但是当多个线程同时读的时候\",{\"1\":{\"221\":1}}],[\"但是当竞争激烈时\",{\"1\":{\"151\":1}}],[\"但是如果使用线程池就不能使用线程的join\",{\"1\":{\"191\":1}}],[\"但是有时候\",{\"1\":{\"288\":1}}],[\"但是有while\",{\"1\":{\"191\":1}}],[\"但是有这种可能性\",{\"1\":{\"131\":1}}],[\"但是循环之后还是在占用cpu\",{\"1\":{\"175\":1}}],[\"但是监视器锁本质又是依赖于底层的操作系统的mutex\",{\"1\":{\"148\":1}}],[\"但是\",{\"1\":{\"139\":1}}],[\"但是要求编译器优化后一定遵守\",{\"1\":{\"136\":1}}],[\"但是readthread的高速缓存中并没有更新\",{\"1\":{\"131\":1}}],[\"但是由于线程1修改了\",{\"1\":{\"127\":1}}],[\"但是由于简单\",{\"1\":{\"18\":1}}],[\"但是其反应出的是瞬时增长率\",{\"1\":{\"92\":1}}],[\"但是通过计算在时间窗口内的平均增长率却无法反应出该问题\",{\"1\":{\"92\":1}}],[\"但是对于prometheus的底层数据来说\",{\"1\":{\"75\":1}}],[\"但是需要对值的控制字符进行转义\",{\"1\":{\"74\":1}}],[\"但是在进行插入和删除操作时\",{\"1\":{\"358\":1}}],[\"但是在大多数情况下\",{\"1\":{\"78\":1}}],[\"但是在使用它的时候需要注意它带来的一些缺点\",{\"1\":{\"51\":1}}],[\"但是在方法上加了锁\",{\"1\":{\"23\":1}}],[\"但是mac电脑只有typec接口\",{\"1\":{\"25\":1}}],[\"但是代码比双重检查模式简洁\",{\"1\":{\"20\":1}}],[\"但此时singleton并还没初始化完毕\",{\"1\":{\"19\":1,\"121\":1}}],[\"但由子类来决定要实例化哪个类\",{\"1\":{\"10\":1,\"42\":1}}],[\"类通过使用关键字\",{\"1\":{\"419\":1}}],[\"类提供了读写数据的方法\",{\"1\":{\"403\":1}}],[\"类内部维护了一个\",{\"1\":{\"393\":1}}],[\"类结构关系\",{\"0\":{\"391\":1}}],[\"类结构图\",{\"0\":{\"381\":1}}],[\"类有多个构造函数\",{\"1\":{\"385\":1}}],[\"类来存储键值对\",{\"1\":{\"374\":1}}],[\"类来表示计算数组元素总和的任务\",{\"1\":{\"349\":1}}],[\"类是\",{\"1\":{\"366\":2}}],[\"类实现了\",{\"1\":{\"364\":1,\"419\":1}}],[\"类实现了future接口\",{\"1\":{\"337\":1}}],[\"类\",{\"1\":{\"346\":1,\"374\":2}}],[\"类型转换和字符串解析等\",{\"1\":{\"423\":1}}],[\"类型转化\",{\"1\":{\"261\":1}}],[\"类型包括\",{\"1\":{\"406\":1}}],[\"类型的引用变量\",{\"1\":{\"419\":1}}],[\"类型的任务\",{\"1\":{\"348\":2}}],[\"类型的值\",{\"1\":{\"288\":1}}],[\"类型的数组\",{\"1\":{\"234\":1,\"393\":1}}],[\"类型变量的值\",{\"1\":{\"288\":2}}],[\"类型数组\",{\"1\":{\"234\":1}}],[\"类型\",{\"1\":{\"234\":2,\"392\":1,\"404\":1}}],[\"类型不相同\",{\"1\":{\"234\":1}}],[\"类型相同\",{\"1\":{\"234\":1}}],[\"类的引用变量来引用\",{\"1\":{\"424\":1}}],[\"类的多态性得到了充分的展现\",{\"1\":{\"418\":1}}],[\"类的uml图如下图所示\",{\"1\":{\"393\":1}}],[\"类的一些主要特性和用法\",{\"1\":{\"337\":1}}],[\"类的核心函数\",{\"0\":{\"172\":1}}],[\"类的构造函数有两个重载的构造函数\",{\"1\":{\"367\":1}}],[\"类的构造函数\",{\"0\":{\"171\":1,\"181\":1,\"196\":1,\"209\":1,\"234\":1,\"257\":1,\"271\":1}}],[\"类的属性\",{\"0\":{\"170\":1,\"180\":1,\"195\":1,\"208\":1,\"233\":1,\"256\":1,\"270\":1}}],[\"类的内部类\",{\"0\":{\"167\":1,\"182\":1,\"197\":1,\"207\":1,\"235\":1,\"250\":1}}],[\"类的继承关系\",{\"0\":{\"166\":1,\"194\":1,\"206\":1,\"232\":1,\"249\":1,\"269\":1}}],[\"类的静态变量或者常量\",{\"1\":{\"146\":1}}],[\"类似于另外一个threadlocal\",{\"1\":{\"288\":1}}],[\"类似于mysql的sql查询语句\",{\"1\":{\"80\":1}}],[\"类似于kubernetes是从google的brog系统演变而来\",{\"1\":{\"61\":1}}],[\"类似于中介\",{\"1\":{\"52\":1}}],[\"类加载是加锁的\",{\"1\":{\"18\":1}}],[\"类和对象如何交互\",{\"1\":{\"12\":1}}],[\"只关心添加操作是否成功\",{\"1\":{\"386\":1}}],[\"只使用键来判断元素的唯一性\",{\"1\":{\"385\":1}}],[\"只可以运行\",{\"1\":{\"348\":1}}],[\"只要对象的属性没有发生改变\",{\"1\":{\"431\":1}}],[\"只要是处理纯文本数据\",{\"1\":{\"399\":1}}],[\"只要发生垃圾回收\",{\"1\":{\"286\":1}}],[\"只要引用存在\",{\"1\":{\"286\":1}}],[\"只要避免其中一个条件\",{\"1\":{\"140\":1}}],[\"只给出了主要的方法\",{\"1\":{\"185\":1}}],[\"只对必要的代码块进行同步\",{\"1\":{\"153\":1}}],[\"只对特定的代码块进行同步\",{\"1\":{\"146\":1}}],[\"只是runnable没有返回值\",{\"1\":{\"315\":1}}],[\"只是维护一组线程\",{\"1\":{\"298\":1}}],[\"只是方法的同步是一种隐式的方式来实现\",{\"1\":{\"147\":1}}],[\"只是重新进入\",{\"1\":{\"147\":1}}],[\"只允许一个线程进入临界区执行\",{\"1\":{\"147\":1}}],[\"只允许通过getinstance\",{\"1\":{\"18\":1}}],[\"只能调用父类中声明的方法和子类中重写了父类的方法\",{\"1\":{\"424\":1}}],[\"只能使用对象类型\",{\"1\":{\"423\":1}}],[\"只能包含抽象方法的声明\",{\"1\":{\"419\":1}}],[\"只能包含常量和抽象方法\",{\"1\":{\"419\":1}}],[\"只能用作基类或父类来使用\",{\"1\":{\"419\":1}}],[\"只能在接口内部被调用\",{\"1\":{\"419\":1}}],[\"只能在队尾进行入队操作\",{\"1\":{\"226\":1}}],[\"只能在原有的基础功能之上做进一步增强\",{\"1\":{\"30\":1}}],[\"只能有一个线程获取到锁\",{\"1\":{\"152\":1}}],[\"只能被一个线程占用\",{\"1\":{\"140\":1}}],[\"只能求到最大的耗时和平均耗时\",{\"1\":{\"97\":1}}],[\"只不过summary是已经在客户端已经计算好的数据\",{\"1\":{\"79\":1}}],[\"只增不减\",{\"1\":{\"75\":1}}],[\"只需要增加相应的具体产品类和工厂类即可\",{\"1\":{\"47\":1}}],[\"只需要修改工厂类的逻辑判断即可\",{\"1\":{\"41\":1}}],[\"只需要财务审批\",{\"1\":{\"36\":1}}],[\"只有arrayblockingqueue和linkedblockingqueue是支持有界的\",{\"1\":{\"226\":1}}],[\"只有在有线程持有写锁时\",{\"1\":{\"221\":1}}],[\"只有拥有锁的时候才会调用\",{\"1\":{\"213\":1}}],[\"只有一个线程能执行\",{\"1\":{\"164\":1}}],[\"只有一个线程可以进入执行方法\",{\"1\":{\"146\":1}}],[\"只有当该节点的前驱结点的状态为signal时\",{\"1\":{\"173\":1}}],[\"只有当其他线程请求锁时\",{\"1\":{\"150\":1}}],[\"只有当线程获取到锁时\",{\"1\":{\"146\":1}}],[\"只有当子类可以替换基类\",{\"1\":{\"14\":1}}],[\"只有理解这些原则在并发场景下的应用\",{\"1\":{\"122\":1}}],[\"只有明确了问题的本质\",{\"1\":{\"122\":1}}],[\"只有第一次调用getsingleton\",{\"1\":{\"19\":1}}],[\"推荐方式\",{\"0\":{\"305\":1,\"306\":1}}],[\"推荐\",{\"0\":{\"18\":1,\"19\":1,\"20\":1},\"1\":{\"323\":1}}],[\"饿汉模式类似于spring框架初始化bean实例\",{\"1\":{\"18\":1}}],[\"饿汉模式\",{\"0\":{\"18\":1}}],[\"其范围为\",{\"1\":{\"429\":1}}],[\"其值就不能被修改\",{\"1\":{\"423\":1}}],[\"其封装了字节流\",{\"1\":{\"401\":1}}],[\"其余四个类是为\",{\"1\":{\"348\":1}}],[\"其内部类都比较简单\",{\"1\":{\"348\":1}}],[\"其与offer函数相对应\",{\"1\":{\"276\":1}}],[\"其与put函数相对应\",{\"1\":{\"275\":1}}],[\"其对队列的操作可能会抛出异常\",{\"1\":{\"269\":1}}],[\"其在序列化与反序列化的时候会发挥作用\",{\"1\":{\"254\":1}}],[\"其在普通的concurrenthashmap操作中已经没有失效\",{\"1\":{\"254\":1}}],[\"其子类pushbackreader\",{\"1\":{\"401\":1}}],[\"其子类keysetview\",{\"1\":{\"253\":1}}],[\"其子类有baseiterator\",{\"1\":{\"252\":1}}],[\"其子类有forwardingnode\",{\"1\":{\"251\":1}}],[\"其也有一个object类型的数组作为copyonwritearraylist数组的快照\",{\"1\":{\"235\":1}}],[\"其关键是\",{\"1\":{\"221\":1}}],[\"其源代码如下\",{\"1\":{\"197\":1,\"207\":1,\"213\":1,\"214\":3}}],[\"其源码如下\",{\"1\":{\"173\":2,\"174\":1,\"198\":2,\"214\":1,\"265\":1}}],[\"其底层是由aqs提供支持\",{\"1\":{\"193\":1}}],[\"其核心都是为了减少这种重量级锁的使用\",{\"1\":{\"148\":1}}],[\"其常量池中多了acc\",{\"1\":{\"147\":1}}],[\"其实不然\",{\"1\":{\"430\":1}}],[\"其实都是调用了线程中threadlocals变量的threadlocalmap类对应的get\",{\"1\":{\"282\":1}}],[\"其实现了sync类中的抽象lock方法\",{\"1\":{\"185\":1}}],[\"其实现了sync类中抽象的lock方法\",{\"1\":{\"184\":1}}],[\"其实本质上没有区别\",{\"1\":{\"147\":1}}],[\"其实wait\",{\"1\":{\"147\":1}}],[\"其实是做不到\",{\"1\":{\"97\":1}}],[\"其实在存储的时候是并没有存储的\",{\"1\":{\"75\":1}}],[\"其中是一个无参的构造函数\",{\"1\":{\"367\":1}}],[\"其中atomicinteger变量ctl的功能非常强大\",{\"1\":{\"309\":1}}],[\"其中参数含义如下\",{\"1\":{\"295\":1}}],[\"其中不少属性在hashmap中就已经介绍过\",{\"1\":{\"256\":1}}],[\"其中主要的内部类框架图如下图所示\",{\"1\":{\"250\":1}}],[\"其中每个hashentry是一个键值对\",{\"1\":{\"245\":1}}],[\"其中会调用到enq函数\",{\"1\":{\"214\":1}}],[\"其中一种写法\",{\"1\":{\"191\":1}}],[\"其中查询订单和派单是可以异步执行了\",{\"1\":{\"191\":1}}],[\"其中\",{\"1\":{\"174\":1,\"185\":1,\"199\":1,\"259\":2,\"273\":1,\"275\":1,\"358\":1}}],[\"其中node为参数\",{\"1\":{\"173\":1}}],[\"其中我们需要关注monitorenter和monitorexit的指令含义\",{\"1\":{\"147\":1}}],[\"其中prometheus\",{\"1\":{\"98\":1}}],[\"其中micrometer\",{\"1\":{\"97\":1}}],[\"其中job为采集任务\",{\"1\":{\"90\":1}}],[\"其无法反应在时间窗口内样本数据的突发变化\",{\"1\":{\"92\":1}}],[\"其他一些功能\",{\"1\":{\"423\":1}}],[\"其他队列都是无界的\",{\"1\":{\"226\":1}}],[\"其他任何线程都无法再获得同一个monitor对象\",{\"1\":{\"147\":1}}],[\"其他被这个monitor阻塞的线程可以尝试去获取这个\",{\"1\":{\"147\":1}}],[\"其他线程无法同时获取读锁或写锁\",{\"1\":{\"221\":1}}],[\"其他线程已经释放锁\",{\"1\":{\"175\":1}}],[\"其他线程需要等待\",{\"1\":{\"152\":1}}],[\"其他线程需要等待锁的释放\",{\"1\":{\"146\":1}}],[\"其他线程需要等待该线程执行完毕后才能继续执行\",{\"1\":{\"146\":1}}],[\"其他线程不能强行抢占线程\",{\"1\":{\"140\":1}}],[\"其他线程如果需要重写读取该变量会再次从主内存中读取\",{\"1\":{\"130\":1}}],[\"其他线程并不知道\",{\"1\":{\"127\":1}}],[\"其他线程知道数据被修改\",{\"1\":{\"127\":1}}],[\"其他线程能否立即看到这个修改\",{\"1\":{\"119\":1}}],[\"其他例子\",{\"1\":{\"115\":1}}],[\"其他常见的函数\",{\"0\":{\"91\":1}}],[\"其他操作系统应该没有这个问题\",{\"1\":{\"67\":1}}],[\"其他\",{\"0\":{\"21\":1}}],[\"其代码实现如下\",{\"1\":{\"17\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"14\":1}}],[\"的默认行为是使用对象的内存地址计算哈希码\",{\"1\":{\"431\":1}}],[\"的默认实现类\",{\"1\":{\"347\":1}}],[\"的多次调用应始终返回相同的结果\",{\"1\":{\"430\":1}}],[\"的区别\",{\"0\":{\"428\":1}}],[\"的类\",{\"1\":{\"421\":2}}],[\"的轮询机制下\",{\"1\":{\"416\":1}}],[\"的情况下\",{\"1\":{\"416\":1}}],[\"的方式能够更高效地处理多个连接的读写事件\",{\"1\":{\"416\":1}}],[\"的方法调用是基于运行时类型而不是编译时类型\",{\"1\":{\"424\":1}}],[\"的方法\",{\"1\":{\"17\":1,\"44\":1,\"401\":3}}],[\"的客户端程序\",{\"1\":{\"415\":1}}],[\"的服务器端程序\",{\"1\":{\"414\":1}}],[\"的网络编程场景\",{\"1\":{\"412\":1}}],[\"的事件\",{\"1\":{\"412\":1}}],[\"的优势在于可以使用较少的线程来处理多个通道的\",{\"1\":{\"407\":1}}],[\"的工作原理如下\",{\"1\":{\"407\":1}}],[\"的常用操作\",{\"1\":{\"406\":1}}],[\"的常用操作包括\",{\"1\":{\"406\":1}}],[\"的容量是在创建时预先确定的\",{\"1\":{\"406\":1}}],[\"的容量达到了一个较大的值\",{\"1\":{\"374\":1}}],[\"的特点和功能包括\",{\"1\":{\"404\":1}}],[\"的实例对象\",{\"1\":{\"419\":1}}],[\"的实例\",{\"1\":{\"401\":1}}],[\"的实现通常是线程安全的\",{\"1\":{\"264\":1}}],[\"的实现使用了快照的思路\",{\"1\":{\"242\":1}}],[\"的功能是查看最后一个字节\",{\"1\":{\"401\":1}}],[\"的数称之为素数\",{\"1\":{\"395\":1}}],[\"的数据读写以缓冲区为中心\",{\"1\":{\"403\":1}}],[\"的数据域\",{\"1\":{\"370\":1}}],[\"的数据到\",{\"1\":{\"370\":1}}],[\"的数据结构\",{\"1\":{\"351\":1}}],[\"的数据结构视为一个\",{\"1\":{\"347\":1}}],[\"的数据结构视为一个栈\",{\"1\":{\"347\":1}}],[\"的基本用法\",{\"1\":{\"393\":1}}],[\"的位数\",{\"1\":{\"393\":1}}],[\"的位置移到了\",{\"1\":{\"203\":1}}],[\"的第\",{\"1\":{\"392\":2}}],[\"的查找\",{\"1\":{\"382\":1}}],[\"的键\",{\"1\":{\"382\":1,\"387\":1,\"388\":1}}],[\"的底层数据结构是基于\",{\"1\":{\"382\":1}}],[\"的底层采用数组实现\",{\"1\":{\"358\":1}}],[\"的哈希值\",{\"1\":{\"377\":1}}],[\"的当前\",{\"1\":{\"377\":1}}],[\"的幂\",{\"1\":{\"375\":1}}],[\"的引用变量\",{\"1\":{\"424\":1}}],[\"的引用\",{\"1\":{\"374\":1}}],[\"的的底层数据结构为数组+链表\",{\"1\":{\"374\":1}}],[\"的内存占用较高\",{\"1\":{\"371\":1}}],[\"的内部计数器会被重置并重新开始等待\",{\"1\":{\"202\":1}}],[\"的后向引用置为\",{\"1\":{\"370\":1}}],[\"的后向节点\",{\"1\":{\"370\":5}}],[\"的后向节点指向\",{\"1\":{\"368\":1,\"370\":1}}],[\"的前向引用置为\",{\"1\":{\"370\":1}}],[\"的前向节点指向\",{\"1\":{\"370\":1}}],[\"的前向节点\",{\"1\":{\"370\":6}}],[\"的过程中\",{\"1\":{\"364\":1}}],[\"的值则被忽略\",{\"1\":{\"385\":1}}],[\"的值在\",{\"1\":{\"378\":1}}],[\"的值\",{\"1\":{\"364\":2,\"382\":1}}],[\"的迭代器通过内部类\",{\"1\":{\"364\":1}}],[\"的迭代器\",{\"1\":{\"364\":1}}],[\"的迭代器返回元素的顺序包含指定\",{\"1\":{\"234\":1}}],[\"的构造函数\",{\"1\":{\"359\":1}}],[\"的大小和是否为空\",{\"1\":{\"354\":1}}],[\"的大小\",{\"1\":{\"354\":1}}],[\"的大小可以根据需要进行动态调整\",{\"1\":{\"352\":1}}],[\"的映射关系\",{\"1\":{\"354\":1}}],[\"的形式存储数据\",{\"1\":{\"351\":1}}],[\"的轻量级实现\",{\"1\":{\"348\":1}}],[\"的顺序\",{\"1\":{\"347\":1}}],[\"的核心数据结构\",{\"1\":{\"347\":1}}],[\"的核心思想是基于一个先进先出\",{\"1\":{\"163\":1}}],[\"的任务\",{\"1\":{\"347\":2}}],[\"的思想\",{\"1\":{\"345\":1}}],[\"的关键特点\",{\"1\":{\"343\":1}}],[\"的一些静态方法设置线程池\",{\"1\":{\"337\":1}}],[\"的一些关键特点\",{\"1\":{\"264\":1}}],[\"的简单的非阻塞客户端程序\",{\"1\":{\"415\":1}}],[\"的简单的非阻塞服务器端程序\",{\"1\":{\"414\":1}}],[\"的简单示例\",{\"1\":{\"323\":1}}],[\"的简要介绍和示例用法\",{\"1\":{\"230\":1}}],[\"的子类都是装饰流\",{\"1\":{\"401\":2}}],[\"的子类\",{\"1\":{\"316\":1}}],[\"的时间内仍然没有新的任务提交\",{\"1\":{\"296\":1}}],[\"的时候\",{\"1\":{\"140\":1,\"328\":1,\"336\":1}}],[\"的设定进行等待\",{\"1\":{\"296\":1}}],[\"的设定被回收\",{\"1\":{\"296\":1}}],[\"的设计思想是在多线程任务中形成一个屏障\",{\"1\":{\"202\":1}}],[\"的问题\",{\"1\":{\"291\":1}}],[\"的元素删除操作是通过调用\",{\"1\":{\"388\":1}}],[\"的元素被存储为\",{\"1\":{\"387\":1,\"388\":1}}],[\"的元素添加操作是通过调用\",{\"1\":{\"386\":1}}],[\"的元素将会以键的形式存储在\",{\"1\":{\"385\":1}}],[\"的元素作为\",{\"1\":{\"382\":1}}],[\"的元素总数减少一个\",{\"1\":{\"362\":1}}],[\"的元素\",{\"1\":{\"271\":1,\"363\":3}}],[\"的线程是否被其他线程中断\",{\"1\":{\"331\":1}}],[\"的线程池\",{\"1\":{\"323\":2}}],[\"的线程安全和阻塞机制\",{\"1\":{\"267\":1}}],[\"的线程执行的操作\",{\"1\":{\"208\":1}}],[\"的阻塞特性\",{\"1\":{\"267\":1}}],[\"的示例代码\",{\"1\":{\"267\":1}}],[\"的性能取决于哈希函数的质量和哈希表的大小\",{\"1\":{\"382\":1}}],[\"的性能可能较低\",{\"1\":{\"229\":1}}],[\"的性能之所以比\",{\"1\":{\"221\":1}}],[\"的读操作是无锁的\",{\"1\":{\"228\":1}}],[\"的两种实现\",{\"1\":{\"225\":1}}],[\"的要求的表格\",{\"1\":{\"224\":1}}],[\"的老版本的sdk中\",{\"1\":{\"222\":1}}],[\"的主要作用包括\",{\"1\":{\"412\":1}}],[\"的主要属性和方法包括\",{\"1\":{\"406\":1}}],[\"的主要特点和组成部分包括\",{\"1\":{\"403\":1}}],[\"的主要特点包括\",{\"1\":{\"202\":1,\"322\":1}}],[\"的主要类\",{\"1\":{\"366\":1}}],[\"的主要实现类及其功能\",{\"1\":{\"266\":1}}],[\"的主要优势在于读取操作的高效性\",{\"1\":{\"229\":1}}],[\"的主线程就会从阻塞态被唤醒\",{\"1\":{\"191\":1}}],[\"的队列\",{\"1\":{\"175\":1,\"347\":1}}],[\"的获取与释放方式即可\",{\"1\":{\"164\":1}}],[\"的等待队列来管理线程的争用\",{\"1\":{\"163\":1}}],[\"的作用有以下几个方面\",{\"1\":{\"145\":1}}],[\"的锁\",{\"1\":{\"139\":2}}],[\"的语义\",{\"1\":{\"128\":1}}],[\"的源头\",{\"1\":{\"123\":1}}],[\"的发生\",{\"1\":{\"119\":1}}],[\"的处理速度\",{\"1\":{\"118\":1}}],[\"的请求量\",{\"1\":{\"116\":1}}],[\"的\",{\"1\":{\"105\":1,\"349\":1,\"352\":1,\"368\":1,\"369\":1,\"370\":1,\"377\":1,\"386\":3,\"387\":2,\"388\":3,\"406\":1,\"407\":1,\"410\":2,\"412\":3,\"414\":2}}],[\"的指标情况\",{\"1\":{\"81\":2}}],[\"的所有权\",{\"1\":{\"147\":1}}],[\"的所有的数据\",{\"1\":{\"81\":1}}],[\"的所有方法\",{\"1\":{\"53\":1}}],[\"的包含时间和值的流式数据\",{\"1\":{\"74\":1}}],[\"的项目\",{\"1\":{\"61\":1}}],[\"的代码如下\",{\"1\":{\"54\":1}}],[\"的抽象方法getname\",{\"1\":{\"41\":2}}],[\"的静态对象和\",{\"1\":{\"17\":1}}],[\"如hashset\",{\"1\":{\"431\":1}}],[\"如何理解java中的多态\",{\"0\":{\"424\":1}}],[\"如何理解面向过程和面向对象\",{\"0\":{\"422\":1}}],[\"如何避免死锁\",{\"0\":{\"141\":1}}],[\"如动物类\",{\"1\":{\"419\":1}}],[\"如读\",{\"1\":{\"407\":1}}],[\"如读写锁\",{\"1\":{\"152\":1}}],[\"如网络连接或文件\",{\"1\":{\"403\":1}}],[\"如图\",{\"1\":{\"416\":1}}],[\"如图片\",{\"1\":{\"399\":1}}],[\"如图所示\",{\"1\":{\"9\":1,\"25\":1}}],[\"如统计40亿个数据中没有出现的数据\",{\"1\":{\"394\":1}}],[\"如截取子列表\",{\"1\":{\"352\":1}}],[\"如list\",{\"1\":{\"351\":1}}],[\"如在try语句之前就返回了\",{\"1\":{\"438\":1}}],[\"如在\",{\"1\":{\"347\":1}}],[\"如exceptionally\",{\"1\":{\"337\":1}}],[\"如受到io限制\",{\"1\":{\"300\":1}}],[\"如锁\",{\"1\":{\"288\":1}}],[\"如锁已被其他线程持有\",{\"1\":{\"163\":1}}],[\"如\",{\"1\":{\"264\":1,\"389\":1,\"401\":2,\"407\":1}}],[\"如tab的第i项为空则用新生成的node替换\",{\"1\":{\"259\":1}}],[\"如进行了add\",{\"1\":{\"239\":1}}],[\"如添加\",{\"1\":{\"223\":1,\"229\":1,\"351\":1}}],[\"如尝试获取锁\",{\"1\":{\"188\":1}}],[\"如获取资源失败入队\",{\"1\":{\"164\":1}}],[\"如semaphore\",{\"1\":{\"164\":1}}],[\"如reentrantlock\",{\"1\":{\"164\":1}}],[\"如wait\",{\"1\":{\"159\":1}}],[\"如notify\",{\"1\":{\"155\":1,\"159\":1}}],[\"如互斥量\",{\"1\":{\"152\":1}}],[\"如类的实例变量\",{\"1\":{\"146\":1}}],[\"如intel的mesi协议\",{\"1\":{\"124\":1}}],[\"如寄存器状态\",{\"1\":{\"120\":1}}],[\"如全局的smtp配置\",{\"1\":{\"106\":1}}],[\"如下示意图可以清晰的表示\",{\"1\":{\"173\":1}}],[\"如下图\",{\"1\":{\"366\":1}}],[\"如下图所示\",{\"1\":{\"120\":1,\"222\":1,\"374\":1,\"435\":1}}],[\"如下图的uml图\",{\"1\":{\"17\":1}}],[\"如下\",{\"1\":{\"98\":2,\"116\":1,\"134\":1,\"149\":1,\"294\":1,\"403\":2}}],[\"如下表示prometheus\",{\"1\":{\"74\":1}}],[\"如果定义为final\",{\"1\":{\"436\":1}}],[\"如果外部类的方法中的变量不定义final\",{\"1\":{\"436\":1}}],[\"如果将局部变量\",{\"1\":{\"436\":1}}],[\"如果被final修饰的变量时引用类型\",{\"1\":{\"435\":1}}],[\"如果被中断则在等待队\",{\"1\":{\"331\":1}}],[\"如果某个属性可以为null\",{\"1\":{\"431\":1}}],[\"如果某个通道的事件处理完成后\",{\"1\":{\"407\":1}}],[\"如果x\",{\"1\":{\"430\":2}}],[\"如果两个对象根据equals\",{\"1\":{\"431\":1}}],[\"如果两个引用指向不同的对象\",{\"1\":{\"429\":1}}],[\"如果两个变量的引用指向同一个对象\",{\"1\":{\"429\":1}}],[\"如果一个类既需要作为其他类的基类\",{\"1\":{\"419\":1}}],[\"如果一个操作不是原子的\",{\"1\":{\"120\":1}}],[\"如果文件存在\",{\"1\":{\"401\":1}}],[\"如果除了1和它本身外\",{\"1\":{\"395\":1}}],[\"如果用于比较的对象信息没有被修改\",{\"1\":{\"430\":1}}],[\"如果用\",{\"1\":{\"392\":1}}],[\"如果相等\",{\"1\":{\"388\":1,\"430\":1}}],[\"如果删除成功\",{\"1\":{\"388\":1}}],[\"如果匹配则直接返回\",{\"1\":{\"378\":1}}],[\"如果匹配到了\",{\"1\":{\"85\":1}}],[\"如果遍历完链表或红黑树仍未找到相同的键\",{\"1\":{\"378\":1}}],[\"如果找到相同的键\",{\"1\":{\"376\":2,\"378\":1}}],[\"如果找到匹配的元素\",{\"1\":{\"362\":1}}],[\"如果头节点上treenode\",{\"1\":{\"376\":1}}],[\"如果该索引位置上没有键值对\",{\"1\":{\"378\":1}}],[\"如果该位置已经有键值对\",{\"1\":{\"377\":1}}],[\"如果该\",{\"1\":{\"376\":1}}],[\"如果链表长度超过了阈值\",{\"1\":{\"376\":1}}],[\"如果链表长度超过阈值\",{\"1\":{\"374\":1}}],[\"如果链表的尾节点\",{\"1\":{\"368\":2}}],[\"如果节点\",{\"1\":{\"370\":2}}],[\"如果索引\",{\"1\":{\"369\":2,\"376\":1,\"378\":1}}],[\"如果索引无效\",{\"1\":{\"369\":1,\"370\":1}}],[\"如果索引位于链表的后半段\",{\"1\":{\"369\":1}}],[\"如果索引位于链表的前半段\",{\"1\":{\"369\":1}}],[\"如果未找到指定元素\",{\"1\":{\"363\":1}}],[\"如果要操作的文件不存在\",{\"1\":{\"401\":1}}],[\"如果要查找的元素不为\",{\"1\":{\"363\":1}}],[\"如果要求分位耗时\",{\"1\":{\"97\":1}}],[\"如果index超出长度\",{\"1\":{\"363\":1}}],[\"如果超出了interger的软最大值则报错\",{\"1\":{\"361\":1}}],[\"如果elementdata是defaultcapacity\",{\"1\":{\"361\":1}}],[\"如果expr表达式的计算结果包含标签\",{\"1\":{\"113\":1}}],[\"如果数组容量过大且元素数量远小于容量的\",{\"1\":{\"358\":1}}],[\"如果数组中不存在\",{\"1\":{\"239\":1}}],[\"如果使用==\",{\"1\":{\"429\":1}}],[\"如果使用基本类型\",{\"1\":{\"423\":1}}],[\"如果使用相同的键插入多个值\",{\"1\":{\"354\":1}}],[\"如果使用没有预定义容量的linkedblockingqueue\",{\"1\":{\"299\":1}}],[\"如果小于阈值\",{\"1\":{\"349\":1}}],[\"如果这些变量共享同一个缓存行\",{\"1\":{\"347\":1}}],[\"如果转化失败则返回false表示取消失败\",{\"1\":{\"332\":1}}],[\"如果替换成功\",{\"1\":{\"331\":1}}],[\"如果第四步中新建的节点还没如队列\",{\"1\":{\"331\":1}}],[\"如果已经超时\",{\"1\":{\"331\":1}}],[\"如果已经存在\",{\"1\":{\"282\":1}}],[\"如果还没有入队列\",{\"1\":{\"331\":1}}],[\"如果等待节点为空\",{\"1\":{\"331\":2}}],[\"如果等待队列中有线程\",{\"1\":{\"175\":1}}],[\"如果等待队列中没有进程\",{\"1\":{\"175\":1}}],[\"如果状态处于中间状态completing\",{\"1\":{\"331\":1}}],[\"如果状态大于completing\",{\"1\":{\"331\":1}}],[\"如果状态为new则接着会通过unsafe类把任务执行线程引用cas的保存在runner字段中\",{\"1\":{\"329\":1}}],[\"如果成立\",{\"1\":{\"330\":1}}],[\"如果保存失败\",{\"1\":{\"329\":1}}],[\"如果赋值失败则直接返回\",{\"1\":{\"329\":1}}],[\"如果阻塞等待过程中超时则会抛出timeoutexception异常\",{\"1\":{\"326\":1}}],[\"如果阻塞等待过程中被中断则会抛出interruptedexception异常\",{\"1\":{\"326\":1}}],[\"如果阻塞队列为空\",{\"1\":{\"314\":1}}],[\"如果完成则返回true\",{\"1\":{\"326\":1}}],[\"如果异步任务已经完成或者已经被取消\",{\"1\":{\"326\":1}}],[\"如果获取到锁\",{\"1\":{\"319\":1}}],[\"如果call执行有异常\",{\"1\":{\"318\":1}}],[\"如果call执行成功\",{\"1\":{\"318\":1}}],[\"如果大于completing\",{\"1\":{\"317\":1}}],[\"如果大量的任务没有采用线程池的方式去执行\",{\"1\":{\"291\":1}}],[\"如果主线程被中断\",{\"1\":{\"317\":1}}],[\"如果发生异常\",{\"1\":{\"315\":1,\"328\":1}}],[\"如果发现该锁被其他线程持有\",{\"1\":{\"153\":1}}],[\"如果发现锁对象已被其他线程持有\",{\"1\":{\"152\":1}}],[\"如果队列中没有任务\",{\"1\":{\"310\":1,\"313\":1}}],[\"如果任务足够小\",{\"1\":{\"349\":1}}],[\"如果任务状态不为new\",{\"1\":{\"332\":1}}],[\"如果任务已经结束\",{\"1\":{\"332\":1}}],[\"如果任务已经开始执行了但是还没有执行完成\",{\"1\":{\"326\":1}}],[\"如果任务已经开始执行或已经完成\",{\"1\":{\"322\":1}}],[\"如果任务处于completing状态\",{\"1\":{\"331\":1}}],[\"如果任务成功执行则调用set\",{\"1\":{\"329\":1}}],[\"如果任务执行发生异常\",{\"1\":{\"329\":1}}],[\"如果任务执行过程发生异常则会抛出executionexception异常\",{\"1\":{\"326\":1}}],[\"如果任务被中断\",{\"1\":{\"329\":1}}],[\"如果任务被取消则会抛出cancellationexception异常\",{\"1\":{\"326\":1}}],[\"如果任务在结束\",{\"1\":{\"326\":1}}],[\"如果任务在指定时间内未完成\",{\"1\":{\"322\":1}}],[\"如果任务还没执行完毕\",{\"1\":{\"330\":1}}],[\"如果任务还没完成则会阻塞等待直到任务执行完成\",{\"1\":{\"326\":1}}],[\"如果任务还没有被执行\",{\"1\":{\"326\":1}}],[\"如果任务还未完成\",{\"1\":{\"322\":1}}],[\"如果任务经常阻塞\",{\"1\":{\"300\":1}}],[\"如果任务提交速度过快\",{\"1\":{\"300\":1}}],[\"如果创建线程和销毁线程的频次很高\",{\"1\":{\"291\":1}}],[\"如果此entity一直不被get\",{\"1\":{\"287\":1}}],[\"如果此时任务已经执行完毕则会直接返回任务结果\",{\"1\":{\"330\":1}}],[\"如果此时该资源恰好被释放\",{\"1\":{\"185\":1}}],[\"如果此时伪代码发生重排序\",{\"1\":{\"19\":1,\"121\":1}}],[\"如果回收之后\",{\"1\":{\"286\":1}}],[\"如果thread中的threadlocals变量为null\",{\"1\":{\"282\":1}}],[\"如果tryrelease成功\",{\"1\":{\"174\":1}}],[\"如果元素o在队列中存在\",{\"1\":{\"265\":1}}],[\"如果bincount大于等于转化为红黑树的阈值\",{\"1\":{\"259\":1}}],[\"如果计数到达零\",{\"1\":{\"199\":1}}],[\"如果存在则直接出队\",{\"1\":{\"265\":2}}],[\"如果存在\",{\"1\":{\"185\":1,\"387\":1}}],[\"如果是链表\",{\"1\":{\"376\":1}}],[\"如果是则抛出异常\",{\"1\":{\"364\":1}}],[\"如果是则继续循环获取锁\",{\"1\":{\"175\":1}}],[\"如果是\",{\"1\":{\"363\":1,\"378\":1}}],[\"如果是的话则在等待队列中删除对应节点然后抛出interruptedexception异常\",{\"1\":{\"331\":1}}],[\"如果是想做与money相关的业务\",{\"1\":{\"65\":1}}],[\"如果加锁成功\",{\"1\":{\"175\":1}}],[\"如果前驱节点是头结点并且能够获取\",{\"1\":{\"173\":1}}],[\"如果sync\",{\"1\":{\"173\":1}}],[\"如果允许\",{\"1\":{\"173\":1,\"183\":1}}],[\"如果所有的线程都在等待此条件\",{\"1\":{\"169\":2,\"214\":1}}],[\"如果对共享资源的争用时间很短\",{\"1\":{\"153\":1}}],[\"如果对上述内容有较好的了解的话\",{\"1\":{\"152\":1}}],[\"如果只需要保证可见性\",{\"1\":{\"153\":1}}],[\"如果共享资源在读操作上存在更多的并发访问\",{\"1\":{\"153\":1}}],[\"如果始终得不到锁竞争的线程使用自旋会消耗cpu\",{\"1\":{\"152\":1}}],[\"如果线程不允许无休止空闲timed\",{\"1\":{\"314\":1}}],[\"如果线程允许空闲等待而不被销毁timed\",{\"1\":{\"314\":1}}],[\"如果线程池没有running\",{\"1\":{\"311\":1}}],[\"如果线程池已经达到最大线程数\",{\"1\":{\"303\":1}}],[\"如果线程池中的线程数已经达到核心线程数\",{\"1\":{\"303\":1}}],[\"如果线程池处于饱和状态\",{\"1\":{\"302\":1}}],[\"如果线程间存在锁竞争\",{\"1\":{\"152\":1}}],[\"如果线程已经占有该monitor\",{\"1\":{\"147\":1}}],[\"如果没有找到相同的键\",{\"1\":{\"376\":1}}],[\"如果没有立即可用的线程来运行任务\",{\"1\":{\"298\":1}}],[\"如果没有限制则返回integer\",{\"1\":{\"265\":1}}],[\"如果没有空间则等待timeout时间\",{\"1\":{\"265\":2}}],[\"如果没有空间则一直阻塞等待\",{\"1\":{\"265\":2}}],[\"如果没有空间则抛出illegalstateexception\",{\"1\":{\"265\":1}}],[\"如果没有空间返回false\",{\"1\":{\"265\":1}}],[\"如果没有设置sziectl的值\",{\"1\":{\"259\":1}}],[\"如果没有加锁成功\",{\"1\":{\"175\":1}}],[\"如果没有获取到锁\",{\"1\":{\"158\":1}}],[\"如果没有其他线程持有该锁对象\",{\"1\":{\"151\":1}}],[\"如果没有配置\",{\"1\":{\"113\":1}}],[\"如果设置了\",{\"1\":{\"147\":1}}],[\"如果减1后进入数为0\",{\"1\":{\"147\":1}}],[\"如果其他线程已经占用了monitor\",{\"1\":{\"147\":1}}],[\"如果其他处理器也包含该变量\",{\"1\":{\"124\":1}}],[\"如果monitor的进入数为0\",{\"1\":{\"147\":1}}],[\"如果锁已经被其他线程持有\",{\"1\":{\"147\":1}}],[\"如果当前任务状态大于completing则表示任务执行完成\",{\"1\":{\"331\":1}}],[\"如果当前state等于completing\",{\"1\":{\"317\":1}}],[\"如果当前运行的线程数小于最大线程数\",{\"1\":{\"303\":1}}],[\"如果当前运行的线程数小于核心线程数\",{\"1\":{\"303\":1}}],[\"如果当前运行的线程数已经达到核心线程数\",{\"1\":{\"303\":1}}],[\"如果当前线程未被中断\",{\"1\":{\"273\":1,\"275\":1}}],[\"如果当前线程在一定时间内没有完成任务\",{\"1\":{\"141\":1}}],[\"如果当前没有其他线程持有锁\",{\"1\":{\"147\":1}}],[\"如果当前账户的id小于目标账户的id\",{\"1\":{\"143\":1}}],[\"如果资源申请不成功\",{\"1\":{\"142\":1}}],[\"如果\",{\"1\":{\"136\":1,\"376\":1,\"377\":1,\"378\":2,\"386\":2,\"387\":1}}],[\"如果在finally中再次使用了return操作\",{\"1\":{\"438\":2}}],[\"如果在catch中再次使用了return操作\",{\"1\":{\"438\":1}}],[\"如果在try块中发生了异常\",{\"1\":{\"438\":2}}],[\"如果在try块中没有发生异常\",{\"1\":{\"438\":1}}],[\"如果在此过程中发生了异常\",{\"1\":{\"432\":1}}],[\"如果在单线程环境下进行字符串操作\",{\"1\":{\"421\":1}}],[\"如果在多线程环境下执行字符串操作\",{\"1\":{\"421\":1}}],[\"如果在多线程环境下使用\",{\"1\":{\"389\":1}}],[\"如果在链表或红黑树中找到键对应的节点\",{\"1\":{\"378\":1}}],[\"如果在keepalivetime时间内\",{\"1\":{\"314\":1}}],[\"如果在\",{\"1\":{\"153\":1,\"296\":1}}],[\"如果在这个过程中发现有其他线程竞争锁对象\",{\"1\":{\"151\":1}}],[\"如果在变量加上volatile关键字\",{\"1\":{\"131\":1}}],[\"如果在目标类中\",{\"1\":{\"27\":1}}],[\"如果有新的任务提交给线程池\",{\"1\":{\"297\":1}}],[\"如果有空间则直接插入\",{\"1\":{\"265\":4}}],[\"如果有两个线程同时对i进行i++操作\",{\"1\":{\"124\":1}}],[\"如果有告警发生\",{\"1\":{\"101\":1}}],[\"如果我们没有重写hashcode\",{\"1\":{\"431\":1}}],[\"如果我们没有搞清楚并发编程的原理\",{\"1\":{\"119\":1}}],[\"如果我们想查询一个时间区间的样本\",{\"1\":{\"82\":1}}],[\"如果labels配置中含有额外的标签也会放到新的timeseries中\",{\"1\":{\"113\":1}}],[\"如果判断需要发送消息给下游的webhook程序\",{\"1\":{\"110\":1}}],[\"如果告警消息符合匹配\",{\"1\":{\"105\":1}}],[\"如果系统发出成千上万条相同的告警消息\",{\"1\":{\"103\":1}}],[\"如果想要创建一个符合业务场景的线程池\",{\"1\":{\"294\":1}}],[\"如果想计算所有的请求的总数\",{\"1\":{\"90\":1}}],[\"如果想查询五分钟前的数据\",{\"1\":{\"83\":1}}],[\"如果不相等则抛出异常\",{\"1\":{\"364\":1}}],[\"如果不为空数组\",{\"1\":{\"361\":1}}],[\"如果不为new则说明任务或者已经执行过\",{\"1\":{\"329\":1}}],[\"如果不够\",{\"1\":{\"358\":1}}],[\"如果不需要中断任务执行线程\",{\"1\":{\"332\":2}}],[\"如果不成立表明任务已经结束\",{\"1\":{\"330\":1}}],[\"如果不使用线程池\",{\"1\":{\"291\":1}}],[\"如果不使用观察者模式来捕获一个被观察对象的属性变化\",{\"1\":{\"51\":1}}],[\"如果不同线程对同一变量的操作不是可见的\",{\"1\":{\"119\":1}}],[\"如果不进行分组合并\",{\"1\":{\"103\":1}}],[\"如果不用ignoring修改器\",{\"1\":{\"89\":1}}],[\"如果需要在多线程中操作同一个map\",{\"1\":{\"379\":1}}],[\"如果需要进行扩容操作\",{\"1\":{\"377\":1}}],[\"如果需要使用返回值\",{\"1\":{\"336\":1}}],[\"如果需要中断任务执行线程\",{\"1\":{\"332\":1}}],[\"如果需要等待特定时间\",{\"1\":{\"331\":1}}],[\"如果需要把证消息发送的顺序\",{\"1\":{\"51\":1}}],[\"如果需要增加新的产品类\",{\"1\":{\"41\":1}}],[\"如果处理链路过长\",{\"1\":{\"37\":1}}],[\"方便更好地表示一个变量无值的状态\",{\"1\":{\"423\":1}}],[\"方便处理异步操作中的异常情况\",{\"1\":{\"337\":1}}],[\"方便统一管理和修改\",{\"1\":{\"16\":1}}],[\"方案二\",{\"0\":{\"98\":1}}],[\"方案一\",{\"0\":{\"97\":1}}],[\"方案设计\",{\"1\":{\"8\":1}}],[\"方法和变量\",{\"1\":{\"435\":1,\"437\":1}}],[\"方法和用法示例\",{\"1\":{\"393\":1}}],[\"方法应返回相同的值\",{\"1\":{\"431\":1}}],[\"方法比较相等\",{\"1\":{\"431\":1}}],[\"方法是\",{\"1\":{\"431\":1}}],[\"方法是很重要的\",{\"1\":{\"431\":1}}],[\"方法是比较两个对象的内存地址是否相等\",{\"1\":{\"430\":1}}],[\"方法计算出来的哈希码可能不相等\",{\"1\":{\"431\":1}}],[\"方法而不是==\",{\"1\":{\"423\":1}}],[\"方法重载\",{\"1\":{\"423\":1}}],[\"方法默认是抽象类并且是pulic方法\",{\"1\":{\"419\":1}}],[\"方法向客户端写入数据\",{\"1\":{\"414\":1}}],[\"方法从\",{\"1\":{\"414\":1}}],[\"方法从文件通道中读取数据到缓冲区\",{\"1\":{\"405\":1}}],[\"方法接收连接\",{\"1\":{\"414\":1}}],[\"方法接受一个对象\",{\"1\":{\"387\":1,\"388\":1}}],[\"方法接受一个元素\",{\"1\":{\"386\":1}}],[\"方法绑定服务器端口\",{\"1\":{\"411\":1}}],[\"方法关闭通道\",{\"1\":{\"410\":1}}],[\"方法创建一个\",{\"1\":{\"407\":1,\"412\":1}}],[\"方法读取部分数据\",{\"1\":{\"406\":1}}],[\"方法写入数据\",{\"1\":{\"406\":1}}],[\"方法写入数据到缓冲区\",{\"1\":{\"406\":1}}],[\"方法清空缓冲区\",{\"1\":{\"406\":1}}],[\"方法清除变量副本\",{\"1\":{\"281\":1}}],[\"方法逐个字节读取数据并输出\",{\"1\":{\"406\":1}}],[\"方法切换为读取模式\",{\"1\":{\"406\":1}}],[\"方法演示\",{\"1\":{\"406\":2}}],[\"方法将要监听的事件和对应的事件处理器注册到\",{\"1\":{\"412\":1}}],[\"方法将缓冲区的位置重置为\",{\"1\":{\"406\":1}}],[\"方法将读取模式切换为写入模式\",{\"1\":{\"406\":1}}],[\"方法将写入模式切换为读取模式\",{\"1\":{\"406\":1}}],[\"方法将位置重置为标记位置\",{\"1\":{\"406\":1}}],[\"方法将当前位置设置为标记位置\",{\"1\":{\"406\":1}}],[\"方法将数据写入文件通道\",{\"1\":{\"405\":1}}],[\"方法将\",{\"1\":{\"388\":1}}],[\"方法将元素\",{\"1\":{\"386\":1}}],[\"方法将元素或集合添加到列表中\",{\"1\":{\"352\":1}}],[\"方法成功时\",{\"1\":{\"388\":1}}],[\"方法最终返回\",{\"1\":{\"387\":1}}],[\"方法最后根据\",{\"1\":{\"386\":1}}],[\"方法返回之前执行\",{\"1\":{\"438\":1}}],[\"方法返回\",{\"1\":{\"368\":1}}],[\"方法返回的类型\",{\"1\":{\"325\":1}}],[\"方法先调用\",{\"1\":{\"368\":1,\"369\":1,\"370\":1}}],[\"方法删除元素\",{\"1\":{\"364\":1}}],[\"方法删除指定元素或集合中的元素\",{\"1\":{\"352\":1}}],[\"方法移除元素后\",{\"1\":{\"364\":1}}],[\"方法检查索引是否有效\",{\"1\":{\"369\":1,\"370\":1}}],[\"方法检查\",{\"1\":{\"364\":2}}],[\"方法用于根据哈希值和键在\",{\"1\":{\"378\":1}}],[\"方法用于计算大于等于给定容量的最小\",{\"1\":{\"375\":1}}],[\"方法用于删除链表中指定索引处的元素\",{\"1\":{\"370\":1}}],[\"方法用于删除链表头部的元素\",{\"1\":{\"366\":1}}],[\"方法用于在链表的尾部添加元素\",{\"1\":{\"368\":1}}],[\"方法用于在链表尾部添加元素\",{\"1\":{\"366\":1}}],[\"方法用于返回链表的大小\",{\"1\":{\"366\":1}}],[\"方法用于获取链表中指定索引处的元素\",{\"1\":{\"369\":1}}],[\"方法用于获取指定索引位置上的元素\",{\"1\":{\"366\":1}}],[\"方法用于获取下一个元素\",{\"1\":{\"364\":1}}],[\"方法用于检查\",{\"1\":{\"364\":1,\"387\":1}}],[\"方法用于移除上一个元素\",{\"1\":{\"364\":1}}],[\"方法用于判断是否还有下一个元素\",{\"1\":{\"364\":1}}],[\"方法用来取消异步任务的执行\",{\"1\":{\"326\":1}}],[\"方法首先判断要查找的元素是否为\",{\"1\":{\"363\":1}}],[\"方法首先会\",{\"1\":{\"329\":1}}],[\"方法内部调用了\",{\"1\":{\"363\":1}}],[\"方法名称相同\",{\"1\":{\"418\":1}}],[\"方法名\",{\"1\":{\"360\":1}}],[\"方法遍历列表中的元素\",{\"1\":{\"352\":1}}],[\"方法修改列表中指定位置的元素\",{\"1\":{\"352\":1}}],[\"方法在任务结果计算完毕之后才会运行\",{\"1\":{\"348\":1}}],[\"方法在队列已满或为空时会阻塞当前线程一段特定的时间\",{\"1\":{\"265\":1}}],[\"方法在队列已满或为空时会阻塞当前线程\",{\"1\":{\"265\":1}}],[\"方法在队列已满或为空时会返回特定值\",{\"1\":{\"265\":1}}],[\"方法在队列已满或为空时会抛出异常\",{\"1\":{\"265\":1}}],[\"方法执行异步任务\",{\"1\":{\"343\":1}}],[\"方法执行完后再释放monitor\",{\"1\":{\"147\":1}}],[\"方法并配合回调函数实现这个需求\",{\"1\":{\"341\":1,\"342\":1}}],[\"方法并等待指定的时间到期后\",{\"1\":{\"157\":1}}],[\"方法异步处理最终的结果\",{\"1\":{\"340\":1}}],[\"方法对任务的结果进行二倍处理\",{\"1\":{\"340\":1}}],[\"方法提交一个异步任务\",{\"1\":{\"339\":1,\"340\":1}}],[\"方法提交任务并获得一个\",{\"1\":{\"323\":1}}],[\"方法会根据指定键的哈希值和相等性判断\",{\"1\":{\"387\":1,\"388\":1}}],[\"方法会判断是否删除的是\",{\"1\":{\"362\":1}}],[\"方法会做下面几件事\",{\"1\":{\"332\":1}}],[\"方法会阻塞当前线程直到任务完成并返回结果\",{\"1\":{\"322\":1}}],[\"方法进行数据的写入\",{\"1\":{\"410\":1}}],[\"方法进行数据的读取\",{\"1\":{\"410\":1}}],[\"方法进行判断\",{\"1\":{\"382\":1}}],[\"方法进行查找操作\",{\"1\":{\"378\":1}}],[\"方法进行删除\",{\"1\":{\"364\":1}}],[\"方法进行元素的删除操作\",{\"1\":{\"364\":1}}],[\"方法进行比较\",{\"1\":{\"363\":1}}],[\"方法进行快速删除\",{\"1\":{\"362\":1}}],[\"方法进行阻塞等待\",{\"1\":{\"331\":1}}],[\"方法进行内存的清除\",{\"1\":{\"287\":1}}],[\"方法实现\",{\"1\":{\"419\":1}}],[\"方法实现的\",{\"1\":{\"386\":1,\"388\":1}}],[\"方法实现对列表的操作\",{\"1\":{\"352\":1}}],[\"方法实现子任务的并行执行和结果的合并\",{\"1\":{\"349\":1}}],[\"方法实现比较简单\",{\"1\":{\"330\":1}}],[\"方法实现如下\",{\"1\":{\"329\":1,\"330\":1}}],[\"方法设置为非阻塞模式\",{\"1\":{\"410\":1,\"411\":1}}],[\"方法设置执行结果\",{\"1\":{\"329\":1}}],[\"方法设置等待任务结果的时间限制\",{\"1\":{\"322\":1}}],[\"方法中的locksupport\",{\"1\":{\"333\":1}}],[\"方法中\",{\"1\":{\"329\":1,\"349\":1,\"368\":1,\"369\":1,\"370\":1,\"414\":5,\"415\":1}}],[\"方法如下\",{\"1\":{\"329\":1}}],[\"方法保存异常信息\",{\"1\":{\"329\":1}}],[\"方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前\",{\"1\":{\"328\":1}}],[\"方法取消任务且不中断任务执行线程\",{\"1\":{\"328\":1}}],[\"方法取消任务的执行\",{\"1\":{\"322\":1,\"332\":1}}],[\"方法等待异步任务执行完成\",{\"1\":{\"339\":1,\"340\":1}}],[\"方法等待任务执行完成并获取结果\",{\"1\":{\"343\":1}}],[\"方法等待任务执行完成\",{\"1\":{\"323\":2}}],[\"方法等待它们执行结束\",{\"1\":{\"119\":1}}],[\"方法判断任务是否已经完成\",{\"1\":{\"322\":1}}],[\"方法已经执行完成\",{\"1\":{\"309\":1}}],[\"方法获取到\",{\"1\":{\"407\":1}}],[\"方法获取元素或元素的索引\",{\"1\":{\"352\":1}}],[\"方法获取任务的结果\",{\"1\":{\"322\":1}}],[\"方法获取自己的变量副本\",{\"1\":{\"281\":1}}],[\"方法获取实例\",{\"1\":{\"18\":1}}],[\"方法体里面每次都去创建一个countdownlatch去做线程的同步等待\",{\"1\":{\"203\":1}}],[\"方法使得计数器\",{\"1\":{\"190\":1}}],[\"方法来轮询已注册的\",{\"1\":{\"412\":1}}],[\"方法来轮询监听注册的通道\",{\"1\":{\"407\":1}}],[\"方法来接受客户端的连接请求\",{\"1\":{\"411\":1}}],[\"方法来连接远程服务器\",{\"1\":{\"410\":1}}],[\"方法来打开一个\",{\"1\":{\"410\":1,\"411\":1}}],[\"方法来删除\",{\"1\":{\"388\":1}}],[\"方法来判断\",{\"1\":{\"387\":1}}],[\"方法来初始化\",{\"1\":{\"377\":1}}],[\"方法来执行元素的插入操作\",{\"1\":{\"368\":1}}],[\"方法来执行任务\",{\"1\":{\"346\":1}}],[\"方法来执行任务并返回结果\",{\"1\":{\"346\":1}}],[\"方法来支持迭代\",{\"1\":{\"364\":1}}],[\"方法来创建一个新的\",{\"1\":{\"341\":1,\"342\":1}}],[\"方法来处理可能发生的异常情况\",{\"1\":{\"340\":1}}],[\"方法来获取任务执行结果\",{\"1\":{\"330\":1}}],[\"方法来更改核心线程数量或允许核心线程超时\",{\"1\":{\"295\":1}}],[\"方法来实现等待\",{\"1\":{\"186\":1}}],[\"方法来协调两个线程的执行顺序\",{\"1\":{\"160\":1}}],[\"方法时需要注意的规则\",{\"1\":{\"431\":1}}],[\"方法时\",{\"1\":{\"157\":1,\"190\":1,\"282\":1,\"386\":1,\"424\":1,\"431\":2}}],[\"方法的定义如下\",{\"1\":{\"431\":1}}],[\"方法的比较内容无关\",{\"1\":{\"431\":1}}],[\"方法的重写\",{\"1\":{\"424\":1}}],[\"方法的使用\",{\"1\":{\"406\":1}}],[\"方法的返回值将被用作对象的索引\",{\"1\":{\"431\":1}}],[\"方法的返回值\",{\"1\":{\"412\":1}}],[\"方法的返回值与固定的占位符对象\",{\"1\":{\"388\":1}}],[\"方法的返回结果\",{\"1\":{\"386\":1}}],[\"方法的结果\",{\"1\":{\"387\":1}}],[\"方法的简化版源码\",{\"1\":{\"378\":1}}],[\"方法的源码分析\",{\"1\":{\"387\":1,\"388\":1}}],[\"方法的源码\",{\"1\":{\"370\":1,\"386\":1}}],[\"方法的源码如下\",{\"1\":{\"368\":1,\"369\":1}}],[\"方法的同步并没有通过指令monitorenter和monitorexit来完成\",{\"1\":{\"147\":1}}],[\"方法的原子性操作\",{\"1\":{\"146\":1}}],[\"方法的调用\",{\"1\":{\"136\":1,\"198\":1,\"199\":1}}],[\"方法之前和之后做了功能的增强\",{\"1\":{\"54\":1}}],[\"方法\",{\"0\":{\"311\":1,\"368\":1,\"369\":1,\"370\":1},\"1\":{\"20\":1,\"36\":3,\"47\":1,\"136\":1,\"147\":1,\"157\":1,\"175\":1,\"186\":1,\"191\":1,\"203\":1,\"265\":1,\"282\":1,\"314\":1,\"333\":1,\"337\":1,\"362\":1,\"363\":2,\"369\":1,\"370\":1,\"376\":1,\"401\":1,\"419\":1,\"422\":1,\"424\":2,\"430\":3,\"431\":2}}],[\"方法才会初始化实例instance\",{\"1\":{\"19\":1}}],[\"提交给线程池执行\",{\"1\":{\"323\":1,\"336\":1}}],[\"提交任务并获得\",{\"1\":{\"323\":1}}],[\"提交任务\",{\"1\":{\"303\":1}}],[\"提交任务的线程会自己执行任务\",{\"1\":{\"302\":1}}],[\"提交查询订单的任务和查询派单的任务\",{\"1\":{\"203\":1}}],[\"提高代码的安全性\",{\"1\":{\"435\":1}}],[\"提高散列存储结构的性能\",{\"1\":{\"431\":1}}],[\"提高系统的吞吐量和响应性能\",{\"1\":{\"407\":1}}],[\"提高系统的响应速度和吞吐量\",{\"1\":{\"291\":1}}],[\"提高\",{\"1\":{\"403\":1}}],[\"提高并发性能\",{\"1\":{\"153\":1}}],[\"提高多线程程序的性能\",{\"1\":{\"146\":1}}],[\"提高程序的运行效率\",{\"1\":{\"118\":1}}],[\"提高了\",{\"1\":{\"412\":1}}],[\"提高了系统的并发处理能力\",{\"1\":{\"412\":1}}],[\"提高了系统的资源利用率和响应速度\",{\"1\":{\"407\":1}}],[\"提高了系统的灵活性和可维护性\",{\"1\":{\"37\":1}}],[\"提高了数据传输的效率\",{\"1\":{\"404\":1}}],[\"提高了程序的响应速度\",{\"1\":{\"152\":1}}],[\"提高了程序的性能和响应能力\",{\"1\":{\"403\":1}}],[\"提高了程序的性能\",{\"1\":{\"150\":1}}],[\"提高了cpu的工作效率\",{\"1\":{\"118\":1}}],[\"提升代码的可扩展性\",{\"1\":{\"37\":1}}],[\"提升代码的复用性\",{\"1\":{\"16\":1}}],[\"提供一些通用方法的实现\",{\"1\":{\"419\":1}}],[\"提供一个静态工厂方法用于创建不同的产品对象\",{\"1\":{\"40\":1}}],[\"提供一个全局的访问点\",{\"1\":{\"10\":1}}],[\"提供的一种多路复用的机制\",{\"1\":{\"403\":1}}],[\"提供的乐观读\",{\"1\":{\"221\":1}}],[\"提供更加灵活和可控的线程管理方式\",{\"1\":{\"291\":1}}],[\"提供更大的灵活性\",{\"1\":{\"57\":1}}],[\"提供了访问基本类型数据的方法\",{\"1\":{\"423\":1}}],[\"提供了灵活而高效的\",{\"1\":{\"410\":1,\"411\":1}}],[\"提供了对文件的更强大和灵活的支持\",{\"1\":{\"403\":1}}],[\"提供了更高效的数据传输能力\",{\"1\":{\"403\":1}}],[\"提供了字符缓冲功能\",{\"1\":{\"401\":1}}],[\"提供了写入基本数据类型\",{\"1\":{\"401\":1}}],[\"提供了写入数据的高效能力\",{\"1\":{\"401\":1}}],[\"提供了\",{\"1\":{\"401\":1}}],[\"提供了读取基本数据类型\",{\"1\":{\"401\":1}}],[\"提供了读取数据的高效能力\",{\"1\":{\"401\":1}}],[\"提供了基本的类操作方法\",{\"1\":{\"401\":1}}],[\"提供了相关操作方法\",{\"1\":{\"399\":1}}],[\"提供了高效的事件多路复用能力\",{\"1\":{\"412\":1}}],[\"提供了高效的键值对存储和查找能力\",{\"1\":{\"379\":1}}],[\"提供了高效的查找操作\",{\"1\":{\"353\":1}}],[\"提供了多种方法来操作链表\",{\"1\":{\"371\":1}}],[\"提供了根据键快速查找对应值的方法\",{\"1\":{\"354\":1}}],[\"提供了丰富的方法和组合操作\",{\"1\":{\"337\":1}}],[\"提供了异常处理的方法\",{\"1\":{\"337\":1}}],[\"提供了runnable\",{\"1\":{\"292\":1}}],[\"提供了线程本地的变量副本\",{\"1\":{\"280\":1}}],[\"提供了一套完整的开发工具\",{\"1\":{\"433\":1}}],[\"提供了一种通用的规范\",{\"1\":{\"419\":1}}],[\"提供了一种基于\",{\"1\":{\"223\":1}}],[\"提供了一系列的阻塞队列操作\",{\"1\":{\"264\":1}}],[\"提供了copyonwritearrayset和concurrentskiplistset\",{\"1\":{\"225\":1}}],[\"提供了同步容器\",{\"1\":{\"222\":1}}],[\"提供了公平锁和非公平锁的获取方式\",{\"1\":{\"188\":1}}],[\"提供了非常多的面板和插件\",{\"1\":{\"71\":1}}],[\"提供了单节点和分布式的数据存储方案\",{\"1\":{\"62\":1}}],[\"提供了数据查询的promql\",{\"1\":{\"62\":1}}],[\"提供了数据采集\",{\"1\":{\"61\":1}}],[\"提供整个责任链的可扩展性\",{\"1\":{\"37\":1}}],[\"提供统一的方法来访问内部子系统\",{\"1\":{\"11\":1}}],[\"防止程序因为出现异常而奔溃\",{\"1\":{\"432\":1}}],[\"防止指令重排\",{\"0\":{\"135\":1}}],[\"防止对象的频繁创建\",{\"1\":{\"16\":1}}],[\"防止它频繁的被创建或者被销毁\",{\"1\":{\"16\":1}}],[\"就不能再指向另一个对象了\",{\"1\":{\"435\":1}}],[\"就不能再更改\",{\"1\":{\"435\":1}}],[\"就无法访问其对象方法和属性\",{\"1\":{\"423\":1}}],[\"就需要将其包装成相应的对象类型\",{\"1\":{\"423\":1}}],[\"就遍历处理相应的事件类型\",{\"1\":{\"414\":1}}],[\"就优先考虑使用字符流\",{\"1\":{\"399\":1}}],[\"就搞定\",{\"1\":{\"392\":1}}],[\"就执行结束返回了\",{\"1\":{\"331\":1}}],[\"就说明worker是空闲的\",{\"1\":{\"319\":1}}],[\"就拒绝再接受任务\",{\"1\":{\"319\":1}}],[\"就先尝试执行这个任务\",{\"1\":{\"313\":1}}],[\"就remove\",{\"1\":{\"311\":1}}],[\"就从父线程哪里拷贝过来一个过来\",{\"1\":{\"288\":1}}],[\"就会无意中影响彼此的性能\",{\"1\":{\"347\":1}}],[\"就会返回false\",{\"1\":{\"319\":1}}],[\"就会将parent的inheritablethreadlocals\",{\"1\":{\"288\":1}}],[\"就会阻塞\",{\"1\":{\"148\":1}}],[\"就一直不会被回收\",{\"1\":{\"287\":1}}],[\"就指向这个内部数组\",{\"1\":{\"223\":1,\"229\":1}}],[\"就绪状态\",{\"1\":{\"155\":1}}],[\"就能够预防死锁的发生\",{\"1\":{\"140\":1}}],[\"就能够提供给其他对象在各个地方使用\",{\"1\":{\"16\":1}}],[\"就有可能发生死锁\",{\"1\":{\"140\":1}}],[\"就可能导致数据不一致\",{\"1\":{\"119\":1}}],[\"就可以直接中断它\",{\"1\":{\"319\":1}}],[\"就可以具体的执行告警逻辑\",{\"1\":{\"110\":1}}],[\"就可以看到本机的资源dashboard\",{\"1\":{\"71\":1}}],[\"就可以看到各个目录的磁盘剩余字节数了\",{\"1\":{\"69\":1}}],[\"就可以进行配置的热更新\",{\"1\":{\"70\":1}}],[\"就可以采集node\",{\"1\":{\"69\":1}}],[\"就可以查看node\",{\"1\":{\"69\":1}}],[\"就可以访问prometheus页面了\",{\"1\":{\"67\":1}}],[\"就是printstream\",{\"1\":{\"401\":1}}],[\"就是\",{\"1\":{\"392\":1}}],[\"就是如果当前线程的inheritablethreadlocals不为null\",{\"1\":{\"288\":1}}],[\"就是循环等待\",{\"1\":{\"140\":1}}],[\"就是这三者的处理速度差异非常大\",{\"1\":{\"118\":1}}],[\"就是一个对象应该尽量对外少暴露\",{\"1\":{\"14\":1}}],[\"就是将实例化工作交给子类完成\",{\"1\":{\"10\":1,\"42\":1}}],[\"对异常进行合适的处理\",{\"1\":{\"432\":1}}],[\"对称性\",{\"1\":{\"430\":1}}],[\"对字符串进行操作时不需要创建新的对象\",{\"1\":{\"421\":1}}],[\"对性能会有一定的影响\",{\"1\":{\"421\":1}}],[\"对每一个新进来的连接都会创建一个socketchannel\",{\"1\":{\"403\":1}}],[\"对reader\",{\"1\":{\"401\":1}}],[\"对reentrantlock类的操作大部分都直接转化为对sync和abstractqueuedsynchronizer类的操作\",{\"1\":{\"180\":1}}],[\"对空数组进行初始化\",{\"1\":{\"361\":1}}],[\"对应的键值对\",{\"1\":{\"388\":1}}],[\"对应的entity就成了key为null的实例\",{\"1\":{\"287\":1}}],[\"对应的entry也会被从threadlocalmap中删除\",{\"1\":{\"285\":1}}],[\"对应的get方法源码如下\",{\"1\":{\"282\":1}}],[\"对应的java实体如下\",{\"1\":{\"110\":1}}],[\"对变量进行操作\",{\"1\":{\"281\":1}}],[\"对其他线程而言是隔离的\",{\"1\":{\"280\":1}}],[\"对桶中第一个结点进行加锁\",{\"1\":{\"259\":1}}],[\"对桶中的第一个结点\",{\"1\":{\"259\":1}}],[\"对该桶进行遍历\",{\"1\":{\"259\":1}}],[\"对表初始化和扩容控制\",{\"1\":{\"256\":1}}],[\"对视图均可以进行操作\",{\"1\":{\"253\":1}}],[\"对current进行遍历操作\",{\"1\":{\"239\":1}}],[\"对countdown的调用转换为对sync对象的releaseshared\",{\"1\":{\"199\":1}}],[\"对countdownlatch的countdown调用大致会有如下的调用链\",{\"1\":{\"199\":1}}],[\"对countdownlatch的await调用大致会有如下的调用链\",{\"1\":{\"198\":1}}],[\"对countdownlatch对象的await的调用会转发为对sync的acquiresharedinterruptibly\",{\"1\":{\"198\":1}}],[\"对countdownlatch方法的调用会转发到对sync或aqs的方法的调用\",{\"1\":{\"197\":1}}],[\"对数组len索引的元素赋值为e\",{\"1\":{\"239\":1}}],[\"对数组进行了修改\",{\"1\":{\"239\":2}}],[\"对写操作加了排他性的限制\",{\"1\":{\"218\":1}}],[\"对写入的字符进行先加密再压缩\",{\"1\":{\"31\":1}}],[\"对写入的字符进行压缩\",{\"1\":{\"31\":1}}],[\"对写入的字符进行加密\",{\"1\":{\"31\":1}}],[\"对写入字符进行压缩\",{\"1\":{\"31\":1}}],[\"对写入文件的字符的加密\",{\"1\":{\"31\":1}}],[\"对锁的粒度要求较高\",{\"1\":{\"218\":1}}],[\"对账成功\",{\"1\":{\"191\":3,\"203\":1}}],[\"对资源的共享方式\",{\"0\":{\"164\":1}}],[\"对代码进行静态分析\",{\"1\":{\"153\":1}}],[\"对synchronized的实现机制进行了较大调整\",{\"1\":{\"149\":1}}],[\"对齐填充\",{\"1\":{\"149\":1}}],[\"对象中重写的\",{\"1\":{\"424\":1}}],[\"对象用于读写数据\",{\"1\":{\"415\":1}}],[\"对象进行数据的读取和写入\",{\"1\":{\"411\":1}}],[\"对象进行装饰\",{\"1\":{\"401\":1}}],[\"对象作为参数\",{\"1\":{\"376\":1}}],[\"对象作为参数传入\",{\"1\":{\"323\":2,\"336\":1}}],[\"对象计算哈希值\",{\"1\":{\"376\":1,\"378\":1}}],[\"对象包含了键\",{\"1\":{\"374\":1}}],[\"对象时\",{\"1\":{\"358\":1}}],[\"对象任务\",{\"1\":{\"347\":1}}],[\"对象的相应方法进行操作\",{\"1\":{\"407\":1}}],[\"对象的\",{\"1\":{\"337\":1,\"364\":1,\"410\":1,\"411\":1}}],[\"对象的构造函数执行\",{\"1\":{\"136\":1}}],[\"对象提交给线程池执行\",{\"1\":{\"323\":1}}],[\"对象传入\",{\"1\":{\"323\":2}}],[\"对象数组\",{\"1\":{\"233\":1}}],[\"对象头的mark\",{\"1\":{\"149\":1}}],[\"对象头的内容非常多这里我们只做简单介绍以引出后文\",{\"1\":{\"149\":1}}],[\"对象头\",{\"0\":{\"149\":1},\"1\":{\"149\":1}}],[\"对象\",{\"1\":{\"146\":1,\"267\":1,\"323\":10,\"336\":2,\"341\":2,\"342\":2,\"352\":1,\"353\":2,\"354\":1,\"375\":2,\"385\":2,\"401\":1,\"407\":1,\"410\":1,\"411\":1,\"412\":1,\"414\":2,\"424\":2}}],[\"对象之间通过消息传递来进行通信和协作\",{\"1\":{\"422\":1}}],[\"对象之间关系也比较清晰\",{\"1\":{\"51\":1}}],[\"对象之间尽量少了解\",{\"1\":{\"14\":1}}],[\"对线程\",{\"1\":{\"136\":1}}],[\"对一个\",{\"1\":{\"136\":1}}],[\"对一个锁的解锁操作\",{\"1\":{\"136\":1}}],[\"对一些基础类无法修改\",{\"1\":{\"32\":1}}],[\"对meric使用了rate操作将metric原来的名称去掉\",{\"1\":{\"115\":1}}],[\"对处理者来说是一个灾难\",{\"1\":{\"103\":1}}],[\"对照分析\",{\"1\":{\"65\":1}}],[\"对监控指标进行长期趋势分析\",{\"1\":{\"65\":1}}],[\"对final方法和final类的限制\",{\"1\":{\"57\":1}}],[\"对原有功能的做扩展或者增强\",{\"1\":{\"52\":1}}],[\"对读取的字符进行先解压再解密\",{\"1\":{\"31\":1}}],[\"对读取的字符进行解压\",{\"1\":{\"31\":2}}],[\"对读取的字符进行解密\",{\"1\":{\"31\":2}}],[\"对它进行功能的增强\",{\"1\":{\"31\":2}}],[\"对于被final修饰的局部变量\",{\"1\":{\"435\":1}}],[\"对于实例变量\",{\"1\":{\"435\":1}}],[\"对于任何非null的引用值x和y\",{\"1\":{\"430\":2}}],[\"对于任何非null的引用值x\",{\"1\":{\"430\":3}}],[\"对于基本数据类型的变量\",{\"1\":{\"429\":1}}],[\"对于包装类\",{\"1\":{\"423\":1}}],[\"对于读取操作\",{\"1\":{\"406\":1}}],[\"对于写入操作\",{\"1\":{\"406\":1}}],[\"对于需要执行的任务需要实现callable接口\",{\"1\":{\"325\":1}}],[\"对于需要代理的类数量较多或变化频繁的情况下\",{\"1\":{\"53\":1}}],[\"对于多个线程之间需要共享数据的情况\",{\"1\":{\"288\":1}}],[\"对于结点hash值大于0的情况\",{\"1\":{\"260\":1}}],[\"对于table的大小\",{\"1\":{\"259\":1}}],[\"对于putval函数的流程大体如下\",{\"1\":{\"259\":1}}],[\"对于cpu密集型的任务\",{\"1\":{\"295\":1}}],[\"对于copyonwritearraylist的函数分析\",{\"1\":{\"236\":1}}],[\"对于cancelacquire与unparksuccessor函数\",{\"1\":{\"173\":1}}],[\"对于其他函数我们也可以分析\",{\"1\":{\"174\":1}}],[\"对于语句a\",{\"1\":{\"120\":1}}],[\"对于请求数量在5分钟的时间窗口内\",{\"1\":{\"92\":1}}],[\"对于分位数的计算而言\",{\"1\":{\"79\":1}}],[\"对于标签值无约束\",{\"1\":{\"74\":1}}],[\"对于修改是封闭的\",{\"1\":{\"14\":1}}],[\"对于扩展是开放的\",{\"1\":{\"14\":1}}],[\"迪米特法则\",{\"1\":{\"14\":1}}],[\"简介\",{\"0\":{\"345\":1,\"398\":1,\"403\":1}}],[\"简单示例\",{\"0\":{\"383\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"40\":1}}],[\"简单工厂模式是一种常见的设计模式\",{\"1\":{\"41\":1}}],[\"简单工厂模式提供一个简单的工厂类\",{\"1\":{\"39\":1}}],[\"简单工厂模式\",{\"1\":{\"39\":1}}],[\"简单工厂\",{\"0\":{\"39\":1}}],[\"简单的说就是要求对抽象接口进行编程\",{\"1\":{\"14\":1}}],[\"简称\",{\"1\":{\"14\":5}}],[\"drainqueue\",{\"1\":{\"319\":1}}],[\"drainto\",{\"1\":{\"265\":2}}],[\"dragonprotocol等\",{\"1\":{\"124\":1}}],[\"during\",{\"1\":{\"256\":1}}],[\"duration\",{\"1\":{\"68\":10,\"78\":13,\"79\":11,\"85\":1,\"94\":13}}],[\"due\",{\"1\":{\"110\":1,\"312\":1}}],[\"did\",{\"1\":{\"314\":1}}],[\"died\",{\"1\":{\"311\":1}}],[\"discardoldestpolicy\",{\"1\":{\"302\":1}}],[\"discardpolicy\",{\"1\":{\"302\":1}}],[\"distinguishing\",{\"1\":{\"115\":1}}],[\"dir\",{\"1\":{\"259\":7}}],[\"divide\",{\"1\":{\"115\":1,\"432\":2}}],[\"division\",{\"1\":{\"85\":1}}],[\"dimensions\",{\"1\":{\"90\":7}}],[\"dip\",{\"1\":{\"14\":1}}],[\"db中\",{\"1\":{\"75\":1}}],[\"dl\",{\"1\":{\"71\":1}}],[\"daemon\",{\"1\":{\"305\":1}}],[\"date\",{\"1\":{\"110\":2,\"169\":1}}],[\"datagramchannel\",{\"1\":{\"403\":1,\"404\":1}}],[\"dataoutputstream\",{\"1\":{\"401\":1}}],[\"datainputstream\",{\"1\":{\"401\":1}}],[\"data\",{\"1\":{\"31\":8,\"256\":1,\"267\":2,\"405\":2,\"410\":2,\"411\":2,\"414\":2}}],[\"dashboards\",{\"1\":{\"71\":1}}],[\"darwin\",{\"1\":{\"67\":2,\"71\":2}}],[\"dog=new\",{\"1\":{\"418\":1}}],[\"dog\",{\"1\":{\"418\":3,\"419\":8,\"424\":6}}],[\"dog继承了animal父类\",{\"1\":{\"418\":1}}],[\"double等封装类中\",{\"1\":{\"430\":1}}],[\"double等等\",{\"1\":{\"423\":1}}],[\"double等\",{\"1\":{\"423\":1}}],[\"doublebuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"double\",{\"1\":{\"311\":2,\"377\":1,\"401\":2,\"403\":1,\"419\":4,\"429\":1}}],[\"dofilter\",{\"1\":{\"287\":2}}],[\"doreleaseshared\",{\"1\":{\"198\":2,\"199\":2}}],[\"doreceived\",{\"1\":{\"186\":2}}],[\"doacquiresharedinterruptibly函数的源码如下\",{\"1\":{\"198\":1}}],[\"doacquiresharedinterruptibly\",{\"1\":{\"198\":2}}],[\"doesn\",{\"1\":{\"173\":1}}],[\"done\",{\"1\":{\"186\":4,\"333\":1}}],[\"don\",{\"1\":{\"173\":1,\"183\":1,\"185\":1}}],[\"down\",{\"1\":{\"311\":2,\"312\":1}}],[\"download\",{\"1\":{\"67\":1,\"106\":1}}],[\"downloads\",{\"1\":{\"31\":1}}],[\"dowait方法的逻辑会进行一系列的判断\",{\"1\":{\"213\":1}}],[\"dowait\",{\"1\":{\"213\":1}}],[\"dowait函数\",{\"0\":{\"213\":1}}],[\"dowork\",{\"1\":{\"146\":1}}],[\"dolphin0520\",{\"1\":{\"137\":1}}],[\"docs\",{\"1\":{\"95\":1,\"110\":1}}],[\"do\",{\"1\":{\"54\":2,\"56\":1,\"57\":1,\"173\":1,\"183\":1,\"214\":1,\"277\":1,\"377\":1,\"378\":1}}],[\"dosignalall函数源码如下\",{\"1\":{\"214\":1}}],[\"dosignalall\",{\"1\":{\"214\":2}}],[\"dosomethingwithconfig\",{\"1\":{\"135\":1}}],[\"dos\",{\"1\":{\"31\":3}}],[\"deal\",{\"1\":{\"313\":1}}],[\"deadline\",{\"1\":{\"169\":1,\"317\":2,\"331\":2}}],[\"deadlockdemo3\",{\"1\":{\"143\":1}}],[\"deadlockdemo2\",{\"1\":{\"142\":1}}],[\"deadlock1\",{\"1\":{\"139\":1}}],[\"deadlock\",{\"1\":{\"139\":1,\"142\":1}}],[\"demo=new\",{\"1\":{\"418\":1}}],[\"demo\",{\"1\":{\"306\":1,\"418\":2,\"419\":1,\"436\":3}}],[\"dequeue函数用于将取元素\",{\"1\":{\"275\":1}}],[\"dequeue函数源码如下\",{\"1\":{\"275\":1}}],[\"dequeue\",{\"1\":{\"275\":2,\"276\":1}}],[\"deemed\",{\"1\":{\"213\":1}}],[\"decrementworkercount\",{\"1\":{\"314\":1}}],[\"decrement\",{\"1\":{\"197\":1,\"199\":1}}],[\"dec\",{\"1\":{\"187\":4}}],[\"decompress\",{\"1\":{\"31\":2}}],[\"decode\",{\"1\":{\"31\":4}}],[\"denominator\",{\"1\":{\"115\":1}}],[\"details\",{\"1\":{\"111\":1,\"320\":1}}],[\"deduplicate\",{\"1\":{\"110\":1}}],[\"deserializes\",{\"1\":{\"183\":1}}],[\"description\",{\"1\":{\"108\":1}}],[\"design\",{\"1\":{\"24\":2,\"36\":2,\"50\":5}}],[\"development\",{\"1\":{\"433\":1}}],[\"dev\",{\"1\":{\"106\":1,\"107\":3}}],[\"deviation\",{\"1\":{\"90\":1}}],[\"defaultcapacity\",{\"1\":{\"358\":1,\"359\":2,\"361\":1}}],[\"defaultforkjoinworkerthreadfactory\",{\"1\":{\"347\":1}}],[\"defaultthreadfactory\",{\"1\":{\"294\":1,\"301\":1}}],[\"defaultreadobject\",{\"1\":{\"183\":1}}],[\"default\",{\"1\":{\"107\":3,\"113\":1,\"256\":3,\"259\":1,\"361\":1,\"375\":1,\"377\":1,\"419\":1}}],[\"defaultvalue\",{\"1\":{\"97\":1,\"98\":1}}],[\"deflater\",{\"1\":{\"31\":1}}],[\"deflateroutputstream\",{\"1\":{\"31\":2}}],[\"delegates\",{\"1\":{\"313\":1}}],[\"delayqueue\",{\"1\":{\"226\":1,\"266\":1}}],[\"del\",{\"1\":{\"89\":1}}],[\"delta\",{\"1\":{\"77\":1}}],[\"dependency>\",{\"1\":{\"57\":1,\"97\":3,\"98\":3}}],[\"dependency\",{\"1\":{\"14\":1}}],[\"d\",{\"1\":{\"14\":1,\"82\":1,\"230\":1,\"305\":1,\"306\":1,\"406\":1}}],[\"i+\",{\"1\":{\"395\":1}}],[\"i++\",{\"1\":{\"31\":2,\"50\":1,\"119\":2,\"126\":1,\"127\":1,\"132\":1,\"160\":2,\"235\":1,\"239\":1,\"271\":1,\"323\":3,\"336\":1,\"349\":1,\"362\":2,\"363\":2,\"369\":1,\"393\":1,\"395\":9,\"415\":1,\"430\":1,\"431\":1}}],[\"ie\",{\"1\":{\"213\":2}}],[\"illegalstateexception\",{\"1\":{\"364\":1}}],[\"illegal\",{\"1\":{\"359\":1,\"375\":2}}],[\"illegalthreadstateexception\",{\"1\":{\"312\":1}}],[\"illegalargumentexception\",{\"1\":{\"196\":1,\"210\":1,\"271\":2,\"294\":1,\"359\":1,\"375\":2}}],[\"illegalmonitorstateexception\",{\"1\":{\"183\":1,\"214\":1}}],[\"illegalmonitorstateexception的异常的原因\",{\"1\":{\"147\":1}}],[\"ignore\",{\"1\":{\"173\":1,\"319\":1}}],[\"ignoring\",{\"1\":{\"88\":1,\"89\":2}}],[\"isconnectable\",{\"1\":{\"414\":2}}],[\"iscanceled\",{\"1\":{\"326\":1}}],[\"iscancelled\",{\"1\":{\"326\":1}}],[\"isvalid\",{\"1\":{\"414\":1}}],[\"iswritable\",{\"1\":{\"412\":1,\"414\":1}}],[\"isreadable\",{\"1\":{\"412\":1,\"414\":1}}],[\"isrunning\",{\"1\":{\"311\":2}}],[\"isacceptable\",{\"1\":{\"412\":1,\"414\":1}}],[\"isalive\",{\"1\":{\"312\":1}}],[\"isnan\",{\"1\":{\"375\":1}}],[\"iselementindex\",{\"1\":{\"369\":2,\"370\":2}}],[\"isempty\",{\"1\":{\"312\":1,\"314\":2,\"352\":1,\"353\":1,\"354\":1,\"393\":1}}],[\"isinterrupted\",{\"1\":{\"313\":1,\"319\":1}}],[\"isdone\",{\"1\":{\"186\":4,\"322\":1,\"326\":2}}],[\"islocked\",{\"1\":{\"183\":1}}],[\"isheldexclusively\",{\"1\":{\"183\":2,\"214\":1}}],[\"is\",{\"1\":{\"173\":7,\"175\":1,\"183\":2,\"185\":1,\"213\":1,\"214\":1,\"235\":3,\"256\":4,\"282\":1,\"309\":1,\"312\":1,\"313\":3,\"318\":1,\"329\":1,\"352\":2,\"353\":2,\"354\":2,\"361\":1,\"419\":3,\"438\":1}}],[\"isshared\",{\"1\":{\"168\":1,\"198\":1}}],[\"isp\",{\"1\":{\"14\":1}}],[\"i=\",{\"1\":{\"160\":2}}],[\"i=0这是一个赋值操作\",{\"1\":{\"126\":1}}],[\"i=0\",{\"1\":{\"126\":1,\"127\":1}}],[\"idea提示\",{\"1\":{\"438\":1}}],[\"idea会提示错误\",{\"1\":{\"435\":1}}],[\"identify\",{\"1\":{\"110\":1}}],[\"identifying\",{\"1\":{\"110\":1}}],[\"identifies\",{\"1\":{\"110\":1}}],[\"id=0\",{\"1\":{\"396\":1}}],[\"id=cxigd\",{\"1\":{\"295\":2}}],[\"id\",{\"1\":{\"143\":6,\"288\":1}}],[\"iplusdemo\",{\"1\":{\"119\":1}}],[\"itr\",{\"1\":{\"364\":4}}],[\"itrs\",{\"1\":{\"270\":2,\"275\":2,\"277\":2}}],[\"its\",{\"1\":{\"311\":1}}],[\"iter\",{\"1\":{\"414\":4}}],[\"iterate\",{\"1\":{\"395\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"412\":1,\"414\":1}}],[\"iterator<e>\",{\"1\":{\"364\":2}}],[\"iterator\",{\"1\":{\"235\":3,\"364\":1,\"412\":1,\"414\":2}}],[\"item\",{\"1\":{\"366\":2,\"369\":2,\"370\":3}}],[\"items\",{\"1\":{\"270\":1,\"271\":2,\"273\":6,\"274\":1,\"275\":6,\"277\":4}}],[\"it\",{\"1\":{\"107\":1,\"173\":6,\"183\":1,\"311\":2}}],[\"itypec\",{\"1\":{\"26\":2}}],[\"irate\",{\"1\":{\"92\":1}}],[\"irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率\",{\"1\":{\"92\":1}}],[\"irate同样用于计算区间向量的计算率\",{\"1\":{\"92\":1}}],[\"iin\",{\"1\":{\"31\":3}}],[\"immutable\",{\"1\":{\"421\":1}}],[\"img\",{\"1\":{\"65\":1,\"147\":1,\"149\":2,\"152\":1,\"173\":2,\"183\":1,\"185\":1,\"198\":1,\"199\":1,\"213\":1,\"214\":1,\"245\":1,\"246\":1,\"250\":2,\"264\":1,\"292\":1,\"295\":1,\"309\":1,\"315\":1,\"322\":1,\"328\":1,\"347\":1,\"348\":1,\"382\":1,\"401\":1}}],[\"import\",{\"1\":{\"50\":2,\"98\":6,\"142\":2,\"175\":4,\"187\":3,\"191\":4,\"203\":1,\"219\":3,\"221\":3,\"230\":1,\"247\":1,\"267\":1,\"281\":1,\"323\":8,\"336\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"349\":2,\"352\":2,\"353\":2,\"354\":2,\"393\":1,\"395\":2,\"405\":3,\"406\":2,\"414\":9,\"415\":5}}],[\"implements\",{\"1\":{\"26\":2,\"31\":3,\"44\":2,\"47\":1,\"50\":2,\"54\":2,\"56\":1,\"57\":1,\"98\":1,\"166\":2,\"170\":1,\"179\":1,\"180\":1,\"232\":1,\"233\":1,\"235\":1,\"249\":1,\"256\":1,\"267\":2,\"269\":1,\"270\":1,\"288\":1,\"313\":1,\"317\":1,\"358\":1,\"364\":1,\"419\":2}}],[\"image\",{\"1\":{\"9\":1,\"17\":1,\"30\":1,\"43\":1,\"49\":1,\"59\":1,\"67\":2,\"69\":1,\"71\":2,\"74\":1,\"81\":2,\"82\":1,\"100\":2,\"101\":1,\"108\":2,\"109\":1,\"116\":1,\"119\":1,\"120\":1,\"147\":1,\"155\":1,\"163\":2,\"218\":1,\"223\":2,\"229\":2,\"280\":1,\"282\":1,\"285\":1,\"293\":1,\"337\":1,\"345\":1,\"349\":1,\"400\":1}}],[\"iusb\",{\"1\":{\"26\":9}}],[\"io来说\",{\"1\":{\"403\":1}}],[\"io库提供了多个基本的io流类\",{\"1\":{\"399\":1}}],[\"io流对象\",{\"0\":{\"401\":1}}],[\"io流基本类\",{\"0\":{\"399\":1}}],[\"io流主要包括字节流和字符流两种类型\",{\"1\":{\"398\":1}}],[\"io学习总结\",{\"0\":{\"397\":1}}],[\"io读写等\",{\"1\":{\"69\":1}}],[\"ioexception\",{\"1\":{\"31\":6,\"98\":1,\"183\":1,\"414\":6,\"415\":5}}],[\"io\",{\"1\":{\"24\":1,\"36\":2,\"50\":5,\"67\":1,\"95\":1,\"98\":3,\"106\":1,\"110\":1,\"111\":1,\"119\":1,\"139\":1,\"142\":1,\"147\":1,\"159\":1,\"160\":1,\"166\":2,\"170\":1,\"175\":1,\"179\":1,\"180\":1,\"183\":2,\"187\":1,\"191\":2,\"203\":1,\"219\":1,\"221\":1,\"232\":1,\"233\":1,\"269\":1,\"270\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1,\"358\":1,\"398\":2,\"401\":4,\"405\":1,\"414\":2,\"415\":2,\"438\":1}}],[\"ifurniturefactory\",{\"1\":{\"46\":1,\"47\":5}}],[\"ifactory的具体实现类americasofafactory\",{\"1\":{\"44\":1}}],[\"ifactory的具体实现类chinesesofafactory\",{\"1\":{\"44\":1}}],[\"ifactory\",{\"1\":{\"43\":1,\"44\":4}}],[\"if\",{\"1\":{\"19\":2,\"22\":1,\"23\":1,\"31\":4,\"36\":3,\"41\":2,\"68\":1,\"107\":1,\"121\":2,\"142\":1,\"143\":1,\"160\":2,\"168\":1,\"173\":27,\"174\":2,\"175\":7,\"183\":7,\"184\":1,\"185\":4,\"186\":3,\"196\":1,\"197\":2,\"198\":13,\"199\":8,\"210\":1,\"213\":12,\"214\":9,\"221\":1,\"234\":2,\"235\":2,\"239\":3,\"240\":1,\"241\":1,\"256\":1,\"259\":46,\"260\":5,\"261\":17,\"271\":1,\"273\":1,\"274\":1,\"275\":2,\"277\":3,\"282\":3,\"288\":1,\"294\":2,\"311\":15,\"312\":13,\"313\":3,\"314\":6,\"316\":1,\"317\":9,\"318\":4,\"319\":2,\"329\":6,\"330\":1,\"331\":8,\"332\":5,\"333\":3,\"349\":1,\"359\":4,\"360\":1,\"361\":4,\"362\":4,\"363\":3,\"364\":4,\"368\":1,\"369\":2,\"370\":3,\"375\":3,\"376\":7,\"377\":13,\"378\":5,\"395\":4,\"412\":4,\"414\":8,\"415\":2,\"430\":4,\"431\":1}}],[\"inetsocketaddress\",{\"1\":{\"410\":1,\"411\":1,\"414\":2,\"415\":3}}],[\"inlining\",{\"1\":{\"361\":1}}],[\"innocuousforkjoinworkerthreadfactory\",{\"1\":{\"347\":1}}],[\"inner\",{\"1\":{\"20\":2,\"312\":1}}],[\"innerclzsingleton\",{\"1\":{\"20\":5}}],[\"inheritance\",{\"1\":{\"420\":1}}],[\"inheritablethreadlocals\",{\"1\":{\"288\":5}}],[\"inheritablethreadlocal<>\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal<string>\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocaltest\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal并不能解决所有线程间的共享数据问题\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal的原理和内部实现与threadlocal类似\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal可以在父线程和子线程之间实现变量值的传递\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal和threadlocal的使用方式非常相似\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal是threadlocal的一个变种\",{\"1\":{\"288\":1}}],[\"inheritablethreadlocal\",{\"0\":{\"288\":1},\"1\":{\"288\":7}}],[\"inheritthreadlocals\",{\"1\":{\"288\":2}}],[\"inhibiting\",{\"1\":{\"107\":1}}],[\"inhibit\",{\"1\":{\"106\":2,\"107\":3,\"313\":2}}],[\"index++\",{\"1\":{\"395\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"364\":1,\"369\":2,\"370\":2}}],[\"indexof\",{\"1\":{\"239\":1,\"352\":1,\"363\":4}}],[\"index的值和elementdata的长度相等\",{\"1\":{\"360\":1}}],[\"index\",{\"0\":{\"369\":1,\"370\":1},\"1\":{\"213\":3,\"235\":1,\"240\":3,\"241\":8,\"256\":1,\"259\":4,\"360\":8,\"362\":2,\"363\":4,\"366\":2,\"369\":22,\"370\":15,\"393\":3,\"395\":3}}],[\"indicate\",{\"1\":{\"173\":2,\"214\":1}}],[\"input\",{\"1\":{\"398\":1}}],[\"inputstreamreader\",{\"1\":{\"401\":2}}],[\"inputstream\",{\"1\":{\"31\":1,\"399\":1,\"401\":1}}],[\"inprogress\",{\"1\":{\"113\":2}}],[\"init\",{\"1\":{\"288\":1}}],[\"inittable函数源码如下\",{\"1\":{\"259\":1}}],[\"inittable\",{\"1\":{\"259\":3}}],[\"inited\",{\"1\":{\"135\":3}}],[\"initialcapacity\",{\"1\":{\"359\":6,\"375\":8}}],[\"initialcursor\",{\"1\":{\"235\":2}}],[\"initialized\",{\"1\":{\"256\":1}}],[\"initialization\",{\"1\":{\"256\":4,\"259\":1}}],[\"initial\",{\"1\":{\"107\":2,\"168\":1,\"256\":1,\"375\":2,\"377\":1}}],[\"initially\",{\"1\":{\"107\":1,\"317\":1}}],[\"ini文件下\",{\"1\":{\"71\":1}}],[\"instead\",{\"1\":{\"173\":1}}],[\"instruction\",{\"1\":{\"128\":1}}],[\"instrumentation\",{\"1\":{\"98\":2,\"115\":1}}],[\"instant\",{\"0\":{\"81\":1},\"1\":{\"94\":1}}],[\"instanceof\",{\"1\":{\"259\":2,\"261\":1,\"376\":1,\"377\":1,\"378\":1,\"430\":1}}],[\"instances\",{\"1\":{\"115\":1}}],[\"instance的标签值相等\",{\"1\":{\"107\":1}}],[\"instance=\",{\"1\":{\"90\":1,\"94\":10}}],[\"instance为被采集的实例\",{\"1\":{\"90\":1}}],[\"instance\",{\"1\":{\"17\":1,\"19\":5,\"20\":2,\"22\":4,\"23\":4,\"90\":2,\"106\":1,\"107\":2,\"115\":13,\"116\":2,\"121\":5,\"183\":1}}],[\"incorrectly\",{\"1\":{\"234\":1}}],[\"incoming\",{\"1\":{\"107\":1}}],[\"incr\",{\"1\":{\"187\":3}}],[\"incr=\",{\"1\":{\"187\":1}}],[\"incrementandget\",{\"1\":{\"281\":1}}],[\"incrementtask\",{\"1\":{\"281\":4}}],[\"increment\",{\"1\":{\"146\":3}}],[\"increase是promql中的一个函数\",{\"1\":{\"76\":1}}],[\"increase\",{\"1\":{\"76\":1,\"92\":2,\"100\":2,\"108\":1,\"132\":3}}],[\"inc的值无效需要重读\",{\"1\":{\"132\":1}}],[\"inc++\",{\"1\":{\"132\":2}}],[\"inc\",{\"1\":{\"98\":1,\"132\":2}}],[\"include=prometheus\",{\"1\":{\"97\":1}}],[\"infinity\",{\"1\":{\"94\":1}}],[\"information\",{\"1\":{\"68\":1,\"415\":5}}],[\"info\",{\"1\":{\"68\":3,\"110\":1,\"415\":2}}],[\"inflaterinputstream\",{\"1\":{\"31\":2}}],[\"invoke\",{\"1\":{\"56\":6,\"57\":1,\"349\":1}}],[\"invocationhandler\",{\"1\":{\"56\":1}}],[\"invocationhandler接口来实现动态代理\",{\"1\":{\"56\":1}}],[\"inversion\",{\"1\":{\"14\":1}}],[\"in\",{\"1\":{\"31\":3,\"68\":1,\"90\":2,\"173\":3,\"183\":1,\"214\":1,\"288\":1,\"309\":1,\"311\":1,\"313\":1,\"361\":1,\"395\":2}}],[\"intbuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"into\",{\"1\":{\"311\":1}}],[\"int是32位的\",{\"1\":{\"308\":1}}],[\"integer\",{\"1\":{\"256\":4,\"309\":1,\"323\":3,\"336\":2,\"339\":1,\"340\":1,\"361\":1,\"377\":1,\"423\":1}}],[\"integer>\",{\"1\":{\"247\":1,\"354\":3}}],[\"interference\",{\"1\":{\"173\":1}}],[\"interface的继承接口\",{\"1\":{\"351\":1}}],[\"interface\",{\"1\":{\"14\":1,\"26\":2,\"31\":1,\"44\":1,\"47\":1,\"50\":2,\"54\":1,\"169\":1,\"179\":1,\"265\":1,\"325\":1,\"326\":1,\"351\":1,\"419\":2,\"420\":1}}],[\"interruptworkers\",{\"1\":{\"319\":2}}],[\"interruptifstarted\",{\"1\":{\"319\":1}}],[\"interruptidleworkers\",{\"1\":{\"319\":4}}],[\"interrupting\",{\"1\":{\"317\":2,\"318\":1,\"328\":2,\"329\":1,\"332\":1}}],[\"interrupts\",{\"1\":{\"313\":3,\"318\":1,\"329\":1}}],[\"interrupted\",{\"1\":{\"173\":4,\"198\":1,\"213\":3,\"313\":3,\"317\":3,\"328\":2,\"331\":1,\"332\":1}}],[\"interruptedexception\",{\"1\":{\"119\":1,\"131\":1,\"132\":1,\"139\":3,\"142\":2,\"143\":2,\"158\":1,\"159\":3,\"160\":5,\"169\":4,\"179\":2,\"187\":2,\"191\":6,\"198\":5,\"203\":4,\"213\":3,\"265\":4,\"267\":2,\"273\":1,\"275\":1,\"314\":1,\"315\":1,\"317\":3,\"323\":2,\"326\":2,\"330\":1,\"331\":2,\"336\":1,\"339\":2,\"340\":2,\"341\":3,\"342\":4,\"415\":1}}],[\"interrupt\",{\"1\":{\"136\":1,\"213\":2,\"313\":2,\"319\":1,\"332\":1}}],[\"intersection\",{\"1\":{\"87\":1}}],[\"interval是全局配置告警规则任务的计算\",{\"1\":{\"68\":1}}],[\"interval\",{\"1\":{\"68\":3,\"106\":2,\"107\":4,\"113\":3,\"116\":1}}],[\"interceptorregistry\",{\"1\":{\"98\":1}}],[\"intercept\",{\"1\":{\"57\":1}}],[\"int\",{\"0\":{\"210\":1,\"211\":1,\"369\":1,\"370\":1},\"1\":{\"26\":10,\"31\":3,\"36\":8,\"50\":1,\"110\":1,\"119\":3,\"126\":1,\"131\":1,\"132\":3,\"139\":3,\"142\":3,\"143\":5,\"146\":1,\"160\":1,\"163\":5,\"168\":6,\"170\":1,\"173\":5,\"174\":1,\"175\":7,\"183\":6,\"184\":1,\"185\":3,\"186\":1,\"187\":11,\"196\":2,\"197\":7,\"198\":7,\"199\":5,\"208\":2,\"210\":1,\"211\":1,\"213\":2,\"214\":1,\"235\":6,\"237\":1,\"238\":1,\"239\":3,\"240\":2,\"241\":3,\"247\":2,\"256\":21,\"259\":17,\"260\":2,\"261\":2,\"265\":4,\"267\":2,\"270\":3,\"271\":7,\"277\":3,\"293\":5,\"294\":2,\"308\":3,\"309\":14,\"311\":2,\"312\":5,\"314\":3,\"317\":11,\"318\":1,\"323\":6,\"328\":8,\"329\":1,\"330\":1,\"331\":2,\"336\":2,\"349\":10,\"352\":1,\"353\":1,\"354\":4,\"359\":1,\"360\":4,\"361\":12,\"362\":5,\"363\":5,\"364\":4,\"366\":3,\"369\":10,\"370\":6,\"375\":1,\"376\":3,\"377\":4,\"378\":3,\"385\":1,\"392\":1,\"393\":7,\"395\":27,\"401\":2,\"403\":1,\"405\":1,\"410\":1,\"411\":1,\"412\":1,\"414\":3,\"415\":2,\"419\":1,\"423\":1,\"429\":3,\"430\":2,\"431\":3,\"432\":4,\"435\":6,\"438\":8}}],[\"i\",{\"1\":{\"14\":1,\"31\":6,\"50\":3,\"118\":3,\"119\":4,\"132\":2,\"160\":5,\"173\":1,\"235\":3,\"239\":5,\"259\":9,\"261\":5,\"271\":4,\"277\":4,\"323\":9,\"336\":3,\"349\":3,\"362\":11,\"363\":8,\"364\":5,\"369\":5,\"376\":5,\"377\":1,\"378\":2,\"393\":4,\"395\":42,\"403\":8,\"404\":2,\"407\":3,\"410\":3,\"411\":3,\"412\":7,\"414\":1,\"415\":7,\"416\":3,\"423\":2,\"430\":3,\"431\":3}}],[\"基于优先级的阻塞队列\",{\"1\":{\"266\":1}}],[\"基于链表的阻塞队列\",{\"1\":{\"266\":1}}],[\"基于数组的阻塞队列\",{\"1\":{\"266\":1}}],[\"基于java\",{\"1\":{\"248\":1}}],[\"基于cas的算法能够在多线程并发修改共享数据时\",{\"1\":{\"246\":1}}],[\"基于cas操作来实现对并发更新的支持\",{\"1\":{\"246\":1}}],[\"基于分段锁的concurrenthashmap\",{\"0\":{\"245\":1}}],[\"基于promql表达式告警触发条件\",{\"1\":{\"108\":1}}],[\"基于5小时的样本数据\",{\"1\":{\"93\":1}}],[\"基本数据类型\",{\"1\":{\"429\":1}}],[\"基本类型不是对象\",{\"1\":{\"423\":1}}],[\"基本类型的取值范围是有限的\",{\"1\":{\"423\":1}}],[\"基本的\",{\"1\":{\"406\":1}}],[\"基本计数\",{\"1\":{\"256\":1}}],[\"基本查询格式是\",{\"1\":{\"90\":1}}],[\"基本功能实现类和不同的装饰器只实现自己的独一的功能\",{\"1\":{\"32\":1}}],[\"基本上也遵循solid\",{\"1\":{\"14\":1}}],[\"基类功能可以被复用\",{\"1\":{\"14\":1}}],[\"lotail\",{\"1\":{\"377\":6}}],[\"lohead\",{\"1\":{\"377\":3}}],[\"loadfactor\",{\"1\":{\"375\":8,\"377\":1}}],[\"load\",{\"1\":{\"256\":1,\"375\":2}}],[\"loadcontext\",{\"1\":{\"135\":1}}],[\"loop\",{\"1\":{\"198\":2,\"199\":2,\"213\":1,\"312\":1,\"313\":1}}],[\"lost\",{\"1\":{\"173\":1,\"239\":1,\"259\":1}}],[\"localname\",{\"1\":{\"287\":2}}],[\"localholder\",{\"1\":{\"175\":6}}],[\"localhost\",{\"1\":{\"67\":1,\"68\":2,\"69\":4,\"70\":1,\"90\":1,\"94\":10,\"98\":1,\"99\":1,\"109\":1}}],[\"lockroot\",{\"1\":{\"259\":1}}],[\"locked\",{\"1\":{\"256\":1}}],[\"lockoffset\",{\"1\":{\"233\":2}}],[\"lock域的内存偏移量\",{\"1\":{\"233\":1}}],[\"lockinterruptibly\",{\"1\":{\"179\":1,\"273\":1,\"275\":1}}],[\"locking\",{\"1\":{\"153\":2}}],[\"lock接口代码如下\",{\"1\":{\"179\":1}}],[\"lock接口中定义了lock与unlock相关操作\",{\"1\":{\"179\":1}}],[\"locks\",{\"1\":{\"175\":1,\"187\":3,\"219\":1,\"221\":1}}],[\"locksupport\",{\"1\":{\"173\":2,\"175\":3,\"214\":1,\"317\":2,\"331\":2,\"333\":1}}],[\"lock所实现的锁我们称之为\",{\"1\":{\"148\":1}}],[\"lock来实现的\",{\"1\":{\"148\":1}}],[\"lock\",{\"1\":{\"146\":2,\"147\":1,\"153\":2,\"159\":5,\"160\":8,\"175\":1,\"176\":1,\"179\":3,\"180\":1,\"183\":2,\"184\":1,\"185\":2,\"186\":11,\"187\":12,\"208\":3,\"213\":5,\"219\":9,\"220\":4,\"221\":3,\"233\":2,\"238\":5,\"239\":5,\"240\":5,\"241\":5,\"259\":1,\"270\":1,\"271\":9,\"273\":5,\"274\":5,\"275\":5,\"276\":5,\"277\":6,\"312\":3,\"313\":1,\"319\":4}}],[\"logger\",{\"1\":{\"110\":1}}],[\"longbuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"long\",{\"1\":{\"98\":4,\"107\":3,\"157\":1,\"166\":1,\"169\":3,\"170\":7,\"175\":1,\"179\":1,\"180\":1,\"183\":1,\"184\":1,\"185\":1,\"186\":2,\"197\":1,\"213\":1,\"221\":2,\"233\":2,\"256\":8,\"259\":6,\"265\":2,\"270\":1,\"288\":1,\"294\":1,\"308\":1,\"313\":1,\"317\":2,\"326\":2,\"331\":2,\"349\":5,\"391\":1,\"392\":5,\"393\":3,\"403\":1,\"414\":1,\"429\":1}}],[\"legs\",{\"1\":{\"419\":2}}],[\"leaked\",{\"1\":{\"318\":1,\"329\":1}}],[\"len\",{\"1\":{\"238\":3,\"239\":7,\"240\":2,\"241\":4,\"415\":2}}],[\"length属性\",{\"1\":{\"392\":1}}],[\"length和newlength的较小者\",{\"1\":{\"237\":1}}],[\"length\",{\"1\":{\"31\":2,\"234\":2,\"235\":2,\"237\":1,\"238\":3,\"239\":2,\"240\":1,\"241\":2,\"259\":7,\"260\":1,\"261\":1,\"273\":2,\"274\":1,\"275\":1,\"277\":1,\"349\":1,\"359\":1,\"360\":1,\"361\":6,\"364\":1,\"376\":1,\"377\":3,\"378\":1,\"393\":1,\"395\":4,\"430\":2,\"431\":2}}],[\"leesf456\",{\"1\":{\"176\":1,\"200\":1,\"216\":1,\"262\":1,\"278\":1}}],[\"level\",{\"1\":{\"115\":4,\"256\":1}}],[\"le\",{\"1\":{\"94\":2,\"100\":1}}],[\"leftresult\",{\"1\":{\"349\":2}}],[\"left修改器进行查询\",{\"1\":{\"89\":1}}],[\"left\",{\"1\":{\"89\":2,\"115\":1,\"187\":10,\"259\":3,\"349\":3}}],[\"less\",{\"1\":{\"86\":2}}],[\"le=\",{\"1\":{\"78\":12,\"94\":10,\"98\":12}}],[\"limit\",{\"1\":{\"406\":1}}],[\"lifo\",{\"1\":{\"347\":1}}],[\"lifecycle\",{\"1\":{\"70\":2}}],[\"linenumberinputstream\",{\"1\":{\"401\":1}}],[\"line\",{\"1\":{\"347\":1}}],[\"linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据\",{\"1\":{\"93\":1}}],[\"linear函数对指标的数据变化趋势进行预测\",{\"1\":{\"77\":1}}],[\"linear\",{\"1\":{\"77\":1,\"93\":2}}],[\"linghu\",{\"1\":{\"334\":1}}],[\"linklast\",{\"1\":{\"368\":4}}],[\"linkedlist类主要由linkedlist和它的内部类node构成\",{\"1\":{\"366\":1}}],[\"linkedlist的底层数据结构是使用一个双向的链表结构实现的\",{\"1\":{\"366\":1}}],[\"linkedlist的类结构图如下\",{\"1\":{\"366\":1}}],[\"linkedlist的类结构图\",{\"0\":{\"366\":1}}],[\"linkedlist除了继承abstractsequentiallist之外\",{\"1\":{\"366\":1}}],[\"linkedlist是java集合中比较常见的线性表的数据结构\",{\"1\":{\"366\":1}}],[\"linkedlist源码解析\",{\"0\":{\"365\":1}}],[\"linkedlist\",{\"1\":{\"351\":2,\"366\":4,\"367\":3,\"368\":1,\"369\":1,\"370\":1,\"371\":6}}],[\"linkedblockingdeque\",{\"1\":{\"226\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"306\":1}}],[\"linkedblockingqueue是采用链表实现的无界队列\",{\"1\":{\"299\":1}}],[\"linkedblockingqueue\",{\"0\":{\"299\":1},\"1\":{\"226\":1,\"266\":3,\"297\":1}}],[\"linkedtransferqueue\",{\"1\":{\"226\":1}}],[\"linkedhashmap\",{\"1\":{\"224\":1,\"354\":1}}],[\"link\",{\"1\":{\"173\":1}}],[\"lightweight\",{\"1\":{\"153\":1}}],[\"libraries\",{\"1\":{\"63\":1}}],[\"library\",{\"1\":{\"57\":1}}],[\"lisi\",{\"1\":{\"418\":2}}],[\"listexample\",{\"1\":{\"352\":1}}],[\"listiterator<e>\",{\"1\":{\"235\":1}}],[\"list接口定义了对列表的基本操作\",{\"1\":{\"232\":1}}],[\"list<string>\",{\"1\":{\"352\":1}}],[\"list<runnable>\",{\"1\":{\"319\":2}}],[\"list<e>\",{\"1\":{\"232\":1,\"233\":1,\"358\":1}}],[\"list<account>\",{\"1\":{\"142\":1}}],[\"list<observer>\",{\"1\":{\"50\":1}}],[\"list>\",{\"1\":{\"90\":1}}],[\"list\",{\"0\":{\"223\":1,\"352\":1},\"1\":{\"50\":5,\"142\":8,\"228\":1,\"230\":7,\"351\":2,\"352\":18,\"357\":1}}],[\"liskov\",{\"1\":{\"14\":1}}],[\"large\",{\"1\":{\"361\":1}}],[\"largestpoolsize\",{\"1\":{\"308\":1,\"312\":2}}],[\"largest\",{\"1\":{\"90\":1}}],[\"lastret\",{\"1\":{\"364\":11}}],[\"lastindexof\",{\"1\":{\"352\":1}}],[\"lastwaiter\",{\"1\":{\"214\":1}}],[\"last\",{\"1\":{\"214\":1,\"311\":1,\"314\":1,\"366\":2,\"368\":10,\"369\":1,\"370\":1}}],[\"latex\",{\"1\":{\"295\":2}}],[\"latest\",{\"1\":{\"95\":1,\"110\":1}}],[\"latch\",{\"1\":{\"191\":3}}],[\"latch=new\",{\"1\":{\"191\":1}}],[\"lang3包\",{\"1\":{\"305\":1}}],[\"lang\",{\"1\":{\"56\":2,\"147\":1,\"175\":1}}],[\"lable\",{\"1\":{\"81\":1}}],[\"labelvalues\",{\"1\":{\"98\":2}}],[\"labelnames\",{\"1\":{\"98\":2}}],[\"label\",{\"1\":{\"81\":5}}],[\"labels\",{\"1\":{\"81\":4,\"85\":1,\"107\":1,\"108\":2,\"110\":2,\"113\":1,\"115\":1,\"116\":1}}],[\"lab\",{\"1\":{\"24\":1}}],[\"labs\",{\"1\":{\"24\":1}}],[\"lazyinstancesafe\",{\"1\":{\"23\":5}}],[\"lazyinstancenosafe\",{\"1\":{\"22\":5}}],[\"lazyinstance\",{\"1\":{\"19\":6,\"121\":6}}],[\"lsp\",{\"1\":{\"14\":1}}],[\"l\",{\"1\":{\"14\":1,\"147\":1,\"406\":3}}],[\"ov了object类的equals\",{\"1\":{\"430\":1}}],[\"overwrittingdemo\",{\"1\":{\"418\":1}}],[\"overlodingdemo\",{\"1\":{\"418\":3}}],[\"overloading\",{\"1\":{\"418\":2}}],[\"overriding\",{\"1\":{\"418\":2}}],[\"override\",{\"1\":{\"26\":2,\"31\":6,\"36\":3,\"41\":2,\"44\":2,\"47\":3,\"50\":3,\"54\":2,\"56\":1,\"57\":1,\"98\":4,\"119\":2,\"131\":1,\"139\":2,\"142\":2,\"143\":2,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"187\":2,\"191\":4,\"203\":2,\"235\":1,\"267\":2,\"315\":1,\"349\":1,\"418\":1,\"419\":2,\"424\":2,\"435\":1,\"436\":2,\"437\":1}}],[\"overflow\",{\"1\":{\"183\":1,\"361\":2}}],[\"over\",{\"1\":{\"90\":7,\"173\":1,\"395\":2,\"420\":1}}],[\"oldthr\",{\"1\":{\"377\":2}}],[\"oldtab\",{\"1\":{\"377\":8}}],[\"oldcap\",{\"1\":{\"377\":11}}],[\"oldcapacity\",{\"1\":{\"361\":5}}],[\"oldlength\",{\"1\":{\"361\":7}}],[\"oldval\",{\"1\":{\"259\":5,\"261\":5}}],[\"oldvalue\",{\"1\":{\"240\":3,\"241\":2}}],[\"old\",{\"1\":{\"198\":1}}],[\"owner\",{\"1\":{\"183\":2}}],[\"ourselves\",{\"1\":{\"173\":1}}],[\"outputstreamwriter\",{\"1\":{\"401\":2}}],[\"outputstream\",{\"1\":{\"399\":1,\"401\":1}}],[\"output\",{\"1\":{\"398\":1}}],[\"outofmemoryerror\",{\"1\":{\"361\":1}}],[\"outcome字段用来保存任务执行结果或者异常原因\",{\"1\":{\"329\":1}}],[\"outcome字段用来保存任务执行结果\",{\"1\":{\"328\":1}}],[\"outcome\",{\"1\":{\"328\":1,\"329\":2}}],[\"outcome=\",{\"1\":{\"97\":3}}],[\"outer\",{\"1\":{\"183\":1,\"313\":1}}],[\"out\",{\"1\":{\"26\":3,\"31\":3,\"36\":6,\"41\":1,\"47\":1,\"50\":1,\"54\":3,\"56\":2,\"57\":2,\"119\":1,\"131\":1,\"132\":1,\"142\":1,\"143\":1,\"147\":2,\"156\":2,\"157\":2,\"158\":2,\"159\":2,\"160\":2,\"187\":6,\"191\":8,\"203\":4,\"213\":1,\"230\":1,\"247\":2,\"267\":2,\"281\":1,\"288\":2,\"306\":1,\"312\":1,\"314\":1,\"315\":1,\"317\":1,\"323\":9,\"331\":1,\"336\":3,\"339\":2,\"340\":4,\"341\":2,\"342\":4,\"349\":1,\"352\":10,\"353\":7,\"354\":9,\"383\":1,\"393\":3,\"395\":11,\"401\":2,\"405\":1,\"406\":8,\"414\":5,\"415\":2,\"418\":5,\"419\":5,\"424\":2,\"429\":3,\"432\":3,\"435\":3,\"436\":2,\"438\":8}}],[\"otherwise\",{\"1\":{\"173\":1,\"256\":1}}],[\"other\",{\"1\":{\"173\":2}}],[\"o设备的输入输出请求\",{\"1\":{\"118\":1}}],[\"o设备的速度差异\",{\"1\":{\"118\":1}}],[\"ok\",{\"1\":{\"98\":17,\"110\":1,\"173\":1}}],[\"op\",{\"1\":{\"240\":1,\"407\":4,\"412\":2,\"414\":2}}],[\"optimize\",{\"1\":{\"239\":1}}],[\"optimistic\",{\"1\":{\"221\":1}}],[\"op>\",{\"1\":{\"90\":1}}],[\"operations\",{\"1\":{\"115\":2}}],[\"operation\",{\"1\":{\"54\":9,\"56\":3,\"57\":1,\"239\":1}}],[\"open\",{\"1\":{\"14\":1,\"407\":1,\"410\":2,\"411\":2,\"412\":2,\"414\":2,\"415\":1}}],[\"onshutdown\",{\"1\":{\"319\":1}}],[\"onlyone\",{\"1\":{\"319\":2}}],[\"only\",{\"1\":{\"271\":1,\"312\":1,\"314\":1}}],[\"onlyifabsent\",{\"1\":{\"259\":3}}],[\"onto\",{\"1\":{\"214\":1}}],[\"ones\",{\"1\":{\"311\":1}}],[\"one\",{\"1\":{\"88\":3,\"89\":2,\"173\":1,\"256\":1}}],[\"on\",{\"1\":{\"88\":1,\"173\":1,\"198\":1,\"199\":1,\"208\":1,\"223\":1,\"256\":1,\"312\":1}}],[\"oriented\",{\"1\":{\"422\":1}}],[\"original\",{\"1\":{\"237\":4}}],[\"orange\",{\"1\":{\"352\":3}}],[\"ordering\",{\"1\":{\"395\":1}}],[\"orderedarray\",{\"1\":{\"395\":3}}],[\"order\",{\"1\":{\"309\":1,\"377\":1}}],[\"org\",{\"1\":{\"98\":2}}],[\"or\",{\"1\":{\"86\":2,\"87\":1,\"107\":3,\"115\":1,\"168\":1,\"173\":4,\"185\":2,\"213\":1,\"214\":1,\"256\":3,\"311\":3,\"312\":1,\"393\":3}}],[\"offer函数添加元素不会抛出异常\",{\"1\":{\"274\":1}}],[\"offer函数也用于存放元素\",{\"1\":{\"274\":1}}],[\"offer函数\",{\"0\":{\"274\":1}}],[\"offer\",{\"1\":{\"264\":1,\"265\":6,\"274\":1,\"311\":1}}],[\"offset\",{\"0\":{\"83\":1},\"1\":{\"83\":2,\"395\":2}}],[\"of\",{\"1\":{\"68\":6,\"74\":1,\"75\":1,\"79\":2,\"90\":2,\"107\":2,\"110\":1,\"173\":4,\"185\":1,\"208\":1,\"214\":2,\"235\":2,\"256\":7,\"317\":1,\"361\":1}}],[\"observe\",{\"1\":{\"98\":1}}],[\"observer2\",{\"1\":{\"50\":2}}],[\"observer1\",{\"1\":{\"50\":2}}],[\"observerimpl\",{\"1\":{\"50\":4}}],[\"observer接口的实现类observerimpl的代码如下\",{\"1\":{\"50\":1}}],[\"observer\",{\"1\":{\"48\":1,\"49\":1,\"50\":7}}],[\"obeserver2\",{\"1\":{\"50\":5}}],[\"obj\",{\"1\":{\"50\":3,\"430\":2}}],[\"objectoutputstream\",{\"1\":{\"401\":1}}],[\"objectoutputstream来写\",{\"1\":{\"357\":1,\"373\":1,\"381\":1,\"391\":1}}],[\"objectstreamfield\",{\"1\":{\"256\":4}}],[\"objects\",{\"1\":{\"235\":1,\"363\":1}}],[\"object>\",{\"1\":{\"219\":1,\"220\":1,\"221\":1}}],[\"objectinputstream\",{\"1\":{\"183\":1,\"401\":1}}],[\"objectfieldoffset\",{\"1\":{\"170\":5,\"175\":1,\"233\":1,\"256\":5}}],[\"object\",{\"1\":{\"50\":5,\"56\":10,\"57\":7,\"98\":3,\"146\":3,\"159\":2,\"160\":2,\"175\":2,\"186\":1,\"219\":2,\"220\":2,\"221\":3,\"233\":1,\"234\":8,\"235\":3,\"237\":4,\"238\":2,\"239\":3,\"240\":2,\"241\":3,\"260\":1,\"261\":2,\"265\":2,\"270\":1,\"271\":1,\"273\":1,\"275\":1,\"277\":1,\"328\":1,\"358\":1,\"359\":3,\"360\":1,\"361\":3,\"362\":5,\"363\":6,\"364\":1,\"376\":1,\"378\":6,\"387\":2,\"388\":1,\"422\":1,\"430\":2}}],[\"ocp\",{\"1\":{\"14\":1}}],[\"o\",{\"1\":{\"14\":1,\"50\":3,\"57\":1,\"71\":1,\"118\":4,\"265\":2,\"358\":2,\"362\":5,\"363\":9,\"382\":1,\"387\":5,\"388\":4,\"403\":8,\"404\":2,\"406\":2,\"407\":3,\"410\":3,\"411\":3,\"412\":7,\"414\":1,\"415\":1,\"416\":3}}],[\"rs\",{\"1\":{\"259\":9,\"309\":2,\"312\":7,\"314\":3}}],[\"robin\",{\"1\":{\"376\":1}}],[\"roll\",{\"1\":{\"311\":1}}],[\"root\",{\"1\":{\"259\":5,\"261\":1}}],[\"roots\",{\"1\":{\"256\":1}}],[\"route配置\",{\"1\":{\"107\":1}}],[\"route\",{\"1\":{\"106\":2,\"107\":1}}],[\"r\",{\"1\":{\"198\":3,\"261\":3,\"314\":4,\"401\":1,\"406\":1}}],[\"rpc结果返回时调用该方法\",{\"1\":{\"186\":1}}],[\"rpc结果是否已经返回\",{\"1\":{\"186\":1}}],[\"rpc\",{\"1\":{\"186\":3}}],[\"run2\",{\"1\":{\"436\":2}}],[\"run1\",{\"1\":{\"436\":2}}],[\"runasync\",{\"1\":{\"337\":1}}],[\"run方法是在线程池中被执行的\",{\"1\":{\"318\":1}}],[\"run方法\",{\"0\":{\"318\":1,\"329\":1}}],[\"runworker方法是线程池的核心\",{\"1\":{\"313\":1}}],[\"runworker\",{\"1\":{\"313\":5}}],[\"runstateatleast\",{\"1\":{\"313\":2}}],[\"runstateof\",{\"1\":{\"309\":1,\"312\":3,\"314\":1}}],[\"runstate\",{\"1\":{\"309\":1,\"311\":1}}],[\"runner\",{\"1\":{\"318\":3,\"328\":1,\"329\":3,\"332\":1}}],[\"runneroffset\",{\"1\":{\"318\":1,\"329\":1}}],[\"running\",{\"1\":{\"293\":2,\"308\":1,\"309\":3,\"311\":1,\"419\":1}}],[\"runnable不会返回数据也不能抛出异常\",{\"1\":{\"325\":1}}],[\"runnablefuture<v>\",{\"1\":{\"317\":1}}],[\"runnablefuture<void>\",{\"1\":{\"316\":1}}],[\"runnable\",{\"0\":{\"157\":1,\"210\":1},\"1\":{\"119\":2,\"139\":2,\"142\":2,\"143\":2,\"155\":2,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"187\":2,\"191\":4,\"203\":2,\"208\":1,\"210\":1,\"213\":1,\"267\":2,\"281\":1,\"288\":2,\"311\":1,\"312\":1,\"313\":5,\"314\":3,\"316\":3,\"348\":2}}],[\"runtime\",{\"1\":{\"256\":1,\"433\":1}}],[\"runtimeexception\",{\"1\":{\"175\":1,\"313\":1}}],[\"run\",{\"1\":{\"119\":2,\"131\":1,\"139\":2,\"142\":2,\"143\":2,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"187\":2,\"191\":4,\"203\":2,\"208\":1,\"213\":1,\"267\":2,\"313\":3,\"317\":1,\"318\":2,\"329\":4,\"419\":1,\"436\":7}}],[\"rule规则文件的路径\",{\"1\":{\"116\":1}}],[\"rule产生的新的指标\",{\"1\":{\"115\":1}}],[\"rule的命令规范很重要\",{\"1\":{\"114\":1}}],[\"rule的最佳实践\",{\"0\":{\"114\":1}}],[\"rule的具体配置\",{\"1\":{\"113\":1}}],[\"rule的规则定义如下\",{\"1\":{\"113\":1}}],[\"rule类似\",{\"1\":{\"113\":1}}],[\"rule是预先计算成本较高的表达式\",{\"1\":{\"112\":1}}],[\"rules选项是recording\",{\"1\":{\"113\":1}}],[\"rules\",{\"0\":{\"113\":1},\"1\":{\"68\":2,\"106\":2,\"107\":3,\"108\":2,\"113\":1,\"116\":1}}],[\"rule\",{\"0\":{\"112\":1},\"1\":{\"68\":2,\"108\":4,\"111\":1,\"112\":1,\"113\":2,\"116\":5}}],[\"rightresult\",{\"1\":{\"349\":2}}],[\"right\",{\"1\":{\"89\":1,\"259\":3,\"349\":2}}],[\"radius\",{\"1\":{\"419\":6}}],[\"ran\",{\"1\":{\"318\":4,\"329\":4}}],[\"randomaccessfile\",{\"1\":{\"405\":5}}],[\"randomaccessfile类\",{\"1\":{\"401\":1}}],[\"randomaccess\",{\"1\":{\"232\":1,\"233\":1,\"357\":1,\"358\":1}}],[\"ranaction\",{\"1\":{\"213\":3}}],[\"rangecheckforadd\",{\"1\":{\"360\":1}}],[\"range\",{\"0\":{\"82\":1},\"1\":{\"92\":1,\"93\":1}}],[\"races\",{\"1\":{\"256\":1}}],[\"race\",{\"1\":{\"119\":1,\"173\":1,\"239\":1,\"259\":1,\"313\":1}}],[\"ram\",{\"1\":{\"118\":1}}],[\"ratio\",{\"1\":{\"115\":4}}],[\"rate1m\",{\"1\":{\"116\":1}}],[\"rate\",{\"1\":{\"92\":1,\"94\":2,\"115\":2,\"116\":1}}],[\"rate5m\",{\"1\":{\"89\":12,\"115\":12}}],[\"ray\",{\"1\":{\"7\":1}}],[\"rw\",{\"1\":{\"31\":2,\"401\":1,\"405\":1}}],[\"rewind\",{\"1\":{\"406\":4}}],[\"reverse\",{\"1\":{\"352\":1}}],[\"reject\",{\"1\":{\"311\":3}}],[\"rejectedexecutionexception\",{\"1\":{\"302\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"294\":1,\"308\":1}}],[\"remaining\",{\"1\":{\"415\":1}}],[\"remainingcapacity\",{\"1\":{\"265\":1}}],[\"removing\",{\"1\":{\"352\":2,\"354\":2}}],[\"removeall\",{\"1\":{\"352\":1}}],[\"removewaiter\",{\"1\":{\"317\":2,\"331\":2}}],[\"removetreenode\",{\"1\":{\"261\":1}}],[\"remove函数底层是调用的replacenode函数实现结点的删除\",{\"1\":{\"261\":1}}],[\"remove函数\",{\"0\":{\"241\":1}}],[\"remove等操作\",{\"1\":{\"239\":1}}],[\"remove\",{\"0\":{\"370\":1},\"1\":{\"142\":2,\"173\":1,\"230\":1,\"235\":3,\"241\":1,\"247\":1,\"265\":3,\"281\":2,\"287\":2,\"311\":1,\"352\":2,\"353\":1,\"354\":1,\"362\":3,\"364\":8,\"366\":2,\"370\":4,\"388\":10,\"412\":1,\"414\":1}}],[\"replace\",{\"1\":{\"359\":1}}],[\"replacenode\",{\"1\":{\"261\":1}}],[\"replacenode函数\",{\"0\":{\"261\":1}}],[\"report\",{\"1\":{\"317\":1,\"330\":1}}],[\"repeat\",{\"1\":{\"106\":1,\"107\":2}}],[\"reduce\",{\"1\":{\"333\":1}}],[\"red\",{\"1\":{\"259\":2}}],[\"required\",{\"1\":{\"361\":1}}],[\"requires\",{\"1\":{\"313\":1}}],[\"requirenonnull\",{\"1\":{\"235\":1}}],[\"requestbody\",{\"1\":{\"110\":1}}],[\"requestparam\",{\"1\":{\"97\":1,\"98\":1}}],[\"requestmapping\",{\"1\":{\"97\":1,\"98\":1}}],[\"requests\",{\"1\":{\"74\":12,\"75\":4,\"76\":3,\"81\":8,\"82\":1,\"83\":4,\"85\":3,\"89\":5,\"90\":6,\"92\":5,\"97\":10,\"108\":1,\"113\":2,\"115\":10,\"116\":2}}],[\"request\",{\"1\":{\"35\":1,\"78\":13,\"85\":1,\"94\":13,\"98\":5,\"115\":8,\"287\":2}}],[\"re\",{\"1\":{\"213\":1,\"312\":1,\"318\":1,\"329\":1}}],[\"reentrant\",{\"1\":{\"219\":1}}],[\"reentrantlockdemo3\",{\"1\":{\"219\":1}}],[\"reentrantlockdemo2\",{\"1\":{\"187\":1}}],[\"reentrantlock是java并发包中提供的一种可重入互斥锁\",{\"1\":{\"219\":1}}],[\"reentrantlock使用示例\",{\"0\":{\"187\":1}}],[\"reentrantlock在dubbo中的使用\",{\"0\":{\"186\":1}}],[\"reentrantlock中的内部抽象类sync继承了abstractqueuedsynchronizer\",{\"1\":{\"180\":1}}],[\"reentrantlock类的sync变量是实现lock功能的关键\",{\"1\":{\"180\":1}}],[\"reentrantlock类继承关系\",{\"0\":{\"179\":1}}],[\"reentrantlock实现了lock接口\",{\"1\":{\"179\":1}}],[\"reentrantlock\",{\"0\":{\"219\":1},\"1\":{\"179\":1,\"180\":1,\"181\":2,\"186\":1,\"187\":2,\"188\":1,\"208\":2,\"213\":1,\"218\":2,\"219\":3,\"233\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"270\":1,\"271\":2,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"312\":3,\"319\":4}}],[\"reentrantlock的特点总结\",{\"0\":{\"188\":1}}],[\"reentrantlock的继承关系如下\",{\"1\":{\"179\":1}}],[\"reentrantlock的底层数据结构是借助abstractqueuedsynchronizer实现\",{\"1\":{\"178\":1}}],[\"reentrantlock数据结构\",{\"0\":{\"178\":1}}],[\"reentrantlock源码解析\",{\"0\":{\"177\":1}}],[\"reentrantreadwritelock\",{\"1\":{\"162\":1,\"164\":1,\"220\":1}}],[\"retry\",{\"1\":{\"173\":2,\"312\":4,\"314\":1}}],[\"returning\",{\"1\":{\"311\":1}}],[\"returned\",{\"1\":{\"235\":1}}],[\"returnfromresponse\",{\"1\":{\"186\":1}}],[\"returnvalue\",{\"1\":{\"57\":2}}],[\"return\",{\"1\":{\"18\":1,\"19\":1,\"20\":1,\"22\":1,\"23\":1,\"31\":9,\"36\":1,\"41\":3,\"44\":2,\"47\":3,\"56\":1,\"57\":2,\"97\":1,\"98\":3,\"110\":1,\"121\":1,\"142\":2,\"163\":2,\"166\":1,\"168\":2,\"173\":8,\"174\":2,\"175\":9,\"183\":9,\"184\":1,\"185\":3,\"186\":2,\"197\":4,\"198\":2,\"199\":4,\"213\":2,\"214\":3,\"219\":1,\"220\":1,\"221\":1,\"234\":1,\"235\":6,\"237\":1,\"238\":1,\"239\":3,\"240\":1,\"241\":1,\"259\":12,\"260\":4,\"261\":2,\"274\":2,\"275\":2,\"276\":1,\"282\":3,\"288\":1,\"309\":3,\"311\":1,\"312\":3,\"314\":3,\"315\":1,\"316\":1,\"317\":3,\"318\":1,\"319\":1,\"323\":3,\"329\":1,\"330\":1,\"331\":2,\"332\":4,\"336\":1,\"339\":1,\"340\":2,\"341\":2,\"342\":2,\"349\":2,\"360\":1,\"361\":7,\"362\":2,\"363\":5,\"364\":2,\"368\":1,\"369\":4,\"370\":3,\"376\":1,\"377\":1,\"378\":6,\"386\":1,\"387\":1,\"388\":1,\"395\":4,\"419\":1,\"430\":5,\"431\":1,\"432\":1,\"435\":2,\"438\":6}}],[\"reorder\",{\"1\":{\"128\":1}}],[\"recvfrom\",{\"1\":{\"416\":1}}],[\"recheck\",{\"1\":{\"198\":1,\"199\":1,\"311\":6,\"312\":1,\"313\":1}}],[\"recursiveaction\",{\"1\":{\"346\":1}}],[\"recursivetask<long>\",{\"1\":{\"349\":1}}],[\"recursivetask\",{\"1\":{\"346\":1,\"349\":2}}],[\"recursive\",{\"1\":{\"185\":1}}],[\"reconstitutes\",{\"1\":{\"183\":1}}],[\"recoding\",{\"1\":{\"116\":1}}],[\"record\",{\"1\":{\"113\":2,\"115\":5,\"116\":1,\"198\":1}}],[\"recording的计算规则和alert的计算规则\",{\"1\":{\"113\":1}}],[\"recording\",{\"0\":{\"112\":1,\"114\":1},\"1\":{\"112\":1,\"114\":1,\"116\":1}}],[\"receiver可以集成邮箱\",{\"1\":{\"107\":1}}],[\"receivers配置\",{\"1\":{\"107\":1}}],[\"receivers\",{\"1\":{\"106\":2,\"107\":1}}],[\"receiver\",{\"1\":{\"106\":1,\"107\":1,\"110\":2}}],[\"region\",{\"1\":{\"108\":1,\"116\":1}}],[\"registry\",{\"1\":{\"97\":2,\"98\":2}}],[\"register\",{\"1\":{\"50\":4,\"98\":2,\"412\":3,\"414\":2}}],[\"relayed\",{\"1\":{\"183\":1}}],[\"release方法用于释放资源\",{\"1\":{\"142\":1}}],[\"release\",{\"0\":{\"174\":1},\"1\":{\"71\":1,\"142\":2,\"173\":1,\"174\":1}}],[\"releaseshared源码如下\",{\"1\":{\"199\":1}}],[\"releaseshared\",{\"1\":{\"199\":2}}],[\"releases\",{\"1\":{\"69\":1,\"183\":2,\"197\":1,\"199\":1}}],[\"reload\",{\"1\":{\"70\":1,\"105\":1}}],[\"reflectgetunsafe\",{\"1\":{\"175\":2}}],[\"reflect\",{\"1\":{\"56\":2,\"175\":1}}],[\"realsubject\",{\"1\":{\"53\":1,\"54\":10,\"56\":4,\"57\":1}}],[\"reader\",{\"1\":{\"399\":1,\"401\":1}}],[\"readerwriter的基本实现类是filereaderwriter\",{\"1\":{\"31\":1}}],[\"readerwriter\",{\"1\":{\"31\":21}}],[\"reads\",{\"1\":{\"328\":1}}],[\"readlock\",{\"1\":{\"220\":4}}],[\"readline\",{\"1\":{\"31\":1}}],[\"readobject\",{\"1\":{\"183\":1}}],[\"readwritelockdemo\",{\"1\":{\"220\":1}}],[\"readwritelock将读锁和写锁分离\",{\"1\":{\"220\":1}}],[\"readwritelock的特点包括\",{\"1\":{\"220\":1}}],[\"readwritelock是java并发包中提供的一种读写锁机制\",{\"1\":{\"220\":1}}],[\"readwritelock\",{\"0\":{\"220\":1},\"1\":{\"164\":1,\"218\":3,\"220\":4,\"221\":2}}],[\"readthread\",{\"1\":{\"131\":2}}],[\"readychannels\",{\"1\":{\"412\":2}}],[\"ready\",{\"1\":{\"131\":4}}],[\"read\",{\"1\":{\"31\":9,\"183\":1,\"221\":2,\"312\":1,\"318\":1,\"329\":1,\"405\":3,\"407\":1,\"410\":2,\"411\":1,\"412\":1,\"414\":4,\"415\":1}}],[\"resizing\",{\"1\":{\"256\":4}}],[\"resizestamp\",{\"1\":{\"259\":2}}],[\"resized\",{\"1\":{\"256\":1}}],[\"resizers\",{\"1\":{\"256\":1,\"259\":2}}],[\"resize\",{\"1\":{\"256\":5,\"259\":3,\"376\":1,\"377\":2}}],[\"reservations\",{\"1\":{\"256\":1}}],[\"reservationnode\",{\"1\":{\"251\":1}}],[\"reserved\",{\"1\":{\"256\":1}}],[\"reset\",{\"1\":{\"183\":1,\"406\":1}}],[\"resync\",{\"1\":{\"214\":1}}],[\"res\",{\"1\":{\"186\":2}}],[\"res2\",{\"1\":{\"142\":5}}],[\"res1\",{\"1\":{\"142\":5}}],[\"resmanager\",{\"1\":{\"142\":15}}],[\"resolve\",{\"1\":{\"106\":1,\"107\":2}}],[\"response\",{\"1\":{\"98\":3,\"186\":3,\"287\":1}}],[\"responsebody\",{\"1\":{\"97\":1,\"98\":1}}],[\"responsibility\",{\"1\":{\"14\":1}}],[\"resultfuture\",{\"1\":{\"341\":3}}],[\"resulting\",{\"1\":{\"90\":1}}],[\"result\",{\"1\":{\"31\":8,\"221\":3,\"282\":2,\"315\":3,\"316\":1,\"318\":4,\"323\":6,\"329\":4,\"336\":3,\"339\":2,\"340\":4,\"341\":2,\"349\":2,\"432\":2,\"438\":2}}],[\"ss\",{\"1\":{\"435\":1}}],[\"ssc\",{\"1\":{\"414\":7}}],[\"sschannel\",{\"1\":{\"414\":2}}],[\"s3\",{\"1\":{\"435\":4}}],[\"s2=\",{\"1\":{\"435\":1}}],[\"s2\",{\"1\":{\"435\":2}}],[\"s1\",{\"1\":{\"435\":2}}],[\"s1=\",{\"1\":{\"435\":2}}],[\"sqrt\",{\"1\":{\"395\":1}}],[\"svg\",{\"1\":{\"295\":2}}],[\"snapshot与current之间的较小者\",{\"1\":{\"239\":1}}],[\"snapshot\",{\"1\":{\"235\":7,\"239\":4}}],[\"swap\",{\"1\":{\"222\":1,\"246\":1}}],[\"s赋值为空\",{\"1\":{\"173\":1}}],[\"skip\",{\"1\":{\"173\":3}}],[\"saturated\",{\"1\":{\"311\":1}}],[\"safely\",{\"1\":{\"173\":1}}],[\"sam\",{\"1\":{\"376\":1,\"435\":1}}],[\"same\",{\"1\":{\"90\":1,\"107\":1}}],[\"sample由三部分组成\",{\"1\":{\"74\":1}}],[\"sample\",{\"1\":{\"74\":1,\"90\":2}}],[\"shape\",{\"1\":{\"419\":6}}],[\"shared\",{\"1\":{\"168\":3,\"198\":1}}],[\"share\",{\"1\":{\"164\":1}}],[\"sheep=new\",{\"1\":{\"418\":1}}],[\"sheep\",{\"1\":{\"418\":5}}],[\"sheep继承了animal父类\",{\"1\":{\"418\":1}}],[\"shut\",{\"1\":{\"311\":2,\"312\":1}}],[\"shutdown方法会将线程池的状态设置为shutdown\",{\"1\":{\"319\":1}}],[\"shutdownnow做的比较绝\",{\"1\":{\"319\":1}}],[\"shutdownnow\",{\"1\":{\"313\":1,\"319\":1}}],[\"shutdown\",{\"1\":{\"293\":2,\"306\":2,\"309\":2,\"312\":4,\"314\":1,\"319\":2,\"323\":2,\"336\":1}}],[\"shift\",{\"1\":{\"256\":1,\"259\":3}}],[\"shortbuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"short\",{\"1\":{\"403\":1,\"429\":1}}],[\"should\",{\"1\":{\"311\":1}}],[\"shouldn\",{\"1\":{\"311\":1}}],[\"shouldparkafterfailedacquire\",{\"1\":{\"173\":2,\"198\":1}}],[\"showname\",{\"1\":{\"41\":2,\"44\":1,\"47\":3}}],[\"specified\",{\"1\":{\"288\":1}}],[\"spread\",{\"1\":{\"259\":1,\"260\":1,\"261\":1}}],[\"springboot\",{\"1\":{\"99\":1}}],[\"springboot已经有来micrometer的指标库\",{\"1\":{\"97\":1}}],[\"springframework\",{\"1\":{\"97\":2,\"98\":2}}],[\"spring事务等领域有着广泛的应用\",{\"1\":{\"52\":1}}],[\"spring\",{\"1\":{\"52\":1}}],[\"split\",{\"1\":{\"256\":1,\"377\":1}}],[\"splice\",{\"1\":{\"214\":1}}],[\"spin\",{\"1\":{\"259\":1}}],[\"spinlock\",{\"1\":{\"256\":1}}],[\"spinfortimeoutthreshold\",{\"1\":{\"170\":1}}],[\"spinning\",{\"1\":{\"153\":1}}],[\"sl\",{\"1\":{\"221\":7}}],[\"sleeping\",{\"1\":{\"419\":1}}],[\"sleep\",{\"1\":{\"131\":1,\"132\":1,\"135\":1,\"139\":2,\"142\":1,\"143\":1,\"158\":1,\"159\":1,\"160\":2,\"175\":1,\"191\":6,\"203\":3,\"267\":2,\"315\":1,\"323\":3,\"336\":2,\"339\":1,\"340\":1,\"341\":3,\"342\":3,\"415\":1,\"419\":3}}],[\"slack或者webhook等\",{\"1\":{\"106\":1}}],[\"slack配置等内容\",{\"1\":{\"106\":1}}],[\"s=\",{\"1\":{\"126\":1,\"435\":1}}],[\"sdk\",{\"1\":{\"101\":1}}],[\"sdks\",{\"1\":{\"63\":1}}],[\"score\",{\"1\":{\"354\":8}}],[\"scores\",{\"1\":{\"354\":16}}],[\"scope>\",{\"1\":{\"97\":1}}],[\"schedule\",{\"1\":{\"305\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"305\":1,\"319\":1}}],[\"scheduledthreadpoolexecutor继承threadpoolexecutor并实现了scheduledexecutorservice接口\",{\"1\":{\"292\":1}}],[\"scheduledexecutorservice\",{\"1\":{\"305\":1}}],[\"scheduledexecutorservice继承executorservice接口\",{\"1\":{\"292\":1}}],[\"sc为n\",{\"1\":{\"259\":1}}],[\"sc的值是否大于0\",{\"1\":{\"259\":1}}],[\"sc\",{\"1\":{\"259\":24,\"414\":10}}],[\"scale\",{\"1\":{\"256\":5}}],[\"scalar\",{\"1\":{\"93\":1,\"94\":1}}],[\"scrape\",{\"1\":{\"68\":4,\"69\":1,\"99\":1}}],[\"smallest\",{\"1\":{\"90\":1}}],[\"super\",{\"1\":{\"235\":1,\"265\":2,\"419\":1,\"437\":1}}],[\"supplyasync\",{\"1\":{\"337\":1,\"339\":2,\"340\":2,\"341\":2,\"342\":2,\"343\":1}}],[\"supported\",{\"1\":{\"235\":6}}],[\"suppresswarnings\",{\"1\":{\"235\":3,\"237\":1,\"259\":1,\"275\":1,\"282\":1,\"364\":1}}],[\"sun\",{\"1\":{\"175\":1,\"233\":2,\"256\":2}}],[\"sure\",{\"1\":{\"173\":1}}],[\"successor\",{\"1\":{\"173\":3}}],[\"successfully\",{\"1\":{\"107\":1,\"311\":1}}],[\"success\",{\"1\":{\"97\":3,\"142\":1,\"143\":1}}],[\"sumtask\",{\"1\":{\"349\":8}}],[\"sumcount\",{\"1\":{\"259\":2}}],[\"sum作为后缀\",{\"1\":{\"78\":1}}],[\"sum\",{\"1\":{\"68\":1,\"78\":1,\"79\":1,\"85\":1,\"90\":6,\"94\":2,\"97\":2,\"98\":1,\"100\":2,\"108\":1,\"113\":2,\"115\":4,\"116\":1,\"323\":9,\"336\":3,\"349\":4}}],[\"summary在通过promql进行查询时有更好的性能表现\",{\"1\":{\"79\":1}}],[\"summary是在sdk侧已经计算好了分位数\",{\"1\":{\"79\":1}}],[\"summary和histogram类似\",{\"1\":{\"79\":1}}],[\"summary\",{\"0\":{\"79\":1},\"1\":{\"68\":2,\"75\":1,\"79\":2,\"97\":1,\"108\":1}}],[\"sublist\",{\"1\":{\"352\":1}}],[\"subsequent\",{\"1\":{\"213\":1,\"235\":1}}],[\"substitution\",{\"1\":{\"14\":1}}],[\"submit方法在abstractexecutorservice中的实现\",{\"1\":{\"316\":1}}],[\"submit方法\",{\"0\":{\"316\":1}}],[\"submit任务\",{\"1\":{\"315\":1}}],[\"submit\",{\"1\":{\"191\":2,\"203\":2,\"315\":1,\"316\":8,\"323\":3,\"336\":1}}],[\"subtraction\",{\"1\":{\"85\":1}}],[\"subject\",{\"1\":{\"49\":1,\"53\":1,\"54\":3,\"56\":5,\"57\":5,\"314\":1}}],[\"socket\",{\"1\":{\"414\":1}}],[\"socketchannel介绍\",{\"0\":{\"410\":1}}],[\"socketchannel\",{\"1\":{\"403\":1,\"404\":1,\"407\":1,\"410\":19,\"411\":8,\"414\":8,\"415\":16}}],[\"soft\",{\"1\":{\"361\":4}}],[\"sofa=\",{\"1\":{\"47\":1}}],[\"sofa\",{\"1\":{\"40\":2,\"41\":17,\"43\":2,\"44\":7,\"47\":5}}],[\"sortarray\",{\"1\":{\"395\":1}}],[\"sort\",{\"1\":{\"352\":1}}],[\"some\",{\"1\":{\"256\":1}}],[\"somthing\",{\"1\":{\"54\":2,\"56\":1,\"57\":1}}],[\"so\",{\"1\":{\"115\":1,\"173\":3,\"183\":1,\"213\":1,\"311\":3}}],[\"sourcechannel\",{\"1\":{\"404\":1}}],[\"source\",{\"1\":{\"106\":1,\"107\":2}}],[\"sieve\",{\"1\":{\"395\":7}}],[\"sinkchannel\",{\"1\":{\"404\":1}}],[\"since\",{\"1\":{\"311\":2}}],[\"sington\",{\"1\":{\"24\":1}}],[\"singleton=memory\",{\"1\":{\"19\":1,\"121\":1}}],[\"single\",{\"1\":{\"14\":1}}],[\"site\",{\"1\":{\"263\":1}}],[\"sizings\",{\"1\":{\"256\":1}}],[\"size++\",{\"1\":{\"368\":1}}],[\"sizectl小于0\",{\"1\":{\"259\":1}}],[\"sizectl\",{\"1\":{\"256\":4,\"259\":8}}],[\"size\",{\"1\":{\"50\":1,\"175\":1,\"187\":13,\"235\":3,\"256\":3,\"288\":1,\"309\":1,\"312\":1,\"352\":5,\"353\":5,\"354\":5,\"359\":2,\"360\":3,\"361\":1,\"362\":7,\"363\":3,\"364\":3,\"366\":4,\"368\":1,\"369\":5,\"370\":5,\"377\":1,\"385\":1,\"393\":4,\"395\":14,\"414\":2}}],[\"signalling\",{\"1\":{\"173\":1}}],[\"signal函数\",{\"1\":{\"169\":1}}],[\"signalall\",{\"1\":{\"169\":1,\"214\":2,\"215\":1}}],[\"signal\",{\"1\":{\"168\":3,\"169\":1,\"173\":9,\"186\":2,\"187\":2,\"197\":1,\"198\":2,\"199\":3,\"214\":2,\"273\":1,\"275\":1,\"277\":1}}],[\"sighup信号或者请求alertmanager\",{\"1\":{\"105\":1}}],[\"simplefactory\",{\"1\":{\"41\":3}}],[\"simplesofafactory\",{\"1\":{\"40\":1,\"41\":1}}],[\"simple\",{\"1\":{\"39\":1}}],[\"sequenceinputstream\",{\"1\":{\"401\":1}}],[\"separate\",{\"1\":{\"361\":1}}],[\"securityexception\",{\"1\":{\"319\":1}}],[\"seconds指标\",{\"1\":{\"79\":1}}],[\"seconds\",{\"1\":{\"68\":9,\"78\":13,\"79\":9,\"85\":1,\"94\":13,\"97\":10,\"98\":19,\"100\":1,\"315\":1,\"323\":1,\"336\":2,\"415\":1}}],[\"second\",{\"1\":{\"68\":1,\"313\":1,\"406\":1}}],[\"searched\",{\"1\":{\"259\":3}}],[\"search=\",{\"1\":{\"108\":1}}],[\"search=node+exporter+mac\",{\"1\":{\"71\":1}}],[\"segmentmask\",{\"1\":{\"256\":1}}],[\"segmentshift\",{\"1\":{\"256\":1}}],[\"segments\",{\"1\":{\"256\":1}}],[\"segment类在jdk1\",{\"1\":{\"254\":1}}],[\"segment类\",{\"0\":{\"254\":1}}],[\"segment\",{\"1\":{\"245\":1,\"256\":1}}],[\"segregation\",{\"1\":{\"14\":1}}],[\"semantics\",{\"1\":{\"240\":1}}],[\"semaphore\",{\"1\":{\"162\":1,\"164\":1}}],[\"see\",{\"1\":{\"234\":1}}],[\"selfinterrupt\",{\"1\":{\"173\":1}}],[\"selectedkeys\",{\"1\":{\"407\":1,\"412\":3,\"414\":1}}],[\"selectionkey\",{\"1\":{\"407\":7,\"412\":3,\"414\":10}}],[\"selector介绍\",{\"0\":{\"412\":1}}],[\"selector\",{\"0\":{\"407\":1},\"1\":{\"403\":1,\"407\":13,\"410\":1,\"411\":1,\"412\":21,\"414\":21,\"416\":5}}],[\"selectors查询\",{\"1\":{\"82\":1}}],[\"selectors\",{\"0\":{\"81\":1,\"82\":1}}],[\"select\",{\"1\":{\"90\":2,\"407\":1,\"412\":3,\"414\":2,\"416\":1}}],[\"sent\",{\"1\":{\"107\":2}}],[\"sending\",{\"1\":{\"107\":2}}],[\"send\",{\"1\":{\"107\":1}}],[\"serialpersistentfields\",{\"1\":{\"256\":1}}],[\"serialization\",{\"1\":{\"256\":1}}],[\"serializable\",{\"1\":{\"166\":2,\"170\":1,\"179\":1,\"180\":1,\"232\":1,\"233\":1,\"249\":1,\"256\":1,\"269\":1,\"270\":1,\"357\":1,\"358\":1,\"366\":1}}],[\"serialversionuid\",{\"1\":{\"166\":1,\"170\":1,\"180\":1,\"183\":1,\"184\":1,\"185\":1,\"197\":1,\"233\":1,\"256\":1,\"270\":1}}],[\"series的形式存储在prometheus的level\",{\"1\":{\"75\":1}}],[\"series中每个点被称为一个样子\",{\"1\":{\"74\":1}}],[\"series\",{\"0\":{\"74\":1},\"1\":{\"74\":1}}],[\"serveletrequest\",{\"1\":{\"287\":1}}],[\"serverconnect\",{\"1\":{\"414\":1}}],[\"serversocketchannel介绍\",{\"0\":{\"411\":1}}],[\"serversocketchannel的网络编程\",{\"1\":{\"408\":1}}],[\"serversocketchannel\",{\"1\":{\"403\":1,\"404\":1,\"407\":1,\"411\":19,\"414\":7}}],[\"server中配置告警规则\",{\"1\":{\"101\":1}}],[\"server中配置alertmanager的地址\",{\"1\":{\"101\":1}}],[\"server中的告警规则\",{\"1\":{\"101\":1}}],[\"server进行计算的\",{\"1\":{\"79\":1}}],[\"server\",{\"1\":{\"71\":1,\"97\":10,\"98\":2,\"102\":1,\"410\":1}}],[\"server是最核心的组件\",{\"1\":{\"63\":1}}],[\"servletresponse\",{\"1\":{\"287\":1}}],[\"servlet\",{\"1\":{\"98\":4}}],[\"severity\",{\"1\":{\"106\":2,\"107\":4,\"108\":1}}],[\"sever\",{\"1\":{\"66\":1}}],[\"set<selectionkey>\",{\"1\":{\"412\":1}}],[\"set<string>\",{\"1\":{\"353\":1,\"383\":1}}],[\"set=new\",{\"1\":{\"383\":1}}],[\"set和map接口\",{\"1\":{\"355\":1}}],[\"setexample\",{\"1\":{\"353\":1}}],[\"setexception\",{\"1\":{\"318\":1,\"329\":3}}],[\"setexclusiveownerthread\",{\"1\":{\"166\":1,\"183\":2,\"184\":1,\"185\":1}}],[\"set接口\",{\"0\":{\"353\":1}}],[\"settled\",{\"1\":{\"318\":1,\"329\":1}}],[\"settabat\",{\"1\":{\"259\":1,\"261\":2}}],[\"setname\",{\"1\":{\"435\":1}}],[\"setnameformat\",{\"1\":{\"306\":1}}],[\"setnextapproval\",{\"1\":{\"36\":3}}],[\"setcorepoolsize\",{\"1\":{\"295\":1}}],[\"setcallback\",{\"1\":{\"57\":1}}],[\"setinitialvalue\",{\"1\":{\"282\":1}}],[\"set函数\",{\"0\":{\"240\":1}}],[\"setage\",{\"1\":{\"435\":2}}],[\"setarray\",{\"1\":{\"234\":3,\"238\":1,\"239\":1,\"240\":2,\"241\":2}}],[\"setaccessible\",{\"1\":{\"175\":1}}],[\"setattribute\",{\"1\":{\"98\":1}}],[\"setblocker\",{\"1\":{\"175\":2}}],[\"setlocalholder\",{\"1\":{\"175\":3}}],[\"set\",{\"0\":{\"225\":1},\"1\":{\"173\":2,\"214\":3,\"222\":1,\"230\":1,\"235\":3,\"239\":1,\"240\":1,\"282\":4,\"287\":2,\"288\":3,\"318\":1,\"329\":2,\"351\":3,\"352\":2,\"353\":17,\"383\":6,\"393\":11,\"395\":5}}],[\"setheadandpropagate方法源码如下\",{\"1\":{\"198\":1}}],[\"setheadandpropagate\",{\"1\":{\"198\":2}}],[\"sethead\",{\"1\":{\"173\":1,\"198\":1}}],[\"setstate\",{\"1\":{\"163\":2,\"175\":1,\"183\":3,\"185\":1,\"197\":1,\"313\":2}}],[\"setsuperclass\",{\"1\":{\"57\":1}}],[\"sb\",{\"1\":{\"31\":3,\"395\":5}}],[\"stealing\",{\"1\":{\"347\":1}}],[\"steps\",{\"1\":{\"311\":1}}],[\"step\",{\"1\":{\"173\":1}}],[\"stored\",{\"1\":{\"309\":1}}],[\"stopping\",{\"1\":{\"313\":1}}],[\"stopped\",{\"1\":{\"311\":1}}],[\"stop\",{\"1\":{\"293\":2,\"309\":2,\"313\":2,\"314\":1,\"319\":1}}],[\"str3\",{\"1\":{\"429\":3}}],[\"str2\",{\"1\":{\"429\":3}}],[\"str1\",{\"1\":{\"429\":4}}],[\"str\",{\"1\":{\"395\":3}}],[\"stride\",{\"1\":{\"256\":1}}],[\"string是线程安全的\",{\"1\":{\"421\":1}}],[\"string是不可变\",{\"1\":{\"421\":1}}],[\"string和stringbuffer\",{\"0\":{\"421\":1}}],[\"stringwriter\",{\"1\":{\"401\":1}}],[\"string中读取数据\",{\"1\":{\"401\":1}}],[\"stringreader\",{\"1\":{\"401\":1}}],[\"stringbuffer是线程安全的\",{\"1\":{\"421\":1}}],[\"stringbuffer和stringbuilder是可变的\",{\"1\":{\"421\":1}}],[\"stringbuffer和stringbuilder是可变\",{\"1\":{\"421\":1}}],[\"stringbuffer和stringbuilder是用于处理字符串的类\",{\"1\":{\"421\":1}}],[\"stringbuffer\",{\"1\":{\"401\":1}}],[\"stringbufferinputstream\",{\"1\":{\"401\":2}}],[\"stringbuilder的性能比stringbuffer性能更好\",{\"1\":{\"421\":1}}],[\"stringbuilder的区别是什么\",{\"0\":{\"421\":1}}],[\"stringbuilder是非线程安全的\",{\"1\":{\"421\":1}}],[\"stringbuilder\",{\"1\":{\"31\":2,\"395\":2}}],[\"string>\",{\"1\":{\"110\":5,\"376\":1}}],[\"stringdata\",{\"1\":{\"31\":4}}],[\"string\",{\"1\":{\"26\":1,\"31\":24,\"36\":1,\"41\":5,\"44\":1,\"47\":3,\"50\":3,\"54\":1,\"56\":1,\"57\":1,\"97\":2,\"98\":3,\"110\":9,\"119\":1,\"126\":1,\"131\":1,\"132\":1,\"139\":1,\"142\":1,\"143\":1,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":1,\"187\":1,\"191\":2,\"203\":1,\"219\":2,\"220\":2,\"221\":2,\"230\":2,\"247\":2,\"267\":1,\"281\":1,\"288\":2,\"315\":3,\"323\":3,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":1,\"352\":5,\"353\":3,\"354\":3,\"383\":2,\"393\":1,\"395\":1,\"401\":1,\"405\":2,\"406\":1,\"410\":1,\"411\":1,\"414\":2,\"415\":4,\"418\":5,\"419\":5,\"421\":1,\"429\":4,\"430\":3,\"432\":1,\"435\":10,\"436\":3,\"438\":3}}],[\"streams\",{\"1\":{\"399\":3}}],[\"stream\",{\"1\":{\"183\":1,\"393\":1}}],[\"stdvar\",{\"1\":{\"90\":1}}],[\"stddev\",{\"1\":{\"90\":1}}],[\"still\",{\"1\":{\"68\":1,\"311\":1}}],[\"stack\",{\"1\":{\"288\":1}}],[\"stacksize\",{\"1\":{\"288\":3}}],[\"stash\",{\"1\":{\"288\":1}}],[\"stamp\",{\"1\":{\"221\":7,\"256\":4,\"259\":3}}],[\"stampedlockdemo\",{\"1\":{\"221\":1}}],[\"stampedlock并不支持可重入的读模式\",{\"1\":{\"221\":1}}],[\"stampedlock支持三种模式的访问\",{\"1\":{\"221\":1}}],[\"stampedlock是java\",{\"1\":{\"221\":1}}],[\"stampedlock\",{\"0\":{\"221\":1},\"1\":{\"218\":2,\"221\":6}}],[\"stampedlock等\",{\"1\":{\"218\":1}}],[\"starsray\",{\"1\":{\"320\":1}}],[\"starsliao\",{\"1\":{\"111\":1}}],[\"startable\",{\"1\":{\"312\":1}}],[\"started\",{\"1\":{\"157\":2}}],[\"starter\",{\"0\":{\"97\":1},\"1\":{\"96\":1,\"97\":3}}],[\"start\",{\"1\":{\"119\":2,\"131\":1,\"132\":1,\"139\":2,\"142\":2,\"143\":2,\"147\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"186\":2,\"187\":2,\"191\":2,\"267\":2,\"281\":3,\"288\":1,\"311\":2,\"312\":2,\"323\":1,\"349\":8}}],[\"startsat\",{\"1\":{\"110\":2}}],[\"starttime\",{\"1\":{\"98\":6}}],[\"state内存偏移地址\",{\"1\":{\"170\":2}}],[\"stateoffset\",{\"1\":{\"163\":1,\"170\":2,\"175\":3,\"329\":4,\"332\":3}}],[\"state=runnable\",{\"1\":{\"157\":1}}],[\"state=\",{\"1\":{\"157\":1}}],[\"state\",{\"1\":{\"155\":1,\"156\":2,\"158\":2,\"159\":2,\"163\":3,\"164\":1,\"170\":2,\"175\":8,\"183\":2,\"311\":1,\"317\":6,\"318\":5,\"328\":2,\"329\":7,\"330\":1,\"331\":2,\"332\":2,\"333\":1}}],[\"status\",{\"1\":{\"98\":2,\"110\":4,\"173\":3}}],[\"status=\",{\"1\":{\"97\":3,\"98\":15}}],[\"staticproxy\",{\"1\":{\"53\":1,\"54\":7}}],[\"static\",{\"1\":{\"18\":2,\"19\":2,\"20\":3,\"22\":2,\"23\":2,\"26\":1,\"31\":1,\"36\":1,\"41\":1,\"44\":1,\"47\":1,\"50\":1,\"54\":2,\"56\":2,\"57\":2,\"68\":2,\"69\":2,\"99\":1,\"108\":1,\"110\":1,\"119\":2,\"121\":2,\"131\":4,\"132\":1,\"139\":2,\"142\":3,\"143\":2,\"156\":1,\"157\":1,\"158\":1,\"159\":1,\"160\":2,\"166\":1,\"168\":7,\"170\":9,\"173\":1,\"175\":6,\"180\":1,\"183\":2,\"184\":2,\"185\":2,\"187\":4,\"191\":3,\"197\":2,\"203\":2,\"207\":1,\"230\":1,\"233\":4,\"235\":1,\"237\":1,\"247\":1,\"256\":28,\"259\":2,\"267\":4,\"270\":1,\"281\":2,\"288\":2,\"293\":5,\"309\":10,\"315\":1,\"317\":7,\"323\":3,\"328\":7,\"336\":1,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"349\":3,\"352\":1,\"353\":1,\"354\":1,\"361\":2,\"376\":1,\"383\":1,\"393\":1,\"395\":5,\"405\":1,\"406\":1,\"414\":8,\"415\":2,\"418\":2,\"419\":4,\"432\":2,\"435\":5,\"436\":1,\"438\":6}}],[\"standardcharsets\",{\"1\":{\"414\":2}}],[\"standard\",{\"1\":{\"90\":2}}],[\"staff\",{\"1\":{\"36\":7}}],[\"syntools\",{\"1\":{\"191\":1,\"203\":1}}],[\"sync类存在如下方法和作用如下\",{\"1\":{\"183\":1}}],[\"sync类\",{\"0\":{\"183\":1}}],[\"sync继承了abstractqueuedsynchronizer\",{\"1\":{\"180\":1}}],[\"sync\",{\"1\":{\"180\":2,\"181\":2,\"183\":1,\"184\":1,\"185\":1,\"195\":2,\"196\":2,\"197\":2,\"198\":1,\"199\":1}}],[\"sync队列中的结点在独占且忽略中断的模式下获取\",{\"1\":{\"173\":1}}],[\"synchronousqueue并不能算得上一个真正的队列\",{\"1\":{\"298\":1}}],[\"synchronousqueue\",{\"0\":{\"298\":1},\"1\":{\"162\":1,\"226\":1,\"266\":1,\"297\":1}}],[\"synchronized的优化一览表\",{\"0\":{\"153\":1}}],[\"synchronized的语义底层是通过一个monitor的对象来完成\",{\"1\":{\"147\":1}}],[\"synchronized是通过对象内部的一个叫做监视器锁\",{\"1\":{\"148\":1}}],[\"synchronized优化\",{\"0\":{\"148\":1}}],[\"synchronized标示符\",{\"1\":{\"147\":1}}],[\"synchronizedmethod\",{\"1\":{\"147\":1}}],[\"synchronizeddemo\",{\"1\":{\"147\":3}}],[\"synchronized原理\",{\"0\":{\"147\":1}}],[\"synchronizedexample\",{\"1\":{\"146\":1}}],[\"synchronized关键字并没有显示的为临界区执行加锁和解锁的步骤\",{\"1\":{\"147\":1}}],[\"synchronized关键字的作用\",{\"0\":{\"145\":1}}],[\"synchronized关键字详解\",{\"0\":{\"144\":1}}],[\"synchronized\",{\"1\":{\"19\":1,\"23\":1,\"121\":1,\"128\":2,\"132\":1,\"139\":4,\"142\":4,\"143\":2,\"145\":10,\"146\":11,\"147\":4,\"153\":6,\"158\":2,\"159\":2,\"160\":2,\"259\":2,\"261\":1}}],[\"synchro\",{\"1\":{\"147\":1}}],[\"synapse\",{\"1\":{\"124\":1}}],[\"sys\",{\"1\":{\"68\":3}}],[\"system\",{\"1\":{\"26\":3,\"31\":3,\"36\":6,\"41\":1,\"47\":1,\"50\":1,\"54\":3,\"56\":2,\"57\":2,\"98\":2,\"119\":1,\"131\":1,\"132\":1,\"142\":1,\"143\":1,\"147\":2,\"156\":2,\"157\":2,\"158\":2,\"159\":2,\"160\":2,\"186\":1,\"187\":6,\"191\":8,\"203\":4,\"230\":1,\"237\":1,\"241\":2,\"247\":2,\"267\":2,\"281\":1,\"288\":2,\"294\":1,\"306\":1,\"315\":1,\"317\":2,\"323\":9,\"331\":2,\"336\":3,\"339\":2,\"340\":4,\"341\":2,\"342\":4,\"349\":1,\"352\":10,\"353\":7,\"354\":9,\"360\":1,\"362\":1,\"383\":1,\"393\":3,\"395\":11,\"401\":1,\"405\":1,\"406\":8,\"414\":5,\"415\":2,\"418\":5,\"419\":5,\"424\":2,\"429\":3,\"432\":3,\"435\":3,\"436\":2,\"438\":9}}],[\"src\",{\"1\":{\"24\":1}}],[\"srp\",{\"1\":{\"14\":1,\"41\":1}}],[\"s\",{\"1\":{\"14\":1,\"31\":3,\"82\":1,\"147\":1,\"173\":8,\"183\":2,\"198\":3,\"259\":5,\"312\":3,\"317\":8,\"318\":3,\"329\":3,\"330\":4,\"331\":4,\"354\":2,\"360\":4,\"383\":2,\"435\":2}}],[\"原来的string对象不会被改变\",{\"1\":{\"421\":1}}],[\"原理是什么呢\",{\"1\":{\"288\":1}}],[\"原始数组不会被修改\",{\"1\":{\"223\":1,\"229\":1}}],[\"原始内容\",{\"1\":{\"31\":2}}],[\"原因如下\",{\"1\":{\"175\":1}}],[\"原子操作\",{\"1\":{\"175\":1}}],[\"原子地\",{\"1\":{\"163\":1}}],[\"原子性是指\",{\"1\":{\"126\":1}}],[\"原子性和有序性的问题常常让我们感到困惑\",{\"1\":{\"123\":1}}],[\"原子性和有序性的理解出现偏差\",{\"1\":{\"122\":1}}],[\"原子性和有序性问题\",{\"1\":{\"118\":1}}],[\"原子性\",{\"0\":{\"117\":1,\"118\":1,\"126\":1},\"1\":{\"120\":1}}],[\"原有的类不支持继承\",{\"1\":{\"30\":1}}],[\"原则\",{\"1\":{\"14\":2}}],[\"原型模式\",{\"1\":{\"10\":1}}],[\"面向过程更适合简单的任务和算法\",{\"1\":{\"422\":1}}],[\"面向过程和面向对象都有各自的优点和适用场景\",{\"1\":{\"422\":1}}],[\"面向过程的关注点主要在于解决问题的步骤和流程\",{\"1\":{\"422\":1}}],[\"面向过程是一种基于步骤和函数的编程方法\",{\"1\":{\"422\":1}}],[\"面向过程\",{\"1\":{\"422\":1}}],[\"面向对象\",{\"1\":{\"423\":1}}],[\"面向对象更适合复杂的应用\",{\"1\":{\"422\":1}}],[\"面向对象的关注点主要在于构建对象的结构和定义对象的行为\",{\"1\":{\"422\":1}}],[\"面向对象是一种基于对象和类的编程方法\",{\"1\":{\"422\":1}}],[\"面向对象还有以下的基本原则\",{\"1\":{\"14\":1}}],[\"面向对象有个solid原则\",{\"1\":{\"14\":1}}],[\"面孔\",{\"1\":{\"186\":1}}],[\"面试官不会考察每一种设计模式\",{\"1\":{\"13\":1}}],[\"面试过程中常问的设计模式\",{\"0\":{\"13\":1}}],[\"掌握好以上的几种设计模式\",{\"1\":{\"13\":1}}],[\"单端非阻塞队列\",{\"1\":{\"226\":1}}],[\"单端阻塞队列\",{\"1\":{\"226\":1}}],[\"单端\",{\"1\":{\"226\":1}}],[\"单端与双端\",{\"1\":{\"226\":1}}],[\"单一职责\",{\"1\":{\"27\":2}}],[\"单一职责原则\",{\"1\":{\"14\":1}}],[\"单例模式除了上面的写法\",{\"1\":{\"21\":1}}],[\"单例模式不需要对外提供构造方法\",{\"1\":{\"18\":1}}],[\"单例模式声明了一个名为\",{\"1\":{\"17\":1}}],[\"单例模式的实现\",{\"0\":{\"17\":1}}],[\"单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的\",{\"1\":{\"16\":1}}],[\"单例模式可以解决一个全局的使用的实例\",{\"1\":{\"16\":1}}],[\"单例模式在允许在全局中只存在一个实例\",{\"1\":{\"16\":1}}],[\"单例模式\",{\"0\":{\"15\":1},\"1\":{\"13\":1}}],[\"单列模式\",{\"1\":{\"10\":1}}],[\"一致性\",{\"1\":{\"430\":1,\"431\":1}}],[\"一旦赋值就不能被改变\",{\"1\":{\"435\":1}}],[\"一旦被赋值\",{\"1\":{\"435\":1}}],[\"一旦创建\",{\"1\":{\"423\":1}}],[\"一旦创建就不能被修改\",{\"1\":{\"421\":1}}],[\"一旦有就绪的事件\",{\"1\":{\"414\":1}}],[\"一旦线程处于就绪状态\",{\"1\":{\"157\":1}}],[\"一起使用\",{\"1\":{\"410\":1,\"411\":1}}],[\"一样可以踢出io\",{\"1\":{\"401\":1}}],[\"一次可能读多个字节\",{\"1\":{\"399\":1}}],[\"一些属性还有构造方法\",{\"1\":{\"313\":1}}],[\"一系列的标识\",{\"1\":{\"256\":1}}],[\"一条简单的语句可能会被编译成多条底层的cpu指令来执行\",{\"1\":{\"120\":1}}],[\"一条告警规则主要由以下几部分组成\",{\"1\":{\"108\":1}}],[\"一条成功发送的告警\",{\"1\":{\"107\":1}}],[\"一组已发送初始通知的告警接收到新告警后\",{\"1\":{\"107\":1}}],[\"一组告警第一次发送之前等待的时间\",{\"1\":{\"107\":1}}],[\"一种常用的方式来重写hashcode\",{\"1\":{\"431\":1}}],[\"一种先进先出\",{\"1\":{\"351\":1}}],[\"一种方法是使用资源分配策略\",{\"1\":{\"141\":1}}],[\"一种情况\",{\"1\":{\"132\":1}}],[\"一种是告警告警规则表达式\",{\"1\":{\"112\":1}}],[\"一种是使用springboot自带的spring\",{\"1\":{\"96\":1}}],[\"一种遍历访问聚合对象中各个元素的方法\",{\"1\":{\"12\":1}}],[\"一对多或者多对一\",{\"1\":{\"88\":1}}],[\"一对一\",{\"1\":{\"88\":1}}],[\"一共有53个\",{\"1\":{\"81\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"419\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"419\":3,\"420\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口范围内\",{\"1\":{\"14\":1}}],[\"一个大于1的自然数\",{\"1\":{\"395\":1}}],[\"一个long整数占64比特\",{\"1\":{\"392\":1}}],[\"一个固定的占位符对象\",{\"1\":{\"386\":1}}],[\"一个线程可以向队列提交任务\",{\"1\":{\"264\":1}}],[\"一个线程获取了写锁后\",{\"1\":{\"221\":1}}],[\"一个线程\",{\"1\":{\"136\":1}}],[\"一个线程内的每一个操作\",{\"1\":{\"136\":1}}],[\"一个线程修改了数据\",{\"1\":{\"127\":1}}],[\"一个好的命名规范可以一目了然的知道规则的含义\",{\"1\":{\"114\":1}}],[\"一个简单版的prometheus的架构图如下\",{\"1\":{\"101\":1}}],[\"一个时序数据包含了一个时间戳\",{\"1\":{\"61\":1}}],[\"一个组件可以有很多个装饰器\",{\"1\":{\"30\":1}}],[\"一般为32\",{\"1\":{\"347\":1}}],[\"一般用在可能会阻塞的任务\",{\"1\":{\"347\":1}}],[\"一般当workqueue满了才会用到这个参数\",{\"1\":{\"308\":1}}],[\"一般核心线程数是cpu的个数\",{\"1\":{\"295\":1}}],[\"一般核心线程数是cpu的个数+1\",{\"1\":{\"295\":1}}],[\"一般工程经验\",{\"1\":{\"295\":1}}],[\"一般设置为5分钟或更多\",{\"1\":{\"107\":1}}],[\"一般设置为0秒\",{\"1\":{\"107\":1}}],[\"一般counter类型的指标建议以\",{\"1\":{\"76\":1}}],[\"一般静态代理使用的比较少\",{\"1\":{\"53\":1}}],[\"一般情况下\",{\"1\":{\"30\":1,\"382\":1}}],[\"一般来讲\",{\"1\":{\"30\":1}}],[\"一般常见的考察的面试模式如下\",{\"1\":{\"13\":1}}],[\"某个线程修改了被volatile关键字修饰变量是\",{\"1\":{\"130\":1}}],[\"某个数据库出现网络故障\",{\"1\":{\"103\":1}}],[\"某个类在全局只有一个实例对象\",{\"1\":{\"10\":1}}],[\"某一个操作\",{\"1\":{\"12\":1}}],[\"责任链模式可以提供一种灵活\",{\"1\":{\"37\":1}}],[\"责任链模式将处理逻辑放在链式的逻辑单元中处理\",{\"1\":{\"37\":1}}],[\"责任链模式有两个角色\",{\"1\":{\"35\":1}}],[\"责任链模式的uml图\",{\"0\":{\"35\":1}}],[\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理\",{\"1\":{\"34\":1}}],[\"责任链模式在软件开发中\",{\"1\":{\"34\":1}}],[\"责任链模式\",{\"0\":{\"34\":1},\"1\":{\"12\":1,\"13\":1}}],[\"并按照顺序处理异常\",{\"1\":{\"432\":1}}],[\"并实现相关接口\",{\"1\":{\"419\":1}}],[\"并实现了抽象方法\",{\"1\":{\"419\":1}}],[\"并实现了事件的注册\",{\"1\":{\"414\":1}}],[\"并实现了handle\",{\"1\":{\"36\":3}}],[\"并重写了eat方法\",{\"1\":{\"418\":1}}],[\"并重新读取缓冲区中的数据\",{\"1\":{\"406\":1}}],[\"并接收服务器端的响应\",{\"1\":{\"415\":1}}],[\"并向其中放入要发送给客户端的数据\",{\"1\":{\"414\":1}}],[\"并向客户端发送\",{\"1\":{\"414\":1}}],[\"并向审批流的第一角色handle\",{\"1\":{\"36\":1}}],[\"并注册到\",{\"1\":{\"414\":1}}],[\"并注意其特点和潜在的问题\",{\"1\":{\"226\":1}}],[\"并创建一个\",{\"1\":{\"414\":1}}],[\"并根据实际对象的类型来调用\",{\"1\":{\"424\":1}}],[\"并根据实际对象的类型来执行对应的方法\",{\"1\":{\"424\":1}}],[\"并根据不同的事件类型进行处理\",{\"1\":{\"414\":1}}],[\"并根据事件类型进行监听\",{\"1\":{\"412\":1}}],[\"并指定感兴趣的事件\",{\"1\":{\"407\":1}}],[\"并再次使用\",{\"1\":{\"406\":1}}],[\"并不是在原始中有这样一个行号\",{\"1\":{\"401\":1}}],[\"并不需要改变原有的逻辑功能\",{\"1\":{\"37\":1}}],[\"并具有很好的性能特性\",{\"1\":{\"389\":1}}],[\"并具有相同的norm\",{\"1\":{\"301\":1}}],[\"并存储到新的\",{\"1\":{\"377\":1}}],[\"并增加链表的大小\",{\"1\":{\"368\":1}}],[\"并支持在迭代过程中通过迭代器的\",{\"1\":{\"364\":1}}],[\"并可根据需要创建新的工作线程\",{\"1\":{\"346\":1}}],[\"并可以动态添加观察者或者删除观察者\",{\"1\":{\"49\":1}}],[\"并轻松处理异常情况和组合多个异步任务的结果\",{\"1\":{\"343\":1}}],[\"并处理任务的结果\",{\"1\":{\"343\":1}}],[\"并处理阻塞队列中的任务\",{\"1\":{\"309\":1}}],[\"并行组合以及处理异步计算结果的方法\",{\"1\":{\"337\":1}}],[\"并行执行查询未对账订单\",{\"1\":{\"191\":1}}],[\"并获取结果\",{\"1\":{\"349\":1}}],[\"并获取任务的执行结果\",{\"1\":{\"323\":1}}],[\"并获取执行结果\",{\"1\":{\"323\":3}}],[\"并获取计算结果\",{\"1\":{\"323\":3,\"336\":1,\"339\":1,\"340\":1}}],[\"并阻塞等待运行结果\",{\"1\":{\"315\":1}}],[\"并执行与异常类型匹配的处理代码\",{\"1\":{\"432\":1}}],[\"并执行\",{\"1\":{\"314\":1}}],[\"并执行对账操作\",{\"1\":{\"191\":1}}],[\"并启动woker中的线程\",{\"1\":{\"310\":1}}],[\"并启动这两个线程\",{\"1\":{\"267\":1}}],[\"并尝试重新提交被拒绝的任务\",{\"1\":{\"302\":1}}],[\"并开始逐渐停止执行任务\",{\"1\":{\"293\":1}}],[\"并使用\",{\"1\":{\"349\":1,\"406\":2}}],[\"并使用可用的线程来执行任务\",{\"1\":{\"293\":1}}],[\"并使它们可以互换\",{\"1\":{\"12\":1}}],[\"并进行删除操作\",{\"1\":{\"370\":1}}],[\"并进行了一些初始化操作\",{\"1\":{\"293\":1}}],[\"并进行+1操作\",{\"1\":{\"281\":1}}],[\"并定义延迟或定期执行的方法\",{\"1\":{\"292\":1}}],[\"并定义了观察者接收到通知后的具体行为\",{\"1\":{\"49\":1}}],[\"并继承父线程中的inheritablethreadlocal的值\",{\"1\":{\"288\":1}}],[\"并一直存在于内存中\",{\"1\":{\"285\":1}}],[\"并返回接收结果给客户端\",{\"1\":{\"413\":1}}],[\"并返回旧的值\",{\"1\":{\"386\":1}}],[\"并返回一个布尔值\",{\"1\":{\"386\":1,\"387\":1,\"388\":1}}],[\"并返回计算结果\",{\"1\":{\"339\":1,\"340\":1}}],[\"并返回结果\",{\"1\":{\"331\":1}}],[\"并返回\",{\"1\":{\"276\":1}}],[\"并返回true\",{\"1\":{\"265\":3}}],[\"并唤醒等待notfull条件的线程\",{\"1\":{\"276\":1}}],[\"并唤醒等待notempty条件的线程\",{\"1\":{\"274\":1}}],[\"并以\",{\"1\":{\"271\":1}}],[\"并添加到给定的集合c中\",{\"1\":{\"265\":2}}],[\"并非一定会调用到\",{\"1\":{\"198\":1,\"199\":1}}],[\"并非所有就绪状态的线程都会立即获得cpu时间片\",{\"1\":{\"157\":1}}],[\"并设置为非阻塞模式\",{\"1\":{\"411\":1}}],[\"并设置结点的状态信息\",{\"1\":{\"214\":1}}],[\"并设置了状态数\",{\"1\":{\"196\":1}}],[\"并设置头结点为新生成的结点\",{\"1\":{\"173\":1,\"214\":1}}],[\"并发控制\",{\"1\":{\"343\":1}}],[\"并发容器的数量非常多\",{\"1\":{\"222\":1}}],[\"并发容器详解\",{\"0\":{\"222\":1}}],[\"并发包中的一个接口\",{\"1\":{\"264\":1}}],[\"并发包中的一个线程安全的集合类\",{\"1\":{\"228\":1}}],[\"并发包中提供的一个线程安全的哈希表实现\",{\"1\":{\"244\":1}}],[\"并发包中提供的一种同步工具\",{\"1\":{\"190\":1,\"202\":1}}],[\"并发包有三种常见的锁\",{\"1\":{\"218\":1}}],[\"并发包的锁\",{\"0\":{\"218\":1}}],[\"并发包里的锁总结\",{\"0\":{\"217\":1}}],[\"并发包里提供的countdownlatch\",{\"1\":{\"191\":1}}],[\"并发编程实战\",{\"1\":{\"137\":1}}],[\"并发编程中经常出现的令人难以理解的问题\",{\"1\":{\"122\":1}}],[\"并清除中断标记位\",{\"1\":{\"173\":1}}],[\"并通过\",{\"1\":{\"323\":1,\"340\":1,\"405\":2,\"406\":1}}],[\"并通过unsafe添加到waiters链表\",{\"1\":{\"317\":1}}],[\"并通过locksupport类unpark方法唤醒主线程\",{\"1\":{\"315\":1}}],[\"并通过内置的状态变量和原子操作来实现对共享资源的安全访问和控制\",{\"1\":{\"163\":1}}],[\"并通过案例进行了实战\",{\"1\":{\"95\":1}}],[\"并释放锁\",{\"1\":{\"143\":1,\"160\":1}}],[\"并充分考虑线程之间的依赖关系和顺序\",{\"1\":{\"140\":1}}],[\"并赋值给j\",{\"1\":{\"127\":1}}],[\"并有针对性地解决这些问题\",{\"1\":{\"122\":1}}],[\"并已bean的形式注册\",{\"1\":{\"98\":1}}],[\"并没有差别\",{\"1\":{\"75\":1}}],[\"并展示在监控大盘上\",{\"1\":{\"72\":1}}],[\"并将上界设置为容量\",{\"1\":{\"406\":1}}],[\"并将上界设置为当前位置\",{\"1\":{\"406\":1}}],[\"并将数据写入到文件中\",{\"1\":{\"405\":1}}],[\"并将数据的结果存储在新的时间序列中\",{\"1\":{\"113\":1}}],[\"并将其转换为底层操作系统可以执行的机器码\",{\"1\":{\"433\":1}}],[\"并将其设置为非阻塞模式\",{\"1\":{\"414\":1,\"415\":1}}],[\"并将其注册到\",{\"1\":{\"414\":1}}],[\"并将其赋值给i\",{\"1\":{\"423\":1}}],[\"并将其赋值给\",{\"1\":{\"385\":1}}],[\"并将其分派给空闲的线程执行\",{\"1\":{\"293\":1}}],[\"并将一个固定的对象作为\",{\"1\":{\"382\":1}}],[\"并将对应位置的第一个节点赋值给\",{\"1\":{\"378\":1}}],[\"并将对象头的标记设置为轻量级锁\",{\"1\":{\"151\":1}}],[\"并将键值对插入到对应索引位置\",{\"1\":{\"377\":1}}],[\"并将节点\",{\"1\":{\"370\":2}}],[\"并将最后一个位置上的元素清空\",{\"1\":{\"362\":1}}],[\"并将原有元素复制到新数组中\",{\"1\":{\"358\":1}}],[\"并将futuretask传入\",{\"1\":{\"323\":1}}],[\"并将\",{\"1\":{\"323\":2,\"336\":1,\"364\":1}}],[\"并将threadlocal对象作为key\",{\"1\":{\"285\":1}}],[\"并将修改后的元素添加到新数组中\",{\"1\":{\"223\":1,\"229\":1}}],[\"并将i的值递增\",{\"1\":{\"160\":1}}],[\"并将i的值赋值给j\",{\"1\":{\"127\":1}}],[\"并将计算结果保存在一组新的时间序列上\",{\"1\":{\"112\":1}}],[\"并将告警消息发送给alertmanager\",{\"1\":{\"64\":1}}],[\"并将指标存储在主机的磁盘中\",{\"1\":{\"64\":1}}],[\"并将实际对象的方法调用转发给它\",{\"1\":{\"53\":1}}],[\"并在接受到连接请求时创建对应的\",{\"1\":{\"411\":1}}],[\"并在将来的某个时间获取计算结果\",{\"1\":{\"322\":2}}],[\"并在条件满足时被唤醒\",{\"1\":{\"188\":1}}],[\"并在之后的加锁解锁操作中免去互斥操作\",{\"1\":{\"153\":1}}],[\"并在每个线程循环1000次对inc进行inc++操作\",{\"1\":{\"132\":1}}],[\"并在intercept方法中实现真实对象的功能增强\",{\"1\":{\"57\":1}}],[\"并在主题实现类的对象的operation\",{\"1\":{\"54\":1}}],[\"并在状态改变时通知观察者\",{\"1\":{\"49\":1}}],[\"并隐藏在代理后面可能其他类的实现\",{\"1\":{\"53\":1}}],[\"并且y\",{\"1\":{\"430\":1}}],[\"并且提供了更灵活的类组合方式\",{\"1\":{\"420\":1}}],[\"并且能够避免阻塞影响其他连接的特点成为了非常重要的优势\",{\"1\":{\"416\":1}}],[\"并且接收服务器端发送的反馈消息\",{\"1\":{\"415\":1}}],[\"并且无法更改\",{\"1\":{\"406\":1}}],[\"并且\",{\"1\":{\"376\":1}}],[\"并且元素小于default\",{\"1\":{\"361\":1}}],[\"并且工作队列也已满\",{\"1\":{\"303\":1}}],[\"并且工作队列已满\",{\"1\":{\"303\":1}}],[\"并且没有新的任务到达时\",{\"1\":{\"296\":1}}],[\"并且没有可执行任务时\",{\"1\":{\"294\":1}}],[\"并且有一段时间没有任务可执行时\",{\"1\":{\"296\":1}}],[\"并且对其他线程仍然是不可见的\",{\"1\":{\"288\":1}}],[\"并且对其他线程是不可见的\",{\"1\":{\"288\":1}}],[\"并且执行自己的操作\",{\"1\":{\"281\":1}}],[\"并且会中断正在执行的任务\",{\"1\":{\"293\":1}}],[\"并且会释放所有等待notfull条件的线程\",{\"1\":{\"277\":1}}],[\"并且会唤醒等待notfull条件的线程\",{\"1\":{\"275\":1}}],[\"并且会唤醒等待notempty条件的线程\",{\"1\":{\"273\":1}}],[\"并且当队列为空时\",{\"1\":{\"275\":1}}],[\"并且当队列已经满时\",{\"1\":{\"273\":1}}],[\"并且key也相等\",{\"1\":{\"261\":1}}],[\"并且结点的nexttable不为空\",{\"1\":{\"259\":1}}],[\"并且该桶不为空\",{\"1\":{\"259\":1}}],[\"并且该线程执行完毕后\",{\"1\":{\"157\":1}}],[\"并且保持较低的锁竞争\",{\"1\":{\"245\":1}}],[\"并且迭代器保证不会抛出\",{\"1\":{\"235\":1}}],[\"并且设置为非阻塞模式\",{\"1\":{\"414\":1}}],[\"并且设置了数组某一元素为e\",{\"1\":{\"239\":1}}],[\"并且设置了blocker\",{\"1\":{\"173\":1}}],[\"并且设置当前copyonwritearraylist的数组\",{\"1\":{\"234\":1}}],[\"并且它的key和value也不允许为null值\",{\"1\":{\"224\":1}}],[\"并且乐观读操作较为频繁的情况\",{\"1\":{\"218\":1}}],[\"并且等待时间小于0\",{\"1\":{\"213\":1}}],[\"并且等待时间大于0\",{\"1\":{\"213\":1}}],[\"并且等待线程数可以动态地改变\",{\"1\":{\"202\":1}}],[\"并且唤醒所有的线程\",{\"1\":{\"213\":1}}],[\"并且可以与选择器\",{\"1\":{\"410\":1}}],[\"并且可以通过索引进行访问和操作\",{\"1\":{\"352\":1}}],[\"并且可以获取计算结果\",{\"1\":{\"322\":1}}],[\"并且可以进行资源清理和释放\",{\"1\":{\"293\":1}}],[\"并且可以在高并发情况下提供更好的性能表现\",{\"1\":{\"244\":1}}],[\"并且可以指定在所有线程都进入屏障后的执行动作\",{\"1\":{\"210\":1}}],[\"并且可以根据需要快速的组合逻辑单元\",{\"1\":{\"37\":1}}],[\"并且可能会调用aqs的doreleaseshared函数\",{\"1\":{\"199\":1}}],[\"并且在方法返回之前被执行\",{\"1\":{\"438\":1}}],[\"并且在有数据可读或可写的通道上进行处理\",{\"1\":{\"412\":1}}],[\"并且在函数中会调用到countdownlatch的tryreleaseshared函数\",{\"1\":{\"199\":1}}],[\"并且在释放锁之前\",{\"1\":{\"145\":1}}],[\"并且构造函数内完成了sync的初始化\",{\"1\":{\"196\":1}}],[\"并且还存在newcondition方法\",{\"1\":{\"179\":1}}],[\"并且此线程修改成功了\",{\"1\":{\"175\":1}}],[\"并且本线程也获得机会运行\",{\"1\":{\"173\":1}}],[\"并且pred结点所封装的线程不为空\",{\"1\":{\"173\":1}}],[\"并且pred结点的状态为signal\",{\"1\":{\"173\":1}}],[\"并且比较并设置等待状态为signal成功\",{\"1\":{\"173\":1}}],[\"并且每个节点都存在一个状态\",{\"1\":{\"168\":1}}],[\"并且实现了serializable接口\",{\"1\":{\"166\":1}}],[\"并且不会释放这些资源直到线程完成任务\",{\"1\":{\"141\":1}}],[\"并且是求百分数\",{\"1\":{\"115\":1}}],[\"并且体现出更好的灵敏度\",{\"1\":{\"92\":1}}],[\"并且于2015年对外发布早期版本\",{\"1\":{\"61\":1}}],[\"并且发布者发布消息也是无顺序的\",{\"1\":{\"51\":1}}],[\"并能自由组合包装各种装饰器\",{\"1\":{\"32\":1}}],[\"并持有主题实现类的对象\",{\"1\":{\"54\":1}}],[\"并持有readerwriter的实现类filereaderwriter\",{\"1\":{\"31\":2}}],[\"并持有装饰器componentdecoratorb\",{\"1\":{\"30\":1}}],[\"并持有组件实现类componentimpl\",{\"1\":{\"30\":1}}],[\"并提供了良好的可读性和可维护性\",{\"1\":{\"432\":1}}],[\"并提供了一系列方法来管理数据的读写\",{\"1\":{\"406\":1}}],[\"并提供了一行一行写入字符的方法\",{\"1\":{\"401\":1}}],[\"并提供了一种有效的方式来进行线程间的数据交换\",{\"1\":{\"264\":1}}],[\"并提供了高效的缓冲流和便捷的文件操作\",{\"1\":{\"398\":1}}],[\"并提供了额外的方法来管理异步计算的完成和组合\",{\"1\":{\"337\":1}}],[\"并提供了互斥性\",{\"1\":{\"145\":1}}],[\"并提供了针对这些问题的技术方案\",{\"1\":{\"123\":1}}],[\"并提供解决方法\",{\"1\":{\"141\":1}}],[\"并提供解释器来处理句子中的语法\",{\"1\":{\"12\":1}}],[\"并提供一个方法\",{\"1\":{\"16\":1}}],[\"所管理的所有就绪的\",{\"1\":{\"407\":1}}],[\"所\",{\"1\":{\"357\":1}}],[\"所用到开源组件如下\",{\"1\":{\"59\":1}}],[\"所有位均参与计算\",{\"1\":{\"429\":1}}],[\"所有元素都会被映射到\",{\"1\":{\"382\":1}}],[\"所有任务完成\",{\"1\":{\"342\":1}}],[\"所有任务已经完成\",{\"1\":{\"293\":1}}],[\"所有值大于completing的状态都表示任务已经执行完成\",{\"1\":{\"328\":1}}],[\"所有的任务都已经终止\",{\"1\":{\"309\":1}}],[\"所有的线程都已经关闭\",{\"1\":{\"293\":1}}],[\"所有的线程中的操作\",{\"1\":{\"136\":1}}],[\"所有的读操作都是基于原始的\",{\"1\":{\"223\":1}}],[\"所有的元素都存储在这个数组中\",{\"1\":{\"223\":1,\"229\":1}}],[\"所有的写操作会被阻塞\",{\"1\":{\"221\":1}}],[\"所有线程已经关闭\",{\"1\":{\"293\":1}}],[\"所有线程又可以重新进入到屏障中\",{\"1\":{\"214\":1}}],[\"所有线程都已经进入\",{\"1\":{\"213\":1}}],[\"所有线程会相互等待\",{\"1\":{\"202\":1}}],[\"所有线程会被释放\",{\"1\":{\"202\":1}}],[\"所有依赖于它的对象都会收到通知\",{\"1\":{\"48\":1}}],[\"所有这些都不会违反封装\",{\"1\":{\"12\":1}}],[\"所以char类型取值范围为0~2^16\",{\"1\":{\"429\":1}}],[\"所以需要使用包装类来为这些基本类型提供一个相应的对象类型\",{\"1\":{\"423\":1}}],[\"所以如果想要在泛型中使用一个基本类型的值\",{\"1\":{\"423\":1}}],[\"所以如果worker在执行任务的时候\",{\"1\":{\"319\":1}}],[\"所以不会因为某个连接的阻塞而影响其他连接的读写事件的处理\",{\"1\":{\"416\":1}}],[\"所以不是原子性操作\",{\"1\":{\"126\":1}}],[\"所以在定义接口方法时不需要添加关键字\",{\"1\":{\"419\":1}}],[\"所以在构造的时候需要传入字节流对象进来\",{\"1\":{\"401\":1}}],[\"所以在接下来的文章会从源码和java\",{\"1\":{\"355\":1}}],[\"所以hashset具有了abstractset和set的功能\",{\"1\":{\"381\":1}}],[\"所以hashmap具有了abstractmap和map的功能\",{\"1\":{\"373\":1}}],[\"所以默认的初始化大小为10\",{\"1\":{\"359\":1}}],[\"所以随机访问元素的时间复杂度为\",{\"1\":{\"358\":1}}],[\"所以arraylist具有了abstractlist和list的功能\",{\"1\":{\"357\":1}}],[\"所以arraylist\",{\"1\":{\"357\":1}}],[\"所以这个变量所指向的内存区域就不会变\",{\"1\":{\"436\":1}}],[\"所以这个resolve\",{\"1\":{\"107\":1}}],[\"所以这时候会新建一个节点q\",{\"1\":{\"331\":1}}],[\"所以futuretask既能当做一个runnable直接被thread执行\",{\"1\":{\"322\":1,\"327\":1}}],[\"所以submit方法也是threadpoolexecutor`的方法\",{\"1\":{\"316\":1}}],[\"所以一个线程可以存储多个threadlocal对象\",{\"1\":{\"282\":1}}],[\"所以可以并发进行\",{\"1\":{\"229\":1}}],[\"所以可以通过标签进行对指标的筛选\",{\"1\":{\"80\":1}}],[\"所以读操作可以完全不加锁\",{\"1\":{\"223\":1}}],[\"所以其数据结构可以参考aqs的数据结构\",{\"1\":{\"193\":1}}],[\"所以线程池就能解决这个问题\",{\"1\":{\"191\":1}}],[\"所以reentrantlock数据结构依附于abstractqueuedsynchronizer的数据结构\",{\"1\":{\"178\":1}}],[\"所以\",{\"1\":{\"174\":1,\"197\":1,\"198\":1,\"199\":1,\"205\":1,\"208\":1,\"287\":1,\"386\":1,\"387\":1,\"388\":1,\"431\":1}}],[\"所以此时\",{\"1\":{\"173\":1}}],[\"所以volatile不能保证原子性\",{\"1\":{\"132\":1}}],[\"所以能够输出\",{\"1\":{\"85\":1}}],[\"所以下载的是mac版本的\",{\"1\":{\"71\":1}}],[\"所以只能实现接口的方式进行代理\",{\"1\":{\"56\":1}}],[\"所以我们在实际的使用过程中\",{\"1\":{\"37\":1}}],[\"所以它们之间的\",{\"1\":{\"429\":1}}],[\"所以它天然的保证了\",{\"1\":{\"382\":1}}],[\"所以它的level可以命名为instance\",{\"1\":{\"115\":1}}],[\"所以它属于线程安全的懒汉模式\",{\"1\":{\"20\":1}}],[\"所以它是线程安全的\",{\"1\":{\"18\":1}}],[\"所以jvm是允许的\",{\"1\":{\"19\":1,\"121\":1}}],[\"所以还是比较推荐的\",{\"1\":{\"18\":1}}],[\"所以设计模式是程序员的一项基本功\",{\"1\":{\"8\":1}}],[\"备忘录模式\",{\"1\":{\"12\":1}}],[\"而重写方法必须具有相同的返回类型\",{\"1\":{\"418\":1}}],[\"而重写方法在运行时动态地绑定\",{\"1\":{\"418\":1}}],[\"而字符流只能处理字符类型的数据\",{\"1\":{\"399\":1}}],[\"而有了对字符进行高效操作的流对象\",{\"1\":{\"399\":1}}],[\"而值则被忽略\",{\"1\":{\"387\":1,\"388\":1}}],[\"而应该使用迭代器的\",{\"1\":{\"364\":1}}],[\"而对插入和删除操作效率要求不高的场景\",{\"1\":{\"358\":1}}],[\"而对于io密集型的任务\",{\"1\":{\"295\":1}}],[\"而对于concurrenthashmap而言\",{\"1\":{\"256\":1}}],[\"而非主线程\",{\"1\":{\"318\":1}}],[\"而非整个方法\",{\"1\":{\"146\":1}}],[\"而threadpoolexecutor\",{\"1\":{\"316\":1}}],[\"而t2线程获取了a2对象的锁\",{\"1\":{\"139\":1}}],[\"而t2线程调用a2\",{\"1\":{\"139\":1}}],[\"而char是无符号类型的\",{\"1\":{\"429\":1}}],[\"而ctl\",{\"1\":{\"311\":1}}],[\"而cachedthreadpool正式采用这种形式\",{\"1\":{\"298\":1}}],[\"而condition对象又是基于aqs的\",{\"1\":{\"208\":1}}],[\"而过小的核心线程数量可能无法满足任务执行的需求\",{\"1\":{\"295\":1}}],[\"而线程池可以通过合理的配置\",{\"1\":{\"291\":1}}],[\"而线程池中的线程可以被重复利用\",{\"1\":{\"291\":1}}],[\"而线程t2持有a2对象的锁\",{\"1\":{\"139\":1}}],[\"而且同一个接口可以被多个类实现\",{\"1\":{\"419\":1}}],[\"而且会中断正在运行的任务\",{\"1\":{\"309\":1}}],[\"而且还需要通过压测或者开发经验去大概评估参数的设置\",{\"1\":{\"294\":1}}],[\"而且threadlocalmap的entry对象是使用threadlocal的弱引用作为key创建的\",{\"1\":{\"285\":1}}],[\"而且不需要修改现有的代码\",{\"1\":{\"37\":1}}],[\"而value值则是我们要存的值\",{\"1\":{\"282\":1}}],[\"而另一个线程则可以从队列中获取任务并执行\",{\"1\":{\"264\":1}}],[\"而写操作则是通过创建并复制底层数组的方式实现的\",{\"1\":{\"228\":1}}],[\"而在写操作时对数组进行复制\",{\"1\":{\"223\":1}}],[\"而在样本数据采集的时候\",{\"1\":{\"75\":1}}],[\"而\",{\"1\":{\"221\":1,\"348\":1,\"385\":1,\"429\":1}}],[\"而abstractlist内部已经实现了获取iterator和listiterator的方法\",{\"1\":{\"357\":1}}],[\"而abstractownablesynchronizer抽象类的源码如下\",{\"1\":{\"166\":1}}],[\"而aqs的数据结构核心就是两个虚拟队列\",{\"1\":{\"193\":1}}],[\"而创建线程可是个耗时的操作\",{\"1\":{\"191\":1}}],[\"而并不会按照公平等待的原则进行等待\",{\"1\":{\"184\":1}}],[\"而sync有两个子类类分别为fairsync和nonfairsync\",{\"1\":{\"180\":1}}],[\"而子线程的由于没有获取锁\",{\"1\":{\"158\":1}}],[\"而子类也能够在基类的基础上增加新的行为\",{\"1\":{\"14\":1}}],[\"而同步块可以控制同步范围更加细致\",{\"1\":{\"153\":1}}],[\"而是由java运行时环境\",{\"1\":{\"432\":1}}],[\"而是与其关联的对象在内存中的地址\",{\"1\":{\"429\":1}}],[\"而是通过threadpoolexecutor的方式\",{\"1\":{\"304\":1}}],[\"而是直接通过创建线程的方式执行\",{\"1\":{\"291\":1}}],[\"而是采用了一种全新的数据结构和算法\",{\"1\":{\"246\":1}}],[\"而是采用灵活的单一结构\",{\"1\":{\"52\":1}}],[\"而是转而采用基于cas\",{\"1\":{\"246\":1}}],[\"而是保持不变\",{\"1\":{\"223\":1,\"229\":1}}],[\"而是判断该锁对象是否被其他线程持有\",{\"1\":{\"151\":1}}],[\"而每个线程的threadlocalmap对象则是随着线程的销毁而销毁\",{\"1\":{\"285\":1}}],[\"而每个线程\",{\"1\":{\"124\":1}}],[\"而使用prometheus的java客户端是可以做到分位耗时的\",{\"1\":{\"97\":1}}],[\"而标签组是监控样本的多个维度特征的反应\",{\"1\":{\"80\":1}}],[\"而histogram则会消耗更多服务端的的资源\",{\"1\":{\"79\":1}}],[\"而histogram是通过histogram\",{\"1\":{\"79\":1}}],[\"而个别情况可能导致请求耗时超过了5s\",{\"1\":{\"78\":1}}],[\"而无需移动其他元素\",{\"1\":{\"371\":1}}],[\"而无需在每次访问时都获取全局锁\",{\"1\":{\"222\":1}}],[\"而无需进行互斥同步\",{\"1\":{\"151\":1}}],[\"而无需修改原有的代码\",{\"1\":{\"56\":1}}],[\"而无需指定具体实现类\",{\"1\":{\"10\":1,\"45\":1}}],[\"而java是不允许多继承的\",{\"1\":{\"56\":1}}],[\"而动态代理在各种框架\",{\"1\":{\"53\":1}}],[\"而不会创建新的对象\",{\"1\":{\"421\":1}}],[\"而不会互相干扰\",{\"1\":{\"281\":1}}],[\"而不会先尝试获取资源\",{\"1\":{\"185\":1}}],[\"而不需要在每个方法中显式传递这些信息\",{\"1\":{\"283\":1}}],[\"而不需要在每个方法中传递这些信息\",{\"1\":{\"283\":1}}],[\"而不需要使用传统的锁机制\",{\"1\":{\"246\":1}}],[\"而不需要互斥性\",{\"1\":{\"153\":1}}],[\"而不需要了解具体的实现类\",{\"1\":{\"44\":1}}],[\"而不是立即阻塞和切换线程\",{\"1\":{\"153\":1}}],[\"而不是进行线程阻塞\",{\"1\":{\"151\":1}}],[\"而不是读取自己的高速缓存中的\",{\"1\":{\"130\":1}}],[\"而不是高级语言中的操作符\",{\"1\":{\"120\":1}}],[\"而不是使用summary\",{\"1\":{\"79\":1}}],[\"而不是通过实现接口\",{\"1\":{\"57\":1}}],[\"而不是直接交互\",{\"1\":{\"12\":1}}],[\"而设计模式是基于对象实例的\",{\"1\":{\"14\":1}}],[\"中读取数据\",{\"1\":{\"414\":1}}],[\"中非常重要的组件\",{\"1\":{\"412\":1}}],[\"中写入数据\",{\"1\":{\"401\":1}}],[\"中找到对应的键值对并删除\",{\"1\":{\"388\":1}}],[\"中指定键\",{\"1\":{\"388\":1}}],[\"中包含指定的元素\",{\"1\":{\"387\":1}}],[\"中存在指定的键\",{\"1\":{\"387\":1}}],[\"中是否存在该键\",{\"1\":{\"387\":1}}],[\"中是否包含指定的键\",{\"1\":{\"387\":1}}],[\"中是否包含指定的元素\",{\"1\":{\"387\":1}}],[\"中是否包含某个键\",{\"1\":{\"354\":1}}],[\"中已经存在相同的键\",{\"1\":{\"386\":1}}],[\"中之前不存在相同的键\",{\"1\":{\"386\":1}}],[\"中元素的唯一性\",{\"1\":{\"382\":1}}],[\"中常用的哈希表实现\",{\"1\":{\"379\":1}}],[\"中有个死循环\",{\"1\":{\"331\":1}}],[\"中返回的结果或抛出的异常\",{\"1\":{\"328\":1}}],[\"中用于\",{\"1\":{\"410\":1,\"411\":1}}],[\"中用于等待\",{\"1\":{\"347\":1}}],[\"中用于表示异步计算结果的类\",{\"1\":{\"322\":2}}],[\"中用于实现线程互斥和同步的关键字\",{\"1\":{\"145\":1}}],[\"中等待执行\",{\"1\":{\"297\":1,\"303\":1}}],[\"中查找\",{\"1\":{\"260\":1}}],[\"中断任务执行线程\",{\"1\":{\"332\":2}}],[\"中断任务执行线程之后状态会从interrupting转换到interrupted\",{\"1\":{\"328\":1}}],[\"中断所有的worker\",{\"1\":{\"319\":1}}],[\"中断机制等\",{\"1\":{\"291\":1}}],[\"中断会抛出异常\",{\"1\":{\"275\":1}}],[\"中断当前线程\",{\"1\":{\"213\":1}}],[\"中断标志\",{\"1\":{\"173\":1}}],[\"中断此线程是无效的\",{\"1\":{\"173\":1}}],[\"中的对象\",{\"1\":{\"428\":1}}],[\"中的多态\",{\"1\":{\"424\":1}}],[\"中的一个关键组件\",{\"1\":{\"406\":1}}],[\"中的一种可重入锁\",{\"1\":{\"188\":1}}],[\"中的字节流是极其对称的\",{\"1\":{\"401\":1}}],[\"中的不同键上\",{\"1\":{\"382\":1}}],[\"中的键值对数量超过了负载因子乘以\",{\"1\":{\"376\":1}}],[\"中的键值对\",{\"1\":{\"354\":1}}],[\"中的键值对没有固定的顺序\",{\"1\":{\"354\":1}}],[\"中的键是唯一的\",{\"1\":{\"354\":1}}],[\"中的元素是唯一的\",{\"1\":{\"353\":1}}],[\"中的元素没有固定的顺序\",{\"1\":{\"353\":2}}],[\"中的元素按照插入的顺序进行存储\",{\"1\":{\"352\":1}}],[\"中的任务提供扩展管理并行数的接口\",{\"1\":{\"347\":1}}],[\"中的实现使得\",{\"1\":{\"153\":1}}],[\"中的创建对象的方法\",{\"1\":{\"47\":1}}],[\"中对象布局分为三块区域\",{\"1\":{\"149\":1}}],[\"中\",{\"1\":{\"138\":1,\"354\":1,\"370\":1,\"382\":2,\"385\":1,\"386\":2,\"403\":1,\"404\":1,\"424\":1}}],[\"中央处理器\",{\"1\":{\"118\":1}}],[\"中间件有着广泛的应用\",{\"1\":{\"53\":1}}],[\"中介者对象封装了一组对象之间的交互\",{\"1\":{\"12\":1}}],[\"中介者模式\",{\"1\":{\"12\":1}}],[\"中设置\",{\"1\":{\"1\":1,\"2\":1}}],[\"定义的\",{\"1\":{\"419\":1}}],[\"定义的类\",{\"1\":{\"419\":1}}],[\"定义recoding\",{\"0\":{\"113\":1}}],[\"定义了常量\",{\"1\":{\"419\":1}}],[\"定义了makesofa\",{\"1\":{\"47\":1}}],[\"定义了一个divide方法\",{\"1\":{\"432\":1}}],[\"定义了一个静态整型变量a\",{\"1\":{\"119\":1}}],[\"定义了一个接收发布者消息的方法\",{\"1\":{\"49\":1}}],[\"定义了一个工厂方法makesofa\",{\"1\":{\"43\":1}}],[\"定义了一系列可以创建不同产品对象的方法\",{\"1\":{\"46\":1}}],[\"定义了产品类的属性和方法\",{\"1\":{\"40\":1,\"43\":1,\"46\":1}}],[\"定义文件的写入或者读取的路径\",{\"1\":{\"31\":1}}],[\"定义一个线程安全\",{\"1\":{\"175\":1}}],[\"定义一个抽象主题类\",{\"1\":{\"54\":1}}],[\"定义一个抽象产品类\",{\"1\":{\"41\":1}}],[\"定义一个接口ifactory\",{\"1\":{\"44\":1}}],[\"定义一个写入的字符串text\",{\"1\":{\"31\":1}}],[\"定义一个目标接口readerwriter\",{\"1\":{\"31\":1}}],[\"定义一系列算法\",{\"1\":{\"12\":1}}],[\"定义目标的方法\",{\"1\":{\"30\":1}}],[\"定义对象之间的一对多依赖关系\",{\"1\":{\"12\":1}}],[\"不包含开发工具\",{\"1\":{\"433\":1}}],[\"不包含方法的实现\",{\"1\":{\"419\":1}}],[\"不参与计算\",{\"1\":{\"429\":1}}],[\"不断轮询\",{\"1\":{\"414\":1}}],[\"不满意就放入缓冲区\",{\"1\":{\"401\":1}}],[\"不为\",{\"1\":{\"368\":1}}],[\"不为0则返回\",{\"1\":{\"198\":1}}],[\"不建议直接使用\",{\"1\":{\"364\":1}}],[\"不建议使用\",{\"1\":{\"297\":1}}],[\"不重复性\",{\"1\":{\"353\":1}}],[\"不管是任务执行异常还是任务正常执行完毕\",{\"1\":{\"333\":1}}],[\"不接受新任务\",{\"1\":{\"293\":1}}],[\"不需要初始化容量长度等\",{\"1\":{\"367\":1}}],[\"不需要等待线程的创建\",{\"1\":{\"291\":1}}],[\"不需要修改已有的代码\",{\"1\":{\"51\":1}}],[\"不允许存在重复的键\",{\"1\":{\"382\":1}}],[\"不允许重复\",{\"1\":{\"354\":1}}],[\"不允许重复元素\",{\"1\":{\"351\":1}}],[\"不允许在应用自行显式创建线程\",{\"1\":{\"291\":1}}],[\"不允许等待\",{\"1\":{\"141\":1}}],[\"不相等\",{\"1\":{\"239\":1}}],[\"不添加\",{\"1\":{\"239\":1}}],[\"不受支持\",{\"1\":{\"235\":1}}],[\"不持有队列的阻塞队列\",{\"1\":{\"226\":1}}],[\"不可为null\",{\"1\":{\"224\":7}}],[\"不可重入锁\",{\"1\":{\"221\":1}}],[\"不可抢占\",{\"1\":{\"140\":1}}],[\"不阻塞其他读写操作\",{\"1\":{\"218\":1}}],[\"不适合处理写操作频繁的场景\",{\"1\":{\"218\":1}}],[\"不支持\",{\"1\":{\"265\":2}}],[\"不支持add操作\",{\"1\":{\"235\":1}}],[\"不支持set操作\",{\"1\":{\"235\":1}}],[\"不支持remove操作\",{\"1\":{\"235\":1}}],[\"不支持读写锁的共享特性\",{\"1\":{\"218\":1}}],[\"不支持自身方法调用\",{\"1\":{\"57\":1}}],[\"不被当前线程独占\",{\"1\":{\"214\":1}}],[\"不等于当前代\",{\"1\":{\"213\":1}}],[\"不等于当前带后者是屏障被损坏\",{\"1\":{\"213\":1}}],[\"不同于arraylist可以存储重复元素\",{\"1\":{\"381\":1}}],[\"不同之处在于\",{\"1\":{\"288\":1}}],[\"不同\",{\"1\":{\"202\":2}}],[\"不同的重载方法可以返回不同的结果\",{\"1\":{\"418\":1}}],[\"不同的是\",{\"1\":{\"416\":1}}],[\"不同的条件会有不同的条件队列\",{\"1\":{\"193\":1}}],[\"不同的自定义同步器争用共享资源的方式也不同\",{\"1\":{\"164\":1}}],[\"不同的产品由不同的工厂创建\",{\"1\":{\"44\":1}}],[\"不同的逻辑单元的处理逻辑不耦合\",{\"1\":{\"37\":1}}],[\"不同的装饰器有不同的功能\",{\"1\":{\"30\":1}}],[\"不同的角色做不同的事\",{\"1\":{\"27\":1}}],[\"不成功就继续\",{\"1\":{\"198\":1,\"199\":1}}],[\"不过需要注意的是\",{\"1\":{\"191\":1}}],[\"不过相对于普通方法\",{\"1\":{\"147\":1}}],[\"不用继续等待了\",{\"1\":{\"186\":1}}],[\"不存在多线程间共享的问题\",{\"1\":{\"280\":1}}],[\"不存在下一项\",{\"1\":{\"235\":1}}],[\"不存在已经等待更久的线程并且比较并且设置状态成功\",{\"1\":{\"185\":1}}],[\"不存在第三种情况\",{\"1\":{\"126\":1}}],[\"不再接受新的任务\",{\"1\":{\"293\":1}}],[\"不再累赘\",{\"1\":{\"174\":2}}],[\"不再是这个monitor的所有者\",{\"1\":{\"147\":1}}],[\"不进行交换操作\",{\"1\":{\"259\":1}}],[\"不进行park操作\",{\"1\":{\"173\":1}}],[\"不进行分析\",{\"1\":{\"173\":1}}],[\"不能有子类继承它\",{\"1\":{\"435\":1}}],[\"不能有构造方法\",{\"1\":{\"419\":1}}],[\"不能表示空值或null\",{\"1\":{\"423\":1}}],[\"不能实例化对象\",{\"1\":{\"419\":1}}],[\"不能被修改\",{\"1\":{\"437\":1}}],[\"不能被实现类调用\",{\"1\":{\"419\":1}}],[\"不能被其他自然数整除\",{\"1\":{\"395\":1}}],[\"不能被取消\",{\"1\":{\"332\":1}}],[\"不能在多个线程中操作同一个hashmap\",{\"1\":{\"379\":1}}],[\"不能存储任务\",{\"1\":{\"298\":1}}],[\"不能进行park操作\",{\"1\":{\"173\":1}}],[\"不能东一榔头西一棒槌\",{\"1\":{\"8\":1}}],[\"不响应中断\",{\"1\":{\"169\":1}}],[\"不仅需要对线程池的核心参数需要了解清楚\",{\"1\":{\"294\":1}}],[\"不仅提供了互斥性\",{\"1\":{\"145\":1}}],[\"不仅可以监控系统的一些状态\",{\"1\":{\"62\":1}}],[\"不会包含重复的元素\",{\"1\":{\"353\":1}}],[\"不会阻塞当前线程\",{\"1\":{\"322\":1}}],[\"不会阻塞读取操作\",{\"1\":{\"229\":1}}],[\"不会占用cpu资源\",{\"1\":{\"310\":1,\"313\":1}}],[\"不会有任何异常抛出\",{\"1\":{\"302\":1}}],[\"不会创建超过corepoolsize个线程\",{\"1\":{\"299\":1}}],[\"不会被回收\",{\"1\":{\"285\":1}}],[\"不会抛出异常\",{\"1\":{\"276\":1}}],[\"不会消耗cpu\",{\"1\":{\"152\":1}}],[\"不会立即阻塞\",{\"1\":{\"151\":1}}],[\"不会出现数据不一致的情况\",{\"1\":{\"146\":1}}],[\"不会发生变化的\",{\"1\":{\"143\":1}}],[\"不会输出结果\",{\"1\":{\"85\":1,\"86\":1,\"87\":1}}],[\"不释放共享资源\",{\"1\":{\"140\":1}}],[\"不推荐使用了\",{\"1\":{\"437\":1}}],[\"不推荐\",{\"0\":{\"22\":1,\"23\":1},\"1\":{\"175\":3}}],[\"不提供全局的共享变量\",{\"1\":{\"16\":1}}],[\"不要对实现进行编程\",{\"1\":{\"14\":1}}],[\"不要依赖于具体实现\",{\"1\":{\"14\":1}}],[\"不暴露该对象的内部结构\",{\"1\":{\"12\":1}}],[\"使开发者能够更好地利用系统资源\",{\"1\":{\"403\":1}}],[\"使其进入就绪状态\",{\"1\":{\"163\":1}}],[\"使其成为高效的线程同步机制之一\",{\"1\":{\"153\":1}}],[\"使线程处于等待状态\",{\"1\":{\"159\":1}}],[\"使得一个类可以具备多种类型的行为\",{\"1\":{\"419\":1}}],[\"使得异步操作和结果处理变得更加灵活和高效\",{\"1\":{\"337\":1}}],[\"使得线程能够互相等待\",{\"1\":{\"202\":1}}],[\"使得线程能够在特定的条件下等待\",{\"1\":{\"188\":1}}],[\"使得同步代码块或方法在持有锁的情况下可以被多次进入\",{\"1\":{\"188\":1}}],[\"使得cpu能够直接从高速缓存中读取数据\",{\"1\":{\"124\":1}}],[\"使得发布者和观察者互不影响\",{\"1\":{\"51\":1}}],[\"使得可以用不同的请求来进行参数化\",{\"1\":{\"12\":1}}],[\"使系统能够更好地应对变化和复杂性\",{\"1\":{\"37\":1}}],[\"使用jdk可以进行java应用程序的开发和构建\",{\"1\":{\"433\":1}}],[\"使用join函数\",{\"1\":{\"191\":1}}],[\"使用包装类可以让基本类型像一个对象一样使用\",{\"1\":{\"423\":1}}],[\"使用包装类可以使得变量可以被赋值为null\",{\"1\":{\"423\":1}}],[\"使用接口可以避免命名冲突和菱形继承问题\",{\"1\":{\"420\":1}}],[\"使用多路复用器\",{\"1\":{\"416\":1}}],[\"使用多个节点去采集相通的监控对象可以做到高可用\",{\"1\":{\"65\":1}}],[\"使用代码示例如下\",{\"1\":{\"383\":1}}],[\"使用迭代器\",{\"1\":{\"352\":1}}],[\"使用递归的方式将一个大任务拆分成多个小任务\",{\"1\":{\"345\":1}}],[\"使用get\",{\"1\":{\"341\":1,\"342\":1}}],[\"使用group\",{\"1\":{\"89\":1}}],[\"使用throws关键字\",{\"1\":{\"432\":1}}],[\"使用throw语句\",{\"1\":{\"432\":1}}],[\"使用threadlocal可以在每个线程中保存事务状态\",{\"1\":{\"283\":1}}],[\"使用threadlocal可以确保每个线程都有自己的数据库连接\",{\"1\":{\"283\":1}}],[\"使用threadlocal可以实现每个线程拥有自己的对象实例\",{\"1\":{\"283\":1}}],[\"使用threadlocal\",{\"1\":{\"280\":1}}],[\"使用treiber栈保存等待线程\",{\"1\":{\"328\":1}}],[\"使用小队列大池\",{\"1\":{\"300\":1}}],[\"使用大队列和小池\",{\"1\":{\"300\":1}}],[\"使用arrayblockingqueue可以根据应用场景\",{\"1\":{\"300\":1}}],[\"使用无容量限制的\",{\"1\":{\"297\":1}}],[\"使用线程池的主要目的是为了更高效地管理和利用线程资源\",{\"1\":{\"291\":1}}],[\"使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销\",{\"1\":{\"291\":1}}],[\"使用weakreference修饰的对象被称为弱引用\",{\"1\":{\"286\":1}}],[\"使用场景\",{\"0\":{\"394\":1},\"1\":{\"229\":1,\"421\":1}}],[\"使用队列时要注意队列是否支持有界\",{\"1\":{\"226\":1}}],[\"使用链表实现的双端非阻塞队列\",{\"1\":{\"226\":1}}],[\"使用链表实现的双端阻塞队列\",{\"1\":{\"226\":1}}],[\"使用链表实现的非阻塞队列\",{\"1\":{\"226\":1}}],[\"使用链表实现的有界或无界阻塞队列\",{\"1\":{\"226\":1}}],[\"使用数组实现的有界阻塞队列\",{\"1\":{\"226\":1}}],[\"使用softreference修饰的对象被称为软引用\",{\"1\":{\"286\":1}}],[\"使用stampedlock实现一个并发安全的缓存\",{\"1\":{\"221\":1}}],[\"使用stampedlock可以在读多写少的情况下提供更好的性能\",{\"1\":{\"221\":1}}],[\"使用spring\",{\"0\":{\"97\":1}}],[\"使用读锁和写锁分离\",{\"1\":{\"218\":1}}],[\"使用读写锁\",{\"1\":{\"153\":1}}],[\"使用readwritelock实现一个并发安全的缓存\",{\"1\":{\"220\":1}}],[\"使用reentrantlock实现一个并发安全的缓存\",{\"1\":{\"219\":1}}],[\"使用reentrantlock和condition实现一个阻塞队列\",{\"1\":{\"187\":1}}],[\"使用resmanager来避免死锁\",{\"1\":{\"142\":1}}],[\"使用unsafe类中的park\",{\"1\":{\"175\":1}}],[\"使用volatile修饰保证线程可见性\",{\"1\":{\"163\":1}}],[\"使用一个先进先出的等待队列来管理等待获取同步器的线程\",{\"1\":{\"163\":1}}],[\"使用详解\",{\"0\":{\"154\":1}}],[\"使用自旋锁\",{\"1\":{\"153\":1}}],[\"使用同步块而不是同步方法可以提高性能\",{\"1\":{\"153\":1}}],[\"使用同步块而不是同步方法\",{\"1\":{\"153\":1}}],[\"使用同步代码块来保证线程的安全\",{\"1\":{\"19\":1}}],[\"使用局部变量\",{\"1\":{\"153\":1}}],[\"使用重量级锁时应尽量减少锁的持有时间\",{\"1\":{\"152\":1}}],[\"使用传统的互斥同步方式\",{\"1\":{\"151\":1}}],[\"使用示例\",{\"0\":{\"146\":1,\"349\":1},\"1\":{\"288\":1}}],[\"使用\",{\"1\":{\"145\":1,\"153\":1,\"297\":2,\"337\":1,\"340\":1,\"343\":7,\"347\":1,\"352\":5,\"376\":1,\"392\":1,\"412\":1,\"414\":1,\"415\":2,\"416\":2}}],[\"使用缓存一致性协议\",{\"1\":{\"124\":1}}],[\"使用prometheus\",{\"0\":{\"98\":1}}],[\"使用prometheus明显是不合适的\",{\"1\":{\"65\":1}}],[\"使用以下的查询\",{\"1\":{\"89\":1}}],[\"使用上面的vector\",{\"1\":{\"88\":1}}],[\"使用标签筛选数据的使用\",{\"1\":{\"81\":1}}],[\"使用le标签表示小于的意思\",{\"1\":{\"78\":1}}],[\"使用了prometheus\",{\"1\":{\"78\":1}}],[\"使用counter类型的指标\",{\"1\":{\"76\":1}}],[\"使用观察者模式有以下的收益\",{\"1\":{\"51\":1}}],[\"使用工厂方法模式的缺点是\",{\"1\":{\"44\":1}}],[\"使用工厂方法模式的好处是\",{\"1\":{\"44\":1}}],[\"使用责任链有以下的优点\",{\"1\":{\"37\":1}}],[\"使用责任链模式可以将一个大而复杂的判断逻辑\",{\"1\":{\"37\":1}}],[\"使用责任链的原因有\",{\"1\":{\"37\":1}}],[\"使用装饰器模式有以下的优点\",{\"1\":{\"32\":1}}],[\"使用案例\",{\"0\":{\"31\":1}}],[\"使用到了包装器模式\",{\"1\":{\"29\":1}}],[\"使用适配器模式有以下的优点\",{\"1\":{\"27\":1}}],[\"使用适配器模式有什么收益\",{\"0\":{\"27\":1}}],[\"使用内部类的模式\",{\"1\":{\"20\":1}}],[\"使用内部类模式\",{\"0\":{\"20\":1}}],[\"使用双重检查来判断实例是否初始化\",{\"1\":{\"19\":1}}],[\"使用单例模式有什么好处呢\",{\"1\":{\"16\":1}}],[\"使的多个对象都有处理这个请求的机会\",{\"1\":{\"12\":1}}],[\"使它们都可以独立\",{\"1\":{\"11\":1}}],[\"在回答这个问题前\",{\"1\":{\"438\":1}}],[\"在回调函数中\",{\"1\":{\"341\":1,\"342\":1}}],[\"在静态代码快中赋值\",{\"1\":{\"435\":1}}],[\"在代码快中赋值\",{\"1\":{\"435\":1}}],[\"在代码块内部使用\",{\"1\":{\"146\":1}}],[\"在try或catch块中使用return语句时\",{\"1\":{\"438\":1}}],[\"在try块中有system\",{\"1\":{\"438\":1}}],[\"在try\",{\"1\":{\"437\":1}}],[\"在try代码块中\",{\"1\":{\"432\":1}}],[\"在thread类中\",{\"1\":{\"288\":1}}],[\"在thread类的枚举类state中\",{\"1\":{\"155\":1}}],[\"在对象的生命周期中\",{\"1\":{\"431\":1}}],[\"在对hashmap对象查找元素的时候\",{\"1\":{\"378\":1}}],[\"在object类中\",{\"1\":{\"430\":1}}],[\"在初学java的时候\",{\"1\":{\"430\":1}}],[\"在自动装箱和拆箱时\",{\"1\":{\"423\":1}}],[\"在面向对象编程中\",{\"1\":{\"422\":1}}],[\"在面向过程编程中\",{\"1\":{\"422\":1}}],[\"在面试过程中\",{\"1\":{\"13\":1}}],[\"在单线程环境中\",{\"1\":{\"421\":1}}],[\"在单线程中执行代码\",{\"1\":{\"128\":1}}],[\"在接口定义中\",{\"1\":{\"419\":1}}],[\"在接下来的文章中会逐步讲解这几种设计模式\",{\"1\":{\"13\":1}}],[\"在while循环中\",{\"1\":{\"415\":1}}],[\"在web开发中\",{\"1\":{\"283\":1}}],[\"在一个线程内处理多个\",{\"1\":{\"412\":1}}],[\"在读取模式下\",{\"1\":{\"406\":1}}],[\"在读取文件的字符之后\",{\"1\":{\"31\":2}}],[\"在构造函数接收两种类型的参数\",{\"1\":{\"401\":1}}],[\"在构造函数中赋值\",{\"1\":{\"435\":1}}],[\"在构造函数中\",{\"1\":{\"385\":1}}],[\"在其源代码中明显使用了将fileinputstream\",{\"1\":{\"401\":1}}],[\"在最初写入时会有一个基准的行号\",{\"1\":{\"401\":1}}],[\"在输出部分没有对应的部分\",{\"1\":{\"401\":1}}],[\"在哪里分行是由改类主动确定的\",{\"1\":{\"401\":1}}],[\"在需要处理的数据范围比较大的场景下可以有效减少扩容的次数\",{\"1\":{\"392\":1}}],[\"在需要频繁插入和删除元素的场景下很有优势\",{\"1\":{\"371\":1}}],[\"在处理哈希冲突时\",{\"1\":{\"379\":1}}],[\"在处理可能具有内部依赖关系的请求集时\",{\"1\":{\"298\":1}}],[\"在新的\",{\"1\":{\"377\":1}}],[\"在新一轮的循环中会返回执行结果\",{\"1\":{\"333\":1}}],[\"在插入新键值对后\",{\"1\":{\"376\":1}}],[\"在插入元素时会自动维护有序性\",{\"1\":{\"225\":1}}],[\"在访问元素时相对较慢\",{\"1\":{\"371\":1}}],[\"在访问的时候需要锁占用\",{\"1\":{\"23\":1}}],[\"在指定位置插入元素\",{\"1\":{\"371\":1}}],[\"在通过\",{\"1\":{\"364\":1}}],[\"在制定位置添加元素\",{\"1\":{\"360\":1}}],[\"在如今java面试八股文满天飞的时代\",{\"1\":{\"355\":1}}],[\"在所有completablefuture完成后执行回调函数\",{\"1\":{\"342\":1}}],[\"在获取到对应节点后\",{\"1\":{\"369\":1}}],[\"在获取返回值的时候会阻塞主线程\",{\"1\":{\"336\":1}}],[\"在获取失败后是否需要禁止线程并且进行中断检查\",{\"1\":{\"198\":1}}],[\"在任务执行线程执行任务的时候\",{\"1\":{\"329\":1}}],[\"在string类的方法中\",{\"1\":{\"430\":1}}],[\"在setexception\",{\"1\":{\"329\":1}}],[\"在springboot的项目中增加springboot指标的采集\",{\"1\":{\"99\":1}}],[\"在springboot项目中\",{\"1\":{\"110\":1}}],[\"在springboot项目中的pom文件引入以下的依赖\",{\"1\":{\"98\":1}}],[\"在springboot项目中使用prometheus监控\",{\"0\":{\"96\":1}}],[\"在springboot项目创建一个测试接口\",{\"1\":{\"97\":1}}],[\"在executorservice中的定义\",{\"1\":{\"316\":1}}],[\"在keepalivetime内仍空闲则会被销毁\",{\"1\":{\"314\":1}}],[\"在reentrantlock锁的保证下\",{\"1\":{\"310\":1}}],[\"在resmanager类中\",{\"1\":{\"142\":1}}],[\"在核心线程数量内\",{\"1\":{\"295\":1}}],[\"在创建线程池时\",{\"1\":{\"295\":1}}],[\"在创建阶段之后\",{\"1\":{\"293\":1}}],[\"在终止阶段\",{\"1\":{\"293\":1}}],[\"在关闭阶段之后\",{\"1\":{\"293\":1}}],[\"在关闭阶段\",{\"1\":{\"293\":1}}],[\"在子线程中\",{\"1\":{\"288\":1}}],[\"在业务中无需担心内存泄漏的问题\",{\"1\":{\"285\":1}}],[\"在某些应用场景中\",{\"1\":{\"283\":1}}],[\"在某些情况下\",{\"1\":{\"56\":1,\"141\":1,\"153\":1,\"283\":1}}],[\"在调用set方法\",{\"1\":{\"282\":1}}],[\"在调用arrayblockingqueue的add方法时\",{\"1\":{\"274\":1}}],[\"在线程的内部有一个变量threadlocals\",{\"1\":{\"282\":1}}],[\"在当前线程被中断时会抛出异常\",{\"1\":{\"273\":1,\"275\":1}}],[\"在当前数组中索引指定元素\",{\"1\":{\"239\":1}}],[\"在当前数组中找到e元素\",{\"1\":{\"239\":1}}],[\"在队列为空时\",{\"1\":{\"266\":1}}],[\"在队列已满时将会阻塞入队操作\",{\"1\":{\"266\":1}}],[\"在队首进行出队操作\",{\"1\":{\"226\":1}}],[\"在日常开发中\",{\"1\":{\"266\":1}}],[\"在给定的时间内等待条件的成立\",{\"1\":{\"265\":1}}],[\"在queue接口基础上\",{\"1\":{\"265\":1}}],[\"在桶\",{\"1\":{\"260\":1}}],[\"在扩容操作中\",{\"1\":{\"377\":1}}],[\"在扩容的过程中\",{\"1\":{\"259\":1}}],[\"在扩展性上\",{\"1\":{\"30\":1}}],[\"在进行数据读写时\",{\"1\":{\"406\":1}}],[\"在进行对象实例化时可指定操作模式\",{\"1\":{\"401\":1}}],[\"在进行扩容之前会将当前\",{\"1\":{\"377\":1}}],[\"在进行删除操作时\",{\"1\":{\"358\":1}}],[\"在进行调整时\",{\"1\":{\"295\":1}}],[\"在进行插入\",{\"1\":{\"246\":1}}],[\"在进程内部计算告警规则\",{\"1\":{\"101\":1}}],[\"在迭代器上进行的元素更改操作\",{\"1\":{\"235\":1}}],[\"在选择容器时需要根据实际需求进行评估和决策\",{\"1\":{\"227\":1}}],[\"在实际的开发中\",{\"1\":{\"430\":1}}],[\"在实际的开发过程中是应用非常多的\",{\"1\":{\"10\":1}}],[\"在实际编程中\",{\"1\":{\"422\":1}}],[\"在实际业务场景中\",{\"1\":{\"315\":1}}],[\"在实际工作中\",{\"1\":{\"226\":1,\"227\":1}}],[\"在写入模式下\",{\"1\":{\"406\":2}}],[\"在写入数据时会创建一个新的底层数组来保存数据\",{\"1\":{\"229\":1}}],[\"在写入文件之前\",{\"1\":{\"31\":2}}],[\"在写操作时\",{\"1\":{\"225\":1}}],[\"在并发包里\",{\"1\":{\"225\":1}}],[\"在并发包中提供类了concurrenthashmap和concurrentskiplistmap\",{\"1\":{\"224\":1}}],[\"在并发编程中\",{\"1\":{\"120\":1,\"123\":1}}],[\"在没有线程持有写锁或等待的写锁时\",{\"1\":{\"221\":1}}],[\"在前面对aqs的分析中已经指出了其数据结构\",{\"1\":{\"205\":1}}],[\"在前面的文章已经讲解过prometheus采集数据和查询数据\",{\"1\":{\"101\":1}}],[\"在前面的文章介绍过如下prometheus自身的监控\",{\"1\":{\"74\":1}}],[\"在每次循环中\",{\"1\":{\"203\":1}}],[\"在每一个group中我们可以定义多个告警规则\",{\"1\":{\"108\":1}}],[\"在countdownlatch使用示例\",{\"1\":{\"203\":1}}],[\"在屏障点上\",{\"1\":{\"202\":1}}],[\"在主线程中执行对账操作\",{\"1\":{\"191\":1}}],[\"在dubbo的defaultfuture类中使用了reentrantlock去实现以下的功能\",{\"1\":{\"186\":1}}],[\"在deadlockdemo3类中\",{\"1\":{\"143\":1}}],[\"在deadlockdemo2类中\",{\"1\":{\"142\":1}}],[\"在deadlock1类中\",{\"1\":{\"139\":1}}],[\"在分析了abstractqueuedsynchronier源码后\",{\"1\":{\"177\":1}}],[\"在内存的偏移量值\",{\"1\":{\"175\":1}}],[\"在执行完cancelacquire函数后的效果就是unpark了s结点所包含的t4线程\",{\"1\":{\"173\":1}}],[\"在执行资金转移操作时\",{\"1\":{\"142\":1}}],[\"在许可可用之前禁用当前线程\",{\"1\":{\"173\":1}}],[\"在从\",{\"1\":{\"169\":2}}],[\"在打印完成后\",{\"1\":{\"160\":1}}],[\"在循环内部使用synchronized\",{\"1\":{\"160\":1}}],[\"在操作系统中\",{\"1\":{\"157\":1}}],[\"在操作中定义算法的框架\",{\"1\":{\"12\":1}}],[\"在使用final变量前必须赋值\",{\"1\":{\"435\":1}}],[\"在使用前必须赋值\",{\"1\":{\"435\":1}}],[\"在使用关系操作符\",{\"1\":{\"429\":1}}],[\"在使用\",{\"1\":{\"410\":1,\"411\":1,\"412\":1,\"416\":1}}],[\"在使用迭代器遍历\",{\"1\":{\"364\":1}}],[\"在使用threadlocal时\",{\"1\":{\"283\":1,\"285\":1}}],[\"在使用threadlocal的get\",{\"1\":{\"282\":1}}],[\"在使用无界队列时要注意潜在的oom风险\",{\"1\":{\"226\":1}}],[\"在使用乐观读结果进行后续操作前\",{\"1\":{\"221\":1}}],[\"在使用重量级锁的情况下\",{\"1\":{\"152\":1}}],[\"在使用轻量级锁的情况下\",{\"1\":{\"151\":1}}],[\"在方法签名中明确指定可能抛出的异常类型\",{\"1\":{\"432\":1}}],[\"在方法内部\",{\"1\":{\"386\":1,\"387\":1,\"388\":1}}],[\"在方法执行期间\",{\"1\":{\"147\":1}}],[\"在方法声明时使用\",{\"1\":{\"146\":1}}],[\"在完成资源获取后\",{\"1\":{\"143\":1}}],[\"在转移完成后\",{\"1\":{\"142\":1}}],[\"在aqs的doacquiresharedinterruptibly中可能会再次调用countdownlatch的内部类sync的tryacquireshared方法和aqs的setheadandpropagate方法\",{\"1\":{\"198\":1}}],[\"在abstractqueuedsynchronizer源码中默认会抛出一个异常\",{\"1\":{\"173\":1}}],[\"在account类中\",{\"1\":{\"143\":1}}],[\"在account类的fundtransfer方法中\",{\"1\":{\"142\":1}}],[\"在aftercompletion方法中\",{\"1\":{\"98\":1}}],[\"在等待任务完成时\",{\"1\":{\"323\":1}}],[\"在等待着把元素加入或移出队列\",{\"1\":{\"298\":1}}],[\"在等待共享资源\",{\"1\":{\"140\":1}}],[\"在等待期间新产生告警的状态为pending\",{\"1\":{\"108\":1}}],[\"在fundtransfer方法中\",{\"1\":{\"139\":1,\"142\":1,\"143\":1}}],[\"在\",{\"1\":{\"138\":1,\"149\":1,\"186\":2,\"191\":1,\"349\":1,\"358\":1,\"368\":1,\"369\":1,\"370\":1,\"374\":1,\"382\":2,\"388\":1,\"392\":2,\"403\":2,\"404\":1,\"414\":5,\"415\":2,\"424\":1,\"432\":1}}],[\"在increase方法加上synchronized\",{\"1\":{\"132\":1}}],[\"在之前已经讲述过inc++这样的操作不是一个原子性操作\",{\"1\":{\"132\":1}}],[\"在之前的设计模式的单例模式中\",{\"1\":{\"121\":1}}],[\"在上一篇文章\",{\"1\":{\"336\":1}}],[\"在上述源码中\",{\"1\":{\"378\":1}}],[\"在上述示例中\",{\"1\":{\"267\":1,\"323\":3,\"419\":1,\"429\":1}}],[\"在上述代码中\",{\"1\":{\"131\":1,\"432\":1}}],[\"在上面死锁发生的四个条件中\",{\"1\":{\"141\":1}}],[\"在上面的这个例子中\",{\"1\":{\"419\":1}}],[\"在上面的例子中\",{\"1\":{\"418\":1,\"419\":1}}],[\"在上面的关系图中可以看出\",{\"1\":{\"401\":1}}],[\"在上面的代码中\",{\"1\":{\"121\":1,\"191\":1}}],[\"在上面的示例中\",{\"1\":{\"78\":1,\"146\":1,\"158\":1,\"281\":1,\"339\":1,\"340\":1,\"349\":1}}],[\"在上面讲解的操作符\",{\"1\":{\"88\":1}}],[\"在总线上加锁\",{\"1\":{\"124\":1}}],[\"在juc包中\",{\"1\":{\"222\":1}}],[\"在jvm中\",{\"1\":{\"152\":1}}],[\"在jvm执行多线程任务时\",{\"1\":{\"124\":1}}],[\"在java7版本和java8～21的实现非常不同\",{\"1\":{\"244\":1}}],[\"在java\",{\"1\":{\"222\":1,\"245\":1,\"246\":2}}],[\"在java中有八种基本数据类型\",{\"1\":{\"429\":1}}],[\"在java中使用phantomreference进行定义\",{\"1\":{\"286\":1}}],[\"在java中\",{\"1\":{\"157\":2,\"420\":1,\"421\":1,\"429\":1,\"432\":1}}],[\"在java中创建一个对象\",{\"1\":{\"19\":1,\"121\":1}}],[\"在java并发编程实战一书中有这样\",{\"1\":{\"131\":1}}],[\"在java语言中并支持动态代理\",{\"1\":{\"52\":1}}],[\"在java的io源码中\",{\"1\":{\"29\":1}}],[\"在此处编写你想要执行的回调函数逻辑\",{\"1\":{\"341\":1,\"342\":1}}],[\"在此函数中会调用aqs的signalall方法\",{\"1\":{\"214\":1}}],[\"在此之前\",{\"1\":{\"123\":1}}],[\"在此篇文章只讲解最基础的和几个重要的配置\",{\"1\":{\"107\":1}}],[\"在编程中\",{\"1\":{\"140\":1}}],[\"在编译优化后可能会变成\",{\"1\":{\"121\":1}}],[\"在编写并发程序时\",{\"1\":{\"120\":1}}],[\"在寄存器中执行加1的操作\",{\"1\":{\"120\":1}}],[\"在底层执行时至少会包括三个步骤\",{\"1\":{\"120\":1}}],[\"在高级语言中\",{\"1\":{\"120\":1}}],[\"在多核cpu中\",{\"1\":{\"124\":1}}],[\"在多核处理器系统中\",{\"1\":{\"120\":1}}],[\"在多线程环境下很有可能发生\",{\"1\":{\"311\":1}}],[\"在多线程环境下\",{\"1\":{\"283\":1,\"311\":1}}],[\"在多线程并发情况下也能安全的使用这些容器\",{\"1\":{\"222\":1}}],[\"在多线程并发执行时可能会发生竞态条件等问题\",{\"1\":{\"120\":1}}],[\"在多线程编程中\",{\"1\":{\"136\":1}}],[\"在多线程的情况下\",{\"1\":{\"20\":1}}],[\"在main方法中\",{\"1\":{\"119\":1,\"139\":2,\"142\":1,\"143\":1}}],[\"在文件中写一个指标聚合的表达式\",{\"1\":{\"116\":1}}],[\"在文件流的基础之上使用装饰器模式\",{\"1\":{\"31\":1}}],[\"在告警规则文件中\",{\"1\":{\"108\":1}}],[\"在浏览器中访问localhost\",{\"1\":{\"107\":1}}],[\"在浏览器上请求http\",{\"1\":{\"97\":1}}],[\"在浏览器上请求测试接口http\",{\"1\":{\"97\":1,\"98\":1}}],[\"在再次发送通知之前等待的时间\",{\"1\":{\"107\":1}}],[\"在启动之前\",{\"1\":{\"106\":1}}],[\"在本篇文章中将会讲述prometheus告警与alertmanager实战\",{\"1\":{\"101\":1}}],[\"在本地部署的grafana页面导入node\",{\"1\":{\"71\":1}}],[\"在它内部进行告警消息的管理\",{\"1\":{\"101\":1}}],[\"在项目中有一个测试接口\",{\"1\":{\"98\":1}}],[\"在项目中引入以下的依赖\",{\"1\":{\"97\":1}}],[\"在这种情况下\",{\"1\":{\"431\":1}}],[\"在这段代码中\",{\"1\":{\"139\":1}}],[\"在这个例子中\",{\"1\":{\"423\":1,\"424\":1}}],[\"在这个示例中\",{\"1\":{\"341\":1,\"342\":1,\"438\":1}}],[\"在这个阶段\",{\"1\":{\"293\":1}}],[\"在这个特定的例子中\",{\"1\":{\"119\":1}}],[\"在这个接口中\",{\"1\":{\"56\":1}}],[\"在这里插入图片描述\",{\"1\":{\"303\":1}}],[\"在这里不再累赘\",{\"1\":{\"205\":1}}],[\"在这里\",{\"1\":{\"142\":1}}],[\"在这里有三个指标\",{\"1\":{\"97\":1}}],[\"在这里就不展开讲解了\",{\"1\":{\"97\":1}}],[\"在作用于两个瞬时向量之间\",{\"1\":{\"85\":1}}],[\"在很多场景下\",{\"1\":{\"78\":1}}],[\"在很多rpc框架\",{\"1\":{\"52\":1}}],[\"在下一行\",{\"1\":{\"423\":1}}],[\"在下一篇文章将会讲解\",{\"1\":{\"76\":1}}],[\"在下面的案例中\",{\"1\":{\"18\":1}}],[\"在注释中包含了指标的类型\",{\"1\":{\"75\":1}}],[\"在grafana中为springboot项目配置试图\",{\"1\":{\"100\":1}}],[\"在grafana执行\",{\"1\":{\"81\":1}}],[\"在grafana上查询指标\",{\"1\":{\"74\":1}}],[\"在gui中应用的比较多\",{\"1\":{\"49\":1}}],[\"在更改完配置以后\",{\"1\":{\"70\":1}}],[\"在查询框里输入node\",{\"1\":{\"69\":1}}],[\"在putval函数中会涉及到如下几个函数\",{\"1\":{\"259\":1}}],[\"在prehandle方法中记录请求的开始时间starttime\",{\"1\":{\"98\":1}}],[\"在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算\",{\"1\":{\"88\":1}}],[\"在prometheus的页面上可以查看新指标的数据\",{\"1\":{\"116\":1}}],[\"在prometheus的yaml配置文件中\",{\"1\":{\"116\":1}}],[\"在prometheus的配置文件中\",{\"1\":{\"108\":1}}],[\"在prometheus的配置文prometheus\",{\"1\":{\"69\":1}}],[\"在prometheus的启动程序的同级目录下面\",{\"1\":{\"108\":1}}],[\"在prometheus中配置告警规则\",{\"0\":{\"108\":1}}],[\"在prometheus\",{\"1\":{\"101\":2}}],[\"在prometheus启动的时候加上启动参数\",{\"1\":{\"70\":1}}],[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus\",{\"1\":{\"68\":1}}],[\"在pom文件中引入cglib包\",{\"1\":{\"57\":1}}],[\"在不同的处理器上执行\",{\"1\":{\"124\":1}}],[\"在不同容量情况下系统的并发和负载变化如何\",{\"1\":{\"65\":1}}],[\"在不改变了componentimpl的情况下\",{\"1\":{\"30\":1}}],[\"在不改变已有类的功能的前提下进行批量扩展\",{\"1\":{\"12\":1}}],[\"在微服务的世界里\",{\"1\":{\"65\":1}}],[\"在消息队列的场景有广泛的应用\",{\"1\":{\"49\":1}}],[\"在观察者模式中\",{\"1\":{\"49\":1}}],[\"在流程中有三个角色\",{\"1\":{\"36\":1}}],[\"在工作中\",{\"1\":{\"36\":1}}],[\"在讲解完具体案例后\",{\"1\":{\"32\":1}}],[\"在案例模仿javaio的文件流的写入和读取功能\",{\"1\":{\"31\":1}}],[\"在图中一共有三个角色\",{\"1\":{\"30\":1}}],[\"在程序中\",{\"1\":{\"25\":1}}],[\"在判断singleton==null时不为null\",{\"1\":{\"19\":1,\"121\":1}}],[\"在系统中只需要初始化一个实例\",{\"1\":{\"16\":1}}],[\"在什么样的场景会使用到单列模式呢\",{\"1\":{\"16\":1}}],[\"在复用代码时\",{\"1\":{\"14\":1}}],[\"策略\",{\"1\":{\"223\":1}}],[\"策略让算法独立于使用它的客户端而变化\",{\"1\":{\"12\":1}}],[\"策略模式\",{\"1\":{\"12\":1}}],[\"封装每个算法\",{\"1\":{\"12\":1}}],[\"封装对象的创建过程\",{\"1\":{\"10\":1}}],[\"行为型模式\",{\"0\":{\"12\":1}}],[\"桥接模式\",{\"1\":{\"11\":1}}],[\"将网卡中所有连接的读写事件数据以链表的形式一次性拷贝到内存中的特定区域\",{\"1\":{\"416\":1}}],[\"将其打印到控制台\",{\"1\":{\"414\":1}}],[\"将需要监听的通道注册到\",{\"1\":{\"407\":1}}],[\"将所有未读完的数据移到缓冲区的开头\",{\"1\":{\"406\":1}}],[\"将数据从特定区域零拷贝到用户空间\",{\"1\":{\"416\":1}}],[\"将数据写入文件\",{\"1\":{\"405\":1}}],[\"将数据放入队列中\",{\"1\":{\"267\":1}}],[\"将字符写入到文件中\",{\"1\":{\"401\":1}}],[\"将字节流转换为字符流\",{\"1\":{\"401\":1}}],[\"将两个或者多个输入流当成一个输入流依次读取\",{\"1\":{\"401\":1}}],[\"将bytearray对象转化为bitset\",{\"1\":{\"395\":1}}],[\"将bitset对象转化为bytearray\",{\"1\":{\"395\":1}}],[\"将1到1亿之间没有在随机数中的数求出来\",{\"1\":{\"394\":1}}],[\"将40亿个不同数据进行排序等\",{\"1\":{\"394\":1}}],[\"将每个非空的位置上的键值对重新计算哈希值\",{\"1\":{\"377\":1}}],[\"将节点\",{\"1\":{\"370\":2}}],[\"将链表的尾节点\",{\"1\":{\"368\":1}}],[\"将当前尾节点\",{\"1\":{\"368\":1}}],[\"将当前正在执行的线程暂停下来\",{\"1\":{\"120\":1}}],[\"将collection中的元素都添加到linkedlist中\",{\"1\":{\"367\":1}}],[\"将collection的按照index位置开始的所有元素添加到集合中\",{\"1\":{\"360\":1}}],[\"将collection的全部元素添加到集合中\",{\"1\":{\"360\":1}}],[\"将c集合转化为数组并赋值给elements\",{\"1\":{\"234\":1}}],[\"将在添加第一个元素时扩展为default\",{\"1\":{\"358\":1}}],[\"将不会被添加进去\",{\"1\":{\"353\":1}}],[\"将不能进行park操作\",{\"1\":{\"173\":1}}],[\"将自己设置给他\",{\"1\":{\"313\":1}}],[\"将woker实例本身this作为参数传入\",{\"1\":{\"310\":1}}],[\"将任务提交给线程池\",{\"1\":{\"303\":1}}],[\"将导致新任务都会在队列中等待\",{\"1\":{\"299\":1}}],[\"将元素的放到索引位置\",{\"1\":{\"360\":1}}],[\"将元素添加到size的位置\",{\"1\":{\"360\":1}}],[\"将元素存入底层object数组\",{\"1\":{\"274\":1}}],[\"将元素放入\",{\"1\":{\"273\":1}}],[\"将队列中的元素出队\",{\"1\":{\"265\":1}}],[\"将队列中的所有元素出队\",{\"1\":{\"265\":1}}],[\"将table的结点转移到nexttab中\",{\"1\":{\"259\":1}}],[\"将tocopyin转化为object\",{\"1\":{\"234\":1}}],[\"将hash\",{\"1\":{\"259\":1}}],[\"将指定的value保存至结点\",{\"1\":{\"259\":1}}],[\"将下标为length的数组元素newelements\",{\"1\":{\"238\":1}}],[\"将original数组从下标0开始\",{\"1\":{\"237\":1}}],[\"将object\",{\"1\":{\"237\":1}}],[\"将newtype转化为object类型\",{\"1\":{\"237\":1}}],[\"将node结点的prev域连接到尾结点\",{\"1\":{\"173\":2,\"214\":1}}],[\"将传入的集合转化为数组elements\",{\"1\":{\"234\":1}}],[\"将elements数组转化为object\",{\"1\":{\"234\":1}}],[\"将first结点从condition队列转移到sync队列\",{\"1\":{\"214\":1}}],[\"将\",{\"1\":{\"203\":1,\"323\":3,\"336\":1,\"362\":1,\"368\":1,\"412\":2}}],[\"将state和localholder都置为空\",{\"1\":{\"175\":1}}],[\"将此线程的所有数据放入内存中的运行时数据区\",{\"1\":{\"175\":1}}],[\"将它从等待队列中移除\",{\"1\":{\"175\":1}}],[\"将线程放入等待队列中\",{\"1\":{\"175\":1}}],[\"将会输出以下结果\",{\"1\":{\"352\":1,\"353\":1,\"354\":1}}],[\"将会继续进行步骤①的判断\",{\"1\":{\"173\":1}}],[\"将会被阻塞\",{\"1\":{\"158\":1}}],[\"将同步状态值设置为给定值update如果当前同步状态的值等于expect\",{\"1\":{\"163\":1}}],[\"将结果写回到内存\",{\"1\":{\"120\":1}}],[\"将通过post的http请求发送下游程序\",{\"1\":{\"110\":1}}],[\"将告警消息按照某个标签分组\",{\"1\":{\"107\":1}}],[\"将得不到任何结果\",{\"1\":{\"89\":1}}],[\"将三个审批角色组成一个责任链模式的审批流\",{\"1\":{\"36\":1}}],[\"将目标类和适配的类解耦\",{\"1\":{\"27\":1}}],[\"将适配器这个角色进行高度抽象化\",{\"1\":{\"27\":1}}],[\"将请求的发送者和接收者解耦\",{\"1\":{\"12\":1}}],[\"将命令请求封装为一个对象\",{\"1\":{\"12\":1}}],[\"将一些步骤推迟到子类中\",{\"1\":{\"12\":1}}],[\"将对象头中的标志位设置为偏向模式\",{\"1\":{\"153\":1}}],[\"将对象组合成树形结构以表示整个部分的层次结构\",{\"1\":{\"11\":1}}],[\"将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"11\":1}}],[\"将抽象部分和实现部分分离\",{\"1\":{\"11\":1}}],[\"将类的接口转换为客户期望的另一个接口\",{\"1\":{\"11\":1,\"25\":1}}],[\"享元模式\",{\"1\":{\"11\":1}}],[\"代表该当前节点能够占有锁\",{\"1\":{\"173\":1}}],[\"代表了线程的生命周期\",{\"1\":{\"155\":1}}],[\"代理类\",{\"1\":{\"53\":1,\"54\":1}}],[\"代理对象可以控制客户端对真实对象的访问\",{\"1\":{\"52\":1}}],[\"代理模式分为静态代理和动态代码\",{\"1\":{\"53\":1}}],[\"代理模式常用于对已有功能的增强\",{\"1\":{\"52\":1}}],[\"代理模式是一种结构性模式\",{\"1\":{\"52\":1}}],[\"代理模式并没有做类似于装饰器模式多层嵌套\",{\"1\":{\"52\":1}}],[\"代理模式和装饰器模式类似\",{\"1\":{\"52\":1}}],[\"代理模式\",{\"0\":{\"52\":1},\"1\":{\"11\":1,\"13\":1}}],[\"代码的主要功能包括\",{\"1\":{\"415\":1}}],[\"代码的可扩展性和可复用性非常的强\",{\"1\":{\"32\":1}}],[\"代码示例\",{\"0\":{\"395\":1},\"1\":{\"418\":1}}],[\"代码输出的线程状态为new\",{\"1\":{\"156\":1}}],[\"代码块内部使用局部变量而不是共享变量\",{\"1\":{\"153\":1}}],[\"代码会变得臃肿难以维护\",{\"1\":{\"53\":1}}],[\"代码如下\",{\"1\":{\"47\":4,\"50\":1,\"54\":1,\"56\":1,\"57\":2,\"119\":1,\"121\":1,\"155\":1,\"156\":1,\"173\":1,\"175\":1,\"187\":1,\"376\":1,\"430\":1}}],[\"代码实现\",{\"0\":{\"26\":1,\"41\":1,\"44\":1,\"47\":1,\"54\":1}}],[\"代码编写\",{\"1\":{\"8\":1}}],[\"代码质量是设计出来的\",{\"1\":{\"8\":1}}],[\"形成一个更大的对象\",{\"1\":{\"11\":1}}],[\"它在try块或catch块中的代码执行完毕后立即执行\",{\"1\":{\"438\":1}}],[\"它还具有内存管理\",{\"1\":{\"433\":1}}],[\"它位于异常类的最顶层\",{\"1\":{\"432\":1}}],[\"它比较的是对字符串内容的比较\",{\"1\":{\"430\":1}}],[\"它比reentrantlock和readwritelock更加灵活和高效\",{\"1\":{\"221\":1}}],[\"它让我们可以使用父类的引用变量来引用不同子类的对象\",{\"1\":{\"424\":1}}],[\"它更直观\",{\"1\":{\"422\":1}}],[\"它不能被实例化\",{\"1\":{\"419\":1}}],[\"它首先创建一个\",{\"1\":{\"414\":1}}],[\"它先创建一个\",{\"1\":{\"414\":1}}],[\"它先将线程池状态设置为stop\",{\"1\":{\"319\":1}}],[\"它用于监听客户端的连接请求\",{\"1\":{\"411\":1}}],[\"它表示可以存储的最大数据量\",{\"1\":{\"406\":1}}],[\"它将字节流转变为字符流\",{\"1\":{\"401\":1}}],[\"它将会获取锁\",{\"1\":{\"145\":1}}],[\"它也是一个顶级父类\",{\"1\":{\"401\":2}}],[\"它调用\",{\"1\":{\"387\":1,\"388\":1}}],[\"它利用哈希函数将键映射到数组的索引位置\",{\"1\":{\"379\":1}}],[\"它拓展自\",{\"1\":{\"374\":1}}],[\"它包含了jvm\",{\"1\":{\"433\":1}}],[\"它包含了\",{\"1\":{\"366\":2}}],[\"它包含了读取和写入两个步骤\",{\"1\":{\"126\":1}}],[\"它返回的是一个新的object\",{\"1\":{\"361\":1}}],[\"它继承自\",{\"1\":{\"357\":1}}],[\"它和其子类负责装饰其它reader\",{\"1\":{\"401\":1}}],[\"它和collection接口属于并列的关系\",{\"1\":{\"354\":1}}],[\"它和里氏替换原则相辅相成的\",{\"1\":{\"14\":1}}],[\"它定义了可以被抛出和捕获的异常对象的基本功能\",{\"1\":{\"432\":1}}],[\"它定义了集合的基本操作\",{\"1\":{\"351\":1}}],[\"它定义了一组方法的方法\",{\"1\":{\"419\":1}}],[\"它定义了一些方法\",{\"1\":{\"53\":1}}],[\"它定义了一个创建对象的接口\",{\"1\":{\"10\":1,\"42\":1}}],[\"它管理和调度任务的执行\",{\"1\":{\"346\":1}}],[\"它实现的锁是不可重入的\",{\"1\":{\"319\":1}}],[\"它实现了\",{\"1\":{\"228\":1,\"322\":2}}],[\"它实现了观察者的更新接口\",{\"1\":{\"49\":1}}],[\"它实现了readerwriter接口\",{\"1\":{\"31\":2}}],[\"它实现了目标接口\",{\"1\":{\"30\":3}}],[\"它创建的线程都在同一个threadgroup中\",{\"1\":{\"301\":1}}],[\"它里面存放的entity也会被回收\",{\"1\":{\"287\":1}}],[\"它所使用的所有\",{\"1\":{\"280\":1}}],[\"它与普通变量的区别在于\",{\"1\":{\"280\":1}}],[\"它与cpu之间通过总线进行通信\",{\"1\":{\"118\":1}}],[\"它最初包含给定\",{\"1\":{\"271\":1}}],[\"它适用于需要灵活增减队列长度的场景\",{\"1\":{\"266\":1}}],[\"它基于哈希表的数据结构\",{\"1\":{\"389\":1}}],[\"它基于\",{\"1\":{\"345\":1}}],[\"它基于链表实现\",{\"1\":{\"266\":1}}],[\"它基于数组实现\",{\"1\":{\"266\":1}}],[\"它基于跳表的数据结构\",{\"1\":{\"225\":1}}],[\"它放弃了基于分段锁的实现\",{\"1\":{\"246\":1}}],[\"它被设计用来在多线程环境下进行并发访问\",{\"1\":{\"244\":1}}],[\"它允许我们使用父类的引用变量来引用子类的对象实例\",{\"1\":{\"424\":1}}],[\"它允许子线程继承父线程的threadlocal变量值\",{\"1\":{\"288\":1}}],[\"它允许多个线程同时进入\",{\"1\":{\"221\":1}}],[\"它允许将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"52\":1}}],[\"它以更细粒度的方式控制对共享资源的并发访问\",{\"1\":{\"220\":1}}],[\"它提供了非阻塞的\",{\"1\":{\"410\":1}}],[\"它提供了更多的控制权和灵活性\",{\"1\":{\"403\":1}}],[\"它提供了处理文件\",{\"1\":{\"398\":1}}],[\"它提供了强大的功能来简化异步操作\",{\"1\":{\"337\":1}}],[\"它提供了线程本地变量的支持\",{\"1\":{\"280\":1}}],[\"它提供了独占的锁\",{\"1\":{\"218\":1}}],[\"它提供了一种基于缓冲区\",{\"1\":{\"403\":1}}],[\"它提供了一种基于fifo等待队列的机制\",{\"1\":{\"162\":1}}],[\"它提供了一组接口和类\",{\"1\":{\"351\":1}}],[\"它提供了一个创建一系列相关对象的接口\",{\"1\":{\"10\":1,\"45\":1}}],[\"它总是会先判断sync队列\",{\"1\":{\"185\":1}}],[\"它解决了线程安全问题\",{\"1\":{\"145\":1}}],[\"它会在所有的\",{\"1\":{\"342\":1}}],[\"它会在任意一个\",{\"1\":{\"341\":1}}],[\"它会独占资源\",{\"1\":{\"220\":1}}],[\"它会被垃圾回收\",{\"1\":{\"285\":1}}],[\"它会被阻塞\",{\"1\":{\"190\":1}}],[\"它会被放入等待队列中\",{\"1\":{\"163\":1}}],[\"它会进行一段短暂的自旋\",{\"1\":{\"153\":1}}],[\"它会将对共享变量的修改刷新到主内存中\",{\"1\":{\"145\":1}}],[\"它会含有endts这个时间戳参数\",{\"1\":{\"107\":1}}],[\"它仍执行写操作\",{\"1\":{\"132\":1}}],[\"它分为读\",{\"1\":{\"132\":1}}],[\"它们会被隐式地视为final\",{\"1\":{\"436\":1}}],[\"它们都有一个共同的方法\",{\"1\":{\"424\":1}}],[\"它们都是用于类的方法\",{\"1\":{\"418\":1}}],[\"它们之间有以下区别\",{\"1\":{\"421\":1}}],[\"它们有一些共同点\",{\"1\":{\"419\":1}}],[\"它们有转换作用\",{\"1\":{\"401\":1}}],[\"它们分别用于读写不同类型的数据\",{\"1\":{\"406\":1}}],[\"它们分别向char\",{\"1\":{\"401\":1}}],[\"它们分别向byte\",{\"1\":{\"401\":1}}],[\"它们分别将char\",{\"1\":{\"401\":1}}],[\"它们分别从byte\",{\"1\":{\"401\":1}}],[\"它们分别对变量a进行5000次自增操作\",{\"1\":{\"119\":1}}],[\"它们两类型是一样的\",{\"1\":{\"288\":1}}],[\"它们可以同时进行操作\",{\"1\":{\"245\":1}}],[\"它们可以在不同的线程之间并发访问容器\",{\"1\":{\"222\":1}}],[\"它们的主要区别和特点\",{\"1\":{\"218\":1}}],[\"它们通过共享的锁对象lock来实现交替打印奇数和偶数\",{\"1\":{\"160\":1}}],[\"它们共同组成描述当前指标的特征\",{\"1\":{\"74\":1}}],[\"它可以在合适的场景中使用\",{\"1\":{\"435\":1}}],[\"它可以存放任意数量的任务\",{\"1\":{\"297\":1}}],[\"它可以让多个线程在某个屏障点\",{\"1\":{\"202\":1}}],[\"它可以让一个或多个线程等待其他线程完成操作之后再继续执行\",{\"1\":{\"190\":1}}],[\"它可以被操作系统调度为运行状态\",{\"1\":{\"157\":1}}],[\"它可以提升无竞争情况下的性能\",{\"1\":{\"153\":1}}],[\"它可以应用于方法或代码块\",{\"1\":{\"145\":1}}],[\"它可以是一个邮箱也可以是微信\",{\"1\":{\"106\":1}}],[\"它可以把字符写入到文件中\",{\"1\":{\"31\":1}}],[\"它默认集成在spring\",{\"1\":{\"97\":1}}],[\"它同等于\",{\"1\":{\"90\":1}}],[\"它支持多种类型的数据库\",{\"1\":{\"71\":1}}],[\"它为主机暴露了硬件和内核相关的指标\",{\"1\":{\"69\":1}}],[\"它并不能保证数据的及时性和绝对正确性\",{\"1\":{\"65\":1}}],[\"它对多维数据收集和查询的支持是一个特别的优势\",{\"1\":{\"65\":1}}],[\"它既适合以机器为中心的监视\",{\"1\":{\"65\":1}}],[\"它能够有效地处理程序中可能发生的异常情况\",{\"1\":{\"432\":1}}],[\"它能够提高系统的可扩展性和灵活性\",{\"1\":{\"51\":1}}],[\"它能执行异步任务\",{\"1\":{\"343\":1}}],[\"它能审批10000元以下的借款\",{\"1\":{\"36\":1}}],[\"它能审批5000元以下的借款\",{\"1\":{\"36\":1}}],[\"它维护了一个状态\",{\"1\":{\"49\":1}}],[\"它维护了一个观察者的列表\",{\"1\":{\"49\":1}}],[\"它具有更好的可维护性\",{\"1\":{\"422\":1}}],[\"它具有以下的优点\",{\"1\":{\"47\":1}}],[\"它具有如下的优点\",{\"1\":{\"41\":1}}],[\"它只是提供了一种在父子线程之间传递threadlocal变量值的机制\",{\"1\":{\"288\":1}}],[\"它只能审批1000元以下的借款\",{\"1\":{\"36\":1}}],[\"它只提供typec接口\",{\"1\":{\"27\":1}}],[\"它有一个任务执行的方法\",{\"1\":{\"292\":1}}],[\"它有一个接收通知对象的方法\",{\"1\":{\"50\":1}}],[\"它有一个createsofa\",{\"1\":{\"44\":1}}],[\"它有一个抽象方法getname\",{\"1\":{\"41\":1}}],[\"它有一个核心的处理方法\",{\"1\":{\"35\":1}}],[\"它有读取和写入的功能\",{\"1\":{\"31\":1}}],[\"它是在对象被垃圾回收器回收之前调用的\",{\"1\":{\"437\":1}}],[\"它是throwable的一个子类\",{\"1\":{\"432\":1}}],[\"它是动态绑定来确定运行时对象的实际方法的调用\",{\"1\":{\"418\":1}}],[\"它是子类对父类的同名方法且具有相同的参数的重新实现\",{\"1\":{\"418\":1}}],[\"它是\",{\"1\":{\"404\":1}}],[\"它是collection框架的一部分\",{\"1\":{\"351\":1}}],[\"它是一种特殊的队列\",{\"1\":{\"264\":1}}],[\"它是一种独占锁\",{\"1\":{\"219\":1}}],[\"它是一个最终类\",{\"1\":{\"435\":1}}],[\"它是一个抽象的计算机\",{\"1\":{\"433\":1}}],[\"它是一个抽象类\",{\"1\":{\"401\":1}}],[\"它是一个对象数组\",{\"1\":{\"406\":1}}],[\"它是一个顶级父类\",{\"1\":{\"401\":1}}],[\"它是一个特殊的线程池\",{\"1\":{\"346\":1}}],[\"它是一个threadlocal\",{\"1\":{\"282\":1}}],[\"它是一个有界队列\",{\"1\":{\"266\":1}}],[\"它是一个瞬时向量结果\",{\"1\":{\"82\":1}}],[\"它是一个基础能力\",{\"1\":{\"80\":1}}],[\"它是可增可减的\",{\"1\":{\"77\":1}}],[\"它是实现动态代理的关键\",{\"1\":{\"56\":1}}],[\"它是目标接口\",{\"1\":{\"30\":1}}],[\"它是为了解决具体的编码问题或者是解决某一类问题而产生的\",{\"1\":{\"8\":1}}],[\"它又称为包装器模式\",{\"1\":{\"29\":1}}],[\"它必须持有或者实现目标类和适配类的接口\",{\"1\":{\"25\":1}}],[\"它的方法都使用了synchronized关键字来进行同步\",{\"1\":{\"421\":1}}],[\"它的子类filewriter\",{\"1\":{\"401\":1}}],[\"它的源码如下\",{\"1\":{\"367\":1}}],[\"它的类图如下所示\",{\"1\":{\"292\":1}}],[\"它的容量为3\",{\"1\":{\"267\":1}}],[\"它的入队和出队操作都是阻塞的\",{\"1\":{\"266\":1}}],[\"它的key和value都不允许为null值\",{\"1\":{\"224\":1}}],[\"它的设计思想是假定大多数情况下\",{\"1\":{\"150\":1}}],[\"它的优点如下\",{\"1\":{\"56\":1}}],[\"它的uml图如下所示\",{\"1\":{\"25\":1}}],[\"它的所有依赖项都会自动得到通知和更新\",{\"1\":{\"12\":1}}],[\"它属于懒汉模式\",{\"1\":{\"19\":1}}],[\"创建了一个新的\",{\"1\":{\"385\":1}}],[\"创建了两个线程\",{\"1\":{\"142\":1,\"143\":1,\"191\":1}}],[\"创建了两个线程t1和t2\",{\"1\":{\"119\":1,\"160\":1}}],[\"创建多个completablefuture\",{\"1\":{\"342\":1}}],[\"创建多个线程并执行任务\",{\"1\":{\"281\":1}}],[\"创建两个completablefuture\",{\"1\":{\"341\":1}}],[\"创建阶段\",{\"1\":{\"293\":1}}],[\"创建线程\",{\"1\":{\"313\":1}}],[\"创建线程池\",{\"1\":{\"303\":1}}],[\"创建线程池和cyclicbarrier对象\",{\"1\":{\"203\":1}}],[\"创建线程的开销很大\",{\"1\":{\"291\":1}}],[\"创建一个文件对象\",{\"1\":{\"405\":1}}],[\"创建一个新的\",{\"1\":{\"377\":1}}],[\"创建一个线程池\",{\"1\":{\"323\":1,\"336\":1}}],[\"创建一个线程\",{\"1\":{\"323\":1}}],[\"创建一个\",{\"1\":{\"323\":6,\"336\":2,\"352\":1,\"353\":1,\"354\":1,\"375\":1,\"406\":1}}],[\"创建一个thread\",{\"1\":{\"313\":1}}],[\"创建一个生产者线程和一个消费者线程\",{\"1\":{\"267\":1}}],[\"创建一个最多存储3个元素的\",{\"1\":{\"267\":1}}],[\"创建\",{\"1\":{\"247\":1,\"401\":1,\"406\":1,\"407\":1}}],[\"创建迭代器以后\",{\"1\":{\"235\":1}}],[\"创建锁与条件变量\",{\"1\":{\"186\":1}}],[\"创建子类对象代理\",{\"1\":{\"57\":1}}],[\"创建和业务逻辑判断\",{\"1\":{\"41\":1}}],[\"创建者模式\",{\"1\":{\"10\":1}}],[\"创建型设计模式\",{\"1\":{\"10\":1}}],[\"创建型模式\",{\"0\":{\"10\":1}}],[\"剩下的设计模式会在写完java面试系列文章之后做为补充\",{\"1\":{\"8\":1}}],[\"那\",{\"1\":{\"392\":1}}],[\"那就是\",{\"1\":{\"392\":1}}],[\"那要记录一整年的数据\",{\"1\":{\"392\":1}}],[\"那线程退出monitor\",{\"1\":{\"147\":1}}],[\"那prometheus不适合什么\",{\"1\":{\"65\":1}}],[\"那它的缺点是\",{\"1\":{\"41\":1}}],[\"那么当外部类方法执行完毕的时候\",{\"1\":{\"436\":1}}],[\"那么hashcode\",{\"1\":{\"431\":2}}],[\"那么它们的hashcode\",{\"1\":{\"431\":1}}],[\"那么它们之间的\",{\"1\":{\"429\":2}}],[\"那么它的生命周期会与classloader相同\",{\"1\":{\"285\":1}}],[\"那么在设计时可以考虑将类设计为抽象类\",{\"1\":{\"419\":1}}],[\"那么在多线程环境下就可能发生竞态条件\",{\"1\":{\"120\":1}}],[\"那么会将新的值替换旧的值\",{\"1\":{\"386\":1}}],[\"那么会返回\",{\"1\":{\"386\":1}}],[\"那么command永远不会执行\",{\"1\":{\"311\":1}}],[\"那么继续提交的任务就会根据线程池的拒绝策略处理\",{\"1\":{\"302\":1}}],[\"那么这些多余的线程将会被终止\",{\"1\":{\"296\":1}}],[\"那么默认生成的table大小为16\",{\"1\":{\"259\":1}}],[\"那么如果头结点不为空并且头结点的状态不为0\",{\"1\":{\"174\":1}}],[\"那么如何学习好设计模式呢\",{\"1\":{\"8\":1}}],[\"那么\",{\"1\":{\"173\":1}}],[\"那么i++是原子性操作吗\",{\"1\":{\"126\":1}}],[\"那么每秒的增量率\",{\"1\":{\"92\":1}}],[\"那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑\",{\"1\":{\"51\":1}}],[\"那么为什么还需要使用适配器模式呢\",{\"1\":{\"27\":1}}],[\"那为什么要使用volatile关键字来修饰静态的instance对象呢\",{\"1\":{\"19\":1}}],[\"那本系列教程将会讲述23种经典的设计模式\",{\"1\":{\"8\":1}}],[\"要注意的是\",{\"1\":{\"429\":1}}],[\"要调用子类特有的方法\",{\"1\":{\"424\":1}}],[\"要把键值对\",{\"1\":{\"376\":1}}],[\"要求所有应等待线程数在创建时就指定\",{\"1\":{\"202\":1}}],[\"要求springboot>=2\",{\"1\":{\"97\":1}}],[\"要更新后的值\",{\"1\":{\"175\":1}}],[\"要解决或避免死锁\",{\"1\":{\"140\":1}}],[\"要么一直阻塞知道被其他线程唤醒\",{\"1\":{\"331\":1}}],[\"要么阻塞特定时间\",{\"1\":{\"331\":1}}],[\"要么被取消\",{\"1\":{\"331\":1}}],[\"要么异常结束\",{\"1\":{\"331\":1}}],[\"要么正常结束\",{\"1\":{\"331\":1}}],[\"要么失败\",{\"1\":{\"126\":1}}],[\"要么成功\",{\"1\":{\"126\":1}}],[\"要么全部不执行\",{\"1\":{\"120\":1}}],[\"要么全部执行成功\",{\"1\":{\"120\":1}}],[\"要写出高质量的并发程序\",{\"1\":{\"122\":1}}],[\"要做一些优化工作\",{\"1\":{\"51\":1}}],[\"要做到知其然并知其所以然\",{\"1\":{\"8\":1}}],[\"要尽量先使用组合关系来实现\",{\"1\":{\"14\":1}}],[\"要深挖技术背后的原因\",{\"1\":{\"8\":1}}],[\"刻意的去练习\",{\"1\":{\"8\":1}}],[\"我们调用了divide方法并将结果存储在result变量中\",{\"1\":{\"432\":1}}],[\"我们调用的是get\",{\"1\":{\"378\":1}}],[\"我们需要使用相同的属性来计算hashcode\",{\"1\":{\"431\":1}}],[\"我们需要有一些专注力\",{\"1\":{\"8\":1}}],[\"我们对对象内容的比较\",{\"1\":{\"430\":1}}],[\"我们将字符串数据写入到缓冲区\",{\"1\":{\"405\":1}}],[\"我们将task作为参数传入futuretask构造器创建一个futuretask对象futuretask\",{\"1\":{\"323\":1}}],[\"我们完全可以自己建立一个linenumberoutputstream\",{\"1\":{\"401\":1}}],[\"我们看看这些字节流中不太对称的几个类吧\",{\"1\":{\"401\":1}}],[\"我们看shouldparkafterfailedacquire函数\",{\"1\":{\"173\":1}}],[\"我们并不关心值的内容\",{\"1\":{\"386\":1}}],[\"我们检查了任务的大小是否小于阈值\",{\"1\":{\"349\":1}}],[\"我们定义了一个继承\",{\"1\":{\"349\":1}}],[\"我们使用try\",{\"1\":{\"432\":1}}],[\"我们使用父类\",{\"1\":{\"424\":1}}],[\"我们使用\",{\"1\":{\"340\":1,\"341\":1,\"342\":1}}],[\"我们使用synchronized关键字来同步代码块\",{\"1\":{\"139\":1}}],[\"我们首先通过\",{\"1\":{\"339\":1,\"340\":1}}],[\"我们首先创建一个固定大小为\",{\"1\":{\"323\":1}}],[\"我们会使用future+thread的方式来实现\",{\"1\":{\"336\":1}}],[\"我们一般使用多线程来提交系统的吞吐量\",{\"1\":{\"336\":1}}],[\"我们关闭线程池\",{\"1\":{\"323\":2}}],[\"我们希望父线程设置的threadlocal变量的值可以被其创建的子线程继承和使用\",{\"1\":{\"288\":1}}],[\"我们创建了两个\",{\"1\":{\"341\":1,\"342\":1}}],[\"我们创建了两个线程\",{\"1\":{\"139\":1}}],[\"我们创建了一个线程\",{\"1\":{\"323\":1}}],[\"我们创建了一个callable对象task\",{\"1\":{\"323\":1}}],[\"我们创建了一个生产者线程和一个消费者线程\",{\"1\":{\"267\":1}}],[\"我们创建了一个\",{\"1\":{\"267\":1,\"323\":1}}],[\"我们每次在执行while\",{\"1\":{\"203\":1}}],[\"我们手写一个简单的aqs\",{\"1\":{\"175\":1}}],[\"我们都会在后面讲到\",{\"1\":{\"164\":1}}],[\"我们都会选择使用histogram类型的指标去做分位数的统计\",{\"1\":{\"79\":1}}],[\"我们应该能很清楚的看出synchronized的实现原理\",{\"1\":{\"147\":1}}],[\"我们就可以看到上面类的字节码信息\",{\"1\":{\"147\":1}}],[\"我们先通过反编译下面的代码来看看synchronized是如何实现对代码块进行同步的\",{\"1\":{\"147\":1}}],[\"我们先来了解synchronized的原理\",{\"1\":{\"147\":1}}],[\"我们先看看计算机系统的基本组成部分\",{\"1\":{\"118\":1}}],[\"我们通过\",{\"1\":{\"323\":2}}],[\"我们通过线性化的方式来获取锁\",{\"1\":{\"143\":1}}],[\"我们通过比较id字段的大小\",{\"1\":{\"143\":1}}],[\"我们依然有两个account对象\",{\"1\":{\"143\":1}}],[\"我们引入了resmanager类来管理资源的申请和释放\",{\"1\":{\"142\":1}}],[\"我们有两个account对象\",{\"1\":{\"139\":1,\"142\":1}}],[\"我们预期的结果是10000\",{\"1\":{\"132\":1}}],[\"我们期望j=1\",{\"1\":{\"127\":1}}],[\"我们期望的最终a的结果是2\",{\"1\":{\"120\":1}}],[\"我们还可以通过histogram\",{\"1\":{\"78\":1}}],[\"我们可以实现代码的解耦和类之间的松耦合\",{\"1\":{\"419\":1}}],[\"我们可以从这个类中得到一定的技巧\",{\"1\":{\"401\":1}}],[\"我们可以处理所有任务完成后的逻辑操作\",{\"1\":{\"342\":1}}],[\"我们可以处理首先完成的任务的结果\",{\"1\":{\"341\":1}}],[\"我们可以好理解\",{\"1\":{\"288\":1}}],[\"我们可以通过futuretask\",{\"1\":{\"323\":1}}],[\"我们可以通过过滤器等进行回收方法的调用\",{\"1\":{\"287\":1}}],[\"我们可以通过破坏死锁发生条件中的三个条件来避免死锁的发生\",{\"1\":{\"141\":1}}],[\"我们可以看到以下代码块\",{\"1\":{\"139\":1}}],[\"我们可以看出代理模式有三个关键角色\",{\"1\":{\"53\":1}}],[\"我们可以看出适配器模式中包含三个关键角色\",{\"1\":{\"25\":1}}],[\"我们可以根据指标的名称可以反推出指标的表达式\",{\"1\":{\"115\":1}}],[\"我们可以将一组相关的规则设置定义在一个group下\",{\"1\":{\"108\":1}}],[\"我们可以计算所有handler\",{\"1\":{\"90\":1}}],[\"我们可以使用cyclicbarrier也可以达到同样的效果\",{\"1\":{\"203\":1}}],[\"我们可以使用一个计数器\",{\"1\":{\"191\":1}}],[\"我们可以使用offset关键字\",{\"1\":{\"83\":1}}],[\"我们可以使用求平均值来量化指标\",{\"1\":{\"78\":1}}],[\"我们可以直接输入指标名查询所有的这个指标名的时间序列\",{\"1\":{\"81\":1}}],[\"我们可以提前预测在未来什么时间节点上需要对资源进行扩容\",{\"1\":{\"65\":1}}],[\"我们可以得出以下的一些结论\",{\"1\":{\"37\":1}}],[\"我们经常有一些审批流程\",{\"1\":{\"36\":1}}],[\"我们来思考一下\",{\"1\":{\"32\":1}}],[\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解\",{\"1\":{\"25\":1}}],[\"我们主要讲解最常用到的适配器模式\",{\"1\":{\"25\":1}}],[\"我觉得需要刻意练习\",{\"1\":{\"8\":1}}],[\"都指向常量池中的同一个字符串对象\",{\"1\":{\"429\":1}}],[\"都包含两个引用\",{\"1\":{\"366\":1}}],[\"都完成后执行回调函数\",{\"1\":{\"342\":1}}],[\"都完成后执行回调函数时\",{\"1\":{\"342\":1}}],[\"都可以用于比较\",{\"1\":{\"428\":1}}],[\"都可以被另外一个线程执行\",{\"1\":{\"325\":1}}],[\"都可以通过以下配置\",{\"1\":{\"113\":1}}],[\"都会回收掉只被弱引用关联的对象实例\",{\"1\":{\"286\":1}}],[\"都会让程序员在技术的海洋里迷失\",{\"1\":{\"8\":1}}],[\"都能够保证在最后调用\",{\"1\":{\"203\":1}}],[\"都需要一个共享的对象作为锁\",{\"1\":{\"146\":1}}],[\"都需要良好的程序设计\",{\"1\":{\"8\":1}}],[\"都拥有自己的高速缓存\",{\"1\":{\"124\":1}}],[\"都是小于10000\",{\"1\":{\"132\":1}}],[\"都是以当前时间为基准的\",{\"1\":{\"83\":1}}],[\"都是以time\",{\"1\":{\"75\":1}}],[\"都是在不改变同一个接口功能的前提下\",{\"1\":{\"52\":1}}],[\"都是在程序启动之初创建\",{\"1\":{\"18\":1}}],[\"都很方便替换\",{\"1\":{\"27\":1}}],[\"多态性是继承的一个重要应用\",{\"1\":{\"424\":1}}],[\"多态主要体现在方法的重写和方法的动态绑定上\",{\"1\":{\"424\":1}}],[\"多态是面向对象编程的一个核心概念\",{\"1\":{\"424\":1}}],[\"多继承可能导致菱形继承问题\",{\"1\":{\"420\":1}}],[\"多继承是指一个类可以从多个父类继承属性和方法\",{\"1\":{\"420\":1}}],[\"多继承的支持\",{\"1\":{\"419\":1}}],[\"多路复用\",{\"1\":{\"412\":1}}],[\"多线程环境下需要额外的同步处理\",{\"1\":{\"392\":1}}],[\"多余的线程将会根据\",{\"1\":{\"296\":1}}],[\"多余的线程会根据\",{\"1\":{\"296\":1}}],[\"多个线程可以同时访问不同的段\",{\"1\":{\"245\":1}}],[\"多个线程可以同时获取读锁\",{\"1\":{\"220\":1,\"221\":1}}],[\"多个线程可同时执行\",{\"1\":{\"164\":1}}],[\"多次运行main函数\",{\"1\":{\"132\":1}}],[\"多维的数据结构\",{\"1\":{\"62\":1}}],[\"多应用\",{\"1\":{\"8\":1}}],[\"多练\",{\"1\":{\"8\":1}}],[\"越来越体会到系统是运营出来的\",{\"1\":{\"8\":1}}],[\"这将导致在存储和查找对象时出现问题\",{\"1\":{\"431\":1}}],[\"这将导致具有相等内容的对象\",{\"1\":{\"431\":1}}],[\"这将使整个方法成为一个临界区\",{\"1\":{\"146\":1}}],[\"这会触发内核中的\",{\"1\":{\"416\":1}}],[\"这段代码实现了一个基于\",{\"1\":{\"414\":1,\"415\":1}}],[\"这也说明了finally语句被执行的必要条件是\",{\"1\":{\"438\":1}}],[\"这也会降低吞吐量\",{\"1\":{\"300\":1}}],[\"这也是和nonfair最大的区别\",{\"1\":{\"185\":1}}],[\"这有助于快速响应任务请求并提供较低的响应延迟\",{\"1\":{\"295\":1}}],[\"这么做的原因是\",{\"1\":{\"291\":1}}],[\"这使得它非常适用于需要同时处理大量连接的网络编程场景\",{\"1\":{\"407\":1}}],[\"这使得它可以代理更多类型的类\",{\"1\":{\"57\":1}}],[\"这使得\",{\"1\":{\"371\":1}}],[\"这使得concurrenthashmap在高并发情况下拥有更好的性能表现\",{\"1\":{\"246\":1}}],[\"这使得concurrenthashmap成为处理高并发情况下的线程安全哈希表的理想选择\",{\"1\":{\"245\":1}}],[\"这就实现了运行时的动态绑定\",{\"1\":{\"424\":1}}],[\"这就造成了不公平的现象\",{\"1\":{\"185\":1}}],[\"这就是伪共享\",{\"1\":{\"347\":1}}],[\"这就是使用inheritablethreadlocal的场景\",{\"1\":{\"288\":1}}],[\"这就是为什么synchronized效率低的原因\",{\"1\":{\"148\":1}}],[\"这就是为什么只有在同步的块或者方法中才能调用wait\",{\"1\":{\"147\":1}}],[\"这就是线程切换带来的原子性的问题\",{\"1\":{\"120\":1}}],[\"这就是缓存可见性的问题\",{\"1\":{\"119\":1}}],[\"这\",{\"1\":{\"157\":1}}],[\"这对于大多数情况下只有一个线程访问对象的场景非常有效\",{\"1\":{\"153\":1}}],[\"这意味着你可以在多个线程中安全地操作队列而无需额外的同步控制\",{\"1\":{\"264\":1}}],[\"这意味着可以将不必要的同步操作消除\",{\"1\":{\"153\":1}}],[\"这意味着在开始执行之前\",{\"1\":{\"141\":1}}],[\"这意味着在多核cpu上\",{\"1\":{\"120\":1}}],[\"这项优化特别适用于线程独占锁的场景\",{\"1\":{\"150\":1}}],[\"这可以通过使用乘法和加法等算法来实现\",{\"1\":{\"431\":1}}],[\"这可以通过引入资源的优先级和超时机制来实现\",{\"1\":{\"141\":1}}],[\"这可能导致意外的结果\",{\"1\":{\"423\":1}}],[\"这可能会引起无限循环或抛出异常\",{\"1\":{\"57\":1}}],[\"这10个线程共享一个变量inc\",{\"1\":{\"132\":1}}],[\"这两个greeting方法有不同的参数个数\",{\"1\":{\"418\":1}}],[\"这两个流对象是字符体系中的成员\",{\"1\":{\"401\":1}}],[\"这两个类的uml图如下\",{\"1\":{\"366\":1}}],[\"这两个任务都会等待其他线程到达屏障点\",{\"1\":{\"203\":1}}],[\"这两个操作\",{\"1\":{\"191\":1}}],[\"这两个方法会被子类调用\",{\"1\":{\"166\":1}}],[\"这两个标签对于同一个实例来说基本不变\",{\"1\":{\"90\":1}}],[\"这两种状态都被统称为runnable\",{\"1\":{\"157\":1}}],[\"这两行代码有可能发生指令重排\",{\"1\":{\"131\":1}}],[\"这一步是原子性操作\",{\"1\":{\"126\":1}}],[\"这引发了数据一致性的问题\",{\"1\":{\"124\":1}}],[\"这是个中间状态\",{\"1\":{\"332\":1}}],[\"这是一个中间状态\",{\"1\":{\"328\":1}}],[\"这是一个最终态\",{\"1\":{\"328\":4}}],[\"这是初始状态\",{\"1\":{\"328\":1}}],[\"这是默认的处理策略\",{\"1\":{\"302\":1}}],[\"这是考察线程同步的例子\",{\"1\":{\"160\":1}}],[\"这是因为我们在使用基于散列的数据结构\",{\"1\":{\"431\":1}}],[\"这是因为在\",{\"1\":{\"416\":1}}],[\"这是因为防止编译器进行编译优化\",{\"1\":{\"121\":1}}],[\"这是因为t1和t2线程共同对变量a进行自增操作\",{\"1\":{\"119\":1}}],[\"这是项目主页的案例\",{\"1\":{\"1\":1,\"2\":1}}],[\"这与equals\",{\"1\":{\"431\":1}}],[\"这与\",{\"1\":{\"118\":1}}],[\"这允许在系统或服务之间建立依赖关系\",{\"1\":{\"107\":1}}],[\"这在系统出现大量故障的时候非常有用\",{\"1\":{\"103\":1}}],[\"这里简单罗列概括成几点\",{\"1\":{\"392\":1}}],[\"这里的结束包括任务正常执行完毕\",{\"1\":{\"330\":1}}],[\"这里trylock\",{\"1\":{\"319\":1}}],[\"这里面涉及到keepalivetime的使用\",{\"1\":{\"314\":1}}],[\"这里把int的高3位拿来充当线程池状态的标志位\",{\"1\":{\"308\":1}}],[\"这里使用固定大小为\",{\"1\":{\"323\":1}}],[\"这里使用了工厂模式threadfactory创建新线程\",{\"1\":{\"301\":1}}],[\"这里使用prometheus\",{\"1\":{\"92\":1}}],[\"这里我们可以看到set中key为this\",{\"1\":{\"282\":1}}],[\"这里我们以单例模式经典的懒汉式初始化方式为例\",{\"1\":{\"17\":1}}],[\"这里是需要线程同步的代码块\",{\"1\":{\"146\":2}}],[\"这里一次性申请性申请了所有的资源\",{\"1\":{\"142\":1}}],[\"这几个handler构成了一个链式的处理顺序\",{\"1\":{\"35\":1}}],[\"这时主线程只需通过yield方法让出cpu资源\",{\"1\":{\"317\":1}}],[\"这时一个非常常见的面试题\",{\"1\":{\"160\":1}}],[\"这时获取子线程的状态为blocked状态\",{\"1\":{\"158\":1}}],[\"这时会有线程切换的开销\",{\"1\":{\"148\":1}}],[\"这时需要用锁来保证\",{\"1\":{\"132\":1}}],[\"这时数据就会出现问题\",{\"1\":{\"132\":1}}],[\"这时j的值为0\",{\"1\":{\"127\":1}}],[\"这时我们需要一个拓展坞\",{\"1\":{\"25\":1}}],[\"这时程序会出错\",{\"1\":{\"19\":1,\"121\":1}}],[\"这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象\",{\"1\":{\"424\":1}}],[\"这种设计思想能够提高代码的可读性\",{\"1\":{\"420\":1}}],[\"这种结构使得在插入和删除元素时具有较高的效率\",{\"1\":{\"371\":1}}],[\"这种最常用\",{\"1\":{\"359\":1}}],[\"这种依托队列处理任务的方式恰与synchronousqueue依托线程处理任务的方式相反\",{\"1\":{\"299\":1}}],[\"这种依赖于操作系统mutex\",{\"1\":{\"148\":1}}],[\"这种场景下maximumpoolsize的值对于线程数量没有任何影响\",{\"1\":{\"299\":1}}],[\"这种队列方式通常需要无限的maximumpoolsizes以避免拒绝新提交的任务\",{\"1\":{\"298\":1}}],[\"这种情况是不会发生内存泄漏的\",{\"1\":{\"287\":1}}],[\"这种情况下可能会发生死锁\",{\"1\":{\"139\":1}}],[\"这种情况下在多线程下是不安全的\",{\"1\":{\"22\":1}}],[\"这种快照风格的迭代器方法在创建迭代器时使用了对当时数组状态的引用\",{\"1\":{\"235\":1}}],[\"这种优化技术可以避免频繁的锁释放和获取操作带来的开销\",{\"1\":{\"153\":1}}],[\"这种阻塞的机制会导致线程的上下文切换\",{\"1\":{\"152\":1}}],[\"这种自动处理的方式简化了代码编写\",{\"1\":{\"147\":1}}],[\"这种方式可以减少线程阻塞和切换的开销\",{\"1\":{\"153\":1}}],[\"这种方式可以避免在时间窗口范围内的\",{\"1\":{\"92\":1}}],[\"这种方式假设每个账户具有唯一的id\",{\"1\":{\"143\":1}}],[\"这种双重检查模式经常在面试中被考察\",{\"1\":{\"19\":1}}],[\"这种模式称为饿汉模式\",{\"1\":{\"18\":1}}],[\"这种模式是在类加载的时候就完成了对象的实例化\",{\"1\":{\"18\":1}}],[\"这个局部变量肯定也就被gc了\",{\"1\":{\"436\":1}}],[\"这个程序使用\",{\"1\":{\"414\":1}}],[\"这个构造函数没有参数\",{\"1\":{\"385\":1}}],[\"这个过程称为扩容\",{\"1\":{\"358\":1}}],[\"这个示例展示了如何使用\",{\"1\":{\"340\":1}}],[\"这个转换过程对应上图中的四\",{\"1\":{\"332\":2}}],[\"这个时候他所引用的外部变量已经找不到了\",{\"1\":{\"436\":1}}],[\"这个时候会把第一轮循环中生成的节点的netx指针指向waiters\",{\"1\":{\"331\":1}}],[\"这个时候有两个线程threada和threadb先后调用get\",{\"1\":{\"331\":1}}],[\"这个时候调用线程让出执行权让其他线程优先执行\",{\"1\":{\"331\":1}}],[\"这个时候让出执行权让其他线程优先执行\",{\"1\":{\"331\":1}}],[\"这个时候状态会从new转化为cancelled状态\",{\"1\":{\"328\":1}}],[\"这个方法的实现比较简单\",{\"1\":{\"333\":1}}],[\"这个方法跟上面分析的setexception\",{\"1\":{\"329\":1}}],[\"这个方法里面\",{\"1\":{\"186\":2}}],[\"这个状态转换对应着上图中的一\",{\"1\":{\"329\":1}}],[\"这个状态转换对应着上图中的二\",{\"1\":{\"329\":1}}],[\"这个状态可以是自定义的\",{\"1\":{\"163\":1}}],[\"这个属性是用来存放\",{\"1\":{\"308\":1}}],[\"这个属性相当重要\",{\"1\":{\"195\":1}}],[\"这个线程就处于新建状态\",{\"1\":{\"156\":1}}],[\"这个成本非常高\",{\"1\":{\"148\":1}}],[\"这个对象是一个定制化的map\",{\"1\":{\"282\":1}}],[\"这个对象可以是任何\",{\"1\":{\"146\":1}}],[\"这个对于prometheus的告警消息来说\",{\"1\":{\"107\":1}}],[\"这个内存屏障具有特殊的作用\",{\"1\":{\"145\":1}}],[\"这个内置指标对请求耗时统计不是做的很好\",{\"1\":{\"97\":1}}],[\"这个复杂操作是原子性的\",{\"1\":{\"126\":1}}],[\"这个文件是告警规则计算的配置\",{\"1\":{\"108\":1}}],[\"这个平均值是不能反应的请求的真实状态\",{\"1\":{\"78\":1}}],[\"这个配置文件是prometheus启动的时候会读取的配置\",{\"1\":{\"68\":1}}],[\"这个页面提供了对prometheus数据的查询和告警信息的查询\",{\"1\":{\"67\":1}}],[\"这个数据结构包括一个指标名和一系列的键值对\",{\"1\":{\"62\":1}}],[\"这个代理类本身已经继承了jdk包中的proxy对象\",{\"1\":{\"56\":1}}],[\"这个职责是唯一引起该类变化的原因\",{\"1\":{\"14\":1}}],[\"这个原则在面试过程中会经常被问到\",{\"1\":{\"14\":1}}],[\"这组对象会将它们的交互委托给中介者对象\",{\"1\":{\"12\":1}}],[\"这样finally语句就不会执行\",{\"1\":{\"438\":1}}],[\"这样的语句\",{\"1\":{\"438\":1}}],[\"这样的话\",{\"1\":{\"436\":1}}],[\"这样的处理方式让写的同学更加明确线程池的运行规则\",{\"1\":{\"304\":1}}],[\"这样调用者就能清楚地知道需要处理哪些异常\",{\"1\":{\"432\":1}}],[\"这样做的好处是实现了代码的灵活性\",{\"1\":{\"424\":1}}],[\"这样做的好处是可以通过统一的接口来操作不同的子类对象\",{\"1\":{\"424\":1}}],[\"这样做可能导致竞态条件\",{\"1\":{\"119\":1}}],[\"这样迭代过程中使用的是原来的底层数组快照\",{\"1\":{\"242\":1}}],[\"这样保证了写操作的线程安全性\",{\"1\":{\"229\":1}}],[\"这样一来\",{\"1\":{\"223\":1,\"229\":1,\"245\":1,\"416\":1}}],[\"这样无论线程是否发生异常\",{\"1\":{\"203\":1}}],[\"这样\",{\"1\":{\"151\":1,\"267\":1,\"285\":1}}],[\"这样有助于避免忘记解锁而导致的问题\",{\"1\":{\"147\":1}}],[\"这样可以兼顾抽象类和接口的优势\",{\"1\":{\"419\":1}}],[\"这样可以允许多个读线程同时获取读锁\",{\"1\":{\"220\":1}}],[\"这样可以减少线程间的竞争\",{\"1\":{\"153\":1}}],[\"这样可以减少同步的范围\",{\"1\":{\"146\":1}}],[\"这样可以避免任务丢失\",{\"1\":{\"302\":1}}],[\"这样可以避免多个线程共享同一个数据库连接时的并发问题\",{\"1\":{\"283\":1}}],[\"这样可以避免某个桶中的结点数量太大\",{\"1\":{\"259\":1}}],[\"这样可以避免线程之间的循环等待\",{\"1\":{\"141\":1}}],[\"这样可以避免接受一些与实际问题相关的告警\",{\"1\":{\"104\":1}}],[\"这样就可以管理多个网络连接\",{\"1\":{\"412\":1}}],[\"这样就可以手动创建线程来执行futuretask\",{\"1\":{\"323\":1}}],[\"这样就可以利用\",{\"1\":{\"323\":1}}],[\"这样就可以确保多线程在共享数据时不会出现意外的错误\",{\"1\":{\"124\":1}}],[\"这样就完成了元素的添加\",{\"1\":{\"238\":1}}],[\"这样就能确保多个线程对\",{\"1\":{\"146\":1}}],[\"这样就能保证inc++的正确性了啊\",{\"1\":{\"132\":1}}],[\"这样就形成了循环等待的死锁情况\",{\"1\":{\"139\":1}}],[\"这样就降低了客户与实现模块间的耦合\",{\"1\":{\"14\":1}}],[\"这样其他处理器在需要读取该变量时\",{\"1\":{\"124\":1}}],[\"这样真的一目了然\",{\"1\":{\"115\":1}}],[\"这样webhook的程序收到告警消息后\",{\"1\":{\"110\":1}}],[\"这样不仅增加了代码的耦合性\",{\"1\":{\"51\":1}}],[\"这样代码会非常的臃肿\",{\"1\":{\"27\":1}}],[\"这样当一个对象改变状态时\",{\"1\":{\"12\":1}}],[\"这样只会原地踏步走\",{\"1\":{\"8\":1}}],[\"这些包装类实现了相应类型的对象类型\",{\"1\":{\"423\":1}}],[\"这些抽象方法通常是定义了一组规范或者行为\",{\"1\":{\"419\":1}}],[\"这些基本的io流类提供了在java程序中进行输入输出操作的基础功能\",{\"1\":{\"399\":1}}],[\"这些红黑树节点被实现为\",{\"1\":{\"374\":1}}],[\"这些预定义策略都实现了rejectedexecutionhandler接口\",{\"1\":{\"302\":1}}],[\"这些新的任务会被放入\",{\"1\":{\"297\":1}}],[\"这些核心线程会一直存在于线程池中\",{\"1\":{\"295\":1}}],[\"这些方法只有方法签名\",{\"1\":{\"419\":1}}],[\"这些方法具有相同的方法名称\",{\"1\":{\"418\":1}}],[\"这些方法可以通过不同的方式来处理队列已满或为空的情况\",{\"1\":{\"265\":1}}],[\"这些方法将抛出\",{\"1\":{\"235\":1}}],[\"这些节点被组织成一个数组\",{\"1\":{\"246\":1}}],[\"这些都是基于synchronized关键字实现的\",{\"1\":{\"222\":1}}],[\"这些都离不开设计模式的思想\",{\"1\":{\"8\":1}}],[\"这些优化技术在\",{\"1\":{\"153\":1}}],[\"这些协议帮助确保处理器之间的数据一致性\",{\"1\":{\"124\":1}}],[\"这些操作能够在队列满或为空时进行阻塞\",{\"1\":{\"264\":1}}],[\"这些操作需要消耗一定的系统资源\",{\"1\":{\"120\":1}}],[\"这些操作符使用于瞬时向量的查询\",{\"1\":{\"85\":1}}],[\"这些设备负责将数据从计算机系统的内存传输到外部世界\",{\"1\":{\"118\":1}}],[\"这些类型的指标在存储的时候\",{\"1\":{\"75\":1}}],[\"这些组件构成了一个完整的监控系统\",{\"1\":{\"64\":1}}],[\"这些在流水线的处理类对象构成了一个单项链表结构\",{\"1\":{\"34\":1}}],[\"这些规则的执行有先后顺序\",{\"1\":{\"34\":1}}],[\"这些对象一般只提供具体的方法\",{\"1\":{\"16\":1}}],[\"这些年技术层出不穷\",{\"1\":{\"8\":1}}],[\"这些年无论是生产环境遇到的事故\",{\"1\":{\"8\":1}}],[\"ftask\",{\"1\":{\"316\":3}}],[\"fh\",{\"1\":{\"259\":3,\"261\":3}}],[\"f\",{\"1\":{\"259\":15,\"261\":9}}],[\"future2\",{\"1\":{\"341\":4,\"342\":5}}],[\"future1\",{\"1\":{\"341\":5,\"342\":5}}],[\"future接口的定义如下\",{\"1\":{\"326\":1}}],[\"future接口代表异步计算的结果\",{\"1\":{\"326\":1}}],[\"future接口\",{\"0\":{\"326\":1}}],[\"futurewithexecutorserviceexample\",{\"1\":{\"323\":1}}],[\"future<v>\",{\"1\":{\"326\":1}}],[\"future<integer>\",{\"1\":{\"323\":1}}],[\"future<\",{\"1\":{\"316\":2}}],[\"future<t>\",{\"1\":{\"316\":2}}],[\"future<string>\",{\"1\":{\"315\":1}}],[\"future负责获取结果\",{\"1\":{\"315\":1}}],[\"future和callable基本是成对出现的\",{\"1\":{\"315\":1}}],[\"future\",{\"1\":{\"315\":4,\"322\":2,\"323\":11,\"339\":3,\"340\":4,\"348\":2}}],[\"futuretask源码解析\",{\"0\":{\"324\":1}}],[\"futuretaskexample\",{\"1\":{\"323\":1,\"336\":1}}],[\"futuretask<>\",{\"1\":{\"323\":2,\"336\":1}}],[\"futuretask<integer>\",{\"1\":{\"323\":2,\"336\":1}}],[\"futuretask<v>\",{\"1\":{\"317\":1}}],[\"futuretaskwiththreadexample\",{\"1\":{\"323\":1}}],[\"futuretask使用示例\",{\"0\":{\"323\":1}}],[\"futuretask实现了runnablefuture接口\",{\"1\":{\"322\":1,\"327\":1}}],[\"futuretask详解中已经讲解了这种实现\",{\"1\":{\"336\":1}}],[\"futuretask详解\",{\"0\":{\"321\":1}}],[\"futuretask\",{\"0\":{\"327\":1},\"1\":{\"318\":1,\"322\":4,\"323\":19,\"336\":6}}],[\"futuretask对象\",{\"0\":{\"317\":1}}],[\"futuretask任务执行完成后\",{\"1\":{\"315\":1}}],[\"futuretask等主要线程实现接口扩展\",{\"1\":{\"292\":1}}],[\"futuretask等同步器提供了基础支持\",{\"1\":{\"162\":1}}],[\"further\",{\"1\":{\"173\":1}}],[\"furniturefactory\",{\"1\":{\"46\":1,\"47\":3}}],[\"fulladdcount\",{\"1\":{\"259\":1}}],[\"full\",{\"1\":{\"173\":1,\"187\":3}}],[\"fund\",{\"1\":{\"139\":12,\"142\":8,\"143\":8}}],[\"fundtransfer\",{\"1\":{\"139\":5,\"142\":4,\"143\":4}}],[\"fewer\",{\"1\":{\"311\":1}}],[\"few\",{\"1\":{\"107\":1}}],[\"fruit\",{\"1\":{\"352\":8}}],[\"fruits\",{\"1\":{\"352\":17}}],[\"from\",{\"1\":{\"115\":1,\"173\":2,\"183\":2,\"415\":5}}],[\"front\",{\"1\":{\"1\":1,\"2\":1}}],[\"free\",{\"1\":{\"69\":1,\"77\":1,\"93\":1,\"173\":1,\"183\":3}}],[\"freed\",{\"1\":{\"68\":1}}],[\"flip\",{\"1\":{\"405\":3,\"406\":5,\"410\":1,\"411\":1,\"414\":3,\"415\":2}}],[\"flink\",{\"1\":{\"59\":1}}],[\"floatbuffer\",{\"1\":{\"403\":1,\"406\":1}}],[\"float\",{\"1\":{\"256\":1,\"375\":2,\"403\":1,\"423\":2,\"429\":1}}],[\"float64类型的值\",{\"1\":{\"74\":1}}],[\"flush\",{\"1\":{\"31\":1}}],[\"fallback\",{\"1\":{\"256\":1}}],[\"false\",{\"1\":{\"135\":1,\"142\":1,\"173\":3,\"174\":1,\"175\":2,\"183\":2,\"185\":1,\"197\":1,\"198\":1,\"199\":2,\"207\":1,\"213\":1,\"214\":1,\"239\":2,\"259\":1,\"261\":1,\"271\":1,\"274\":1,\"311\":4,\"312\":4,\"313\":1,\"314\":3,\"317\":2,\"318\":1,\"319\":1,\"328\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":3,\"353\":1,\"362\":1,\"387\":1,\"393\":1,\"395\":1,\"410\":2,\"411\":2,\"414\":2,\"415\":1,\"429\":4,\"430\":2}}],[\"factor\",{\"1\":{\"256\":1,\"375\":2}}],[\"factory=new\",{\"1\":{\"44\":1}}],[\"factory\",{\"1\":{\"39\":1,\"41\":2,\"42\":1,\"45\":1,\"47\":3}}],[\"fairsyn类\",{\"0\":{\"185\":1}}],[\"fairsync类的lock的方法调用如下\",{\"1\":{\"185\":1}}],[\"fairsync类也继承了sync类\",{\"1\":{\"185\":1}}],[\"fairsync\",{\"1\":{\"181\":1,\"185\":1}}],[\"fair\",{\"1\":{\"181\":2,\"185\":1,\"271\":4}}],[\"fails\",{\"1\":{\"173\":1,\"214\":1,\"311\":1}}],[\"fail\",{\"1\":{\"173\":1}}],[\"failed\",{\"1\":{\"173\":3,\"198\":4,\"199\":1,\"312\":1}}],[\"failure\",{\"1\":{\"173\":1,\"312\":1}}],[\"failures\",{\"1\":{\"115\":8}}],[\"fastremove\",{\"1\":{\"362\":3}}],[\"fast\",{\"1\":{\"173\":1}}],[\"fangzhipeng\",{\"1\":{\"31\":3,\"50\":3,\"262\":1}}],[\"filterreader\",{\"1\":{\"401\":1}}],[\"filechannelexample\",{\"1\":{\"405\":1}}],[\"filechannel\",{\"0\":{\"405\":1},\"1\":{\"403\":1,\"404\":1,\"405\":6}}],[\"file对象\",{\"1\":{\"401\":1}}],[\"file类保存文件或目录的各种元数据信息\",{\"1\":{\"401\":1}}],[\"file类是对文件系统中文件以及文件夹进行封装的对象\",{\"1\":{\"401\":1}}],[\"file类\",{\"1\":{\"401\":1}}],[\"fileoutputstream\",{\"1\":{\"399\":1,\"401\":1}}],[\"fileinputstream\",{\"1\":{\"399\":1,\"401\":1}}],[\"file=alertmanager\",{\"1\":{\"106\":1}}],[\"files定义recoding\",{\"1\":{\"116\":1}}],[\"filesystem\",{\"1\":{\"69\":1,\"77\":4,\"93\":1}}],[\"files是配置告警规则文件的路径\",{\"1\":{\"68\":1}}],[\"files\",{\"1\":{\"68\":1,\"108\":1,\"116\":1}}],[\"filewriter\",{\"1\":{\"31\":7,\"399\":1}}],[\"filenotfoundexception\",{\"1\":{\"31\":1}}],[\"filepath=\",{\"1\":{\"31\":1}}],[\"filepath\",{\"1\":{\"31\":8}}],[\"file\",{\"1\":{\"29\":1,\"31\":8,\"399\":1,\"405\":3}}],[\"filereaderwriter=new\",{\"1\":{\"31\":1}}],[\"filereaderwriter\",{\"1\":{\"31\":5}}],[\"filereader\",{\"1\":{\"29\":3,\"31\":7,\"399\":1,\"401\":1}}],[\"field\",{\"1\":{\"175\":6}}],[\"fifo\",{\"1\":{\"163\":1,\"347\":1,\"351\":1}}],[\"firely\",{\"1\":{\"124\":1}}],[\"firstfruit\",{\"1\":{\"352\":2}}],[\"firsttask\",{\"1\":{\"312\":5,\"313\":9}}],[\"firsttask执行完成之后\",{\"1\":{\"310\":1}}],[\"firstvalue\",{\"1\":{\"282\":2}}],[\"firstwaiter\",{\"1\":{\"214\":2}}],[\"first\",{\"1\":{\"68\":1,\"108\":1,\"116\":1,\"175\":3,\"185\":1,\"214\":9,\"259\":3,\"261\":1,\"311\":1,\"352\":2,\"366\":2,\"368\":2,\"369\":1,\"370\":1,\"378\":14,\"406\":1}}],[\"finishconnect\",{\"1\":{\"415\":2}}],[\"finishcompletion方法\",{\"0\":{\"333\":1}}],[\"finishcompletion\",{\"1\":{\"329\":2,\"332\":1,\"333\":1}}],[\"finish\",{\"1\":{\"213\":1}}],[\"finished\",{\"1\":{\"31\":1}}],[\"findtreenode\",{\"1\":{\"259\":2,\"261\":1}}],[\"find\",{\"1\":{\"173\":1,\"260\":1}}],[\"fingerprint\",{\"1\":{\"110\":3}}],[\"finalreturn3\",{\"1\":{\"438\":1}}],[\"finalreturn2\",{\"1\":{\"438\":1}}],[\"finalreturn1\",{\"1\":{\"438\":1}}],[\"finalresult\",{\"1\":{\"340\":2}}],[\"final是java中的修饰符\",{\"1\":{\"437\":1}}],[\"finaldemo\",{\"1\":{\"436\":3}}],[\"finalobject\",{\"1\":{\"435\":1}}],[\"finalmethodedemo2是不能重新它的父类finalmethoddemo的final方法的\",{\"1\":{\"435\":1}}],[\"finalmethodedemo2\",{\"1\":{\"435\":1}}],[\"finalmethoddemo\",{\"1\":{\"435\":2}}],[\"finaltest\",{\"1\":{\"435\":2,\"438\":1}}],[\"final关键字的使用可以增加代码的可读性\",{\"1\":{\"435\":1}}],[\"final关键字的基本用法\",{\"0\":{\"435\":1}}],[\"final关键字可以用于修饰类\",{\"1\":{\"435\":1}}],[\"final关键字\",{\"1\":{\"435\":1}}],[\"final关键字详解\",{\"0\":{\"434\":1}}],[\"finalbit\",{\"1\":{\"395\":2}}],[\"finalize方法已经过时\",{\"1\":{\"437\":1}}],[\"finalize是一个方法\",{\"1\":{\"437\":1}}],[\"finalize的区别\",{\"0\":{\"426\":1,\"437\":1}}],[\"finalize\",{\"1\":{\"136\":1,\"437\":3}}],[\"finally语句中没有使用return操作\",{\"1\":{\"438\":1}}],[\"finally语句在java中用于定义一段无论是否发生异常都会执行的代码块\",{\"1\":{\"438\":1}}],[\"finally语句块都将执行\",{\"1\":{\"438\":2}}],[\"finally语句将在try块执行完毕后立即执行\",{\"1\":{\"438\":1}}],[\"finally语句也不会被执行到\",{\"1\":{\"438\":1}}],[\"finally语句到底是在return之前还是之后执行\",{\"0\":{\"438\":1},\"1\":{\"438\":1}}],[\"finally或其他资源管理机制来确保资源的释放\",{\"1\":{\"437\":1}}],[\"finally是java中的关键字\",{\"1\":{\"437\":1}}],[\"finally代码块中的代码始终会执行\",{\"1\":{\"432\":1}}],[\"finally的用法\",{\"1\":{\"432\":1}}],[\"finally块中的代码也会在return语句执行后执行\",{\"1\":{\"438\":1}}],[\"finally块中的代码也会在方法返回之前执行\",{\"1\":{\"437\":1}}],[\"finally块中的代码将在return语句执行之后\",{\"1\":{\"438\":1}}],[\"finally块中的代码都会被执行\",{\"1\":{\"437\":1,\"438\":1}}],[\"finally块通常用于释放资源\",{\"1\":{\"437\":1}}],[\"finally块在try块或catch块执行完毕后执行\",{\"1\":{\"432\":1}}],[\"finally块用于定义无论是否发生异常都需要执行的代码\",{\"1\":{\"432\":1}}],[\"finally块\",{\"1\":{\"432\":2}}],[\"finally异常处理语句模板\",{\"1\":{\"432\":1}}],[\"finally\",{\"0\":{\"426\":1,\"437\":1},\"1\":{\"31\":2,\"142\":1,\"173\":1,\"186\":4,\"187\":2,\"198\":1,\"203\":2,\"213\":2,\"219\":2,\"220\":2,\"221\":2,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"259\":2,\"271\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"277\":1,\"287\":1,\"312\":2,\"313\":3,\"318\":1,\"319\":5,\"329\":1,\"414\":1,\"415\":2,\"432\":1,\"437\":2,\"438\":9}}],[\"final\",{\"1\":{\"20\":1,\"132\":1,\"159\":1,\"163\":3,\"166\":3,\"168\":9,\"170\":8,\"173\":6,\"174\":1,\"175\":2,\"180\":2,\"183\":9,\"184\":4,\"185\":5,\"186\":2,\"195\":1,\"197\":2,\"198\":3,\"199\":1,\"208\":4,\"213\":3,\"214\":3,\"219\":1,\"220\":1,\"221\":1,\"233\":4,\"235\":3,\"238\":1,\"239\":1,\"240\":1,\"241\":1,\"256\":26,\"259\":7,\"261\":1,\"270\":5,\"271\":1,\"273\":2,\"274\":1,\"275\":2,\"276\":1,\"277\":3,\"293\":5,\"308\":3,\"309\":8,\"312\":3,\"313\":3,\"317\":8,\"319\":4,\"328\":7,\"329\":2,\"331\":1,\"332\":1,\"349\":1,\"360\":1,\"362\":3,\"364\":1,\"370\":3,\"376\":2,\"378\":1,\"414\":3,\"419\":1,\"435\":8,\"436\":2}}],[\"found\",{\"1\":{\"362\":3}}],[\"forkjoinexample\",{\"1\":{\"349\":1}}],[\"forkjoinworkerthreadfactory\",{\"1\":{\"347\":3}}],[\"forkjointask继承关系\",{\"0\":{\"348\":1}}],[\"forkjointask\",{\"1\":{\"346\":2,\"347\":1,\"348\":3}}],[\"forkjoinpool继承关系\",{\"0\":{\"347\":1}}],[\"forkjoinpool\",{\"1\":{\"346\":2,\"347\":2,\"348\":1,\"349\":5,\"350\":1}}],[\"fork\",{\"0\":{\"344\":1},\"1\":{\"345\":2,\"346\":4,\"347\":1,\"348\":1,\"349\":3}}],[\"forwardingnode<k\",{\"1\":{\"259\":1}}],[\"forwardingnode\",{\"1\":{\"259\":1}}],[\"forwarding\",{\"1\":{\"256\":1}}],[\"foreach\",{\"1\":{\"352\":1}}],[\"foreachremaining\",{\"1\":{\"235\":1}}],[\"forezp\",{\"1\":{\"24\":2,\"31\":1,\"36\":2,\"50\":5,\"98\":1,\"119\":1,\"139\":1,\"142\":1,\"147\":1,\"159\":1,\"160\":1,\"175\":1,\"187\":1,\"191\":2,\"203\":1,\"219\":1,\"221\":1,\"336\":1,\"341\":1,\"342\":1,\"349\":1,\"414\":1,\"415\":1,\"438\":1}}],[\"for\",{\"1\":{\"31\":2,\"50\":1,\"107\":5,\"108\":2,\"119\":2,\"132\":2,\"173\":3,\"175\":1,\"197\":1,\"198\":3,\"199\":2,\"208\":1,\"213\":1,\"214\":1,\"230\":1,\"235\":1,\"239\":2,\"247\":3,\"256\":6,\"259\":4,\"261\":2,\"271\":2,\"277\":1,\"312\":2,\"314\":1,\"317\":1,\"319\":3,\"323\":3,\"331\":1,\"333\":2,\"336\":1,\"349\":1,\"352\":4,\"353\":2,\"354\":4,\"362\":2,\"363\":2,\"369\":2,\"376\":3,\"377\":1,\"383\":1,\"393\":1,\"395\":14,\"431\":1}}],[\"footprint\",{\"1\":{\"333\":1}}],[\"foo\",{\"0\":{\"7\":1}}],[\"幻灯片页\",{\"0\":{\"3\":1}}],[\"项目主页配置\",{\"1\":{\"1\":1,\"2\":1}}],[\"你可以使用\",{\"1\":{\"341\":1,\"342\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"1\":1,\"2\":1}}],[\"你看到的都是熟悉的\",{\"1\":{\"186\":1}}],[\"你会发现结果永远都不会为10000\",{\"1\":{\"132\":1}}],[\"你需要在页面\",{\"1\":{\"1\":1,\"2\":1}}],[\"想要使用此布局\",{\"1\":{\"1\":1,\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
