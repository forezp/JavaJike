const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":261,\"nextId\":261,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#更新计划\",\"2\":\"v-8daa1a0e#更新计划-1\",\"3\":\"v-2e3eac9e\",\"4\":\"v-1473bf53\",\"5\":\"v-1473bf53#目录\",\"6\":\"v-1473bf53@0\",\"7\":\"v-4e65ec78\",\"8\":\"v-4e65ec78@0\",\"9\":\"v-4e65ec78@1\",\"10\":\"v-c151bf32\",\"11\":\"v-c151bf32@0\",\"12\":\"v-c151bf32@1\",\"13\":\"v-438ffe52\",\"14\":\"v-438ffe52#markdown-介绍\",\"15\":\"v-438ffe52#markdown-配置\",\"16\":\"v-438ffe52#markdown-扩展\",\"17\":\"v-438ffe52#vuepress-扩展\",\"18\":\"v-438ffe52#主题扩展\",\"19\":\"v-438ffe52#自定义容器\",\"20\":\"v-438ffe52#代码块\",\"21\":\"v-438ffe52#上下角标\",\"22\":\"v-438ffe52#自定义对齐\",\"23\":\"v-438ffe52#attrs\",\"24\":\"v-438ffe52#脚注\",\"25\":\"v-438ffe52#标记\",\"26\":\"v-438ffe52#任务列表\",\"27\":\"v-438ffe52#图片增强\",\"28\":\"v-438ffe52#卡片\",\"29\":\"v-438ffe52#图表\",\"30\":\"v-438ffe52#echarts\",\"31\":\"v-438ffe52#流程图\",\"32\":\"v-438ffe52#mermaid\",\"33\":\"v-438ffe52#tex-语法\",\"34\":\"v-438ffe52#导入文件\",\"35\":\"v-438ffe52#代码演示\",\"36\":\"v-438ffe52#样式化\",\"37\":\"v-438ffe52#交互演示\",\"38\":\"v-438ffe52#vue-交互演示\",\"39\":\"v-438ffe52#幻灯片\",\"40\":\"v-438ffe52@0\",\"41\":\"v-438ffe52@1\",\"42\":\"v-6e19edb7\",\"43\":\"v-6e19edb7#页面信息\",\"44\":\"v-6e19edb7#页面内容\",\"45\":\"v-6e19edb7#页面结构\",\"46\":\"v-6e19edb7@0\",\"47\":\"v-6e19edb7@1\",\"48\":\"v-fffb8e28\",\"49\":\"v-fffb8e28#功能亮点\",\"50\":\"v-fffb8e28#bar\",\"51\":\"v-fffb8e28#foo\",\"52\":\"v-71b3ae87\",\"53\":\"v-71b3ae87#功能亮点\",\"54\":\"v-71b3ae87#bar\",\"55\":\"v-71b3ae87#foo\",\"56\":\"v-5d5c2d30\",\"57\":\"v-5d5c2d30#介绍\",\"58\":\"v-5d5c2d30#详情\",\"59\":\"v-177e1f06\",\"60\":\"v-5d5821d6\",\"61\":\"v-5d5821d6#介绍\",\"62\":\"v-5d5821d6#详情\",\"63\":\"v-0b6fc5f8\",\"64\":\"v-9cffac66\",\"65\":\"v-9cffac66#设计模式有哪些类型\",\"66\":\"v-9cffac66#创建型模式\",\"67\":\"v-9cffac66#结构型模式\",\"68\":\"v-9cffac66#行为型模式\",\"69\":\"v-9cffac66#面试过程中常问的设计模式\",\"70\":\"v-9cffac66#设计模式的几种原则\",\"71\":\"v-1110218a\",\"72\":\"v-1110218a#什么是单例模式\",\"73\":\"v-1110218a#单例模式的实现\",\"74\":\"v-1110218a#饿汉模式-线程安全-推荐\",\"75\":\"v-1110218a#双重检查-线程安全-推荐\",\"76\":\"v-1110218a#使用内部类模式-线程安全-推荐\",\"77\":\"v-1110218a#其他\",\"78\":\"v-1110218a#懒汉模式-线程不安全-不推荐\",\"79\":\"v-1110218a#懒汉模式-线程不安全-不推荐-1\",\"80\":\"v-1110218a#源码下载\",\"81\":\"v-3be12559\",\"82\":\"v-3be12559#代码实现\",\"83\":\"v-3be12559#使用适配器模式有什么收益\",\"84\":\"v-3be12559#源码下载\",\"85\":\"v-4b45c2fc\",\"86\":\"v-4b45c2fc#uml图\",\"87\":\"v-4b45c2fc#使用案例\",\"88\":\"v-4b45c2fc#为什么要使用装饰器模式\",\"89\":\"v-4b45c2fc#源码下载\",\"90\":\"v-7f97107a\",\"91\":\"v-7f97107a#责任链模式的uml图\",\"92\":\"v-7f97107a#案例实战\",\"93\":\"v-7f97107a#为什么要使用责任链模式\",\"94\":\"v-9b0dc620\",\"95\":\"v-9b0dc620#简单工厂\",\"96\":\"v-9b0dc620#uml图\",\"97\":\"v-9b0dc620#代码实现\",\"98\":\"v-9b0dc620#工厂方法模式\",\"99\":\"v-9b0dc620#uml图-1\",\"100\":\"v-9b0dc620#代码实现-1\",\"101\":\"v-9b0dc620#抽象工厂\",\"102\":\"v-9b0dc620#uml图-2\",\"103\":\"v-9b0dc620#代码实现-2\",\"104\":\"v-63d3fd84\",\"105\":\"v-63d3fd84#观察者模式uml图\",\"106\":\"v-63d3fd84#案例实战\",\"107\":\"v-63d3fd84#为什么要使用观察者模式\",\"108\":\"v-a950132e\",\"109\":\"v-a950132e#静态代理\",\"110\":\"v-a950132e#代码实现\",\"111\":\"v-a950132e#动态代理\",\"112\":\"v-a950132e#java-动态代理\",\"113\":\"v-a950132e#cglib代码\",\"114\":\"v-7e340ee0\",\"115\":\"v-7e340ee0#prometheus教程介绍\",\"116\":\"v-69099ac7\",\"117\":\"v-69099ac7#什么是prometheus\",\"118\":\"v-69099ac7#prometheus提供的特性\",\"119\":\"v-69099ac7#组件\",\"120\":\"v-69099ac7#架构\",\"121\":\"v-69099ac7#prometheus适用的场景\",\"122\":\"v-300045a1\",\"123\":\"v-300045a1#安装prometheus\",\"124\":\"v-300045a1#prometheus配置文件讲解\",\"125\":\"v-300045a1#采集node-exporter的指标\",\"126\":\"v-300045a1#prometheus配置文件热更新\",\"127\":\"v-300045a1#grafana安装\",\"128\":\"v-300045a1#总结\",\"129\":\"v-0890d0c6\",\"130\":\"v-0890d0c6#什么是time-series\",\"131\":\"v-0890d0c6#指标的类型\",\"132\":\"v-0890d0c6#counter-累加器\",\"133\":\"v-0890d0c6#gauge仪表盘\",\"134\":\"v-0890d0c6#histogram直方图\",\"135\":\"v-0890d0c6#summary\",\"136\":\"v-40c62e56\",\"137\":\"v-40c62e56#瞬时向量查询-instant-vector-selectors\",\"138\":\"v-40c62e56#范围向量查询-range-vector-selectors\",\"139\":\"v-40c62e56#offset-时间位移操作\",\"140\":\"v-40c62e56#操作符\",\"141\":\"v-40c62e56#数学操作符\",\"142\":\"v-40c62e56#比较操作符\",\"143\":\"v-40c62e56#逻辑运算符\",\"144\":\"v-40c62e56#向量匹配符号-vector-matching\",\"145\":\"v-40c62e56#分组修改器-group-modifiers\",\"146\":\"v-40c62e56#聚合函数\",\"147\":\"v-40c62e56#其他常见的函数\",\"148\":\"v-40c62e56#计算counter的增长率\",\"149\":\"v-40c62e56#预测指标变化趋势\",\"150\":\"v-40c62e56#计算分位数\",\"151\":\"v-40c62e56#总结\",\"152\":\"v-a5f16108\",\"153\":\"v-a5f16108#方案一-使用spring-boot-starter-actuator\",\"154\":\"v-a5f16108#方案二-使用prometheus\",\"155\":\"v-a5f16108#配置prometheus采集\",\"156\":\"v-a5f16108#配置grafana视图\",\"157\":\"v-9930b448\",\"158\":\"v-9930b448#alertmanager介绍\",\"159\":\"v-9930b448#分组\",\"160\":\"v-9930b448#抑制\",\"161\":\"v-9930b448#静默\",\"162\":\"v-9930b448#alertmanager安装\",\"163\":\"v-9930b448#配置讲解\",\"164\":\"v-9930b448#在prometheus中配置告警规则\",\"165\":\"v-9930b448#alertmanager查看告警消息\",\"166\":\"v-9930b448#webhook\",\"167\":\"v-9930b448#参考文档\",\"168\":\"v-012ad836\",\"169\":\"v-012ad836#定义recoding-rules\",\"170\":\"v-012ad836#recording-rule的最佳实践\",\"171\":\"v-012ad836#命名规范\",\"172\":\"v-012ad836#实战\",\"173\":\"v-4d4f79fa\",\"174\":\"v-4d4f79fa#list-接口\",\"175\":\"v-4d4f79fa#set接口\",\"176\":\"v-4d4f79fa#map接口\",\"177\":\"v-4d4f79fa#总结\",\"178\":\"v-8631ab70\",\"179\":\"v-8631ab70#arraylist的类结构图\",\"180\":\"v-8631ab70#arraylist底层是如何实现的\",\"181\":\"v-8631ab70#arraylist的初始化\",\"182\":\"v-8631ab70#添加元素\",\"183\":\"v-8631ab70#扩容\",\"184\":\"v-8631ab70#删除元素\",\"185\":\"v-8631ab70#查找元素\",\"186\":\"v-8631ab70#迭代器源码解析\",\"187\":\"v-618535c6\",\"188\":\"v-618535c6#linkedlist的类结构图\",\"189\":\"v-618535c6#构造函数\",\"190\":\"v-618535c6#add-e-e-方法\",\"191\":\"v-618535c6#get-int-index-方法\",\"192\":\"v-618535c6#remove-int-index-方法\",\"193\":\"v-618535c6#总结\",\"194\":\"v-4e3cbe0a\",\"195\":\"v-4e3cbe0a#hashmap的类结构图\",\"196\":\"v-4e3cbe0a#hashmap的底层数据结构\",\"197\":\"v-4e3cbe0a#构造函数\",\"198\":\"v-4e3cbe0a#存储元素过程\",\"199\":\"v-4e3cbe0a#扩容\",\"200\":\"v-4e3cbe0a#获取元素\",\"201\":\"v-4e3cbe0a#总结\",\"202\":\"v-42225482\",\"203\":\"v-42225482#类结构图\",\"204\":\"v-42225482#底层数据结构\",\"205\":\"v-42225482#简单示例\",\"206\":\"v-42225482#源码解析\",\"207\":\"v-42225482#构造函数\",\"208\":\"v-42225482#添加元素\",\"209\":\"v-42225482#查找元素\",\"210\":\"v-42225482#删除元素\",\"211\":\"v-42225482#总结\",\"212\":\"v-4689cbba\",\"213\":\"v-4689cbba#类结构关系\",\"214\":\"v-4689cbba#bitset介绍\",\"215\":\"v-4689cbba#bitset的简单使用\",\"216\":\"v-4689cbba#使用场景\",\"217\":\"v-4689cbba#代码示例\",\"218\":\"v-4689cbba#参考\",\"219\":\"v-6ca18109\",\"220\":\"v-6ca18109#简介\",\"221\":\"v-6ca18109#io流基本类\",\"222\":\"v-6ca18109#java流类图结构\",\"223\":\"v-6ca18109#java-io流对象\",\"224\":\"v-518ce18e\",\"225\":\"v-518ce18e#简介\",\"226\":\"v-518ce18e#channel\",\"227\":\"v-518ce18e#filechannel\",\"228\":\"v-518ce18e#buffer\",\"229\":\"v-518ce18e#selector\",\"230\":\"v-518ce18e#总结\",\"231\":\"v-bb4bc3d6\",\"232\":\"v-bb4bc3d6#socketchannel介绍\",\"233\":\"v-bb4bc3d6#serversocketchannel介绍\",\"234\":\"v-bb4bc3d6#selector介绍\",\"235\":\"v-bb4bc3d6#案列介绍\",\"236\":\"v-bb4bc3d6#服务端代码\",\"237\":\"v-bb4bc3d6#客户端代码\",\"238\":\"v-bb4bc3d6#nio底层原理\",\"239\":\"v-879b283a\",\"240\":\"v-879b283a#重载与重写的区别\",\"241\":\"v-879b283a#抽象类和接口的区别\",\"242\":\"v-879b283a#为什么java不支持多继承\",\"243\":\"v-879b283a#string和stringbuffer、stringbuilder的区别是什么\",\"244\":\"v-879b283a#如何理解面向过程和面向对象\",\"245\":\"v-879b283a#java基本类型为什么需要包装类\",\"246\":\"v-879b283a#如何理解java中的多态\",\"247\":\"v-2f0fbf99\",\"248\":\"v-2f0fbf99#谈谈final、finally、finalize的区别\",\"249\":\"v-e4b894f2\",\"250\":\"v-e4b894f2#和-equals-的区别\",\"251\":\"v-e4b894f2#关系操作符号\",\"252\":\"v-e4b894f2#equals\",\"253\":\"v-e4b894f2#equals-和hashcode的关系\",\"254\":\"v-e4b894f2#java中的异常处理机制\",\"255\":\"v-e4b894f2#jdk、jre、jvm的区别和联系\",\"256\":\"v-9e8a134a\",\"257\":\"v-9e8a134a#final关键字的基本用法\",\"258\":\"v-9e8a134a#为什么内部类引用的外部变量必须用final修饰\",\"259\":\"v-9e8a134a#谈谈final、finally、finalize的区别\",\"260\":\"v-9e8a134a#finally语句到底是在return之前还是之后执行\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[6],\"1\":[1,12],\"2\":[1,12],\"3\":[1],\"4\":[1],\"5\":[1,5],\"6\":[null,null,1],\"7\":[1,18],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[1,7],\"11\":[null,null,1],\"12\":[null,null,1],\"13\":[2,11],\"14\":[2,8],\"15\":[2,13],\"16\":[2,11],\"17\":[2,10],\"18\":[1,10],\"19\":[1,19],\"20\":[1,1],\"21\":[1,3],\"22\":[1,3],\"23\":[1,5],\"24\":[1,3],\"25\":[1,3],\"26\":[1,5],\"27\":[1,2],\"28\":[1,23],\"29\":[1,1],\"30\":[1,1],\"31\":[1,1],\"32\":[1,1],\"33\":[2,10],\"34\":[1,6],\"35\":[1,1],\"36\":[1,5],\"37\":[1,1],\"38\":[2,1],\"39\":[1,3],\"40\":[null,null,1],\"41\":[null,null,1],\"42\":[1,3],\"43\":[1,20],\"44\":[1,17],\"45\":[1,16],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1],\"49\":[1],\"50\":[1,2],\"51\":[1,2],\"52\":[1],\"53\":[1],\"54\":[1,2],\"55\":[1,2],\"56\":[2],\"57\":[1,4],\"58\":[1,2],\"59\":[1,2],\"60\":[2],\"61\":[1,4],\"62\":[1,2],\"63\":[1,2],\"64\":[1,35],\"65\":[2,8],\"66\":[1,21],\"67\":[1,19],\"68\":[1,43],\"69\":[1,21],\"70\":[1,62],\"71\":[1],\"72\":[1,22],\"73\":[1,12],\"74\":[4,29],\"75\":[4,59],\"76\":[4,28],\"77\":[1,4],\"78\":[4,17],\"79\":[4,20],\"80\":[1,15],\"81\":[1,34],\"82\":[1,49],\"83\":[1,31],\"84\":[1],\"85\":[1,17],\"86\":[1,32],\"87\":[1,155],\"88\":[2,24],\"89\":[1],\"90\":[1,8],\"91\":[1,13],\"92\":[1,88],\"93\":[1,41],\"94\":[1],\"95\":[1,10],\"96\":[1,14],\"97\":[1,65],\"98\":[1,10],\"99\":[1,19],\"100\":[1,49],\"101\":[1,15],\"102\":[1,18],\"103\":[1,64],\"104\":[1,8],\"105\":[1,29],\"106\":[1,71],\"107\":[1,33],\"108\":[1,18],\"109\":[1,27],\"110\":[1,43],\"111\":[1,4],\"112\":[2,91],\"113\":[1,108],\"114\":[1],\"115\":[1,14],\"116\":[1],\"117\":[1,22],\"118\":[1,29],\"119\":[1,23],\"120\":[1,30],\"121\":[1,41],\"122\":[1,12],\"123\":[1,37],\"124\":[1,125],\"125\":[2,52],\"126\":[1,17],\"127\":[1,65],\"128\":[1,10],\"129\":[1],\"130\":[2,79],\"131\":[1,41],\"132\":[2,23],\"133\":[1,25],\"134\":[1,66],\"135\":[1,47],\"136\":[1,15],\"137\":[5,55],\"138\":[5,37],\"139\":[2,18],\"140\":[1],\"141\":[1,53],\"142\":[1,20],\"143\":[1,16],\"144\":[3,21],\"145\":[3,46],\"146\":[1,88],\"147\":[1],\"148\":[1,46],\"149\":[1,23],\"150\":[1,51],\"151\":[1,13],\"152\":[1,7],\"153\":[5,106],\"154\":[2,172],\"155\":[1,15],\"156\":[1,22],\"157\":[1,37],\"158\":[1,10],\"159\":[1,16],\"160\":[1,7],\"161\":[1,15],\"162\":[1,66],\"163\":[1,145],\"164\":[1,78],\"165\":[1,8],\"166\":[1,84],\"167\":[1,27],\"168\":[3,9],\"169\":[2,56],\"170\":[2,5],\"171\":[1,69],\"172\":[1,46],\"173\":[2,58],\"174\":[2,122],\"175\":[1,89],\"176\":[1,113],\"177\":[1,13],\"178\":[1],\"179\":[1,33],\"180\":[2,73],\"181\":[1,51],\"182\":[1,46],\"183\":[1,95],\"184\":[1,60],\"185\":[1,50],\"186\":[1,103],\"187\":[1],\"188\":[1,53],\"189\":[1,18],\"190\":[4,54],\"191\":[4,66],\"192\":[4,82],\"193\":[1,24],\"194\":[1],\"195\":[1,16],\"196\":[1,31],\"197\":[1,47],\"198\":[1,110],\"199\":[1,108],\"200\":[1,85],\"201\":[1,19],\"202\":[1],\"203\":[1,17],\"204\":[1,37],\"205\":[1,21],\"206\":[1],\"207\":[1,42],\"208\":[1,52],\"209\":[1,45],\"210\":[1,48],\"211\":[1,13],\"212\":[1],\"213\":[1,16],\"214\":[1,61],\"215\":[1,85],\"216\":[1,9],\"217\":[1,123],\"218\":[1,8],\"219\":[2],\"220\":[1,15],\"221\":[1,66],\"222\":[1,3],\"223\":[2,236],\"224\":[2],\"225\":[1,91],\"226\":[1,48],\"227\":[1,79],\"228\":[1,152],\"229\":[1,67],\"230\":[1,7],\"231\":[2],\"232\":[1,77],\"233\":[1,86],\"234\":[1,93],\"235\":[1,5],\"236\":[1,170],\"237\":[1,119],\"238\":[1,47],\"239\":[1],\"240\":[1,94],\"241\":[1,185],\"242\":[1,34],\"243\":[2,46],\"244\":[1,35],\"245\":[1,67],\"246\":[1,77],\"247\":[1],\"248\":[3],\"249\":[1],\"250\":[5,8],\"251\":[3,81],\"252\":[2,78],\"253\":[3,78],\"254\":[1,122],\"255\":[3,48],\"256\":[1],\"257\":[1,99],\"258\":[1,52],\"259\":[3,55],\"260\":[2,95]},\"averageFieldLength\":[1.3644109763300165,37.16193772649279,0.49126766091051804],\"storedFields\":{\"0\":{\"h\":\"方志朋,Java,Spring,Spring Boot,Spring Cloud,Java后端技术\"},\"1\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"2\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"3\":{\"h\":\"幻灯片页\"},\"4\":{\"h\":\"主要功能与配置演示\"},\"5\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"6\":{\"c\":[\"使用指南\"]},\"7\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"禁用\"]},\"10\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"11\":{\"c\":[\"使用指南\"]},\"12\":{\"c\":[\"文章加密\"]},\"13\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"14\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"15\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"16\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"17\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"18\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"19\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"20\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"23\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"24\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"25\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"26\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"27\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"28\":{\"h\":\"卡片\",\"t\":[\"title: Mr.Hope desc: Where there is light, there is hope logo: https://mister-hope.com/logo.svg link: https://mister-hope.com color: rgba(253, 230, 138, 0.15) \",\"查看详情\"]},\"29\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"30\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"31\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"32\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"33\":{\"h\":\"Tex 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"34\":{\"h\":\"导入文件\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\",\"查看详情\"]},\"35\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"36\":{\"h\":\"样式化\",\"t\":[\"向 Mr.Hope 捐赠一杯咖啡。 \",\"查看详情\"]},\"37\":{\"h\":\"交互演示\",\"t\":[\"查看详情\"]},\"38\":{\"h\":\"Vue 交互演示\",\"t\":[\"查看详情\"]},\"39\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"40\":{\"c\":[\"使用指南\"]},\"41\":{\"c\":[\"Markdown\"]},\"42\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"43\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"44\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"45\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"46\":{\"c\":[\"使用指南\"]},\"47\":{\"c\":[\"页面配置\",\"使用指南\"]},\"48\":{\"h\":\"指南\"},\"49\":{\"h\":\"功能亮点\"},\"50\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"51\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"52\":{\"h\":\"指南\"},\"53\":{\"h\":\"功能亮点\"},\"54\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"55\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"56\":{\"h\":\"Bar 功能\"},\"57\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"58\":{\"h\":\"详情\",\"t\":[\"baz\",\"...\"]},\"59\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"60\":{\"h\":\"Foo 功能\"},\"61\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"62\":{\"h\":\"详情\",\"t\":[\"ray\",\"...\"]},\"63\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"64\":{\"h\":\"设计模式面试概述\",\"t\":[\"设计模式是软件开发的一种指导思想，它是为了解决具体的编码问题或者是解决某一类问题而产生的。这些年无论是生产环境遇到的事故，还是自己自己做的一些开源项目中，越来越体会到系统是运营出来的，代码质量是设计出来的。无论是在前期的需求分析、方案设计、代码编写，都需要良好的程序设计，这些都离不开设计模式的思想。所以设计模式是程序员的一项基本功。\",\"那么如何学习好设计模式呢，我觉得需要刻意练习，说的简单一点就是多写、多练、多应用。\",\"这些年技术层出不穷，新的框架、新的工具、新的软件开发模式，都会让程序员在技术的海洋里迷失。无论面对什么的环境，我们需要有一些专注力，刻意的去练习、要深挖技术背后的原因，要做到知其然并知其所以然。不能东一榔头西一棒槌，这样只会原地踏步走。\",\"那本系列教程将会讲述23种经典的设计模式，有两个目标：\",\"优先讲解面试过程中常见遇到的几种设计模式；剩下的设计模式会在写完Java面试系列文章之后做为补充。\",\"尽量以通俗易懂的语言和代码案例去讲述。\"]},\"65\":{\"h\":\"设计模式有哪些类型？\",\"t\":[\"设计模式可以分为三种类型，分别是创建性型设计模式、结构型设计模式和行为型设计模式。每种类型的设计模式又包含了多种设计模式，总共有23种设计模式，如图所示：\",\"image-20231112200737983\"]},\"66\":{\"h\":\"创建型模式\",\"t\":[\"创建型设计模式，用于解耦对象的实例化过程，用于对象的实例化，包含了5种设计模式，在实际的开发过程中是应用非常多的：\",\"单列模式：某个类在全局只有一个实例对象，提供一个全局的访问点。\",\"创建者模式：封装对象的创建过程，可以按照方法去构造对象。\",\"工厂方法模式：它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成\",\"抽象工厂模式：它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\",\"原型模式：通过复制原有的实例来创建新的实例。\"]},\"67\":{\"h\":\"结构型模式\",\"t\":[\"结构型设计模式是多个对象实例的结合或者组装，形成一个更大的对象。\",\"装饰器模式：装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能。\",\"代理模式：将对象的访问控制和代码运行位置转移到代理对象中。\",\"享元模式：通过共享对象池技术，共享对象。\",\"适配器模式：将类的接口转换为客户期望的另一个接口\",\"外观模式：提供统一的方法来访问内部子系统。\",\"桥接模式：将抽象部分和实现部分分离，使它们都可以独立\",\"组合模式：将对象组合成树形结构以表示整个部分的层次结构。\"]},\"68\":{\"h\":\"行为型模式\",\"t\":[\"类和对象如何交互，及划分责任和算法。\",\"策略模式：定义一系列算法，封装每个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化。\",\"模板模式：在操作中定义算法的框架，将一些步骤推迟到子类中。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。\",\"命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。\",\"迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。\",\"观察者模式：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。\",\"中介者模式：中介者对象封装了一组对象之间的交互，这组对象会将它们的交互委托给中介者对象，而不是直接交互。\",\"备忘录模式：捕获并外部化对象的内部状态，以便以后可以恢复，所有这些都不会违反封装。\",\"解释器模式：给用于定义语言的语法规则表示，并提供解释器来处理句子中的语法。\",\"状态模式：状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",\"责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。\",\"访问者模式：访问者模式是以行为（某一个操作）作为扩展对象功能的出发点，在不改变已有类的功能的前提下进行批量扩展。\"]},\"69\":{\"h\":\"面试过程中常问的设计模式\",\"t\":[\"设计模式有23种，每种设计模式有非常多的应用，能够熟练使用设计模式，可以极大程度的提高我们写代码的质量。熟练使用23种设计模式是高阶程序员必须掌握的技能。\",\"在面试过程中，面试官不会考察每一种设计模式，笔者作为多年面试官，一般常见的考察的面试模式如下：\",\"单例模式\",\"工厂方法模式\",\"抽象工厂模式\",\"装饰器模式\",\"适配器模式\",\"责任链模式\",\"代理模式\",\"观察者模式\",\"掌握好以上的几种设计模式，应对面试应该是足够的，在接下来的文章中会逐步讲解这几种设计模式。\"]},\"70\":{\"h\":\"设计模式的几种原则\",\"t\":[\"面向对象有个SOLID原则，而设计模式是基于对象实例的，基本上也遵循SOLID 原则。这个原则在面试过程中会经常被问到。\",\"S（Single Responsibility Principle，简称 SRP）：单一职责原则，该类的职责是唯一的，这个职责是唯一引起该类变化的原因。\",\"O（Open–Closed Principle，简称 OCP）：开闭原则，对于扩展是开放的，对于修改是封闭的。\",\"L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。里氏代换原则是继承复用的基石，只有当子类可以替换基类，软件功能在不受影响时，基类功能可以被复用，而子类也能够在基类的基础上增加新的行为。\",\"I（Interface Segregation Principle，简称 ISP）：接口隔离原则，接口互相隔离，一个类对另一个类的依赖应该建立在最小的接口范围内。\",\"D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象接口进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\",\"除了以上的SOLID 原则，面向对象还有以下的基本原则：\",\"迪米特法则：又被叫做最小知识原则，就是一个对象应该尽量对外少暴露，对象之间尽量少了解。\",\"组合优先原则：在复用代码时，要尽量先使用组合关系来实现，其次才考虑使用继承关系来实现。它和里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。\"]},\"71\":{\"h\":\"单例模式\"},\"72\":{\"h\":\"什么是单例模式\",\"t\":[\"单例模式在允许在全局中只存在一个实例，并提供一个方法，让其他的对象可以访问这个实例。单例模式可以解决一个全局的使用的实例，防止它频繁的被创建或者被销毁，从而提高整个系统的性能。单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的。\",\"在什么样的场景会使用到单列模式呢？\",\"需要表示全局唯一的对象，比如id生成器，比如工具类，或者访问资源配置文件的reader。这些对象一般只提供具体的方法、不提供全局的共享变量。在系统中只需要初始化一个实例，就能够提供给其他对象在各个地方使用。\",\"使用单例模式有什么好处呢？\",\"可以节约系统的资源，防止对象的频繁创建\",\"提升代码的复用性\",\"统一全局的访问点控制，方便统一管理和修改\"]},\"73\":{\"h\":\"单例模式的实现\",\"t\":[\"如下图的UML图，单例模式声明了一个名为 instance 的静态对象和 get­Instance() 的方法，静态对象用来存储对象自身的属性和方法，静态方法用来返回其所属类的一个相同实例。这里我们以单例模式经典的懒汉式初始化方式为例，其代码实现如下：\",\"image-20231030213851667\"]},\"74\":{\"h\":\"饿汉模式（线程安全，推荐）\",\"t\":[\"单例模式不需要对外提供构造方法，只允许通过getInstance()方法获取实例，在下面的案例中，会在程序的类的加载过程中，自动创建hugryInstance的静态实例，然后getInstance()去提供获取对象的服务。这种模式是在类加载的时候就完成了对象的实例化，类加载是加锁的，所以它是线程安全的。这种模式称为饿汉模式。\",\"饿汉模式类似于Spring框架初始化Bean实例，都是在程序启动之初创建。虽然可能会造成一定资源开销和浪费，但是由于简单、安全，所以还是比较推荐的。\",\"public class HugryInstance { private static HugryInstance hugryInstance = new HugryInstance(); private HugryInstance() { } public static HugryInstance getInstance() { return hugryInstance; } } \"]},\"75\":{\"h\":\"双重检查（线程安全，推荐）\",\"t\":[\"这种双重检查模式经常在面试中被考察，近几年由于八股文泛滥，可能问的少一些。\",\"public class LazyInstance { private static volatile LazyInstance instance; private LazyInstance() { } public static LazyInstance getInstance() { if (instance == null) { synchronized (LazyInstance.class) { if (instance == null) { instance = new LazyInstance(); } } } return instance; } } \",\"双重检查模式，它属于懒汉模式，只有第一次调用getSingleton()方法才会初始化实例instance。\",\"同时它是线程安全的，使用同步代码块来保证线程的安全。\",\"使用双重检查来判断实例是否初始化，减少同步创建实例的开销。\",\"那为什么要使用volatile关键字来修饰静态的instance对象呢？\",\"在java中创建一个对象，需要如下几步，伪代码如下：\",\"memory=allocate(); //1：分配内存空间 ctorInstance(); //2:初始化对象 singleton=memory; //3:设置singleton指向刚分配的内存空间 \",\"当线程1在执行上面伪代码时，2和3可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以JVM是允许的。如果此时伪代码发生重排序，步骤变为1->3->2，线程1执行到第3步时，线程2调用getsingleton方法，在判断singleton==null时不为null，则返回singleton。但此时singleton并还没初始化完毕，线程2访问的将是个还没初始化完毕的对象。这时程序会出错！\",\"当声明对象的引用为volatile后，伪代码的2、3的重排序在多线程中将被禁止!\"]},\"76\":{\"h\":\"使用内部类模式（线程安全，推荐）\",\"t\":[\"public class InnerClzSingleton { private InnerClzSingleton(){ } public static InnerClzSingleton getSingleton(){ return Inner.instance; } private static class Inner { private static final InnerClzSingleton instance = new InnerClzSingleton(); } } \",\"使用内部类的模式，有以下的优点在：\",\"延迟初始化，属于懒汉模式，需要第一次调用getSingleton()方法，才会初始化内部类。\",\"线程安全，Jvm在执行类的初始化的时候，会进行加锁初始化，在多线程的情况下，也不会频繁创建对象。\",\"所以它属于线程安全的懒汉模式，和双重检查模式一样，但是代码比双重检查模式简洁。\"]},\"77\":{\"h\":\"其他\",\"t\":[\"单例模式除了上面的写法，还有其他的写法，但是不太推荐。\"]},\"78\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是最简单的懒汉模式的单列模式，这种情况下在多线程下是不安全的，可能会同时存在多个实例的创建。\",\"public class LazyInstanceNoSafe { private static LazyInstanceNoSafe instance; private LazyInstanceNoSafe() { } public static LazyInstanceNoSafe getInstance() { if (instance == null) { instance = new LazyInstanceNoSafe(); } return instance; } } \"]},\"79\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是懒汉模式的线程安全的，但是在方法上加了锁，在访问的时候需要锁占用，会导致一定的资源开销和性能下降。此种模式是不推荐的。\",\"public class LazyInstanceSafe { private static LazyInstanceSafe instance; private LazyInstanceSafe() { } public static synchronized LazyInstanceSafe getInstance() { if (instance == null) { instance = new LazyInstanceSafe(); } return instance; } } \"]},\"80\":{\"h\":\"源码下载\",\"t\":[\"https://github.com/forezp/Java-Labs/tree/main/design-pattern-lab/src/main/java/io/github/forezp/java/design/sington\"]},\"81\":{\"h\":\"适配器模式\",\"t\":[\"今天这一讲，我们主要讲解最常用到的适配器模式。\",\"在程序中，经常需要新的项目中需要对老代码进行适配才能用。适配器模式就是将旧代码和新程序的中间的转换角色。举个现实例子，比如我们的MAC电脑需要连接USB接口的键盘，但是MAC电脑只有typec接口，这时我们需要一个拓展坞，需要把typec接口转换成USB接口，给键盘使用，如图所示：\",\"适配器模式的定义是：将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。\",\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解，它的UML图如下所示：\",\"从 UML 图中，我们可以看出适配器模式中包含三个关键角色：\",\"目标类Target， 适配器类即将要进行适配的抽象类或接口，比如TypeC接口；\",\"适配器类Adapter，是作为适配的中间类，它必须持有或者实现目标类和适配类的接口，比如拓展坞类实现了目标接口TypeC接口，持有适配者的类Keyboard；\",\"需要被适配器转换的对象 Adaptee, 比如图中的键盘（实现了USB接口）。\"]},\"82\":{\"h\":\"代码实现\",\"t\":[\"需要被适配的接口USB接口：\",\"public interface IUsb { void connect(int x, int y); } \",\"需要被适配的接口的实现类，比如案例中Keyboard：\",\"public class Keyboard implements IUsb{ @Override public void connect(int x, int y) { System.out.println(\\\"keyborad 连上了usb接口\\\"); } } \",\"目标接口ITypeC：\",\"public interface ITypeC { void connect(int x, int y,int z); } \",\"ExpansionDockAdapter（拓展坞适配器）实现了ITypeC的目标接口接口，ExpansionDockAdapter并持有需要被适配的IUsb接口，适配器只有同时实现或者持有目标接口和被适配的对象，才能进行适配工作：\",\"public class ExpansionDockAdapter implements ITypeC{ private IUsb iUsb; public ExpansionDockAdapter(IUsb iUsb) { this.iUsb = iUsb; } @Override public void connect(int x, int y, int z) { System.out.println(\\\"拓展坞将Typec接口转换成USB接口\\\"); iUsb.connect(x,y); } } \",\"最后，可以调用客户端对它们调用：\",\"public class McClient { public static void main(String[] args) { Keyboard keyboard = new Keyboard(); ExpansionDockAdapter adapter = new ExpansionDockAdapter(keyboard); System.out.println(\\\"mac连接typec\\\"); adapter.connect(1, 2, 3); } } \"]},\"83\":{\"h\":\"使用适配器模式有什么收益\",\"t\":[\"可能有很多人比较疑惑，如果在目标类中，新写一个方法就可以将需要适配的类进行转换。那么为什么还需要使用适配器模式呢？\",\"首先 ，是为了保持简单性，正如mac电脑一样，它只提供TypeC接口。由拓展坞去做USB或者是HDMI接口的转换。保证了MAC电脑对外接口的简单性。\",\"单一职责，不同的角色做不同的事，没有必要将多个事情给一个角色做完，这样代码会非常的臃肿，难以维护。\",\"可复用，将适配器这个角色进行高度抽象化，可以做到移植可复用\",\"使用适配器模式有以下的优点：\",\"将目标类和适配的类解耦，引入一个适配器类兼容现有目标类，拓展新的适配者类功能，很好的避免了现有类和适配者类的耦合。\",\"单一职责，目标类和适配者类各司其职，互不干扰。\",\"满足里氏替换原则。 目标类和适配者类是通过适配器进行交互的，适配器类只要不影响目标类的接口功能，适配者类无论出现什么新功能，都很方便替换。\"]},\"84\":{\"h\":\"源码下载\"},\"85\":{\"h\":\"装饰器模式\",\"t\":[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能，相当于对原有的类进行类一个包装，它又称为包装器模式。\",\"在Java的IO源码中，使用到了包装器模式，比如在以下的代码中，BufferedReader和FileReader都是使用到包装器模式，各种Reader一层套一层，进行数据的转换或者功能的增强。\",\" fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); \"]},\"86\":{\"h\":\"UML图\",\"t\":[\"image-20231102232111957\",\"上图是装饰器的UML图，在图中一共有三个角色：\",\"组件Component，它是目标接口，定义目标的方法\",\"组件实现类ComponentImpl，它实现了目标接口\",\"装饰器ComponentDecoratorB和ComponentDecoratorA \",\"ComponentDecoratorB，它实现了目标接口，并持有组件实现类ComponentImpl\",\"ComponentDecoratorA，它实现了目标接口，并持有装饰器ComponentDecoratorB\",\"ComponentImpl提供基本的实现方法，在不改变了ComponentImpl的情况下，ComponentDecoratorB和ComponentDecoratorA分别对ComponentImpl进行了增强。\",\"什么时候使用装饰器模式\",\"一般来讲，装饰模式不改变原有类的结构，是不能改变原有的基础功能，只能在原有的基础功能之上做进一步增强。一般情况下，装饰器模式经常使用到以下场景：\",\"一个组件可以有很多个装饰器，不同的装饰器有不同的功能，可以按照需要使用不同装饰器组合。在扩展性上，装饰器非常的灵活。\",\"原有的类不支持继承，比如使用类final关键字的类。\"]},\"87\":{\"h\":\"使用案例\",\"t\":[\"在案例模仿JavaIO的文件流的写入和读取功能，在文件流的基础之上使用装饰器模式，做下面的增强功能：\",\"加密装饰器：对写入文件的字符的加密，对读取的字符进行解密\",\"压缩解压装饰器：对写入字符进行压缩，对读取的字符进行解压\",\"可以通过顺序组合包装的方式来附加扩张功能，比如可以先使用加密装饰器，后使用压缩解压装饰器；也可以把他们的顺序对调。\",\"首先，定义一个目标接口ReaderWriter，它有读取和写入的功能：\",\"public interface ReaderWriter { String read(); void write(String content); } \",\"ReaderWriter的基本实现类是FileReaderWriter，它可以把字符写入到文件中，也可以读取文件的字符。\",\"public class FileReaderWriter implements ReaderWriter { private String filePath; public FileReaderWriter(String filePath) { this.filePath = filePath; } @Override public String read() { StringBuilder sb = new StringBuilder(); File file = new File(filePath); BufferedReader bufferedReader = null; FileReader fileReader = null; try { fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); String s; while ((s = bufferedReader.readLine()) != null) { sb.append(s); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } if (bufferedReader != null) { bufferedReader.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } @Override public void write(String content) { File file = new File(filePath); FileWriter fileWriter = null; BufferedWriter bufferedWriter = null; try { fileWriter = new FileWriter(file); bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(content); bufferedWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileWriter != null) { fileWriter.close(); } if (bufferedWriter != null) { bufferedWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"EncryptionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行加密\",\"在读取文件的字符之后 ，对读取的字符进行解密\",\"public class EncryptionFileReaderWriter implements ReaderWriter{ private ReaderWriter readerWriter; public EncryptionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decode(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(encode(content)); } private String encode(String data) { byte[] result = data.getBytes(); for (int i = 0; i < result.length; i++) { result[i] += (byte) 1; } return Base64.getEncoder().encodeToString(result); } private String decode(String data) { byte[] result = Base64.getDecoder().decode(data); for (int i = 0; i < result.length; i++) { result[i] -= (byte) 1; } return new String(result); } } \",\"CompressionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行压缩\",\"在读取文件的字符之后 ，对读取的字符进行解压\",\"public class CompressionFileReaderWriter implements ReaderWriter { private ReaderWriter readerWriter; public CompressionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decompress(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(compress(content)); } private String compress(String stringData) { byte[] data = stringData.getBytes(); try { ByteArrayOutputStream bout = new ByteArrayOutputStream(512); DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater()); dos.write(data); dos.close(); bout.close(); return Base64.getEncoder().encodeToString(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } private String decompress(String stringData) { byte[] data = Base64.getDecoder().decode(stringData); try { InputStream in = new ByteArrayInputStream(data); InflaterInputStream iin = new InflaterInputStream(in); ByteArrayOutputStream bout = new ByteArrayOutputStream(512); int b; while ((b = iin.read()) != -1) { bout.write(b); } in.close(); iin.close(); bout.close(); return new String(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } } \",\"写一个客户端测试类：\",\"定义一个写入的字符串text\",\"定义文件的写入或者读取的路径\",\"然后使用装饰器模式，嵌套了两个装饰器（加减密装饰器和压缩解缩的装饰器），对写入的字符进行先加密再压缩；对读取的字符进行先解压再解密。\",\"具体实现如下：\",\"public class Client { public static void main(String[] args) { String text = \\\"fangzhipeng.com\\\"; String filePath=\\\"/Users/forezp/Downloads//test.txt\\\"; System.out.println(\\\"原始内容：\\\"+text); ReaderWriter rw = new CompressionFileReaderWriter(new EncryptionFileReaderWriter(new FileReaderWriter(filePath))); rw.write(text); FileReaderWriter fileReaderWriter=new FileReaderWriter(filePath); // System.out.println(\\\"加密后、压缩后的内容为：\\\"+fileReaderWriter.read()); System.out.println(\\\"解密后、解缩后的内容为：\\\"+rw.read()); } } \",\"执行测试类，控制台打出的结果如下：\",\"原始内容：fangzhipeng.com 加密后、压缩后的内容为：Zkt5TVQ5eU1zOXNKTUZrT1Q6ZU17dDlHQkVFSENnOT4= 解密后、解缩后的内容为：fangzhipeng.com\",\"Process finished with exit code 0\"]},\"88\":{\"h\":\"为什么要使用装饰器模式？\",\"t\":[\"在讲解完具体案例后，我们来思考一下，为什么要使用装饰器模式，主要原因：\",\"能够快速的扩展现有类的功能，并能自由组合包装各种装饰器，达到不同的效果，也就是能够根据需求，快速的装载和卸载装饰器\",\"希望继承原有类的功能，但又不方便继承。\",\"使用装饰器模式有以下的优点：\",\"代码的可扩展性和可复用性非常的强，对一些基础类无法修改，需要扩展功能的时候，采用装饰器模式能够快速的扩展功能，同时有不会影响原有的公民\",\"满足单一职责的原则。基本功能实现类和不同的装饰器只实现自己的独一的功能，后面加一些功能，可以增加新的装饰器。\",\"可以快速装载和卸载增强功能\",\"可以快速组合，通过包装不同的装饰器组合来满足自己的业务需求\"]},\"89\":{\"h\":\"源码下载\"},\"90\":{\"h\":\"责任链模式\",\"t\":[\"责任链模式在软件开发中，是会经常使用到的一个设计模式，比如对某一次请求进行不同的规则的校验，这些规则的执行有先后顺序，组成了链式的执行顺序。\",\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理。这些在流水线的处理类对象构成了一个单项链表结构。\"]},\"91\":{\"h\":\"责任链模式的UML图\",\"t\":[\"从该UML中中，责任链模式有两个角色：\",\"处理类Handler，可以是一个接口，也可以是一个抽象类。它有一个核心的处理方法，比如handle_request();\",\"处理类的实现类HandlerA、HandlerB、HandlerC，这几个Handler构成了一个链式的处理顺序。\"]},\"92\":{\"h\":\"案例实战\",\"t\":[\"在工作中，我们经常有一些审批流程，现在使用责任链模式去模拟一个向公司借款的流程。在流程中有三个角色，分别是员工、经历、CFO三个角色，根据借款金额的不同，需要不同的审批角色。\",\"当借款金额小于1000元，只需要财务审批\",\"当借款金额大于1000元小于5000元，需要经理审批\",\"当借款金额大于5000元小于10000元，需要CFO审批\",\"当借款金额大于10000元，审批拒绝。\",\"首先创建一个审批抽象类Aproval，有一个核心的抽象处理方法handle(int amount)和持有一个Aproval对象。\",\"public abstract class Aproval { private Aproval nextApproval; public abstract void handle(int amount); public Aproval getNextApproval() { return nextApproval; } public void setNextApproval(Aproval nextApproval) { this.nextApproval = nextApproval; } } \",\"Staff（财务）继承了Aproval，并实现了handle(int amount)方法，里面有具体的处理逻辑，它只能审批1000元以下的借款。\",\"public class Staff extends Aproval { @Override public void handle(int amount) { if(amount<1000){ System.out.println(\\\"审批通过\\\"); }else { System.out.println(\\\"财物权限不够，需要经理审批\\\"); getNextApproval().handle(amount); } } } \",\"Manager继承了Aproval，并实现了handle(int amount)方法，它能审批5000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class Manager extends Aproval { @Override public void handle(int amount) { if (amount < 5000) { System.out.println(\\\"经理审批通过\\\"); } else { System.out.println(\\\"经理权限不够，需要总裁审批\\\"); getNextApproval().handle(amount); } } } \",\"CFO继承了Aproval，并实现了handle(int amount)方法，它能审批10000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class CFO extends Aproval { @Override public void handle(int amount) { if (amount < 10000) { System.out.println(\\\"cfo审批通过\\\"); } else { System.out.println(\\\"金额太大，审批不通过\\\"); } } } \",\"写一个测试类，将三个审批角色组成一个责任链模式的审批流，并向审批流的第一角色handle(9000)：\",\"public class Client { public static void main(String[] args) { Staff staff = new Staff(); Manager manager = new Manager(); CFO cfo = new CFO(); staff.setNextApproval(manager); manager.setNextApproval(cfo); staff.handle(9000); } } \",\"运行代码处理结果如下：\",\"财物权限不够，需要经理审批 经理权限不够，需要总裁审批 cfo审批通过\"]},\"93\":{\"h\":\"为什么要使用责任链模式\",\"t\":[\"从上面的使用场景，我们可以得出以下的一些结论，使用责任链的原因有：\",\"使用责任链模式可以将一个大而复杂的判断逻辑，分成多个小的逻辑单元，每个逻辑单元组成了链中的一环。每个逻辑单元的功能都是解藕的。\",\"可以动态的扩展责任链中的逻辑单元，当需要扩展新的功能，可以写一个Handler即可\",\"也可以根据需求快速的删除一些逻辑单元，并且可以根据需要快速的组合逻辑单元\",\"从上面的分析原因我们可以得出，使用责任链有以下的优点：\",\"降低逻辑单元之间的耦合度，不同的逻辑单元的处理逻辑不耦合，提高了系统的灵活性和可维护性。\",\"提升代码的可扩展性，可以快速的装载和卸载逻辑单元，提供整个责任链的可扩展性。可以根据不同的需求，制定不同的处理流程，而且不需要修改现有的代码\",\"符合开闭原则：责任链模式将处理逻辑放在链式的逻辑单元中处理，新增一个逻辑功能，并不需要改变原有的逻辑功能\",\"可以灵活的控制责任链中逻辑单元的处理顺序\",\"总之，责任链模式可以提供一种灵活、可扩展和可维护的链式处理的机制，使系统能够更好地应对变化和复杂性。但需要防止责任链模式有过多的处理逻辑单元，如果处理链路过长，系统出错，很难去排查，也有可能影响系统的性能。所以我们在实际的使用过程中，需要权衡一下利弊，根据实际的情况做设计和优化。\"]},\"94\":{\"h\":\"工厂模式\"},\"95\":{\"h\":\"简单工厂\",\"t\":[\"简单工厂模式（Simple Factory Pattern）也称为静态工厂方法模式，属于创建型设计模式的一种。简单工厂模式提供一个简单的工厂类，根据传入参数的不同，返回不同类的实例对象。\"]},\"96\":{\"h\":\"UML图\",\"t\":[\"简单工厂包含如下角色：\",\"工厂类（SimpleSofaFactory）:负责创建实例对象的类，提供一个静态工厂方法用于创建不同的产品对象。工厂类根据客户端传入的参数来创建相应的产品对象。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"97\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象产品类（Sofa），它有一个抽象方法getName()和一个具体方法showName()\",\"public abstract class Sofa { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" sofa\\\"); } } \",\"ChineseSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class ChineseSofa extends Sofa { @Override String getName() { return \\\"china\\\"; } } \",\"AmericaSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class AmericaSofa extends Sofa{ @Override String getName() { return \\\"america\\\"; } } \",\"工厂类（SimpleSofaFactory）根据客户端传入的参数来创建相应的产品对象Sofa。\",\"public class SimpleFactory { public Sofa createCoffee(String type) { Sofa sofa = null; if(\\\"us\\\".equals(type)) { sofa = new AmericaSofa(); } else if(\\\"cn\\\".equals(type)) { sofa = new ChineseSofa(); } return sofa; } } \",\"写一个客户端，测试类：\",\"public class Client { public static void main(String[] args) { SimpleFactory factory = new SimpleFactory(); Sofa sofa = factory.createSofa(\\\"cn\\\"); sofa.showName(); } } \",\"运行结果如下：\",\"china sofa\",\"简单工厂模式是一种常见的设计模式，它具有如下的优点：\",\"工厂类包含了必要的逻辑判断，可以根据客户端的需求，动态地实例化具体的产品类。\",\"系统扩展性好，如果需要增加新的产品类，只需要修改工厂类的逻辑判断即可。\",\"那它的缺点是：\",\"工厂类包含了所有产品对象的创建逻辑，导致工厂类的代码会随着产品类型的增多而变得越来越复杂。\",\"违反了单一职责原则（SRP），工厂类负责了两个职责：创建和业务逻辑判断。\"]},\"98\":{\"h\":\"工厂方法模式\",\"t\":[\"工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成。工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题。\"]},\"99\":{\"h\":\"UML图\",\"t\":[\"image-20231105210628018\",\"工厂方法模式包含以下角色：\",\"抽象工厂（IFactory）：定义了一个工厂方法makeSofa()，用于创建产品对象的接口。\",\"具体工厂（ChineseSofaFactory）：实现抽象工厂类中定义的工厂方法makeSofa，返回一个具体的产品对象Sofa。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"100\":{\"h\":\"代码实现\",\"t\":[\"定义一个接口IFactory，它有一个createSofa()的方法：\",\"public interface IFactory { Sofa createSofa(); } \",\"IFactory的具体实现类ChineseSofaFactory：\",\"public class ChineseSofaFactory implements IFactory { @Override public Sofa createSofa() { return new ChineseSofa(); } } \",\"IFactory的具体实现类AmericaSofaFactory：\",\"public class AmericaSofaFactory implements IFactory{ @Override public Sofa createSofa() { return new AmericaSofa(); } } \",\"写一个客户端用于测试：\",\"public class Client { public static void main(String[] args) { IFactory factory=new ChineseSofaFactory(); Sofa sofa =factory.createSofa(); sofa.showName(); } } \",\"上面的测试输出结果：\",\"china sofa\",\"使用工厂方法模式的好处是：\",\"客户端通过抽象工厂来创建产品对象，可以方便地创建出不同的产品对象，而不需要了解具体的实现类。\",\"不同的产品由不同的工厂创建，符合单一职责原则，相对于简单工厂，具体工厂类的代码更加简洁。\",\"具备良好的扩展性，增加新的产品和新的工厂非常容易，无需修改已有代码。\",\"使用工厂方法模式的缺点是：\",\"大量的类：每个具体产品都需要一个具体工厂类来创建，会导致类的数量增加，增加了系统的复杂度。\"]},\"101\":{\"h\":\"抽象工厂\",\"t\":[\"工厂方法模式中考虑的是一类产品的生产，比如sofa的生产，但现实生活中，有很多同类型的产品生产，比如家具厂除了生产沙发，还生产桌子、椅子。\",\"抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\"]},\"102\":{\"h\":\"UML图\",\"t\":[\"抽象工厂的UML图如下：\",\"抽象工厂模式包含以下角色：\",\"抽象工厂（IFurnitureFactory）：定义了一系列可以创建不同产品对象的方法，每个方法对应一个具体产品类的创建方法。\",\"具体工厂（FurnitureFactory ）：实现了抽象工厂接口，负责创建一族相关的具体产品对象。\",\"抽象产品类（Table）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（ChineseTable）：实现了抽象产品类的属性和方法。\"]},\"103\":{\"h\":\"代码实现\",\"t\":[\"抽象产品类（Table），代码如下：\",\"public abstract class Table { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" table\\\"); } } \",\"具体产品类（ChineseTable），代码如下：\",\"public class ChineseTable extends Table{ @Override String getName() { return \\\"china\\\"; } } \",\"抽象工厂（IFurnitureFactory），定义了makeSofa()和makeTable()方法，代码如下：\",\"public interface IFurnitureFactory { Sofa makeSofa(); Table makeTable(); } \",\"具体工厂（FurnitureFactory ）实现了抽象工厂（IFurnitureFactory）中的创建对象的方法：\",\"public class FurnitureFactory implements IFurnitureFactory { @Override public Sofa makeSofa() { return new ChineseSofa(); } @Override public Table makeTable() { return new ChineseTable(); } } \",\"写一个测试类，该类使用抽象工厂模式创建不同的产品对象，代码如下：\",\"public class Client { public static void main(String[] args) { IFurnitureFactory factory = new FurnitureFactory(); Sofa sofa= factory.makeSofa(); Table table= factory.makeTable(); sofa.showName(); table.showName(); } } \",\"运行上面的代码，输出如下：\",\"china sofa china table\",\"抽象工厂模式提供了一种创建一族相关对象的方法，能够实现不同产品族的兼容性和高度可扩展性，它具有以下的优点：\",\"可以创建一系列相关的产品对象，保证了这些对象之间的兼容性。\",\"客户端代码与具体产品的创建实现了解耦\",\"符合开闭原则，新增一族产品时，只需要增加相应的具体产品类和工厂类即可。\",\"同时它具有以下的缺点：\",\"新增产品族、比较困难，需要修改抽象工厂的接口和具体工厂类。\",\"增加系统的复杂性\"]},\"104\":{\"h\":\"观察者模式\",\"t\":[\"观察者模式（Observer Pattern）是一种行为型设计模式，用于对象之间的一对多的依赖关系，当对象发生改变时，所有依赖于它的对象都会收到通知。\"]},\"105\":{\"h\":\"观察者模式UML图\",\"t\":[\"UML图如下：\",\"image-20231107230028268\",\"从UML图上可以得出，在观察者模式中，有以下的角色：\",\"发布者Publisher：或者被称为被观察者，它维护了一个观察者的列表，并可以动态添加观察者或者删除观察者。\",\"观察者Observer：定义了一个接收发布者消息的方法，当发布者发布消息，观察者会执行该方法。\",\"具体主题（Concrete Subject）：具体主题是主题的具体实现，它维护了一个状态，并在状态改变时通知观察者。\",\"具体观察者（Concrete Observer）：具体观察者是观察者的具体实现，它实现了观察者的更新接口，并定义了观察者接收到通知后的具体行为。\",\"观察者模式在软件开发中有非常多的应用，在GUI中应用的比较多，在消息队列的场景有广泛的应用。\"]},\"106\":{\"h\":\"案例实战\",\"t\":[\"写一个观察者接口Observer，它有一个接收通知对象的方法 notify (Object obj);\",\"package io.github.forezp.java.design.obeserver2; public interface Observer { void notify (Object obj); } \",\"Observer接口的实现类ObserverImpl的代码如下：\",\"package io.github.forezp.java.design.obeserver2; public class ObserverImpl implements Observer { private String name; public ObserverImpl(String name) { this.name = name; } @Override public void notify(Object obj) { System.out.println(name+\\\":\\\"+obj.toString()); } } \",\"消息发布者Publisher接口，可以向它注册观察者对象，也可以用它来向观察者发送消息：\",\"package io.github.forezp.java.design.obeserver2; public interface Publisher { void register(Observer observer); void notify(Object o); } \",\"Publisher接口的实现类PublisherImpl，代码如下：\",\"package io.github.forezp.java.design.obeserver2; import java.util.ArrayList; import java.util.List; public class PublisherImpl implements Publisher { private List<Observer> list = new ArrayList<>(); @Override public void register(Observer observer) { list.add(observer); } @Override public void notify(Object o) { for (int i = 0; i < list.size(); i++) { list.get(i).notify(o); } } } \",\"写一个客户端测试类：\",\"package io.github.forezp.java.design.obeserver2; public class Client { public static void main(String[] args) { Publisher publisher=new PublisherImpl(); publisher.register(new ObserverImpl(\\\"observer1\\\")); publisher.register(new ObserverImpl(\\\"observer2\\\")); publisher.notify(\\\"fangzhipeng.com\\\"); } } \",\"运行结果如下：\",\"observer1:fangzhipeng.com observer2:fangzhipeng.com\"]},\"107\":{\"h\":\"为什么要使用观察者模式\",\"t\":[\"观察者模式的核心思想是将观察者对象注册到发布者对象中，发布者对象可以对所有的观察者发送消息，观察者收到消息后可以做出响应。\",\"使用观察者模式有以下的收益：\",\"主题和观察者之间松耦合，使得发布者和观察者互不影响。对象之间关系也比较清晰。可以利用发布者向所有的观察者发送消息。\",\"可扩展性很强，可以动态地添加和删除观察者，灵活性非常高。如果不使用观察者模式来捕获一个被观察对象的属性变化，那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑，这样不仅增加了代码的耦合性，也让代码扩展变得非常困难。\",\"观察者模式符合开闭原则，增加新的观察者，不需要修改已有的代码。\",\"同时，观察者模式也有一些缺点，比如发布者维护的观察者对象是无顺序的，并且发布者发布消息也是无顺序的，如果需要把证消息发送的顺序，需要做更多的工作。此外，过多的观察者会影响性能，需要做性能测试。\",\"综上所述，观察者模式是一种实用并且简单的设计模式，它能够提高系统的可扩展性和灵活性。但是在使用它的时候需要注意它带来的一些缺点，要做一些优化工作。\"]},\"108\":{\"h\":\"代理模式\",\"t\":[\"代理模式和装饰器模式类似，都是在不改变同一个接口功能的前提下，对原有功能的做扩展或者增强。代理模式并没有做类似于装饰器模式多层嵌套，而是采用灵活的单一结构。在Java语言中并支持动态代理，在很多RPC框架、Spring AOP、Spring事务等领域有着广泛的应用。\",\"代理模式是一种结构性模式，它允许将对象的访问控制和代码运行位置转移到代理对象中。类似于中介，代理对象可以控制客户端对真实对象的访问。代理模式常用于对已有功能的增强，比如访问控制、远程调用。\"]},\"109\":{\"h\":\"静态代理\",\"t\":[\"代理模式分为静态代理和动态代码，一般静态代理使用的比较少，而动态代理在各种框架、中间件有着广泛的应用。\",\"静态代理需要手动创建一个代理类，实现被代理对象的接口，并将实际对象的方法调用转发给它。静态代理的优点是简单易懂，但缺点是需要手动创建代理类，对于需要代理的类数量较多或变化频繁的情况下，代码会变得臃肿难以维护。\",\"从上面的 UML 图中，我们可以看出代理模式有三个关键角色：\",\"抽象主题接口类（Subject）：它定义了一些方法。\",\"主题实现类（RealSubject）：实现了抽象接口类（的所有方法\",\"代理类（StaticProxy）：实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。\"]},\"110\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象主题类：\",\"public interface Subject { void operation(); } \",\"主题实现类（RealSubject）的代码如下：\",\"public class RealSubject implements Subject{ @Override public void operation() { System.out.println(\\\"do somthing\\\"); } } \",\"代理类（StaticProxy）实现了抽象主题类，并持有主题实现类的对象，并在主题实现类的对象的operation()方法之前和之后做了功能的增强，具体代码如下：\",\"public class StaticProxy implements Subject{ private RealSubject realSubject; public StaticProxy(RealSubject realSubject) { this.realSubject = realSubject; } @Override public void operation() { System.out.println(\\\"before operation...\\\"); realSubject.operation(); System.out.println(\\\"after operation...\\\"); } } \",\"写一个客户端实现类，代码如下：\",\"public class Client { public static void main(String[] args) { testStatic(); } public static void testStatic() { StaticProxy staticProxy = new StaticProxy(new RealSubject()); staticProxy.operation(); } } \",\"运行代码，输出如下：\",\"before operation... do somthing after operation...\"]},\"111\":{\"h\":\"动态代理\",\"t\":[\"动态代理可以使用 Java 动态代理机制和CGLIB动态代理。\"]},\"112\":{\"h\":\"Java 动态代理\",\"t\":[\"Java 动态代理是在运行时自动生成代理类并将方法调用转发到实际对象。 Java 动态代理的优点是避免了手动创建代理类的麻烦，但缺点是对于一些无法实现接口的类，无法使用动态代理。\",\"Java 动态代理是使用Java的反射机制来实现动态代理。Java提供了java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。\",\"具体使用Java 动态代理的步骤是先实现InvocationHandler接口。和静态代理类似：在这个接口中，需要对真实的代理对象的功能需要做一下加强，它是实现动态代理的关键，代码如下：\",\"public class ProxyHandler implements InvocationHandler { private Object object; public ProxyHandler(Object object){ this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"Before invoke \\\" + method.getName()); method.invoke(object, args); System.out.println(\\\"After invoke \\\" + method.getName()); return null; } } \",\"实现代理如下：\",\"public class Client { /** * jdk动态代理 */ public static void testJdkProxy() { Subject realSubject = new RealSubject(); ProxyHandler handler = new ProxyHandler(realSubject); Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.operation(); } public static void main(String[] args) { testJdkProxy(); } } \",\"运行代码输出：\",\"Before invoke operation do somthing After invoke operation\",\"Java动态代理是基于反射生产的一个代理类，这个代理类本身已经继承了jdk包中的Proxy对象，而Java是不允许多继承的，所以只能实现接口的方式进行代理。\",\"它的优点如下：\",\"Java动态代理不需要任何依赖\",\"灵活性：动态代理可以在运行时动态生成代理类，\",\"可拓展性：可以通过动态代理实现一些横切关注点，比如日志记录、性能监控等，而无需修改原有的代码。\",\"缺点：\",\"性能开销：由于动态代理是在运行时动态生成代理类，相比直接调用实现类的方法，会带来一定的性能开销\",\"功能限制：动态代理只能对接口进行代理，在某些情况下，无法代理实现类的方法。\"]},\"113\":{\"h\":\"CGLIB代码\",\"t\":[\"在pom文件中引入cglib包，代码如下：\",\" <dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> version>3.2.5</version> </dependency> \",\"CGlib代码模式需要实现MethodInterceptor，并在intercept方法中实现真实对象的功能增强，代码如下：\",\"public class CglibProxyFactory implements MethodInterceptor { private Object target;//维护一个目标对象 public CglibProxyFactory(Object target) { this.target = target; } //为目标对象生成代理对象 public Object getProxyInstance() { //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象代理 return en.create(); } @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"开始cglib拦截\\\"); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\\\"结束cglib拦截\\\"); return returnValue; } } \",\"写一个测试类：\",\"public class Client { public static void main(String[] args) { testCglibProxy(); } /** * 测试cglib */ public static void testCglibProxy() { Subject subject = new RealSubject(); Subject proxy = (Subject) new CglibProxyFactory(subject).getProxyInstance(); proxy.operation(); } } \",\"执行结果如下：\",\"开始cglib拦截 do somthing 结束cglib拦截\",\"CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，用于在运行时扩展Java类和实现动态代理。与Java动态代理不同，CGLIB可以代理非接口类型的类。\",\"CGLIB动态代理的优点:\",\"性能高：相比Java动态代理，CGLIB动态代理通常能够提供更好的性能，因为它是通过生成子类来代理目标类，而不是通过实现接口。\",\"功能强大：CGLIB能够代理普通类和接口类，更灵活地满足额外需求，例如代理私有方法、拦截静态方法等。\",\"无需依赖接口：CGLIB动态代理可以代理没有实现任何接口的类，这使得它可以代理更多类型的类，提供更大的灵活性。\",\"CGLIB动态代理的缺点:\",\"需要额外依赖：CGLIB动态代理需要引入额外的库，增加项目的依赖，相比Java动态代理而言更为复杂。\",\"对final方法和final类的限制：CGLIB无法代理final方法和final类。\",\"不支持自身方法调用：CGLIB无法从代理对象中调用自身的方法，这可能会引起无限循环或抛出异常。\"]},\"114\":{\"h\":\"概览\"},\"115\":{\"h\":\"Prometheus教程介绍\",\"t\":[\"本篇文章为系列教程，旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统。所用到开源组件如下：\",\"Prometheus\",\"Grafana\",\"VictoriaMetrics系列\",\"Node-exporter\",\"Alertmanager\",\"Kafka\",\"Flink\",\"最终的技术架构如下：\",\"image-20230830224136440\"]},\"116\":{\"h\":\"Prometheus概述\"},\"117\":{\"h\":\"什么是Prometheus\",\"t\":[\"Prometheus是一个开源的监控系统，提供了数据采集、告警计算、告警管理等一系列工具包，周边生态非常的丰富。\",\"Prometheus受启发于Google的Brogmon监控系统（类似于Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师以开源软件的形式进行研发，并且于2015年对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF(云原生计算基金会)的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。\",\"Prometheus通过时序数据来收集和存储指标。一个时序数据包含了一个时间戳、值和一个或者是多个key-value键值对。\"]},\"118\":{\"h\":\"Prometheus提供的特性\",\"t\":[\"作为新一代的监控系统，Prometheus和传统的监控系统相比，有着非常大的创新。Prometheus让监控从传统的黑盒子监控提升到了白盒监控；不仅可以监控系统的一些状态，也可以深入到进程内部关键点的监控（白盒监控）。\",\"Prometheus提供一些关键的特性：\",\"多维的数据结构，这个数据结构包括一个指标名和一系列的键值对（指标）。\",\"提供了数据查询的Promql，Promql非常的强大和灵活。\",\"提供了单节点和分布式的数据存储方案。也可以使用第三方时序数据去存储，比如influxdb、thanos、victoriaMetrics\",\"时序数据使用http协议采集，通常是pull模式，也可以使用push模式（通过中间层push_gateway）\",\"采集目标可以使用服务发现的方式（比如k8s系统、consul），也可以通过静态的配置去发现采集目标。\",\"可以和开源组件grafana无缝对接。\"]},\"119\":{\"h\":\"组件\",\"t\":[\"Prometheus生态包含了一系列组件，除了Prometheus很多组件是可选的：\",\"Prometheus server是最核心的组件，用来抓取和存储时序数据的。\",\"Client-libraries（sdks）是用来开发应用指标的工具包\",\"Push_gateway是用来短暂存储push类型指标的\",\"exporters是用来暴露或者导出被监控对象的指标的，比如虚拟机、nginx、mysql等\",\"alertmanager是用来管理告警消息的，比如对消息的去重、静默、恢复等管理\",\"还有一系列其他的组件\",\"大多数Prometheus组件都是使用go语言写的，非常容易的打包和部署。\"]},\"120\":{\"h\":\"架构\",\"t\":[\"下图是Prometheus和它周边生态组件的架构图，这些组件构成了一个完整的监控系统：\",\"Prometheus architecture\",\"Prometheus通过pull的方式去周期性（通常15-30s）采集监控对象的指标，健康对象包含： \",\"直接采集的jobs和exporters\",\"也可以是短生命周期的任务推送到pushgateway的指标\",\"监控对象的发现 \",\"可以是k8s的集群的服务发现\",\"也可以是consul\",\"或者静态的配置文件\",\"prometheus发现到监控目标后，会周期性的去采集指标，并将指标存储在主机的磁盘中\",\"通过了内置的告警规则计算，并将告警消息发送给alertmanager\",\"alertmanager提供了对告警消息的管理、去重、静默、分发，可以配置多种分发方式： \",\"比如email\",\"webhook\",\"prometheus提供了http接口的方式让外部第三方访问数据，比如可以将指标数据展示在grafana上。\"]},\"121\":{\"h\":\"prometheus适用的场景\",\"t\":[\"prometheus可以很好地记录任何纯粹的数字时间序列。它既适合以机器为中心的监视，也适合高度动态的面向服务的体系结构的监视。\",\"在微服务的世界里，它对多维数据收集和查询的支持是一个特别的优势。\",\"Prometheus是为可靠性而设计的。每个Prometheus都是单节点设计的，使用多个节点去采集相通的监控对象可以做到高可用。通过Prometheus建立完善的监控体系，从而达到以下目的：\",\"长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。\",\"对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。\",\"告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。\",\"故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题。\",\"数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息\",\"img\",\"那prometheus不适合什么？\",\"由于prometheus是使用周期性的采集数据，它并不能保证数据的及时性和绝对正确性，如果是想做与money相关的业务，使用prometheus明显是不合适的。\"]},\"122\":{\"h\":\"Prometheus环境搭建\",\"t\":[\"本文是Prometheus环境的搭建和安装，包括prometheus-sever、node-exporter、grafna的安装。安装成功后，配置prometheus采集node-exporter的指标，然后在grafana展示node-exporter采集的指标。\"]},\"123\":{\"h\":\"安装prometheus\",\"t\":[\"去prometheus官网下载prometheus，下载地址为https://prometheus.io/download/ ，目前提供了Linux\\\\windows\\\\mac的版本，笔者这里下载mac版本的。\",\"image-20231008083006727\",\"下载完成后，执行解压：\",\"tar -zxvf prometheus-2.47.1.darwin-amd64.tar.gz cd prometheus-2.47.1.darwin-amd64 \",\"执行启动命令：\",\"./prometheus \",\"笔者是mac电脑，运行时会被系统拒绝运行，需要打开系统偏好设置-安全与隐私，允许prometheus运行。\",\"其他操作系统应该没有这个问题。\",\"启动成功后，访问http://localhost:9090 ，就可以访问prometheus页面了，这个页面提供了对prometheus数据的查询和告警信息的查询，页面展示如下：\",\"image-20231008084050835\"]},\"124\":{\"h\":\"prometheus配置文件讲解\",\"t\":[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus.yml，这个配置文件是prometheus启动的时候会读取的配置。具体如下：\",\"# my global config global: scrape_interval: 15s evaluation_interval: 15s # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] \",\"具体的配置介绍如下：\",\"global.scrape_interval 是全局配置默认采集时间间隔（周期性采集监控目标）\",\"global.evaluation_interval是全局配置告警规则任务的计算\",\"alerting.alertmanagers是配置alertmanagers的地址的，alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",\"rule_files是配置告警规则文件的路径，可以使用通配符\",\"scrape_configs是配置采集任务的，支持多种类型的采集，比如从k8s、consul、也可以配置静态采集任务。上面的配置是采集prometheus自身的监控指标。可以访问prometheus自身的监控指标的暴露端点：http://localhost:9090/metrics，可以得到prometheus的监控指标，内容如下：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 4.5782e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 7.745e-05 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000123743 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000251038 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.002707693 go_gc_duration_seconds_sum 0.009608685 go_gc_duration_seconds_count 35 # HELP go_goroutines Number of goroutines that currently exist. # TYPE go_goroutines gauge go_goroutines 32 # HELP go_info Information about the Go environment. # TYPE go_info gauge go_info{version=\\\"go1.21.1\\\"} 1 # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use. # TYPE go_memstats_alloc_bytes gauge go_memstats_alloc_bytes 2.1363728e+07 # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed. # TYPE go_memstats_alloc_bytes_total counter go_memstats_alloc_bytes_total 3.82033736e+08 # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table. # TYPE go_memstats_buck_hash_sys_bytes gauge go_memstats_buck_hash_sys_bytes 1.489234e+06 ... \"]},\"125\":{\"h\":\"采集Node Exporter的指标\",\"t\":[\"Node Exporter是Prometheus生态的一员，它为主机暴露了硬件和内核相关的指标，比如主机的cpu、内存、磁盘、io读写等。目前支持linux系统、windows系统和mac系统，下载地址为：\",\"https://github.com/prometheus/node_exporter/releases \",\"下载完成后，启动node_exporter，node_exporter的端口为9100，访问http://localhost:9100/metrics，就可以查看node_exporter暴露的端口指标。\",\"在prometheus的配置文prometheus.yml中，增加采集Node Exporter的任务，配置信息如下：\",\"scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] - job_name: \\\"node_exporter\\\" static_configs: - targets: [\\\"localhost:9100\\\"] \",\"重新启动prometheus的程序，prometheus 就可以采集Node_Exporter的指标了。\",\"访问prometheus的网页，http://localhost:9090/graph，在查询框里输入node_filesystem_free_bytes（文件系统里剩余的磁盘字节数），就可以看到各个目录的磁盘剩余字节数了。\",\"image-20231008231356066\"]},\"126\":{\"h\":\"prometheus配置文件热更新\",\"t\":[\"在prometheus启动的时候加上启动参数--web.enable-lifecycle，具体命令如下：\",\"prometheus --web.enable-lifecycle \",\"在更改完配置以后，就可以进行配置的热更新，通过拉prometheus的配置热更新接口，接口如戏：\",\"curl -XPOST http://localhost:9090/-/reload \"]},\"127\":{\"h\":\"grafana安装\",\"t\":[\"Grafana是一个开源的、流行的、炫酷的展示数据的可视化仪表盘，它支持多种类型的数据库，提供了非常多的面板和插件，可以让开发者轻松的实现监控大盘。\",\"grafana可以完美的和prometheus结合，展示prometheus数据。\",\"进入grafana官网下载安装包，笔者是mac，所以下载的是mac版本的，下载命令如下：\",\"curl -O https://dl.grafana.com/enterprise/release/grafana-enterprise-10.1.4.darwin-amd64.tar.gz tar -zxvf grafana-enterprise-10.1.4.darwin-amd64.tar.gz \",\"下载并解压成功后，进入到grafana的安装目录，启动grafana，启动命令如下：\",\"./bin/grafana-server \",\"grafana有很多配置项在conf目录下default.ini文件下，此篇文章不讲解这部分内容。\",\"启动成功后，进入grafana的页面，地址为localhost:3030 ，grafana的默认登陆用户名admin、密码为admin\",\"登陆成功后，需要为grafana配置prometheus的数据源，配置界面的路径和配置如下：\",\"配置完成后保存。\",\"然后去grafana官方网站的dashboard社区找一个node exporter的面板，搜索地址：https://grafana.com/grafana/dashboards/?pg=community&plcmt=topnav&search=node+exporter+mac\",\"搜索成功后，在本地部署的grafana页面导入node exporter的dashboard，页面的导入路径如下：\",\"image-20231010201727866\",\"导入成功后，就可以看到本机的资源dashboard（由node exporter采集的指标生产）\",\"image-20231009220040376\"]},\"128\":{\"h\":\"总结\",\"t\":[\"prometheus作为一个采集组件，采集了node-exporter的指标\",\"同时prometheus作为一个时序数据库，存储了node-expoter的指标时序\",\"grafana作为数据展示前端，读取prometheus的指标时序，并展示在监控大盘上。\"]},\"129\":{\"h\":\"Prometheus的数据模型\"},\"130\":{\"h\":\"什么是time-series\",\"t\":[\"Prometheus通过时间序列来存储所有的数据的。时间序列是指标（有相同指标名和标签构成的）的包含时间和值的流式数据。采用的数据模型是单值模型，且只支持浮点数指标。举个例子：\",\"在前面的文章介绍过如下Prometheus自身的监控，通过/metrics接口暴露，Prometheus可以通过调用/metrics接口来获取自身的数据。指标定义如下：\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \",\"指标是单值模型，即一个指标代表一种含义，如下表示prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 指标在不同时间下的值。\",\"指标名称(name)\",\"code\",\"handler\",\"Timestamp\",\"Value\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984318.82\",\"1205\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984153.822\",\"1194\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984033.817\",\"1186\",\"指标在不同时间有不同的值，被称为time-series（时间序列），time-series中每个点被称为一个样子（sample)，sample由三部分组成：\",\"指标：指标是由指标名和标签组成，它们共同组成描述当前指标的特征 \",\"指标名和标签名的命名需要满足[a-zA-Z_:][a-zA-Z0-9_:]*\",\"对于标签值无约束，但是需要对值的控制字符进行转义\",\"时间戳(timestamp)：时间戳精度为毫秒\",\"值(value)： float64类型的值。\",\"<--------------- metric -------------------------------------><-timestamp -><-value-> prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984318.82 => 1205 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984153.822 => 1194 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984033.817 => 1186 \",\"在grafana上查询指标：prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}；\",\"image-20231012215203283\"]},\"131\":{\"h\":\"指标的类型\",\"t\":[\"Prometheus定义来四种类型的指标：\",\"Counter（累加器），初始值为0，只增不减，或者重启的进程的时候重置为0\",\"Gauge（仪表盘），状态值，可增可减。\",\"Histogram（直方图），用于求分位数，比如p99\",\"Summary（摘要），和直方图类似\",\"但是对于Prometheus的底层数据来说，这些类型的指标在存储的时候，并没有差别，都是以time-series的形式存储在Prometheus的level-db中。而在样本数据采集的时候，在注释中包含了指标的类型，其实在存储的时候是并没有存储的。\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \"]},\"132\":{\"h\":\"Counter 累加器\",\"t\":[\"Counter类型的指标和计数器一样，初始值为零，是单调递增的，除非进程重启重置。一般Counter类型的指标建议以_total结尾。例如prometheus_http_requests_total表示prometheus服务的http请求的数量，prometheus每发生一个请求，prometheus_http_requests_total都会累积1。\",\"使用counter类型的指标，可以很容易一段时间的增量数据，比如求最近5分钟prometheus发生了多少次请求：\",\"increase(prometheus_http_requests_total[5m]) \",\"increase是promql中的一个函数，函数的内容，在下一篇文章将会讲解。\"]},\"133\":{\"h\":\"Gauge仪表盘\",\"t\":[\"Gauge类型的指标主要反映的是当前的状态，它是可增可减的，比如node exporter采集的指标中：node_filesystem_avail_bytes，表示的是当前系统文件系统中磁盘可用的字节数，可用通过prometheus的内置函数计算最近5分钟node_filesystem_avail_bytes的差值。\",\"delta(node_filesystem_avail_bytes{}[5m]) \",\"还可以使用predict_linear函数对指标的数据变化趋势进行预测。例如，预测系统磁盘在6个小时之后的剩余情况：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[1h], 6* 3600) \"]},\"134\":{\"h\":\"Histogram直方图\",\"t\":[\"Histogram直方图是用来统计和分析样本的分布情况。\",\"在很多场景下，我们可以使用求平均值来量化指标。比如我们求某个请求耗时的平均值，但是在大多数情况下，请求都是在100ms以内，而个别情况可能导致请求耗时超过了5s，导致请求耗时的平均值远大于100ms，这个平均值是不能反应的请求的真实状态。\",\"Histogram直方图可以解决上面的问题，例如0-10ms的请求有多少个，10ms-20ms的请求又多少个。例如prometheus的服务的/metrics接口耗时，使用了prometheus_http_request_duration_seconds_bucket指标去统计。\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.1\\\"} 1827 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.2\\\"} 1828 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.4\\\"} 1829 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"1\\\"} 1830 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"3\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"8\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"20\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"60\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"120\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"+Inf\\\"} 1831 \",\"在上面的示例中，使用le标签表示小于的意思。\",\"le=\\\"0.1\\\" 表示小于0.1s，有1827个请求\",\"le=\\\"0.2\\\"表示小于0.2s，有1828个请求\",\"通过这种直方图可以很方便的统计请求耗时分布的真实状态。另外，会统计当前指标的记录总数(以_count作为后缀)和值的总和（以_sum作为后缀），例如：\",\"prometheus_http_request_duration_seconds_sum{handler=\\\"/metrics\\\"} 15.171390910999984 prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"} 1831 \",\"Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。\"]},\"135\":{\"h\":\"summary\",\"t\":[\"summary和Histogram类似，只不过summary是已经在客户端已经计算好的数据，例如go_gc_duration_seconds指标：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 6.3884e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 0.00013637 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000194843 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000421166 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.009242327 go_gc_duration_seconds_sum 0.1255515 go_gc_duration_seconds_count 296 \",\"Histogram和summary的区别在于，summary是在sdk侧已经计算好了分位数，而Histogram是通过histogram_quantile函数在prometheus-server进行计算的。对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多服务端的的资源。\",\"通常情况下，我们都会选择使用Histogram类型的指标去做分位数的统计，而不是使用summary。\"]},\"136\":{\"h\":\"Promql快速入门\",\"t\":[\"prometheus的时间序列是通过指标名和一组标签来唯一定义。指标的名称是监控样本的标识，而标签组是监控样本的多个维度特征的反应，所以可以通过标签进行对指标的筛选、过滤、聚合、转换等计算，计算的结果会产生一条新的时间序列。\",\"promql是Prometheus提供的数据查询语言，可以对时间序列提供丰富的查询。promql被广泛应用于指标视图的配置、告警语句的配置，它是一个基础能力，类似于mysql的sql查询语句。\"]},\"137\":{\"h\":\"瞬时向量查询（Instant vector selectors）\",\"t\":[\"我们可以直接输入指标名查询所有的这个指标名的时间序列，比如：\",\"prometheus_http_requests_total \",\"上面的语句等同于：\",\"prometheus_http_requests_total \",\"可以在grafana上查询，获取了prometheus_http_requests_total指标的不同标签维度的所有指标，一共有53个。\",\"image-20231014210829763\",\"可以筛选出handler=“/metrics\\\"接口的数据，在grafana执行：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"} \",\"image-20231014210912914\",\"另外也可以筛选出handler!=“/metrics\\\"的所有的数据，查询语句为：\",\"prometheus_http_requests_total{handler!=\\\"/metrics\\\"} \",\"也可以使用多个标签值进行进行查询，比如查询handler为\\\"/metrics“和handler为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler=~\\\"/metrics|/api/v1/labels\\\"} \",\"同理，也查询handler不为\\\"/metrics“和handler不为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler!~\\\"/metrics|/api/v1/labels\\\"} \",\"也可以使用.*通配符进行模糊匹配查询：\",\"prometheus_http_requests_total{handler=~\\\"/metric.*\\\"} \",\"小结：\",\"使用标签筛选数据的使用，可以使用完全匹配：\",\"label = value\",\"lable =~ value | value2\",\"也可以进行模糊匹配：\",\"label =~ value.*\",\"取反操作\",\"label != value\",\"Label !~ value1 |value2\",\"Label !~ value.*\"]},\"138\":{\"h\":\"范围向量查询（Range Vector Selectors）\",\"t\":[\"通过Instant vector selectors查询，返回值只会包含该时间序列的最新值的一个样本，它是一个瞬时向量结果。如果我们想查询一个时间区间的样本，可以使用范围矢量查询。范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}[5m] \",\"image-20231014211256244\",\"时间范围除了支持分钟（m)外，还还支持\",\"秒（s)\",\"分钟（m）\",\"小时（h）\",\"天（d）\",\"周（w）\",\"年（y）\"]},\"139\":{\"h\":\"offset 时间位移操作\",\"t\":[\"瞬时向量查询和范围向量查询的表达式中，都是以当前时间为基准的，比如：\",\"prometheus_http_requests_total{}，查询当前时间的最新值\",\"prometheus_http_requests_total{}[5m]，查询的是当前时间的过去五分钟的数据。\",\"如果想查询五分钟前的数据，获取昨天的当前时间同一时刻的五分钟的数据，怎么查询呢，我们可以使用offset关键字：\",\"prometheus_http_requests_total{} offset 5m，查询五分钟前的最新值\",\"prometheus_http_requests_total{}[5m] offset 1d，查询的是昨天的当前时间同一时刻的五分钟的数据\"]},\"140\":{\"h\":\"操作符\"},\"141\":{\"h\":\"数学操作符\",\"t\":[\"Promql支持常见的逻辑和数学操作符，这些操作符使用于瞬时向量的查询，常见的逻辑运算符如下\",\"+ (addition) 加\",\"- (subtraction) 减\",\"* (multiplication) 乘\",\"/ (division) 除\",\"% (modulo) 取模\",\"^ (power/exponentiation) 幂运算\",\"在作用于两个瞬时向量之间，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。如果匹配到了，会将计算结果输出到新的向量上，向量里面的标签是左侧和右侧共同匹配的标签，指标名将会被删除。\",\"例如下面的查询语句不会输出任何结果，因为两个handler标签值不一样。\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}+prometheus_http_requests_total{handler=\\\"/api/v1/labels\\\"} \",\"再比如下面的查询语句的可以输出结果，因为左侧的表达式有一个handler=\\\"/metrics\\\"，右侧的表达式也有一个handler=\\\"/metrics\\\"标签，完全匹配，所以能够输出：\",\"sum(prometheus_http_requests_total{handler=\\\"/metrics\\\"})by(handler)+sum(prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"})by(handler) \"]},\"142\":{\"h\":\"比较操作符\",\"t\":[\"promql还支持常见的比较运算符，比如：\",\"== (equal)\",\"!= (not-equal)\",\"> (greater-than)\",\"< (less-than)\",\">= (greater-or-equal)\",\"<= (less-or-equal)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"143\":{\"h\":\"逻辑运算符\",\"t\":[\"逻辑运算符作用于两个瞬时向量之间，支持的逻辑运算符如下：\",\"and (intersection) 求交集\",\"or (union) 求并集\",\"unless (complement)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"144\":{\"h\":\"向量匹配符号 Vector matching\",\"t\":[\"在上面讲解的操作符，比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算。在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算，promql提供了两个向量匹配符号\",\"on （匹配）\",\"Ignoring （忽略）\",\"使用上面的Vector matching，可以应用于One-to-one vector matches（一对一）和Many-to-one and one-to-many vector matches（一对多或者多对一）\"]},\"145\":{\"h\":\"分组修改器 Group modifiers\",\"t\":[\"分组修改器可以实现many-to-one/one-to-many的向量匹配，通常使用以下的关键字：\",\"group_left\",\"group_right\",\"分组修改器可以一边的标签组赋值给另一边的查询结构。\",\"举例子讲解\",\"比如有以下的时间序列的样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用以下的查询：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"如果不用ignoring修改器，将得不到任何结果。\",\"使用group_left修改器进行查询：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \"]},\"146\":{\"h\":\"聚合函数\",\"t\":[\"Prometheus提供非常的多的聚合函数，可以用来聚合耽搁瞬时向量，聚合完后的结果会生成根据聚合标签生成一个新的序列：\",\"sum (calculate sum over dimensions)\",\"min (select minimum over dimensions)\",\"max (select maximum over dimensions)\",\"avg (calculate the average over dimensions)\",\"group (all values in the resulting vector are 1)\",\"stddev (calculate population standard deviation over dimensions)\",\"stdvar (calculate population standard variance over dimensions)\",\"count (count number of elements in the vector)\",\"count_values (count number of elements with the same value)\",\"bottomk (smallest k elements by sample value)\",\"topk (largest k elements by sample value)\",\"quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\",\"基本查询格式是：\",\"<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>) \",\"比如prometheus_http_requests_total这个指标有4个标签，分别是code、handler、instance、job（其中job为采集任务、instance为被采集的实例，这两个标签对于同一个实例来说基本不变）， timeseries格式如下：\",\"prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} \",\"我们可以计算所有handler、code的的请求总数：\",\"sum by (handler, code) (prometheus_http_requests_total) \",\"它同等于：\",\"sum without (instance, job) (prometheus_http_requests_total) \",\"如果想计算所有的请求的总数：\",\"sum(prometheus_http_requests_total) \",\"获取请求次数最多的5个请求，可以用topk函数：\",\"topk(5,sum by (handler, code) (prometheus_http_requests_total)) \"]},\"147\":{\"h\":\"其他常见的函数\"},\"148\":{\"h\":\"计算counter的增长率\",\"t\":[\"可以使用increase函数计算增量数据，比如计算最近5分钟的请求次数：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"这里使用prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]获取最近五分钟的样本，用increase函数算出五分钟的增量。\",\"那么每秒的增量率，可以将上面的结果除以300，可以使用以下的表达式进行计算：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m])/(60*5) \",\"除了使用increase函数计算增量外，可以使用rate函数计算速率，上面的表达式等价于：\",\"rate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于请求数量在5分钟的时间窗口内，可能在某一时刻访问量突增，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。\",\"为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。\",\"irate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \"]},\"149\":{\"h\":\"预测指标变化趋势\",\"t\":[\"predict_linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据，函数的格式如下：\",\"predict_linear(v range-vector, t scalar) \",\"例如，基于5小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[5h], 24 * 3600) < 0 \"]},\"150\":{\"h\":\"计算分位数\",\"t\":[\"Histogram类型的指标可以使用histogram_quantile函数进行计算，函数格式为：\",\"histogram_quantile(φ scalar, b instant-vector) \",\"例如有以下的指标prometheus_http_request_duration_seconds_bucket\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\", job=\\\"prometheus\\\", le=\\\"0.1\\\"} 3767 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.2\\\"} 3769 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.4\\\"} 3773 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"1\\\"} 3775 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"3\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"8\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"20\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"60\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"120\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"Infinity\\\"} 3776 \",\"计算handler=\\\"/metrics\\\"接口的p90耗时：\",\"histogram_quantile(0.9, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \",\"计算p99耗时的表达式如下：\",\"histogram_quantile(0.99, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \"]},\"151\":{\"h\":\"总结\",\"t\":[\"本文快速的讲解了promql的查询、操作符、函数，并通过案例进行了实战。详细内容可以查看官方网站：https://prometheus.io/docs/prometheus/latest/querying/basics/\"]},\"152\":{\"h\":\"在SpringBoot项目中使用Prometheus监控\",\"t\":[\"本篇文章主要讲解如何在SpringBoot项目中使用Prometheus监控，实现方式有两种，一种是使用Springboot自带的spring-boot-starter-actuator；另一种是使用Prometheus的Java客户端\"]},\"153\":{\"h\":\"方案一：使用spring-boot-starter-actuator\",\"t\":[\"SpringBoot已经有来Micrometer的指标库，它默认集成在spring-boot-starter-actuator的依赖包中（要求SpringBoot>=2.0版本）。\",\"新建一个SpringBoot项目，在项目中引入以下的依赖：\",\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <version>1.11.4</version> </dependency> \",\"其中micrometer-registry-prometheus依赖是将Micrometer的指标转换成prometheus格式的指标。\",\"然后在springboot的配置文件application.properties中开启prometheus的暴露接口：\",\"management.endpoints.web.exposure.include=prometheus \",\"在SpringBoot项目创建一个测试接口：\",\"@Controller public class BasicController { // http://127.0.0.1:8080/hello?name=lisi @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后，在浏览器上请求http://127.0.0.1:8080/actuator/prometheus\",\"可以得到/hello接口相关的指标，当然actuator有很多内置的指标，在这里就不展开讲解了 。\",\"# HELP http_server_requests_seconds # TYPE http_server_requests_seconds summary http_server_requests_seconds_count{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 7.0 http_server_requests_seconds_sum{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.071374449 # HELP http_server_requests_seconds_max # TYPE http_server_requests_seconds_max gauge http_server_requests_seconds_max{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.049234863 \",\"在这里有三个指标，分别为\",\"http_server_requests_seconds_count 请求的总次数\",\"http_server_requests_seconds_sum 请求的总耗时\",\"http_server_requests_seconds_max 请求的最大耗时\",\"这个内置指标对请求耗时统计不是做的很好，只能求到最大的耗时和平均耗时，如果要求分位耗时，其实是做不到。而使用Prometheus的Java客户端是可以做到分位耗时的。\"]},\"154\":{\"h\":\"方案二：使用Prometheus\",\"t\":[\"Prometheus官方提供了Java客户端，用于Java程序的指标暴露。在SpringBoot项目中的pom文件引入以下的依赖：\",\" <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-instrumentation-jvm</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-exporter-httpserver</artifactId> <version>1.0.0</version> </dependency> \",\"其中prometheus-metrics-core包是指标的关键包；prometheus-metrics-instrumentation-jvm是用于暴露JVM相关的指标（可选）；prometheus-metrics-exporter-httpserver是用于导出指标的服务（可选）；\",\"同样的，在项目中有一个测试接口，如下：\",\" @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } \",\"然后，需要创建两个指标，如下：\",\"Counter类型的http_count_total，用于统计请求的数量，包括两个标签uri（请求路径）和status（请求状态码）\",\"Histogram类型的http_count_seconds，用于统计请求的耗时，包括两个标签uri（请求路径）和status（请求状态码）\",\"然后创建一个HandlerInterceptorAdapter的拦截器，用于指标数据的统计：\",\"在preHandle方法中记录请求的开始时间startTime\",\"在afterCompletion方法中，统计请求的次数和请求耗时，\",\"完整的代码如下：\",\"package io.github.forezp.prometheuslab.aop; import io.prometheus.metrics.core.metrics.Counter; import io.prometheus.metrics.core.metrics.Histogram; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ApiStatInterceptor extends HandlerInterceptorAdapter { Counter counter = Counter.builder() .name(\\\"http_count_total\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); Histogram histogram = Histogram.builder() .name(\\\"http_count_seconds\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); request.setAttribute(\\\"startTime\\\", startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { long startTime = (Long) request.getAttribute(\\\"startTime\\\"); long endTime = System.currentTimeMillis(); String uri=request.getRequestURI(); counter.labelValues(uri,\\\"ok\\\").inc(); histogram.labelValues(uri,\\\"ok\\\").observe(endTime-startTime); } } \",\"然后将ApiStatInterceptor注册到WebMvcConfigurer中：\",\"@Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new ApiStatInterceptor()); } } \",\"开启HTTPServer，并已bean的形式注册：\",\" @Bean public HTTPServer createHttpServer() throws IOException { HTTPServer server = HTTPServer.builder() .port(9400) .buildAndStart(); return server; } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后在浏览器上访问http://localhost:9400/metrics，可以看到有两个指标http_count_total和http_count_seconds，指标数据如下：\",\"# HELP http_count_total example counter # TYPE http_count_total counter http_count_total{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2.0 # HELP http_count_seconds example counter # TYPE http_count_seconds histogram http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.005\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.01\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.025\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.05\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.1\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.25\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"1.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"2.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"5.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"10.0\\\"} 1 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"+Inf\\\"} 2 http_count_seconds_count{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2 http_count_seconds_sum{status=\\\"ok\\\",uri=\\\"/hello\\\"} 44.0 \"]},\"155\":{\"h\":\"配置Prometheus采集\",\"t\":[\"在Springboot的项目中增加springboot指标的采集，配置如下：\",\"scrape_configs: - job_name: \\\"springboot\\\" static_configs: - targets: [\\\"localhost:9400\\\"] \",\"配置完成后，重新启动prometheus或者热加载，重新加载一下配置。\"]},\"156\":{\"h\":\"配置grafana视图\",\"t\":[\"在grafana中为Springboot项目配置试图，比如配置每分钟的请求量，配置的表达式如下：\",\"sum(increase(http_count_total{}[1m]))by (uri) \",\"image-20231021115719027\",\"配置请求的p95耗时，配置的表达式如下：\",\"histogram_quantile(0.95,sum(increase(http_count_seconds_bucket{}[1m]))by(uri,le)) \",\"image-20231021115611700\"]},\"157\":{\"h\":\"Prometheus告警与Alertmanager实战\",\"t\":[\"Prometheus的告警分为两部分内容：\",\"Prometheus server中的告警规则、告警发送。\",\"告警消息的处理程序Alertmanager，Alertmanager的主要功能包括告警消息的分组、路由分发、抑制和静默等核心功能\",\"工作流程包括：\",\"配置和启动Alertmanager\",\"在Prometheus server中配置Alertmanager的地址，用于向Alertmanager发送告警消息\",\"在Prometheus server中配置告警规则\",\"一个简单版的Prometheus的架构图如下：\",\"image-20231021170507878\",\"Prometheus作为采集端，采集Node-exporter、sdk client的数据\",\"Prometheus作为存储端，起到了时序数据库的作用，存储采集到的数据\",\"同时Prometheus读取告警规则文件，在进程内部计算告警规则，如果有告警发生，则向Alertmanager发送告警消息\",\"Alertmanager作为告警收敛的组件，在它内部进行告警消息的管理，最终将消息发送给第三方组件，通常是webhook\",\"最后webhook发送给告警平台。\",\"在前面的文章已经讲解过Prometheus采集数据和查询数据，在本篇文章中将会讲述Prometheus告警与Alertmanager实战。\"]},\"158\":{\"h\":\"Alertmanager介绍\",\"t\":[\"Alertmanager处理来自客户端的告警消息，例如Prometheus server，包括消息的去重、分组、路由、抑制和静默等核心功能。先了解这些核心概念，然后通过配置文件的形式来具体讲解。\"]},\"159\":{\"h\":\"分组\",\"t\":[\"分组是将同一组多个的相同的告警消息合并成一个高级消息。这在系统出现大量故障的时候非常有用，如果系统发出成千上万条相同的告警消息，对处理者来说是一个灾难。\",\"比如，某个数据库出现网络故障，导致连接它的应用的几百个实例都出现异常，如果不进行分组合并，则会出现几百上千的告警消息，很可能淹没掉一些其他的告警消息，导致告警处理者漏处理一些告警消息，从而导致一些系统问题。\",\"分组是\",\"告警分组，告警时间间隔，以及告警的接受方式可以通过Alertmanager的配置文件进行配置\"]},\"160\":{\"h\":\"抑制\",\"t\":[\"抑制是当某一告警已经发出，可以停止重复发送由此告警引发的其它告警的机制。\",\"例如，当集群不可用访问出发了告警，通过Alertmanager的配置可以忽略与该集群有关的其它告警功能。这样可以避免接受一些与实际问题相关的告警。\"]},\"161\":{\"h\":\"静默\",\"t\":[\"静默提供了一个标签匹配的设置，如果告警消息符合匹配，Alertmanager则不会发送消息到下游。\",\"Alertmanager 通过配置文件去配置一些配置，然后通过命令行的方式的启动它。Alertmanager 可以在运行时重新加载其配置，通过向Alertmanager 进程发送 SIGHUP信号或者请求Alertmanager 的 /-/reload 接口（POST请求）。\"]},\"162\":{\"h\":\"Alertmanager安装\",\"t\":[\"下载地址：https://prometheus.io/download/\",\"启动alertmanager可以使用以下命令：\",\"./alertmanager --config.file=alertmanager.yml \",\"在启动之前，需要修改alertmanager的配置文件，默认的配置文件如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 30s group_interval: 5m repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"配置文件中包含了4个部分，分别是：\",\"全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容； 告警路由（route）：根据标签匹配，确定当前告警应该如何处理； 接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用； 抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生\"]},\"163\":{\"h\":\"配置讲解\",\"t\":[\"每个部分包含的可配置的参数很多，参数的配置会在以后的文章中讲解，在此篇文章只讲解最基础的和几个重要的配置：\",\"gloabl配置\",\"resolve_timeout\",\"当告警消息没有endTs这个时间戳参数时，Alertmanager会启动它的告警恢复逻辑。当启动告警恢复逻辑时，Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）。这个对于prometheus的告警消息来说，它会含有endTs这个时间戳参数，所以这个resolve_timeout对于prometheus的告警消息是不生效的。\",\"route配置\",\"group_by 默认alertname\",\"The labels by which incoming alerts are grouped together.\",\"将告警消息按照某个标签分组，比如按照alertname\",\"group_wait（default: 30s）\",\"How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) 一组告警第一次发送之前等待的时间。用于等待抑制告警，或等待同一组告警采集更多初始告警后一起发送。（一般设置为0秒 ~ 几分钟\",\"group_interval（default: 5m）\",\"How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) 一组已发送初始通知的告警接收到新告警后，再次发送通知前等待的时间（一般设置为5分钟或更多）\",\"repeat_interval（default: 4h）\",\"How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). 一条成功发送的告警，在再次发送通知之前等待的时间。 （通常设置为3小时或更长时间）。\",\"receivers配置\",\"Receiver可以集成邮箱、微信、邮箱等，本文使用webHook的方式，即Alertmanager通过http接口调用来发送告警消息。\",\"inhibit_rules 配置\",\"抑制允许根据另一组警报的存在来静音一组警报。这允许在系统或服务之间建立依赖关系，以便在中断期间仅发送一组互连警报中最相关的警报。\",\"当存在与另一组匹配器匹配的警报（源）时，禁止规则会静音与一组匹配器匹配的警报（目标）。目标警报和源警报在相等列表中的标签名称必须具有相同的标签值。\",\"inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"比如当发生severity=critical的告警时，会屏蔽掉severity=warning的告警，前提条件是两个告警的alertname、dev、instance的标签值相等。\",\"根据实际情况，最终我的配置修改成如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 10s group_interval: 30s repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:8080/webhook' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"重新启动alertmanager，获取通过热加载的方式重新加载配置文件。\",\"在浏览器中访问localhost:9093，可以看到alertmanager的界面。\"]},\"164\":{\"h\":\"在prometheus中配置告警规则\",\"t\":[\"在prometheus的启动程序的同级目录下面，建一个first_rule.yml的文件，这个文件是告警规则计算的配置，内容如下：\",\"groups: - name: test rules: - alert: HighQps expr: sum(increase(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m])) > 1 for: 1m labels: severity: page env: test region: wuhan annotations: summary: HighQps description: '{{ $value }}' \",\"在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：\",\"alert：告警规则的名称。\",\"expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。\",\"for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。\",\"labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。\",\"annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。\",\"在Prometheus的配置文件中，增加告警规则的配置：\",\"alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:909 rule_files: - ./first_rule.yml \",\"最好创建一个目录专门存储告警规则文件，然后用*.yml去配置所有的告警规则文件。\",\"访问Prometheus的规则文件界面（http://127.0.0.1:9090/rules），可以看到的规则状态如下：\",\"image-20231021174512876\",\"等待1分钟，访问Prometheus的告警页面界面（http://127.0.0.1:9090/alerts?search=），可以看到已经有一条告警消息已经发送给Alertmanager\",\"image-20231021174854220\"]},\"165\":{\"h\":\"Alertmanager查看告警消息\",\"t\":[\"访问alertmanager的界面（http://localhost:9093/#/alerts），显示告警消息已经收到：\",\"image-20231021174948512\"]},\"166\":{\"h\":\"webhook\",\"t\":[\"Alertmanager收到告警消息后，如果判断需要发送消息给下游的Webhook程序，将通过POST的http请求发送下游程序，发送的告警消息的JSON格式如下：\",\"https://prometheus.io/docs/alerting/latest/configuration/#webhook_config\",\"{ \\\"version\\\": \\\"4\\\", \\\"groupKey\\\": <string>, // key identifying the group of alerts (e.g. to deduplicate) \\\"truncatedAlerts\\\": <int>, // how many alerts have been truncated due to \\\"max_alerts\\\" \\\"status\\\": \\\"<resolved|firing>\\\", \\\"receiver\\\": <string>, \\\"groupLabels\\\": <object>, \\\"commonLabels\\\": <object>, \\\"commonAnnotations\\\": <object>, \\\"externalURL\\\": <string>, // backlink to the Alertmanager. \\\"alerts\\\": [ { \\\"status\\\": \\\"<resolved|firing>\\\", \\\"labels\\\": <object>, \\\"annotations\\\": <object>, \\\"startsAt\\\": \\\"<rfc3339>\\\", \\\"endsAt\\\": \\\"<rfc3339>\\\", \\\"generatorURL\\\": <string>, // identifies the entity that caused the alert \\\"fingerprint\\\": <string> // fingerprint to identify the alert }, ... ] } \",\"对应的Java实体如下：\",\" public class Webhook { public String receiver; public String status; public ArrayList<Alert> alerts; public Map<String,String> groupLabels; public Map<String,String> commonLabels; public Map<String,String> commonAnnotations; public String externalURL; public String version; public String groupKey; public int truncatedAlerts public static class Alert { public String status; public Map<String,String> labels; public Map<String,String> annotations; public Date startsAt; public Date endsAt; public String generatorURL; public String fingerprint; } } \",\"在Springboot项目中，写一个接口如下：\",\" @PostMapping(\\\"/webhook\\\") public String webhook(@RequestBody Webhook webhook) { logger.info(webhook.toString()); return \\\"ok\\\"; } \",\"这样webhook的程序收到告警消息后，就可以具体的执行告警逻辑，比如将告警消息发送给运维人员的邮箱。\"]},\"167\":{\"h\":\"参考文档\",\"t\":[\"https://blog.csdn.net/qq_37843943/article/details/120665690\",\"https://www.jianshu.com/p/c661e8050434\",\"https://blog.51cto.com/starsliao/5763175\",\"https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/prometheus-alert-rule\"]},\"168\":{\"h\":\"Prometheus预处理计算-Recording Rule\",\"t\":[\"prometheus支持两种规则表达式，一种是告警告警规则表达式，另外一种是预计算规则recording rule。recording rule是预先计算成本较高的表达式，并将计算结果保存在一组新的时间序列上。预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多。\"]},\"169\":{\"h\":\"定义Recoding rules\",\"t\":[\"Prometheus会定时的根据拉取expr定时表达式的数据，并将数据的结果存储在新的时间序列中，新的序列名称为record中的值。如果expr表达式的计算结果包含标签，则会把标签添加到新的序列中，如果labels配置中含有额外的标签也会放到新的timeseries中。\",\"和alert rule类似，每个Recording rule的规则定义如下：\",\"groups: - name: example rules: - record: job:http_inprogress_requests:sum expr: sum(http_inprogress_requests) by (job) \",\"rule_group可以配置两个参数：\",\"name，group的名称，需要全局唯一\",\"interval, rule_group执行的时间间隔，如果没有配置，则默认是global.evaluation_interval\",\"Groups.rules选项是recording-rule的具体配置，可以有以下几个配置项：\",\"record ： expr执行后生成新的指标的名称，指标名称的定义可以参考下面一小节\",\"expr：具体预处理生成指标的表达式。\",\"labels：可以在新生成的指标上额外加一些标签。\",\"记录和告警规则存在于规则组中。组内的规则以固定的时间间隔按顺序运行，评估时间相同。记录规则的名称必须是有效的指标名称。警报规则的名称必须是有效的标签值。\",\"另外如果没有配置groups的interval配置，recording的计算规则和alert的计算规则，都可以通过以下配置，进行全局的计算频次的设置：\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"170\":{\"h\":\"recording rule的最佳实践\",\"t\":[\"recording rule的命令规范很重要，一个好的命名规范可以一目了然的知道规则的含义，避免出现一些无意义的计算。\"]},\"171\":{\"h\":\"命名规范\",\"t\":[\"通过recording rule产生的新的指标，应该遵循通用的方式：level:metric:operations\",\"level 表示聚合的级别和规则标签的输出\",\"metric 是和预聚合前的名称保存一致\",\"Operations 是应用于指标的操作函数列表，最新的操作函数在前。\",\"当对counter类型使用rate或者是irate操作，去掉_total的后缀\",\"当对指标用作除法,并且是求百分数，可以使用_per_\",\"例如：\",\"- record: instance_path:requests:rate5m expr: rate(requests_total{job=\\\"myjob\\\"}[5m]) \",\"上面的表达式rate(requests_total{job=\\\"myjob\\\"}[5m])，有两个标签分别是instance和path，所以它的level可以命名为instance_path；对meric使用了rate操作将metric原来的名称去掉_total；最后使用是rate操作\",\"最终根据上面的表达式得到的指标的名称是instance_path:requests:rate5m；我们可以根据指标的名称可以反推出指标的表达式，这样真的一目了然。\",\"其他例子：\",\"- record: instance_path:request_failures:rate5m expr: rate(request_failures_total{job=\\\"myjob\\\"}[5m]) - record: instance_path:request_failures_per_requests:ratio_rate5m expr: |2 instance_path:request_failures:rate5m{job=\\\"myjob\\\"} / instance_path:requests:rate5m{job=\\\"myjob\\\"} # Aggregate up numerator and denominator, then divide to get path-level ratio. - record: path:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) # No labels left from instrumentation or distinguishing instances, # so we use 'job' as the level. - record: job:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance, path)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance, path)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) \"]},\"172\":{\"h\":\"实战\",\"t\":[\"新建一个recoding_rule.yml的文件，在文件中写一个指标聚合的表达式，该表达式的计算时间间隔为1分钟，表达式的含义是计算每分钟handler=\\\"/metrics\\\"的请求量，另外在新生成的指标上添加一个新的标签region，具体表达式格式如下：\",\"groups: - name: recording_rule interval: 1m rules: - record: instance_handler_code:prometheus_http_requests:rate1m expr: sum(rate(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m]) )by(instance,handler,code) labels: region: wuhan \",\"在Prometheus的yaml配置文件中，通过rule_files定义recoding rule规则文件的路径。\",\"rule_files: - ./first_rule.yml - ./recoding_rule.yml \",\"重新启动Prometheus，在Prometheus的页面上可以查看新指标的数据，如下：\",\"image-20231023210926364\"]},\"173\":{\"h\":\"Java Collection概述\",\"t\":[\"Java Collection 集合是 Java 编程语言中用于存储和操作对象的框架。它提供了一组接口和类，用于处理不同类型的集合，如List、Set、Queue、Map等。\",\"下面是Java Collection 框架的一些关键概念：\",\"集合接口（Collection Interface）：是 Java Collection 框架的根接口，它定义了集合的基本操作，如添加、删除、遍历等。常见的集合接口包括 List、Set 和 Queue。\",\"列表（List）：以有序的方式存储对象的集合，允许重复元素。常见的列表实现类有 ArrayList 和 LinkedList。\",\"集（Set）：以无序的方式存储对象的集合，不允许重复元素。常见的集实现类有 HashSet 和 TreeSet。\",\"队列（Queue）：一种先进先出（FIFO）的数据结构，用于保存元素并控制元素的插入、删除操作。常见的队列实现类有 LinkedList 和 PriorityQueue。\",\"散列（Map）：以键值对（Key-Value）的形式存储数据，每个键都是唯一的。常见的映射实现类有 HashMap 和 TreeMap。它是Collection框架的一部分，虽然它不是Collection Interface的继承接口。\",\"Java Collection 框架的类的思维导图如下：\"]},\"174\":{\"h\":\"List 接口\",\"t\":[\"Java 的 List 接口是 Collection 接口的继承接口之一，用于表示有序的元素集合，允许元素的重复。List 接口中的元素按照插入的顺序存储，并且可以通过索引进行访问和操作。\",\"List 接口的主要特点包括：\",\"有序性：List 中的元素按照插入的顺序进行存储，元素的顺序可以根据插入和删除操作的顺序动态改变。\",\"可重复性：List 允许包含重复的元素，相同的元素可以出现在列表的不同位置。\",\"可变大小：List 的大小可以根据需要进行动态调整，可以添加或删除元素。\",\"List 接口定义了很多常用的方法，用于添加、删除、获取和操作列表中的元素。例如：\",\"添加元素：使用 add、addAll 方法将元素或集合添加到列表中。\",\"删除元素：使用 remove、removeAll 方法删除指定元素或集合中的元素。\",\"获取元素：使用 get、indexOf、lastIndexOf 方法获取元素或元素的索引。\",\"修改元素：使用 set 方法修改列表中指定位置的元素。\",\"列表操作：使用 subList、sort、reverse 方法实现对列表的操作，如截取子列表、排序、反转等。\",\"遍历列表：使用迭代器、增强的 for 循环或 forEach 方法遍历列表中的元素。\",\"举个例子演示如何使用 List 接口：\",\"import java.util.ArrayList; import java.util.List; public class ListExample { public static void main(String[] args) { // 创建一个 List 对象 List<String> fruits = new ArrayList<>(); // 添加元素到列表中 fruits.add(\\\"Apple\\\"); fruits.add(\\\"Banana\\\"); fruits.add(\\\"Orange\\\"); fruits.add(\\\"Mango\\\"); // 获取列表的大小 int size = fruits.size(); System.out.println(\\\"List size: \\\" + size); // 访问列表中的元素 String firstFruit = fruits.get(0); System.out.println(\\\"First fruit: \\\" + firstFruit); // 遍历列表中的元素 System.out.println(\\\"Fruits:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 检查列表中是否包含某个元素 boolean containsApple = fruits.contains(\\\"Apple\\\"); System.out.println(\\\"Contains Apple? \\\" + containsApple); // 修改列表中的元素 fruits.set(1, \\\"Grapes\\\"); System.out.println(\\\"Updated list:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 删除列表中的元素 fruits.remove(2); System.out.println(\\\"Updated list after removing element:\\\"); for (String fruit : fruits) { System.out.println(fruit); } // 清空列表 fruits.clear(); System.out.println(\\\"List is empty? \\\" + fruits.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"List size: 4 First fruit: Apple Fruits: Apple Banana Orange Mango Contains Apple? true Updated list: Apple Grapes Orange Mango Updated list after removing element: Apple Grapes Mango List is empty? true \"]},\"175\":{\"h\":\"Set接口\",\"t\":[\"Set 接口是 Collection 接口的子接口之一，用于存储不重复的元素。Set 中的元素没有固定的顺序，且不允许包含重复的元素。\",\"Set 接口的主要特点包括：\",\"不重复性：Set 中的元素是唯一的，不会包含重复的元素。添加重复元素时，添加操作会失败并返回 false。\",\"无序性：Set 中的元素没有固定的顺序。具体的排列顺序可能因实现类或元素的添加顺序而不同。\",\"快速查找：Set 提供了高效的查找操作，可以快速判断一个元素是否存在于集合中。\",\"Set 接口继承自 Collection 接口，因此包含了一些常用的方法，例如添加元素、删除元素、判断元素是否存在、获取集合大小等。\",\"举个简单的示例，演示如何使用 Set 接口：\",\"import java.util.HashSet; import java.util.Set; public class SetExample { public static void main(String[] args) { // 创建一个 Set 对象 Set<String> names = new HashSet<>(); // 添加元素到集合中 names.add(\\\"Alice\\\"); names.add(\\\"Bob\\\"); names.add(\\\"Charlie\\\"); names.add(\\\"Bob\\\"); // 重复元素，将不会被添加进去 // 获取集合的大小 int size = names.size(); System.out.println(\\\"Set size: \\\" + size); // 遍历集合中的元素 System.out.println(\\\"Names:\\\"); for (String name : names) { System.out.println(name); } // 检查集合中是否包含某个元素 boolean containsBob = names.contains(\\\"Bob\\\"); System.out.println(\\\"Contains Bob? \\\" + containsBob); // 从集合中删除元素 names.remove(\\\"Charlie\\\"); System.out.println(\\\"Updated set:\\\"); for (String name : names) { System.out.println(name); } // 清空集合 names.clear(); System.out.println(\\\"Set is empty? \\\" + names.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Set size: 3 Names: Bob Charlie Alice Contains Bob? true Updated set: Bob Alice Set is empty? true \",\"上面的例子演示了如何创建 Set 对象，添加、获取、遍历和删除集合中的元素，以及判断集合是否为空。\"]},\"176\":{\"h\":\"Map接口\",\"t\":[\"Map 接口是集合框架中用于存储键值对（Key-Value）的映射关系。每个键值对都是一个条目（Entry），键是唯一的，值可以重复。它和Collection接口属于并列的关系。\",\"Map 接口的主要特点如下：\",\"键的唯一性：Map 中的键是唯一的，不允许重复。如果使用相同的键插入多个值，后面的值会覆盖前面的值。\",\"快速查找：Map 提供了根据键快速查找对应值的方法。\",\"无固定顺序：Map 中的键值对没有固定的顺序。具体的迭代顺序可能因实现类或元素的插入顺序而不同。\",\"Map 接口定义了常用的操作方法，例如添加键值对、删除键值对、获取键值对数量、按键查找值等。常用的 Map 接口的实现类有 HashMap、LinkedHashMap 和 TreeMap。\",\"举个例子演示如何使用 HashMap：\",\"import java.util.HashMap; import java.util.Map; public class HashMapExample { public static void main(String[] args) { // 创建一个 HashMap 对象 Map<String, Integer> scores = new HashMap<>(); // 添加键值对到 HashMap 中 scores.put(\\\"Alice\\\", 95); scores.put(\\\"Bob\\\", 80); scores.put(\\\"Charlie\\\", 90); // 获取键对应的值 int aliceScore = scores.get(\\\"Alice\\\"); System.out.println(\\\"Alice's score: \\\" + aliceScore); // 检查 HashMap 中是否包含某个键 boolean containsKey = scores.containsKey(\\\"Bob\\\"); System.out.println(\\\"Contains key 'Bob'? \\\" + containsKey); // 获取 HashMap 的大小（键值对数量） int size = scores.size(); System.out.println(\\\"HashMap size: \\\" + size); // 遍历 HashMap 中的键值对 System.out.println(\\\"Scores:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 修改某个键对应的值 scores.put(\\\"Bob\\\", 85); System.out.println(\\\"Updated score for Bob: \\\" + scores.get(\\\"Bob\\\")); // 删除某个键值对 scores.remove(\\\"Charlie\\\"); System.out.println(\\\"After removing Charlie:\\\"); for (Map.Entry<String, Integer> entry : scores.entrySet()) { String name = entry.getKey(); int score = entry.getValue(); System.out.println(name + \\\": \\\" + score); } // 清空 HashMap scores.clear(); System.out.println(\\\"HashMap is empty? \\\" + scores.isEmpty()); } } \",\"运行以上代码，将会输出以下结果：\",\"Alice's score: 95 Contains key 'Bob'? true HashMap size: 3 Scores: Alice: 95 Bob: 80 Charlie: 90 Updated score for Bob: 85 After removing Charlie: Alice: 95 Bob: 85 HashMap is empty? true \",\"上面的例子演示了如何创建 HashMap ，以及添加、获取、遍历和删元素对象，以及判断 HashMap 的大小和是否为空。\"]},\"177\":{\"h\":\"总结\",\"t\":[\"本文介绍了Java中的Collection框架，包括了最常见的List、Set和Map接口，以及常见的实现类。然后用案例讲解了这些类的使用。\",\"在如今Java面试八股文满天飞的时代，上面的内容可能不会被面试官问到，因为太基础了，但是Java集合的源码或者手写Java Collection的实现还是经常被问到。所以在接下来的文章会从源码和Java Collection的手写实现两个维度来讲解常见的集合类的具体实现。\"]},\"178\":{\"h\":\"ArrayList源码解析\"},\"179\":{\"h\":\"ArrayList的类结构图\",\"t\":[\"ArrayList 是 java 集合框架中比较常用的用于存储单列数据的容器。它继承自 AbstractList，实现了 List 接口，同时还实现了 RandomAccess、Cloneable、Serializable 接口，所以ArrayList 支持快速访问、复制、序列化。ArrayList底层基于数组实现，容量大小动态可以变化。\",\"ArrayList继承了AbstractList类并实现类List接口，所以ArrayList具有了AbstractList和List的功能。而AbstractList内部已经实现了获取Iterator和ListIterator的方法。所\",\"ArrayList实现了RandomAccess接口，表明ArrayList支持随机访问。\",\"ArrayList实现了Cloneable接口，表明ArrayList支持克隆。\",\"ArrayList实现了Serializable接口，表明ArrayList支持序列，可以将ArrayList以流的形式通过ObjectInputStream/ObjectOutputStream来写/读。\"]},\"180\":{\"h\":\"ArrayList底层是如何实现的？\",\"t\":[\"ArrayList 是通过基于数组的方式实现的动态数组。\",\"在 ArrayList 内部，有一个对象数组（elementData）用于存储元素。当创建 ArrayList 对象时，会初始化一个初始容量的数组。随着元素的不断添加，ArrayList 会根据需要自动进行扩容。\",\"当添加元素时，ArrayList 会检查当前数组容量是否足够，如果不够，则会创建一个新的更大容量的数组，并将原有元素复制到新数组中。这个过程称为扩容。通过这种方式，ArrayList 实现了动态调整数组容量。\",\"在进行删除操作时，ArrayList 会将删除位置后面的元素向前移动一个位置，以填补被删除元素的空缺。同时，ArrayList 会判断是否需要缩小数组容量，如果数组容量过大且元素数量远小于容量的 1/4，则会进行缩容操作，减少内存占用。\",\"由于 ArrayList 的底层采用数组实现，所以随机访问元素的时间复杂度为 O(1)，即常数时间。但是在进行插入和删除操作时，为了保持数组的连续性，可能需要移动大量元素，时间复杂度为 O(n)，其中 n 是元素的数量。因此，ArrayList 适用于对随机访问的需求较多，而对插入和删除操作效率要求不高的场景。\",\"ArrayList的底层使用数组实现的源码如下：\",\"public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable { //存储ArrayList元素的数组缓冲区。 ArrayList的容量就是这个数组缓冲区的长度。任何 empty ArrayList with //elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 将在添加第一个元素时扩展为DEFAULT_CAPACITY。 transient Object[] elementData; .... } \",\"注意，本文的源码为JDK18\"]},\"181\":{\"h\":\"ArrayList的初始化\",\"t\":[\"ArrayList会在构造函数执行的时候初始化，ArrayList有三种构造函数，分别为：\",\"带初始化容量大小参数(initialCapacity)的构造函数\",\"无参构造函数，默认会初始化容量大小为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值为10，所以默认的初始化大小为10；这种最常用。\",\"带有Collection参数的构造函数，会将Collection的元素Copy到elementData成员变量中。\",\" public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } public ArrayList(Collection<? extends E> c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; } \"]},\"182\":{\"h\":\"添加元素\",\"t\":[\"方法名\",\"描述\",\"public boolean add(E e)\",\"添加元素\",\"public void add(int index, E element)\",\"在制定位置添加元素\",\"public boolean addAll(Collection<? extends E> c)\",\"将Collection的全部元素添加到集合中\",\"public boolean addAll(int index, Collection<? extends E> c)\",\"将Collection的按照index位置开始的所有元素添加到集合中\",\"添加元素的源码如下：\",\" public boolean add(E e) { modCount++; add(e, elementData, size);//将元素添加到size的位置 return true; } public void add(int index, E element) { rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; //index的值和elementData的长度相等，则扩容 if ((s = size) == (elementData = this.elementData).length) elementData = grow(); System.arraycopy(elementData, index, elementData, index + 1, s - index); //将元素的放到索引位置 elementData[index] = element; //容器的size+1 size = s + 1; } \"]},\"183\":{\"h\":\"扩容\",\"t\":[\"扩容是在grow()函数中进行，它返回的是一个新的Object[] 数组，新数组已经将就数据拷贝。\",\"如果elementData是DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组），并且元素小于DEFAULT_CAPACITY（10 个），则对空数组进行初始化\",\"如果不为空数组，则进行初始化，正常情况下新的数组大小是旧数组的1.5倍 \",\"如果超出了Interger的软最大值则报错\",\"最多返回Interger的软最大值（ SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8）\",\" private Object[] grow() { return grow(size + 1); } private Object[] grow(int minCapacity) { int oldCapacity = elementData.length; if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { int newCapacity = ArraysSupport.newLength(oldCapacity, minCapacity - oldCapacity, /* minimum growth */ oldCapacity >> 1 /* preferred growth */); return elementData = Arrays.copyOf(elementData, newCapacity); } else { //对空数组进行初始化 return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)]; } } public static int newLength(int oldLength, int minGrowth, int prefGrowth) { // preconditions not checked because of inlining // assert oldLength >= 0 // assert minGrowth > 0 int prefLength = oldLength + Math.max(minGrowth, prefGrowth); // might overflow if (0 < prefLength && prefLength <= SOFT_MAX_ARRAY_LENGTH) { return prefLength; } else { // put code cold in a separate method return hugeLength(oldLength, minGrowth); } } private static int hugeLength(int oldLength, int minGrowth) { int minLength = oldLength + minGrowth; if (minLength < 0) { // overflow throw new OutOfMemoryError( \\\"Required array length \\\" + oldLength + \\\" + \\\" + minGrowth + \\\" is too large\\\"); } else if (minLength <= SOFT_MAX_ARRAY_LENGTH) { return SOFT_MAX_ARRAY_LENGTH; } else { return minLength; } } \"]},\"184\":{\"h\":\"删除元素\",\"t\":[\"remove(Object o) 方法：该方法用于删除指定的元素。\",\" public boolean remove(Object o) { final Object[] es = elementData; final int size = this.size; int i = 0; found: { if (o == null) { for (; i < size; i++) if (es[i] == null) break found; } else { for (; i < size; i++) if (o.equals(es[i])) break found; } return false; } fastRemove(es, i); return true; } private void fastRemove(Object[] es, int i) { modCount++; final int newSize; if ((newSize = size - 1) > i) System.arraycopy(es, i + 1, es, i, newSize - i); es[size = newSize] = null; } \",\"首先，remove(Object o) 方法会判断是否删除的是 null 值，然后遍历 ArrayList 查找匹配的元素。\",\"如果找到匹配的元素，会调用 fastRemove(int index) 方法进行快速删除，该方法将需要删除元素的位置（index）后面的元素向前移动，覆盖需要删除的元素。\",\"最后，将 size 赋值为newSize，newSize实际上是减一了，表示 ArrayList 的元素总数减少一个。\",\"并将最后一个位置上的元素清空。\"]},\"185\":{\"h\":\"查找元素\",\"t\":[\"get(int index)用于获取指定位置的元素，如果index超出长度，则报IndexOutOfBoundsException异常。查找指定位置元素的时间复杂度为O(1)。\",\" public E get(int index) { Objects.checkIndex(index, size); return elementData(index); } \",\"contains(Object o) 方法：该方法用于判断 ArrayList 是否包含指定的元素。\",\"public boolean contains(Object o) { return indexOf(o) >= 0; } \",\"contains(Object o) 方法内部调用了 indexOf(Object o) 方法\",\"public int indexOf(Object o) { if (o == null) { for (int i = 0; i < size; i++) if (elementData[i] == null) return i; } else { for (int i = 0; i < size; i++) if (o.equals(elementData[i])) return i; } return -1; } \",\"indexOf(Object o) 方法首先判断要查找的元素是否为 null，如果是，则遍历 ArrayList 的元素，找到第一个值为 null 的元素，返回其索引值。\",\"如果要查找的元素不为 null，则遍历 ArrayList 的元素，调用元素的 equals 方法进行比较，找到第一个相等的元素，返回其索引值。\",\"如果未找到指定元素，则返回 -1。\"]},\"186\":{\"h\":\"迭代器源码解析\",\"t\":[\"ArrayList 的迭代器（Iterator）是通过内部类 Itr 来实现的，以下是对其源码的解析：\",\"private class Itr implements Iterator<E> { int cursor; // 下一个元素的索引 int lastRet = -1; // 上一个元素的索引 int expectedModCount = modCount; public boolean hasNext() { return cursor != size; } @SuppressWarnings(\\\"unchecked\\\") public E next() { checkForComodification(); // 检查 ArrayList 是否被修改过 int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet < 0) throw new IllegalStateException(); checkForComodification(); // 检查 ArrayList 是否被修改过 try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } \",\"Itr 类实现了 Iterator<E> 接口，通过实现 hasNext()、next()、remove() 和 checkForComodification() 方法来支持迭代。\",\"cursor 属性表示下一个元素的索引，lastRet 属性表示上一个元素的索引，expectedModCount 属性表示预期的修改次数。\",\"hasNext() 方法用于判断是否还有下一个元素，即判断 cursor 是否等于 size。\",\"next() 方法用于获取下一个元素，首先调用 checkForComodification() 方法检查 ArrayList 是否被修改过，然后根据 cursor 获取下一个元素并返回，同时更新 lastRet 和 cursor 的值。\",\"remove() 方法用于移除上一个元素，首先检查 lastRet 是否小于 0，如果是则抛出异常，然后再次调用 checkForComodification() 方法检查 ArrayList 是否被修改过，在通过 ArrayList.this.remove(lastRet) 方法移除元素后，更新 cursor 和 lastRet 的值，并将 expectedModCount 修改为当前的 modCount。\",\"checkForComodification() 方法用于检查 ArrayList 是否被修改过，即判断 modCount 是否等于 expectedModCount，如果不相等则抛出异常。\",\"ArrayList 的迭代器通过内部类 Itr 实现，支持对集合进行顺序迭代，并支持在迭代过程中通过迭代器的 remove() 方法删除元素。迭代器在每次访问元素之前会检查 ArrayList 是否被修改过，利用 modCount 和 expectedModCount 来实现快速失败机制，保证在迭代过程中对集合的修改不会产生错误的结果。\",\"需要注意的是，在使用迭代器遍历 ArrayList 的过程中，不建议直接使用 ArrayList 对象的 remove() 方法进行元素的删除操作，而应该使用迭代器的 remove() 方法进行删除，以避免产生并发修改异常。\"]},\"187\":{\"h\":\"LinkedList源码解析\"},\"188\":{\"h\":\"LinkedList的类结构图\",\"t\":[\"LinkedList是java集合中比较常见的线性表的数据结构，是用于存储单列数据的容器。LinkedList除了继承AbstractSequentialList之外，同时还实现了Deque、Cloneable、Serializable 接口，也就是说LinkedList可以被当做队列使用，还支持快复制、序列化。\",\"如下图，LinkedList的类结构图如下：\",\"LinkedList的底层数据结构是使用一个双向的链表结构实现的，链表中的每个节点（Node）都包含两个引用，prev指向当前节点前一个节点，next指向当前节点后一个节点，可以从头结点遍历到尾结点，也可以从尾结点遍历到头结点。\",\"LinkedList类主要由LinkedList和它的内部类Node构成，这两个类的UML图如下：\",\"+------------------+ | LinkedList | +------------------+ | - size : int | | - first : Node | | - last : Node | +------------------+ | + add(E element) | | + remove() | | + get(int index) | | + size() | +------------------+ +-------------------+ | Node | +-------------------+ | - item : E | | - next : Node | | - prev : Node | +-------------------+ \",\"LinkedList 类是 LinkedList 的主要类。它包含了 size、first 和 last 三个实例变量，分别表示链表的大小、头结点和尾节点。\",\"add(E element) 方法用于在链表尾部添加元素。\",\"remove() 方法用于删除链表头部的元素。\",\"get(int index) 方法用于获取指定索引位置上的元素。\",\"size() 方法用于返回链表的大小。\",\"Node 类是 LinkedList 内部定义的节点类。它包含了 item、next 和 prev 三个实例变量，分别表示节点的数据、下一个节点和上一个节点。\"]},\"189\":{\"h\":\"构造函数\",\"t\":[\"LinkedList 类的构造函数有两个重载的构造函数，其中是一个无参的构造函数，没有任何的代码，因为它是双链表结构，不需要初始化容量长度等，源码如下：\",\"public LinkedList() { } \",\"第二个构造函数可以穿入一个Collection接口的实现类对象，将Collection中的元素都添加到LinkedList中，它的源码如下：\",\" public LinkedList(Collection<? extends E> c) { this(); addAll(c); } \"]},\"190\":{\"h\":\"add(E e)方法\",\"t\":[\"LinkedList 的 add(E e) 方法用于在链表的尾部添加元素。 add(E e) 方法的源码如下：\",\"public boolean add(E e) { linkLast(e); return true; } private void linkLast(E e) { Node<E> newNode = new Node<>(last, e, null); if (last == null) { first = newNode; } else { last.next = newNode; } last = newNode; size++; } \",\"add(E e) 方法先调用 linkLast(e) 方法来执行元素的插入操作。\",\"在 linkLast(e) 方法中，首先创建一个新的节点 newNode，节点的数据为指定的元素 e，前向节点为链表的当前尾节点 last，后向节点为 null。\",\"如果链表的尾节点 last 为 null，说明链表为空链表，即当前插入的节点即为头节点，将 first 设置为 newNode。\",\"如果链表的尾节点 last 不为 nul，将当前尾节点 last 的后向节点指向 newNode，即将 last.next 设置为 newNode。\",\"最后，将链表的尾节点 last 更新为 newNode，并增加链表的大小 size。\",\"方法返回 true，表示插入操作成功。\"]},\"191\":{\"h\":\"get(int index)方法\",\"t\":[\"LinkedList 的 get(int index) 方法用于获取链表中指定索引处的元素。 get(int index) 方法的源码如下：\",\"public E get(int index) { checkElementIndex(index); return node(index).item; } private Node<E> node(int index) { // 如果索引位于链表的前半段，从头节点开始向后遍历 if (index < (size >> 1)) { Node<E> x = first; for (int i = 0; i < index; i++) { x = x.next; } return x; } // 如果索引位于链表的后半段，从尾节点开始向前遍历 else { Node<E> x = last; for (int i = size - 1; i > index; i--) { x = x.prev; } return x; } } private void checkElementIndex(int index) { if (!isElementIndex(index)) { throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size); } } private boolean isElementIndex(int index) { return index >= 0 && index < size; } \",\"get(int index) 方法先调用 checkElementIndex(index) 方法检查索引是否有效，如果索引无效，则抛出 IndexOutOfBoundsException 异常。\",\"然后调用 node(index) 方法，根据索引获取对应的节点。\",\"在 node(int index) 方法中，如果索引 index 小于链表大小的一半，说明索引位于链表的前半段，从头节点开始向后遍历，找到对应的节点并返回。\",\"如果索引 index 大于等于链表大小的一半，说明索引位于链表的后半段，从尾节点开始向前遍历，找到对应的节点并返回。\",\"最后，在获取到对应节点后，返回节点的数据域 item。\"]},\"192\":{\"h\":\"remove(int index)方法\",\"t\":[\"LinkedList 的 remove(int index) 方法用于删除链表中指定索引处的元素。下面是 remove(int index) 方法的源码：\",\"public E remove(int index) { checkElementIndex(index); return unlink(node(index)); } private E unlink(Node<E> x) { final E element = x.item; final Node<E> prev = x.prev; final Node<E> next = x.next; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; return element; } private void checkElementIndex(int index) { if (!isElementIndex(index)) { throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size); } } private boolean isElementIndex(int index) { return index >= 0 && index < size; } \",\"解析：\",\"remove(int index) 方法先调用 checkElementIndex(index) 方法检查索引是否有效，如果索引无效，则抛出 IndexOutOfBoundsException 异常。\",\"然后调用 unlink(node(index)) 方法，根据索引获取对应的节点，并进行删除操作。 \",\"在 unlink(Node<E> x) 方法中，首先保存节点 x 的数据到 element 中。\",\"然后获取节点 x 的前向节点 prev 和后向节点 next。\",\"如果节点 x 的前向节点 prev 为 null，即 x 为头节点，则将头节点指向 x 的后向节点 next。\",\"否则，将节点 x 的前向节点 prev 的后向节点指向 x 的后向节点 next，即 prev.next = next。并将节点 x 的前向节点 prev 的前向引用置为 null，即 x.prev = null。\",\"同样的方式，如果节点 x 的后向节点 next 为 null，即 x 为尾节点，则将尾节点指向 x 的前向节点 prev。\",\"否则，将节点 x 的后向节点 next 的前向节点指向 x 的前向节点 prev，即 next.prev = prev。并将节点 x 的后向节点 next 的后向引用置为 null，即 x.next = null。\",\"接着将节点 x 的数据域 item 置为 null，减小链表的大小 size。\",\"最后返回删除节点的数据域。\"]},\"193\":{\"h\":\"总结\",\"t\":[\"LinkedList 是通过双向链表实现的数据结构，每个节点有前向和后向两个指针，用来连接上一个节点和下一个节点。这种结构使得在插入和删除元素时具有较高的效率，因为只需要修改节点的指针，而无需移动其他元素。\",\"LinkedList 提供了多种方法来操作链表，包括在链表的头部或尾部插入元素、在指定位置插入元素、获取指定位置的元素、删除指定位置的元素等等。这使得 LinkedList 在需要频繁插入和删除元素的场景下很有优势。\",\"然而，LinkedList 在访问元素时相对较慢，因为需要从头部或尾部开始遍历链表。与数组相比，LinkedList 的内存占用较高，因为每个节点需要额外的存储空间来保存前向和后向指针。\",\"综上所述，LinkedList 是一个适用于插入和删除操作频繁的数据结构，但对于随机访问和占用内存方面可能存在劣势。\"]},\"194\":{\"h\":\"HashMap原理解析\"},\"195\":{\"h\":\"HashMap的类结构图\",\"t\":[\"HashMap 是 java 集合框架中用于存储双列数据的散列表，应用非常的广泛。HashMap的类结构图如下：\",\"HashMap继承了AbstractMap类并实现类Map接口，所以HashMap具有了AbstractMap和Map的功能。\",\"HashMap实现了Cloneable接口，表明HashMap支持克隆。\",\"HashMap实现了Serializable接口，表明HashMap支持序列，可以将HashMap以流的形式通过ObjectInputStream/ObjectOutputStream来写/读。\"]},\"196\":{\"h\":\"HashMap的底层数据结构\",\"t\":[\"HashMap 的的底层数据结构为数组+链表（或者红黑树）结构，如下图所示：\",\"HashMap 通过 Node 类来存储键值对（K 表示键的类型，V 表示值的类型）。每个 Node 对象包含了键、值以及指向下一个 Node 的引用。\",\"在 JDK 8 以后的版本中，如果链表长度超过阈值（默认为8），且 HashMap 的容量达到了一个较大的值（默认为64），则部分链表节点会转换为红黑树。这些红黑树节点被实现为 TreeNode 类，它拓展自 Node 类。\"]},\"197\":{\"h\":\"构造函数\",\"t\":[\"HashMap 有两种构造函数：无参构造函数和带初始容量和负载因子的构造函数。无参构造函数创建一个初始容量为16，负载因子为0.75的 HashMap 对象。\",\"public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = tableSizeFor(INITIAL_CAPACITY); } \",\"带参构造函数接收初始容量 initialCapacity 和负载因子 loadFactor 作为参数，创建一个 HashMap 对象。\",\"public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; threshold = tableSizeFor(initialCapacity); } \",\"tableSizeFor(initialCapacity) 方法用于计算大于等于给定容量的最小 2 的幂。\"]},\"198\":{\"h\":\"存储元素过程\",\"t\":[\"首先我们先创建一个HashMap对象，然后使用put(key,value)方法，把元素存储在HashMap对象中，代码如下：\",\" Map<String,String> map=new HashMap<>(); map.put(\\\"james\\\",\\\"1\\\"); map.put(\\\"kobe\\\",\\\"1\\\"); map.put(\\\"robin\\\",\\\"1\\\"); map.put(\\\"sam\\\",\\\"1\\\"); \",\"要把键值对 (“james”,”1”)存入map中，首先，根据传入的 key 对象计算哈希值 hash，计算hash的源码如下：\",\" static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } \",\"调用 hash 和 key 对象作为参数，使用 table 数组的长度 table.length 计算出键值对在 table 数组中的索引位置 i。如果该 i 索引位置没有键值对，则直接将键值对存储在该位置。\",\"if ((p = tab[i = (n - 1) & hash]) == null){ tab[i] = newNode(hash, key, value, null); } \",\"如果索引 i 处有键值对，且发生了哈希冲突，则遍历该位置上的链表或红黑树进行操作。\",\" Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) //如果头节点上treeNode e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); else { // 如果是链表 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st //链表转treeNode treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; //遍历链表，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则更新其对应的值为新的 `value` 值。 p = e; } } \",\"遍历链表或红黑树的过程中，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则更新其对应的值为新的 value 值。\",\"如果没有找到相同的键，则将新的键值对插入到链表或红黑树的头部。如果链表长度超过了阈值（默认为8），并且 table 数组的长度大于阈值（默认为64），则将链表转换为红黑树。\",\"if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st //链表转treeNode treeifyBin(tab, hash); \",\"在插入新键值对后，如果 HashMap 中的键值对数量超过了负载因子乘以 table 数组的长度，即达到了负载因子阈值，需要进行扩容操作。\",\" final Node<K,V>[] resize() { } \"]},\"199\":{\"h\":\"扩容\",\"t\":[\"如果需要进行扩容操作，首先会检查当前的 table 数组是否为 null，若为 null，则表示 HashMap 还未进行过初始化操作，会调用 resize() 方法来初始化 table 数组。\",\"if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"在进行扩容之前会将当前 table 数组的引用赋值给一个临时变量 oldTab。在扩容操作中，会根据当前的 table 数组长度 oldCap 和负载因子 loadFactor 计算出新数组的长度 newCap，通常是将 oldCap 扩大一倍。\",\" int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } \",\"创建一个新的 Node[] 数组，长度为 newCap，作为新的 table 数组进行存储。\",\" Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; table = newTab; \",\"如果 HashMap 的当前 size 大于 0，则需要将旧的键值对重新分布到新的 table 数组中。遍历 oldTab 数组，将每个非空的位置上的键值对重新计算哈希值，并存储到新的 table 数组对应的位置。\",\"完成键值对的重新分布后，会将新的 table 数组赋值给 HashMap 的 table 属性。\",\"最后，在新的 table 数组中重新计算 key 的哈希值，并将键值对插入到对应索引位置 i 处。如果该位置已经有键值对，则按链表或红黑树的规则进行处理。\",\" if (oldTab != null) { for (int j = 0; j < oldCap; ++j) { Node<K,V> e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash & (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode<K,V>)e).split(this, newTab, j, oldCap); else { // preserve order Node<K,V> loHead = null, loTail = null; Node<K,V> hiHead = null, hiTail = null; Node<K,V> next; do { next = e.next; if ((e.hash & oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } \"]},\"200\":{\"h\":\"获取元素\",\"t\":[\"在对HashMap对象查找元素的时候，我们调用的是get(Object key)。\",\"public V get(Object key) { Node<K, V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } \",\"首先，根据传入的 key 对象计算哈希值 hash。\",\"根据 hash 的值在 table 数组中找到对应的索引位置 i。如果该索引位置上没有键值对，则返回 null。\",\"如果索引 i 处有键值对，且发生了哈希冲突，则遍历该位置上的链表或红黑树进行查找操作。\",\"遍历链表或红黑树的过程中，根据键的值与链表或红黑树的键进行比较，如果找到相同的键，则返回对应的值。\",\"如果遍历完链表或红黑树仍未找到相同的键，则返回 null。\",\"下面是 HashMap get(Object key) 方法的简化版源码：\",\"public V get(Object key) { Node<K, V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node<K, V> getNode(int hash, Object key) { Node<K, V>[] tab; Node<K, V> first, e; int n; K k; if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) { if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode<K, V>)first).getTreeNode(hash, key); do { if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } \",\"在上述源码中：\",\"getNode(int hash, Object key) 方法用于根据哈希值和键在 table 数组中查找并返回对应的节点。\",\"首先将 table 数组赋值给 tab 变量，然后根据哈希值计算出索引位置 ((n - 1) & hash)，并将对应位置的第一个节点赋值给 first 变量。\",\"如果 first 节点不为空，则首先检查 first 节点是否与传入的键匹配，如果匹配则直接返回 first 节点。\",\"如果 first 节点与传入的键不匹配，则判断 first 节点是否为红黑树节点，如果是，则调用红黑树节点的 getTreeNode() 方法进行查找操作，否则使用循环遍历链表中的其他节点进行查找。\",\"如果在链表或红黑树中找到键对应的节点，则返回对应的节点，否则返回 null。\"]},\"201\":{\"h\":\"总结\",\"t\":[\"HashMap 是 Java 中常用的哈希表实现，用于存储键值对。HashMap 提供了高效的键值对存储和查找能力。它利用哈希函数将键映射到数组的索引位置，在处理哈希冲突时，通过链表和红黑树的形式来解决。同时，HashMap 也支持动态扩容和再散列，保证了存储的键值对的分布合理性和查询性能的稳定性。\",\"需要注意的是，HashMap不是线程安全的，不能在多个线程中操作同一个HashMap，会导致一些并发问题。如果需要在多线程中操作同一个Map，建议使用ConcurrentHashMap。\"]},\"202\":{\"h\":\"HashSet原理解析\"},\"203\":{\"h\":\"类结构图\",\"t\":[\"HashSet 是 java 集合框架中用于存储单列数据。不同于ArrayList可以存储重复元素，HashSet存储的元素不会重复。下面是HashSet的类结构图：\",\"HashSet继承了AbstractSet类并实现类Set接口，所以HashSet具有了AbstractSet和Set的功能。\",\"HashSet实现了Cloneable接口，表明HashMap支持克隆。\",\"HashSet实现了Serializable接口，表明HashSet支持序列，可以将HashSet以流的形式通过ObjesctInputStream/ObjectOutputStream来写/读。\"]},\"204\":{\"h\":\"底层数据结构\",\"t\":[\"HashSet 的底层数据结构是基于 HashMap 实现的。在 HashSet 中，实际上是使用 HashSet 的元素作为 HashMap 的键（key），并将一个固定的对象作为 HashMap 的值（value）。\",\"在 HashSet 中，所有元素都会被映射到 HashMap 中的不同键上（通过 hashCode 和 equals 方法进行判断），因为 HashMap 不允许存在重复的键，所以它天然的保证了 HashSet 中元素的唯一性。\",\"img\",\"HashSet使用HashMap作为底层存储数据的结构，既保存了数组查询和修改元素效率快的优点，也保存了链表在添加和删除元素时效率快的特点。\",\"HashSet 的性能取决于哈希函数的质量和哈希表的大小。一般情况下，HashSet 的查找、添加和删除操作的时间复杂度为 O(1)。\",\"但同时HashSet和HashMap一样，是线程安全的。\"]},\"205\":{\"h\":\"简单示例\",\"t\":[\"使用代码示例如下：\",\" public static void main(String[] args) { Set<String> set=new HashSet<>(); set.add(\\\"1\\\"); set.add(\\\"2\\\"); set.add(\\\"3\\\"); set.add(\\\"3\\\"); set.add(\\\"1\\\"); for (String s: set) { System.out.println(s); } } \",\"执行上面代码输出：\",\"1 2 3\"]},\"206\":{\"h\":\"源码解析\"},\"207\":{\"h\":\"构造函数\",\"t\":[\"无参构造函数\",\"HashSet 类有多个构造函数，下面我们来分析其中一个常用的构造函数:\",\"public HashSet() { map = new HashMap<>(); } \",\"这个构造函数没有参数，用于创建一个空的 HashSet 对象。\",\"在构造函数中，通过 new HashMap<>() 创建了一个新的 HashMap 对象，并将其赋值给 HashSet 内部的 map 成员变量。\",\"HashSet 的元素将会以键的形式存储在 HashMap 中，而 HashMap 的值则被忽略，只使用键来判断元素的唯一性。\",\"传递一个集合参数的构造函数\",\"/** * 可以将集合中的数据全部添加到新创建的HashSet集合中，会去除掉重复的值。 * @param c */ public HashSet(Collection<? extends E> c) { map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); } \"]},\"208\":{\"h\":\"添加元素\",\"t\":[\"HashSet 的元素添加操作是通过调用 HashMap 的 put 方法实现的。下面是 HashSet 的 add 方法的源码：\",\"public boolean add(E e) { return map.put(e, PRESENT) == null; } \",\"add 方法接受一个元素 e 作为参数，并返回一个布尔值，表示添加元素是否成功。\",\"在方法内部，通过调用 HashMap 的 put 方法将元素 e 作为键、一个固定的占位符对象（比如 PRESENT）作为值存储在 HashMap 中。\",\"当调用 put 方法时，如果 HashMap 中之前不存在相同的键，那么会返回 null，表示添加成功。\",\"如果 HashMap 中已经存在相同的键，那么会将新的值替换旧的值，并返回旧的值。但在 HashSet 中，我们并不关心值的内容，只关心添加操作是否成功。所以，当返回值不为 null 时，表示已经存在相同的元素，添加失败。\",\"add 方法最后根据 put 方法的返回结果，返回一个布尔值，表示添加操作是否成功。\"]},\"209\":{\"h\":\"查找元素\",\"t\":[\"HashSet 的 contains(Object o) 方法用于检查 HashSet 中是否包含指定的元素。下面是 contains 方法的源码分析：\",\"public boolean contains(Object o) { return map.containsKey(o); } \",\"contains 方法接受一个对象 o 作为参数，并返回一个布尔值，表示 HashSet 是否包含该对象。\",\"在方法内部，它调用 HashMap 的 containsKey 方法来判断 HashMap 中是否包含指定的键 o（即是否存在指定的元素）。\",\"containsKey 方法会根据指定键的哈希值和相等性判断，检查 HashMap 中是否存在该键。如果存在，则返回 true；否则返回 false。\",\"因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，如果 HashMap 中存在指定的键，即表示 HashSet 中包含指定的元素。\",\"contains 方法最终返回 containsKey 方法的结果。\"]},\"210\":{\"h\":\"删除元素\",\"t\":[\"HashSet 的元素删除操作是通过调用 HashMap 的 remove 方法实现的。下面是 HashSet 的 remove 方法的源码分析：\",\"public boolean remove(Object o) { return map.remove(o) == PRESENT; } \",\"remove 方法接受一个对象 o 作为参数，并返回一个布尔值，表示删除操作是否成功。\",\"在方法内部，它调用 HashMap 的 remove 方法来删除 HashMap 中指定键 o 对应的键值对。\",\"remove 方法会根据指定键的哈希值和相等性判断，在 HashMap 中找到对应的键值对并删除。如果删除成功，则返回被删除的值；否则返回 null。\",\"因为 HashSet 的元素被存储为 HashMap 的键，而值则被忽略。所以，当调用 remove 方法成功时，返回的值应该是固定的占位符对象（比如 PRESENT），表示删除成功。\",\"remove 方法将 remove 方法的返回值与固定的占位符对象 PRESENT 进行比较。如果相等，则表示删除操作成功。\"]},\"211\":{\"h\":\"总结\",\"t\":[\"HashSet 是一种无序、唯一性的集合实现。它基于哈希表的数据结构，通过使用 HashMap 来存储元素，并具有很好的性能特性。\",\"HashSet 是非线程安全的，如果在多线程环境下使用 HashSet，需要进行同步处理或使用线程安全的替代品，如 ConcurrentHashSet\"]},\"212\":{\"h\":\"BitSet使用讲解\"},\"213\":{\"h\":\"类结构关系\",\"t\":[\"Java提供了BitSet来实现位图，BitSet是采用一个long型的数组来实现位图的，每个 long 变量都包含了 64 个位。BitSet的继承关系结构图如下：\",\"BitSet实现了Cloneable接口，表明HashMap支持克隆。\",\"BitSet实现了Serializable接口，表明HashSet支持序列，可以将HashSet以流的形式通过ObjesctInputStream/ObjectOutputStream来写/读。\"]},\"214\":{\"h\":\"BitSet介绍\",\"t\":[\"BitSet的优点就是省内存，举个简单的例子来说明吧。\",\"比如说有这么个场景：股票的的交易日记为1，休息日记为0， 那要记录一整年的数据，那就是 365 个数字，由1和0组成。 若数字是 int 类型，那 365 个数字，就是 1460 字节。 如果用 BitSet 来记录，理论上 48 个字节就可以了。\",\"BitSet 使用 long 数组来记录数据，long 有8 个字节、64 位，每位可对应一天的数据。 比如第1天是交易日，在 long 的第 1 位，记录为 1， 第2天是休息日，在 long 的第 2 位，记录为 0， 以此类推，365 天， 6 个 long 就搞定。\",\"BitSet中底层的存储结构选用了long数组，一个long整数占64比特，位长是一个byte整数的8倍，在需要处理的数据范围比较大的场景下可以有效减少扩容的次数。BitSet顶部有一些关于其设计上的注释，这里简单罗列概括成几点：\",\"BitSet是可增长比特向量的一个实现，设计上每个比特都是一个布尔值，比特的逻辑索引是非负整数\",\"BitSet的所有比特的初始化值为false（整数0）\",\"BitSet的size属性与其实现有关，length属性（比特表的逻辑长度）与实现无关\",\"BitSet在设计上是非线程安全，多线程环境下需要额外的同步处理\"]},\"215\":{\"h\":\"BitSet的简单使用\",\"t\":[\"BitSet 类的UML图如下图所示：\",\"--------------------- | BitSet | --------------------- | - long[] words | | - int wordsInUse | | - int size | --------------------- | + and(BitSet set)| | + or(BitSet set) | | + xor(BitSet set)| | + set(int bitIndex)| | + set(int bitIndex, boolean value)| | + get(int bitIndex)| | + clear(int bitIndex)| | + cardinality() | | + isEmpty() | | + size() | | + length() | | + toByteArray() | | + toString() | | + stream() | --------------------- \",\"BitSet 类内部维护了一个 long 类型的数组 words，用来存储位信息。每个 long 值都可以容纳 64 个位。\",\"wordsInUse 表示实际用于存储位信息的 words 数组的大小。\",\"size 表示 BitSet 的位数，即总共能表示的位的数量。\",\"以下是一些常用的 BitSet 方法和用法示例：\",\"import java.util.BitSet; public class BitSetExample { public static void main(String[] args) { BitSet bitSet = new BitSet(16); // 设置位 bitSet.set(1); bitSet.set(3); bitSet.set(5); bitSet.set(7); // 获取位值 boolean value = bitSet.get(3); System.out.println(\\\"Bit at index 3: \\\" + value); // 输出 true // 清除位 bitSet.clear(3); System.out.println(\\\"Bit at index 3: \\\" + bitSet.get(3)); // 输出 false // 位运算操作 BitSet anotherBitSet = new BitSet(16); anotherBitSet.set(3); anotherBitSet.set(7); // OR 操作 bitSet.or(anotherBitSet); // 遍历位集合 for (int i = 0; i < bitSet.size(); i++) { boolean bit = bitSet.get(i); System.out.println(\\\"Bit at index \\\" + i + \\\": \\\" + bit); } } } \",\"以上示例代码演示了 BitSet 的基本用法，包括设置位、获取位值、清除位、位运算等操作。\"]},\"216\":{\"h\":\"使用场景\",\"t\":[\"常见的应用是那些需要对海量数据进行一些统计工作的时候，比如日志分析、用户数统计等等\",\"如统计40亿个数据中没有出现的数据，将40亿个不同数据进行排序等。\",\"现在有1千万个随机数，随机数的范围在1到1亿之间。现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来\"]},\"217\":{\"h\":\"代码示例\",\"t\":[\"package util; import java.util.Arrays; import java.util.BitSet; public class BitSetDemo { /** * 求一个字符串包含的char * */ public static void containChars(String str) { BitSet used = new BitSet(); for (int i = 0; i < str.length(); i++) used.set(str.charAt(i)); // set bit for char StringBuilder sb = new StringBuilder(); sb.append(\\\"[\\\"); int size = used.size(); System.out.println(size); for (int i = 0; i < size; i++) { if (used.get(i)) { sb.append((char) i); } } sb.append(\\\"]\\\"); System.out.println(sb.toString()); } /** * 求素数 有无限个。一个大于1的自然数，如果除了1和它本身外，不能被其他自然数整除(除0以外）的数称之为素数(质数） 否则称为合数 */ public static void computePrime() { BitSet sieve = new BitSet(1024); int size = sieve.size(); for (int i = 2; i < size; i++) sieve.set(i); int finalBit = (int) Math.sqrt(sieve.size()); for (int i = 2; i < finalBit; i++) if (sieve.get(i)) for (int j = 2 * i; j < size; j += i) sieve.clear(j); int counter = 0; for (int i = 1; i < size; i++) { if (sieve.get(i)) { System.out.printf(\\\"%5d\\\", i); if (++counter % 15 == 0) System.out.println(); } } System.out.println(); } /** * 进行数字排序 */ public static void sortArray() { int[] array = new int[] { 423, 700, 9999, 2323, 356, 6400, 1,2,3,2,2,2,2 }; BitSet bitSet = new BitSet(2 << 13); // 虽然可以自动扩容，但尽量在构造时指定估算大小,默认为64 System.out.println(\\\"BitSet size: \\\" + bitSet.size()); for (int i = 0; i < array.length; i++) { bitSet.set(array[i]); } //剔除重复数字后的元素个数 int bitLen=bitSet.cardinality(); //进行排序，即把bit为true的元素复制到另一个数组 int[] orderedArray = new int[bitLen]; int k = 0; for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { orderedArray[k++] = i; } System.out.println(\\\"After ordering: \\\"); for (int i = 0; i < bitLen; i++) { System.out.print(orderedArray[i] + \\\"\\\\t\\\"); } System.out.println(\\\"iterate over the true bits in a BitSet\\\"); //或直接迭代BitSet中bit为true的元素iterate over the true bits in a BitSet for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { System.out.print(i+\\\"\\\\t\\\"); } System.out.println(\\\"---------------------------\\\"); } /** * 将BitSet对象转化为ByteArray * @param bitSet * @return */ public static byte[] bitSet2ByteArray(BitSet bitSet) { byte[] bytes = new byte[bitSet.size() / 8]; for (int i = 0; i < bitSet.size(); i++) { int index = i / 8; int offset = 7 - i % 8; bytes[index] |= (bitSet.get(i) ? 1 : 0) << offset; } return bytes; } /** * 将ByteArray对象转化为BitSet * @param bytes * @return */ public static BitSet byteArray2BitSet(byte[] bytes) { BitSet bitSet = new BitSet(bytes.length * 8); int index = 0; for (int i = 0; i < bytes.length; i++) { for (int j = 7; j >= 0; j--) { bitSet.set(index++, (bytes[i] & (1 << j)) >> j == 1 ? true : false); } } return bitSet; } } \"]},\"218\":{\"h\":\"参考\",\"t\":[\"https://zhuanlan.zhihu.com/p/520277367?utm_id=0\"]},\"219\":{\"h\":\"Java IO学习总结\"},\"220\":{\"h\":\"简介\",\"t\":[\"Java IO（Input/Output）是 Java 编程语言用于处理输入和输出的标准库。它提供了处理文件、流、网络传输等操作的类和接口。\",\"IO流主要包括字节流和字符流两种类型，以及文件操作、网络通信和对象序列化等功能。Java IO 可以处理二进制和文本数据，并提供了高效的缓冲流和便捷的文件操作。\"]},\"221\":{\"h\":\"IO流基本类\",\"t\":[\"Java IO库提供了多个基本的IO流类，主要包括以下几类：\",\"字节流（Byte Streams）：\",\"InputStream：抽象类，用于从源中读取字节数据。\",\"OutputStream：抽象类，用于将字节数据写入目标。\",\"字符流（Character Streams）：\",\"Reader：抽象类，用于从源中读取字符数据。\",\"Writer：抽象类，用于将字符数据写入目标。\",\"缓冲流（Buffered Streams）：\",\"BufferedInputStream：字节缓冲流，用于提供更高效的字节读取功能。\",\"BufferedOutputStream：字节缓冲流，用于提供更高效的字节写入功能。\",\"BufferedReader：字符缓冲流，用于提供更高效的字符读取功能。\",\"BufferedWriter：字符缓冲流，用于提供更高效的字符写入功能。\",\"文件操作：\",\"File：表示文件或目录的抽象类，提供了相关操作方法。\",\"FileInputStream：用于从文件中读取字节数据的流。\",\"FileOutputStream：用于将字节数据写入文件的流。\",\"FileReader：用于从文件中读取字符数据的流。\",\"FileWriter：用于将字符数据写入文件的流。\",\"这些基本的IO流类提供了在Java程序中进行输入输出操作的基础功能。\",\"字符流 VS 字节流\",\"字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：\",\"读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\",\"处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\",\"结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。\"]},\"222\":{\"h\":\"Java流类图结构\",\"t\":[\"JavaIO的类图结构如下：\",\"image-20231204151718877\"]},\"223\":{\"h\":\"Java IO流对象\",\"t\":[\"**1.输入字节流InputStream **\",\"InputStream 是所有的输入字节流的父类，它是一个抽象类，提供了基本的类操作方法，被许多具体的子类继承和实现。\",\"ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。\",\"PipedInputStream 是从与其它线程共用的管道中读取数据。\",\"ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 \",\"BufferedInputStream：缓冲输入流，提供了读取数据的高效能力，可以减少实际读取操作对底层资源的访问。\",\"DataInputStream：处理二进制数据，提供了读取基本数据类型（如 int、double 等）的方法。\",\"PushbackInputStream：允许将读取的字节推回输入流中，提供了 unread() 方法。\",\"2.输出字节流OutputStream\",\"OutputStream 是 Java IO 库中用于写入字节数据的抽象类。它也是一个顶级父类，被许多具体的子类继承和实现.\",\"ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。\",\"PipedOutputStream 是向与其它线程共用的管道中写入数据，\",\"ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 \",\"BufferedOutputStream：缓冲输出流，提供了写入数据的高效能力，可以减少实际写入操作对底层资源的访问。\",\"DataOutputStream：处理二进制数据，提供了写入基本数据类型（如 int、double 等）的方法。\",\"3.字节流的输入与输出的对应\",\"图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。从上面的图中可以看出Java IO 中的字节流是极其对称的。“存在及合理”我们看看这些字节流中不太对称的几个类吧！\",\"LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。\",\"PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。\",\"StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。\",\"SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。\",\"PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！\",\"4.字符输入流Reader\",\"Reader 是 Java IO 库中用于读取字符数据的抽象类。它是一个顶级父类，被许多具体的子类继承和实现。\",\"CharArrayReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。\",\"PipedReader 是从与其它线程共用的管道中读取数据。\",\"BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。\",\"FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。\",\"InputStreamReader 将字节流转换为字符流，是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。 \",\"FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。\",\"5.字符输出流Writer\",\"在上面的关系图中可以看出：\",\"Writer 是 Java IO 库中用于写入字符数据的抽象类。它也是一个顶级父类，被许多具体的子类继承和实现。\",\"CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据\",\"PipedWriter 是向与其它线程共用的管道中写入数据\",\"BufferedWriter 是一个装饰器为Writer ，提供了字符缓冲功能，增加了写入字符的效率，并提供了一行一行写入字符的方法。\",\"PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。\",\"OutputStreamWriter 是OutputStream 到Writer转换的桥梁 \",\"它的子类FileWriter ：将字符写入到文件中。\",\"6.字符流的输入与输出的对应\",\"img\",\"7.字符流与字节流转换\",\"转换流的特点：\",\"字符流和字节流之间相互转换\",\"可对读取到的字节数据经过指定编码转换成字符\",\"可对读取到的字符数据经过指定编码转换成字节\",\"何时使用转换流？\",\"当字节和字符之间有转换动作时；\",\"流操作的数据需要编码或解码时。 具体的对象体现：\",\"InputStreamReader:字节到字符的桥梁\",\"OutputStreamWriter:字符到字节的桥梁\",\"这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。\",\"8.File类\",\"File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。\",\"9.RandomAccessFile类 该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：\",\"该对象只能操作文件，在构造函数接收两种类型的参数：字符串文件路径；File对象。\",\"该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw) 注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。\"]},\"224\":{\"h\":\"Java NIO学习总结\"},\"225\":{\"h\":\"简介\",\"t\":[\"Java NIO（New I/O）是 Java 在 JDK 1.4 版本中引入的新的 I/O API。它提供了一种基于缓冲区、通道和非阻塞 I/O 模型的开发方式，相对于传统的 Java IO来说，Java NIO 更加灵活和高效。\",\"Java NIO 的主要特点和组成部分包括：\",\"缓冲区（Buffer）：Java NIO 的数据读写以缓冲区为中心，Buffer 类提供了读写数据的方法，来支持高效的 I/O 操作。常见的Buffer覆盖了能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。如下：\",\"ByteBuffer\",\"CharBuffer\",\"DoubleBuffer\",\"FloatBuffer\",\"IntBuffer\",\"LongBuffer\",\"ShortBuffer\",\"通道（Channel）：通道是一个用于读写数据的对象，可以非阻塞地进行读写操作，提供了更高效的数据传输能力。在 Java NIO 中，大部分 I/O 操作都是基于通道进行的。JAVA NIO中的一些主要Channel的实现，如下：\",\"FileChannel：从文件中读写数据\",\"DatagramChannel：能通过UDP读写网络中的数据\",\"SocketChannel：能通过TCP读写网络中的数据\",\"ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样，对每一个新进来的连接都会创建一个SocketChannel。\",\"选择器（Selector）：选择器是 Java NIO 提供的一种多路复用的机制，允许单个线程处理多个通道（如网络连接或文件），从而提高了系统的吞吐量和响应速度。\",\"非阻塞模式：Java NIO 支持非阻塞（非同步）I/O 操作，可以在等待 I/O 操作完成时同时执行其他任务，提高了程序的性能和响应能力。\",\"文件操作：Java NIO 提供了对文件的更强大和灵活的支持，包括文件读写、文件锁定、文件映射等功能。\",\"Java NIO 可以用于构建高并发、高性能的网络服务器，特别是在面对大量连接的场景下。它提供了更多的控制权和灵活性，使开发者能够更好地利用系统资源，提高 I/O 操作的效率。同时，Java NIO 还被广泛应用于大数据处理、分布式系统和高性能计算等领域。\"]},\"226\":{\"h\":\"Channel\",\"t\":[\"在 Java NIO 中，Channel（通道）是连接数据源和目标的管道，用于对数据进行读取和写入操作。它是 Java NIO 进行 I/O 操作的核心组件之一。\",\"Channel 的特点和功能包括：\",\"支持双向操作：Channel 可以用于读取和写入数据，因此它可以在一个方向上读取数据，同时在另一个方向上写入数据。\",\"高效的数据传输：Channel 实现了高效的数据传输，可以直接将数据从缓冲区读取到通道，或者从通道写入到缓冲区，提高了数据传输的效率。\",\"非阻塞模式：Channel 可以以非阻塞的方式进行读写操作，即在没有数据可读或可写时并不会阻塞线程，可以同时处理多个通道的 I/O 操作。\",\"以下是一些常见的 Channel 类型：\",\"FileChannel：用于对文件进行读写操作。\",\"SocketChannel：用于通过 TCP 协议进行网络连接，进行网络数据的读写操作。\",\"ServerSocketChannel：用于监听和接收客户端的连接请求。\",\"DatagramChannel：用于通过 UDP 协议进行网络数据的读写操作。\",\"Pipe.SinkChannel 和 Pipe.SourceChannel：用于在同一程序中进行线程间通信。\"]},\"227\":{\"h\":\"FileChannel\",\"t\":[\"以下是一个使用 FileChannel 进行文件读写操作的基本示例：\",\"import java.io.RandomAccessFile; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class FileChannelExample { public static void main(String[] args) { try { // 打开一个 RandomAccessFile，以读写模式 RandomAccessFile file = new RandomAccessFile(\\\"test.txt\\\", \\\"rw\\\"); FileChannel channel = file.getChannel(); // 从文件中读取数据到缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = channel.read(buffer); while (bytesRead != -1) { buffer.flip(); // 切换缓冲区为读取模式 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); // 逐个字节读取并输出 } buffer.clear(); // 清空缓冲区 bytesRead = channel.read(buffer); } // 将数据写入文件 String data = \\\"Hello, FileChannel!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); // 切换缓冲区为写入模式 channel.write(buffer); // 关闭通道和文件 channel.close(); file.close(); } catch (Exception e) { e.printStackTrace(); } } } \",\"以上示例演示了如何使用 FileChannel 从文件中读取数据，并将数据写入到文件中。\",\"首先通过 RandomAccessFile 创建一个文件对象，并通过 getChannel() 获取文件对应的 FileChannel。\",\"然后创建一个 ByteBuffer 作为缓冲区，通过 read() 方法从文件通道中读取数据到缓冲区，再通过 flip() 切换为读取模式逐个字节输出。\",\"我们将字符串数据写入到缓冲区，并通过 write() 方法将数据写入文件通道。\",\"最后，关闭通道和文件。\"]},\"228\":{\"h\":\"Buffer\",\"t\":[\"Buffer 是 Java NIO 中的一个关键组件，用于高效地进行数据读写操作。它是一个对象数组，可以存储不同类型的数据，并提供了一系列方法来管理数据的读写。\",\"Buffer 的主要属性和方法包括：\",\"容量（Capacity）：Buffer 的容量是在创建时预先确定的，它表示可以存储的最大数据量。创建 Buffer 时会指定容量，并且无法更改。\",\"位置（Position）：位置表示下一个要读取或写入的元素索引，初始位置为 0。对于写入操作，每次写入后位置会自动递增；对于读取操作，每次读取后位置也会递增。\",\"上界（Limit）：上界表示缓冲区中已经存储的元素数量。在写入模式下，上界等于缓冲区的容量；在读取模式下，上界等于最后一个写入元素的索引加一。\",\"标记（Mark）：可以通过 mark() 方法将当前位置设置为标记位置，并通过 reset() 方法将位置重置为标记位置。\",\"读写模式切换：flip() 方法将写入模式切换为读取模式，同时将位置设置为 0，并将上界设置为当前位置。clear() 方法将读取模式切换为写入模式，同时将位置设置为 0，并将上界设置为容量。\",\"2.png\",\"基本的 Buffer 类型包括 ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 和 DoubleBuffer，它们分别用于读写不同类型的数据。\",\"Buffer 的常用操作包括：\",\"put()：向缓冲区写入数据。\",\"get()：从缓冲区读取数据。\",\"flip()：切换为读取模式，重置位置和上界，准备读取缓冲区中的数据。\",\"clear()：切换为写入模式，重置位置和上界，准备写入数据到缓冲区。\",\"rewind()：重置位置为 0，保持上界不变，准备重新读取缓冲区中的数据。\",\"compact()：在写入模式下，将所有未读完的数据移到缓冲区的开头，重置位置和上界，准备继续写入数据。\",\"Buffer 在进行数据读写时，会通过位置来确定当前要操作的数据元素，通过上界来限制读写的范围。通过适当地使用这些方法，可以有效地管理缓冲区的状态，实现高效的数据处理。\",\"下面是一个使用 Buffer 进行基本操作的示例代码：\",\"import java.nio.Buffer; import java.nio.ByteBuffer; public class BufferExample { public static void main(String[] args) { // 创建一个 ByteBuffer ByteBuffer buffer = ByteBuffer.allocate(10); // 写入数据到缓冲区 buffer.put((byte) 'H'); buffer.put((byte) 'e'); buffer.put((byte) 'l'); buffer.put((byte) 'l'); buffer.put((byte) 'o'); // 切换为读取模式 buffer.flip(); // 从缓冲区读取数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); // 清空缓冲区 buffer.clear(); // 再次写入数据 buffer.put((byte) 'W'); buffer.put((byte) 'o'); buffer.put((byte) 'r'); buffer.put((byte) 'l'); buffer.put((byte) 'd'); // 切换为读取模式 buffer.flip(); // 从缓冲区读取部分数据 System.out.println(\\\"First: \\\" + (char) buffer.get()); System.out.println(\\\"Second: \\\" + (char) buffer.get()); // compact() 方法演示 buffer.compact(); // 从缓冲区读取剩余数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); // rewind() 方法演示 buffer.rewind(); // 从缓冲区重新读取数据 while (buffer.hasRemaining()) { System.out.print((char) buffer.get()); } System.out.println(); } } \",\"以上示例演示了 ByteBuffer 的常用操作。首先创建一个容量为 10 的 ByteBuffer，然后通过 put() 方法写入数据到缓冲区。接着，通过 flip() 方法切换为读取模式，并使用 get() 方法逐个字节读取数据并输出。然后，通过 clear() 方法清空缓冲区，并再次使用 put() 方法写入数据。再次切换为读取模式，并使用 get() 方法读取部分数据。随后演示了 compact() 方法的使用，可以将缓冲区中未读完的数据移到缓冲区的开头。最后，通过 rewind() 方法将缓冲区的位置重置为 0，并重新读取缓冲区中的数据。\"]},\"229\":{\"h\":\"Selector\",\"t\":[\"Selector 是一种多路复用的机制，允许单个线程同时监听多个通道的事件。通过使用 Selector，可以实现在单个线程中处理多个通道的 I/O 操作，提高系统的吞吐量和响应性能。\",\"nio-selector\",\"Selector 的工作原理如下：\",\"创建 Selector 对象：通过调用 Selector.open() 方法创建一个 Selector 实例。\",\"注册通道：将需要监听的通道注册到 Selector 上，并指定感兴趣的事件，如读（SelectionKey.OP_READ）、写（SelectionKey.OP_WRITE）、连接（SelectionKey.OP_CONNECT）或接受（SelectionKey.OP_ACCEPT）等。\",\"轮询就绪事件：通过调用 Selector 的 select() 方法来轮询监听注册的通道，当有通道有感兴趣的事件发生时，该方法将返回。\",\"处理就绪事件：通过 selectedKeys() 方法获取到 Selector 所管理的所有就绪的 SelectionKey，然后遍历这些 SelectionKey，根据就绪的事件类型执行相应的处理逻辑。\",\"取消注册或更新事件：如果某个通道的事件处理完成后，需要取消注册或更新感兴趣的事件，可以通过调用 SelectionKey 对象的相应方法进行操作。\",\"Selector 的优势在于可以使用较少的线程来处理多个通道的 I/O 操作，避免了为每个通道创建一个线程的开销。这使得它非常适用于需要同时处理大量连接的网络编程场景。通过 Selector，开发者可以实现高并发、高性能的网络服务器，提高了系统的资源利用率和响应速度。\",\"需要注意的是，Selector 是非阻塞模式下的特性，因此它和非阻塞的通道（如 SocketChannel 和 ServerSocketChannel）结合使用，以实现高效的 I/O 操作。\"]},\"230\":{\"h\":\"总结\",\"t\":[\"本文主要介绍了NIO的一些基本组件，主要包括通道Channel、缓冲区Buffer、选择器Selecotor组件。后面的文章将以案例的形式介绍SocketChannel、ServerSocketChannel的网络编程。\"]},\"231\":{\"h\":\"Java NIO案列实战\"},\"232\":{\"h\":\"SocketChannel介绍\",\"t\":[\"SocketChannel 是 Java NIO 中用于 TCP 网络通信的通道之一。它提供了非阻塞的 TCP 客户端和服务器端的实现，并且可以与选择器（Selector）一起使用，实现高效的多路复用 I/O。通过 SocketChannel，可以进行连接的建立、数据的读写以及连接的关闭操作。\",\"在使用 SocketChannel 时，通常需要遵循以下步骤：\",\"打开 SocketChannel：通过调用静态的 open() 方法来打开一个 SocketChannel 对象。\",\"连接远程服务器：调用 SocketChannel 的 connect() 方法来连接远程服务器。\",\"读写数据：通过 SocketChannel 对象的 read() 方法进行数据的读取，通过 write() 方法进行数据的写入。\",\"非阻塞模式：SocketChannel 可以通过 configureBlocking(false) 方法设置为非阻塞模式，配合选择器一起使用可以实现高效的多路复用 I/O。\",\"关闭通道：通信结束后，调用 SocketChannel 的 close() 方法关闭通道。\",\"示例代码如下：\",\"// 打开 SocketChannel SocketChannel socketChannel = SocketChannel.open(); // 连接远程服务器 socketChannel.connect(new InetSocketAddress(\\\"服务器IP\\\", 8080)); // 读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = socketChannel.read(buffer); // 写入数据 String data = \\\"Hello, Server!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { socketChannel.write(buffer); } // 非阻塞模式 socketChannel.configureBlocking(false); // 关闭通道 socketChannel.close(); \",\"SocketChannel 提供了灵活而高效的 TCP 网络通信能力，适用于需要使用非阻塞 I/O 和高并发处理的网络编程场景。\"]},\"233\":{\"h\":\"ServerSocketChannel介绍\",\"t\":[\"ServerSocketChannel 是 Java NIO 中用于 TCP 服务器端的通道之一。它用于监听客户端的连接请求，并在接受到连接请求时创建对应的 SocketChannel 与客户端进行通信。ServerSocketChannel 可以与选择器（Selector）一起使用，实现高效的多路复用 I/O。通过 ServerSocketChannel，可以进行服务器的初始化、接受连接、数据的读写以及关闭操作。\",\"在使用 ServerSocketChannel 时，通常需要遵循以下步骤：\",\"打开 ServerSocketChannel：通过调用静态的 open() 方法来打开一个 ServerSocketChannel 对象。\",\"绑定端口：通过 ServerSocketChannel 对象的 bind() 方法绑定服务器端口，并设置为非阻塞模式。\",\"接受连接：调用 accept() 方法来接受客户端的连接请求，返回一个对应的 SocketChannel 用于与客户端进行通信。\",\"读写数据：通过返回的 SocketChannel 对象进行数据的读取和写入。\",\"非阻塞模式：ServerSocketChannel 可以通过 configureBlocking(false) 方法设置为非阻塞模式，配合选择器一起使用可以实现高效的多路复用 I/O。\",\"关闭通道：通信结束后，关闭 ServerSocketChannel。\",\"示例代码如下：\",\"// 打开 ServerSocketChannel ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定端口并设置非阻塞模式 serverSocketChannel.bind(new InetSocketAddress(8080)); serverSocketChannel.configureBlocking(false); // 接受连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 读取数据 ByteBuffer buffer = ByteBuffer.allocate(1024); int bytesRead = socketChannel.read(buffer); // 写入数据 String data = \\\"Hello, Client!\\\"; buffer.clear(); buffer.put(data.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { socketChannel.write(buffer); } // 关闭连接 socketChannel.close(); // 关闭 ServerSocketChannel serverSocketChannel.close(); \",\"ServerSocketChannel 提供了灵活而高效的 TCP 服务器端编程能力，适用于需要使用非阻塞 I/O 和高并发处理的网络服务器编程场景。\"]},\"234\":{\"h\":\"Selector介绍\",\"t\":[\"Selector 是 Java NIO 中非常重要的组件，用于多路复用非阻塞 I/O。使用 Selector 可以用单线程处理多个 Channel，这样就可以管理多个网络连接，并且在有数据可读或可写的通道上进行处理，提高了 I/O 操作的效率。\",\"Selector 的主要作用包括：\",\"监控多个 Channel 的事件：比如读、写、连接、接受连接等事件。\",\"管理注册的 Channel：可以将多个 Channel 注册到一个 Selector 上，并根据事件类型进行监听。\",\"非阻塞 I/O 多路复用：在一个线程内处理多个 Channel 的 I/O 事件，提高了系统的并发处理能力。\",\"在使用 Selector 时，通常需要遵循以下步骤：\",\"打开 Selector：通过调用 Selector.open() 方法创建一个 Selector 对象。\",\"将 Channel 注册到 Selector 上：通过调用 Channel 的 register() 方法将要监听的事件和对应的事件处理器注册到 Selector 上。\",\"轮询事件：通过调用 Selector 的 select() 方法来轮询已注册的 Channel 上是否有对应的 I/O 事件发生。\",\"处理事件：根据 select() 方法的返回值，处理具体的 I/O 事件。\",\"示例代码如下：\",\"// 打开 Selector Selector selector = Selector.open(); // 将 Channel 注册到 Selector 上 channel1.register(selector, SelectionKey.OP_READ); channel2.register(selector, SelectionKey.OP_WRITE); while (true) { // 轮询事件 int readyChannels = selector.select(); if (readyChannels == 0) { continue; } Set<SelectionKey> selectedKeys = selector.selectedKeys(); Iterator<SelectionKey> keyIterator = selectedKeys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // 处理接受连接事件 } else if (key.isReadable()) { // 处理读事件 } else if (key.isWritable()) { // 处理写事件 } keyIterator.remove(); } } \",\"Selector 提供了高效的事件多路复用能力，适用于需要同时处理多个 Channel 的网络编程场景，能够实现高性能的并发 I/O 操作。\"]},\"235\":{\"h\":\"案列介绍\",\"t\":[\"服务端使用ServerSocketChannel和Selector\",\"客户端使用SocketChannel\",\"服务器端不关闭不停接收客户端的数据，并返回接收结果给客户端 。\",\"ClientA不关闭不断发送数据给服务端\"]},\"236\":{\"h\":\"服务端代码\",\"t\":[\"使用 Java NIO（New I/O）包实现的简单的基于 NIO 的服务器端程序，示例代码如下：\",\"package io.github.forezp.javabasiclab.nio; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.nio.charset.StandardCharsets; import java.util.Iterator; public class ServerConnect { private static final int BUF_SIZE = 1024; private static final int PORT = 8080; private static final int TIMEOUT = 3000; public static void main(String[] args) { selector(); } public static void handleAccept(SelectionKey key) throws IOException { ServerSocketChannel ssChannel = (ServerSocketChannel) key.channel(); SocketChannel sc = ssChannel.accept(); sc.configureBlocking(false); sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE)); } public static void handleRead(SelectionKey key) throws IOException { SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buf = (ByteBuffer) key.attachment(); long bytesRead = sc.read(buf); while (bytesRead > 0) { buf.flip(); while (buf.hasRemaining()) { System.out.print((char) buf.get()); } System.out.println(); buf.clear(); bytesRead = sc.read(buf); } buf.put((\\\"服务器端成功接收信息.\\\").getBytes()); buf.flip(); sc.write(buf); buf.clear(); if (bytesRead == -1) { sc.close(); } } public static void handleWrite(SelectionKey key) throws IOException { System.out.println(\\\"write to client\\\"); ByteBuffer buf = (ByteBuffer) key.attachment(); buf.flip(); String data = \\\"Hello, Client!\\\"; buf.put(data.getBytes(StandardCharsets.UTF_8)); SocketChannel sc = (SocketChannel) key.channel(); while (buf.hasRemaining()) { sc.write(buf); } buf.compact(); } public static void selector() { Selector selector = null; ServerSocketChannel ssc = null; try { selector = Selector.open(); ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(PORT)); ssc.configureBlocking(false); ssc.register(selector, SelectionKey.OP_ACCEPT); while (true) { if (selector.select(TIMEOUT) == 0) { System.out.println(\\\"==\\\"); continue; } Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); while (iter.hasNext()) { SelectionKey key = iter.next(); if (key.isAcceptable()) { handleAccept(key); } if (key.isReadable()) { handleRead(key); } if (key.isWritable() && key.isValid()) { handleWrite(key); } if (key.isConnectable()) { System.out.println(\\\"isConnectable = true\\\"); } iter.remove(); } } } catch (IOException e) { e.printStackTrace(); } finally { try { if (selector != null) { selector.close(); } if (ssc != null) { ssc.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"这个程序使用 Selector 来监听多个 Channel，并根据不同的事件类型进行处理。\",\"主要功能包括：\",\"在 selector() 方法中，首先打开一个 Selector，并创建一个 ServerSocketChannel，并将其注册到 Selector 上，并且设置为非阻塞模式。然后进入一个无限循环，不断轮询 Selector 上注册的事件。\",\"在 handleAccept(SelectionKey key) 方法中，当有新连接到来时，调用 ServerSocketChannel.accept() 方法接收连接，并将其设置为非阻塞模式，并注册到 Selector 上以监听读事件。\",\"在 handleRead(SelectionKey key) 方法中，处理读事件。它先创建一个 ByteBuffer 对象，用来读取数据。然后通过 SocketChannel 的 read 方法从 Channel 中读取数据，将其打印到控制台，并向客户端发送\\\"服务器端成功接收信息\\\"。\",\"在 handleWrite(SelectionKey key) 方法中，处理写事件。它首先创建一个 ByteBuffer 对象，并向其中放入要发送给客户端的数据\\\"Hello, Client!\\\"，然后通过 SocketChannel 的 write 方法向客户端写入数据。\",\"在 selector() 方法中，通过无限循环不断调用 Selector.select() 等待事件就绪，一旦有就绪的事件，就遍历处理相应的事件类型。\",\"这段代码实现了一个基于 Java NIO 的简单的非阻塞服务器端程序，能够同时处理多个客户端连接，并实现了事件的注册、轮询和处理。\"]},\"237\":{\"h\":\"客户端代码\",\"t\":[\"使用 Java NIO（New I/O）包实现了基于 NIO 的客户端程序，示例代码如下：\",\"package io.github.forezp.javabasiclab.nio; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SocketChannel; import java.util.concurrent.TimeUnit; public class ClientConnect { public static void main(String[] args) { try { client(); } catch (IOException e) { e.printStackTrace(); } } public static void client() throws IOException { ByteBuffer buffer = ByteBuffer.allocate(1024); SocketChannel socketChannel = null; try { socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); socketChannel.connect(new InetSocketAddress(\\\"127.0.0.1\\\", 8080)); if (socketChannel.finishConnect()) { int i = 0; while (true) { TimeUnit.SECONDS.sleep(1); String info = \\\"I'm \\\" + i++ + \\\"-th information from client\\\"; buffer.clear(); buffer.put(info.getBytes()); buffer.flip(); while (buffer.hasRemaining()) { //System.out.println(new String(buffer.array())); socketChannel.write(buffer); } // buffer.clear(); int len = socketChannel.read(buffer); buffer.flip(); byte[] bytes = new byte[buffer.remaining()]; buffer.get(bytes); System.out.println(new String(bytes, 0 , len)); buffer.clear(); } } } catch (IOException | InterruptedException e) { e.printStackTrace(); } finally { try { if (socketChannel != null) { socketChannel.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"代码的主要功能包括：\",\"在 client() 方法中，首先创建一个 ByteBuffer 对象用于读写数据，然后创建一个 SocketChannel，并将其设置为非阻塞模式。接着通过 socketChannel.connect(new InetSocketAddress(\\\"127.0.0.1\\\", 8080)) 进行连接服务器端。\",\"使用 socketChannel.finishConnect() 来确保连接已经建立，然后进入一个无限循环，向服务器端发送消息，并接收服务器端的响应。\",\"在while循环中，每隔一秒向服务器端发送一条消息，并且接收服务器端发送的反馈消息。\",\"在 finally 块中关闭 SocketChannel。\",\"这段代码实现了一个基于 Java NIO 的简单的非阻塞客户端程序，能够与服务器端建立连接，进行数据的发送和接收。\",\"依次启动服务端程序和客户端程序，服务端打印如下：\",\"== I'm 0-th information from client I'm 1-th information from client I'm 2-th information from client I'm 3-th information from client\",\"客户端打印如下：\",\"服务器端成功接收信息. 服务器端成功接收信息. 服务器端成功接收信息.\"]},\"238\":{\"h\":\"NIO底层原理\",\"t\":[\"NIO的特点是由底层原理决定的，如图：\",\"nio-jieshao\",\"总结来说，和阻塞 I/O（BIO）相比，使用多路复用器（比如 Selector）和非阻塞 I/O（NIO）的方式能够更高效地处理多个连接的读写事件。\",\"在使用 NIO 的情况下，当调用 select() 启动多路复用器时，连接事件会被交由多路复用器管理，这会触发内核中的 epoll() 函数，将网卡中所有连接的读写事件数据以链表的形式一次性拷贝到内存中的特定区域。这样一来，当 Selector 轮询到连接事件时便会触发内核中的 recvFrom(NOBlocking…) 函数，将数据从特定区域零拷贝到用户空间，实现了零拷贝的优化功能。\",\"与阻塞 I/O 不同的是，使用 NIO 和 Selector 能够保证即使某个连接阻塞，也不会影响其他连接的数据已就绪的读写事件。这是因为在 Selector 的轮询机制下，各个客户端的数据已经提前拷贝到内存中，所以不会因为某个连接的阻塞而影响其他连接的读写事件的处理。\",\"因此，使用 NIO 和 Selector 能够更高效地处理多个连接的读写事件，并且能够避免阻塞影响其他连接的特点成为了非常重要的优势。\"]},\"239\":{\"h\":\"java基础高频面试题1\"},\"240\":{\"h\":\"重载与重写的区别\",\"t\":[\"重载（Overloading）和重写（Overriding）是Java语言中的两个重要概念，它们都是用于类的方法。正是由于重载和重写，类的多态性得到了充分的展现。\",\"重载（Overloading）：\",\"重载指的是在一个类中定义多个方法，这些方法具有相同的方法名称，但是参数的个数不同，或者参数的类型不同，或者是参数的顺序不同。重载的方法通过调用时的参数的类型或者数量、顺序来区分调用了哪个方法。重载的方法的返回结果的类型也可以是不同的，但是不能返回结果的类型来定义方法的重载。\",\"重载有以下的特点：\",\"方法名称相同，参数的类型可以不同、参数的个数也可以不同、参数的顺序也可以不同\",\"不同的重载方法可以返回不同的结果；但是不同的返回结果不能作为方法重载的定义。\",\"编译是通过方法的不同的参数来确定方法\",\"代码示例：\",\"public class OverLodingDemo { public static void main(String[] args) { OverLodingDemo demo=new OverLodingDemo(); demo.greeting(\\\"lisi\\\"); demo.greeting(\\\"lisi\\\",\\\"wangwu\\\"); } public void greeting(String name){ System.out.println(\\\"hello \\\"+name); } public void greeting(String name1,String name2){ System.out.println(\\\"hello \\\"+name1 ); System.out.println(\\\"hello \\\"+name2 ); } } \",\"在上面的例子中，有两个greeting方法，这两个greeting方法有不同的参数个数，属于方法的重载。\",\"重写（Overriding）：\",\"重写是指子类对父类方法的重写，它是子类对父类的同名方法且具有相同的参数的重新实现。子类通过重写父类的方法来修改或者扩展父类方法的行为。\",\"被重写的方法具有以下的特点：\",\"子类的方法名称和父类完全相同，且具有相同的参数和返回结构类型\",\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别。\",\"它是动态绑定来确定运行时对象的实际方法的调用。\",\"举个简单的例子，有Animal的父类，有一个eat的方法：\",\"public class Animal { public void eat(){ System.out.println(\\\"animal eat\\\"); } } \",\"Sheep继承了Animal父类，并重写了eat方法：\",\"public class Sheep extends Animal{ @Override public void eat(){ System.out.println(\\\"sheep eat grass\\\"); } } \",\"Dog继承了Animal父类，没有重写了eat方法：\",\"public class Dog extends Animal{ } \",\"写一个测试类：\",\"public class OverwrittingDemo { public static void main(String[] args) { Animal sheep=new Sheep(); sheep.eat(); Animal dog=new Dog(); dog.eat(); } } \",\"执行结果如下：\",\"sheep eat grass animal eat\",\"总结：\",\"重载是针对于同个类中，重新是发生在子类和父类的继承关系之间。\",\"重载是根据方法的参数列表进行区分，重写是根据方法的名称和参数列表进行区分。\",\"重载方法在编译时静态地绑定，而重写方法在运行时动态地绑定。\",\"重载方法可以有不同的返回类型，而重写方法必须具有相同的返回类型。\"]},\"241\":{\"h\":\"抽象类和接口的区别\",\"t\":[\"抽象类\",\"抽象类通过使用关键字 \\\"abstract\\\" 来声明，它不能被实例化，只能用作基类或父类来使用。抽象类用于定义通用的属性和行为，可以包含抽象方法、普通方法、字段以及构造方法。抽象方法只有方法签名，没有方法体。抽象方法必须在非抽象子类中被重写实现。\",\"抽象类通常为其子类提供一个通用的模板，子类必须实现抽象类中的抽象方法。\",\"以下是一个抽象类的示例：\",\"public abstract class Shape { private String color; public Shape(String color) { this.color = color; } abstract double getArea(); } public class Circle extends Shape{ private double radius; public Circle(String color, double radius) { super(color); this.radius = radius; } @Override public double getArea() { return Math.PI * radius * radius; } } public class Demo { public static void main(String[] args) { Shape circle=new Circle(\\\"blue\\\",23); System.out.println(circle.getArea()); } } \",\"在上面的这个例子中，抽象类 Shape 声明了抽象方法 getArea() 。Circle 是其子类，并实现了抽象方法。需要注意的是虽然抽象类Shape具有构造函数，但是它是不能给被实例化的。可以通过抽象类的引用变量来指向它的实现类的实例。在上述示例中，可以使用 Shape 类型的引用变量 引用了 Circle 的实例对象。\",\"接口\",\"接口使用interface关键字定义的，它定义了一组方法的方法，通常是抽象方法，这些方法只有方法签名，没有方法体。这些抽象方法通常是定义了一组规范或者行为，但是没有实现。\",\"接口可以被类实现，一个类可以实现多个接口，而且同一个接口可以被多个类实现，从而使得一个实现类有不同接口的多态性。\",\"在接口定义中，方法默认是抽象类并且是pulic方法，所以在定义接口方法时不需要添加关键字 public和abstract。接口定义中可以包含常量、默认方法（Java 8 及以上版本）、静态方法（Java 8 及以上版本）和私有方法（Java 9 及以上版本）。\",\"以下是一个接口的示例：\",\" interface Animal { int LEGS = 4; // 常量 void makeSound(); // 抽象方法 default void sleep() { // 默认方法 System.out.println(\\\"Animal is sleeping.\\\"); } static void eat() { // 静态方法 System.out.println(\\\"Animal is eating.\\\"); } private void run() { // 私有方法 System.out.println(\\\"Animal is running.\\\"); } } public class Dog implements Animal{ @Override public void makeSound() { System.out.println(\\\"dog bark\\\"); } } public class AnimalDemo { public static void main(String[] args) { Dog dog = new Dog(); dog.makeSound(); dog.sleep(); Animal.eat(); } } \",\"在上面的例子中，\",\"接口Animal，定义了常量 LEGS 和抽象方法 makeSound()，以及默认方法 sleep() 和静态方法 eat()。Dog 类实现了 Animal 接口，实现了 makeSound() 方法。\",\"注意几点：\",\"类通过使用关键字 \\\"implements\\\" 来实现接口。一个类可以实现多个接口\",\"接口中的常量默认是静态常量。默认被 public static final 关键字修饰，可以直接通过接口名直接访问。\",\"接口的默认方法可以被实现该接口的类直接使用，实现类也可以重写接口的默认方法。\",\"静态方法在接口中提供了一些与接口相关的工具方法，可以直接通过接口名调用。\",\"私有方法在接口中定义一些辅助方法，只能在接口内部被调用，不能被实现类调用。\",\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为。通过实现接口，我们可以实现代码的解耦和类之间的松耦合。接口还为多重继承提供了解决方案，使得一个类可以具备多种类型的行为。\",\"抽象类VS接口\",\"抽象类和接口是Java中用于实现抽象和多态性的两个关键概念。它们有一些共同点，但也有一些区别。\",\"区别如下：\",\"实现方式：\",\"抽象类：通过关键字 abstract 定义的类，可以包含普通方法和抽象方法，可以有实例变量和构造方法。可以被继承，用于构建类的继承层级结构。\",\"接口：通过关键字 interface 定义的，只能包含常量和抽象方法（Java 8 之后，接口也可以包含默认方法和静态方法）。没有实例变量和构造方法。可以被类实现，用于实现类的多态性。\",\"多继承的支持：\",\"抽象类：Java只支持单继承，一个类只能继承一个抽象类。\",\"接口：Java支持多实现，一个类可以实现多个接口。\",\"构造方法：\",\"抽象类：可以有构造方法，用于实例化抽象类的对象。\",\"接口：不能有构造方法，接口只提供方法的声明，不能实例化对象。\",\"方法实现：\",\"抽象类：可以包含普通方法的实现。子类可以选择性地重写或调用父类的普通方法。\",\"接口：只能包含抽象方法的声明，不包含方法的实现。实现接口的类必须提供所有抽象方法的具体实现。\",\"设计目的：\",\"抽象类：用于描述一种通用的概念，如动物类、车类等，提供一些通用方法的实现，用作其他类的基类。\",\"接口：用于定义一组合同类型的操作，描述了一个类应该具备的行为，提供了一种通用的规范，用于实现类的多态性。\",\"需要注意的是，如果一个类既需要作为其他类的基类，又需要进行多种类型的实现，那么在设计时可以考虑将类设计为抽象类，并实现相关接口。这样可以兼顾抽象类和接口的优势。\"]},\"242\":{\"h\":\"为什么Java不支持多继承\",\"t\":[\"多继承是指一个类可以从多个父类继承属性和方法。尽管多继承在某些情况下可能很有用，但它也带来了一些问题。\",\"命名冲突：当一个类从多个父类继承相同名称的属性或方法时，可能会产生命名冲突。解决这些冲突需要额外的语法规则和解析过程，增加了语言的复杂性和理解上的困惑。\",\"菱形继承问题：多继承可能导致菱形继承问题，即当一个类同时继承自两个具有共同父类的类时，可能在继承链中得到两个相同的父类实例，导致不确定性。\",\"Java不支持多继承是为了避免多继承带来的上述问题。\",\"Java选择了单继承并使用了接口（interface）来解决多继承的需要。一个类可以实现多个接口，从而达到类似多继承的效果。使用接口可以避免命名冲突和菱形继承问题，并且提供了更灵活的类组合方式。\",\"在Java中，接口的设计可以更好地支持代码的组织和抽象，同时提供了更好的可维护性和扩展性。Java的设计理念是\\\"Prefer composition over inheritance\\\"（倾向于组合而非继承），鼓励使用组合和接口实现代码的复用和扩展。这种设计思想能够提高代码的可读性、可维护性和可扩展性。\"]},\"243\":{\"h\":\"String和StringBuffer、StringBuilder的区别是什么\",\"t\":[\"在Java中，String、StringBuffer和StringBuilder是用于处理字符串的类，它们之间有以下区别：\",\"可变性： \",\"String是不可变（Immutable）的类，一旦创建就不能被修改。每次对String进行修改操作都会创建一个新的String对象，原来的String对象不会被改变。\",\"StringBuffer和StringBuilder是可变（Mutable）的类，可以在原有对象的基础上进行修改。可以对其进行修改、删除、替换等操作，而不会创建新的对象。\",\"线程安全性： \",\"String是线程安全的，可以被多个线程同时访问而不会导致错误。\",\"StringBuffer是线程安全的，它的方法都使用了synchronized关键字来进行同步，保证了线程安全。\",\"StringBuilder是非线程安全的，在单线程环境中，StringBuilder的性能比StringBuffer性能更好。\",\"性能： \",\"由于String是不可变的，每次对String进行修改时都要创建一个新的对象，当需要频繁修改字符串时会产生大量的垃圾对象，对性能会有一定的影响。\",\"StringBuffer和StringBuilder是可变的，对字符串进行操作时不需要创建新的对象，因此在频繁修改字符串的场景下，性能较好。\",\"使用场景：\",\"当字符串不需要修改时，可以使用String。\",\"当需要对字符串进行频繁的修改时，建议使用StringBuffer或StringBuilder。\",\"如果在多线程环境下执行字符串操作，建议使用StringBuffer来保证线程安全。\",\"如果在单线程环境下进行字符串操作，可以使用StringBuilder来获得更好的性能。\"]},\"244\":{\"h\":\"如何理解面向过程和面向对象\",\"t\":[\"面向过程（Procedural Programming）和面向对象（Object-Oriented Programming）是两种不同的编程范式。\",\"面向过程是一种基于步骤和函数的编程方法。在面向过程编程中，程序被分解为可重用的功能模块，每个模块都包含一系列的操作步骤。程序按照一定的顺序执行这些步骤来完成任务。面向过程的关注点主要在于解决问题的步骤和流程。\",\"相比之下，面向对象是一种基于对象和类的编程方法。在面向对象编程中，程序由相互作用的对象组成，每个对象都是某个类的实例。每个对象都有自己的状态（属性）和行为（方法）。对象之间通过消息传递来进行通信和协作。面向对象的关注点主要在于构建对象的结构和定义对象的行为。\",\"面向过程和面向对象都有各自的优点和适用场景。面向过程更适合简单的任务和算法，它更直观、易于理解和调试。面向对象更适合复杂的应用，它具有更好的可维护性、可扩展性和重用性。\",\"在实际编程中，可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法，或者结合两者的特点使用混合编程。\"]},\"245\":{\"h\":\"Java基本类型为什么需要包装类\",\"t\":[\"Java基本类型（比如int、char、float、double等）需要包装类的原因有以下几个方面：\",\"泛型支持：Java的泛型不支持基本类型，只能使用对象类型。所以如果想要在泛型中使用一个基本类型的值，就需要将其包装成相应的对象类型。\",\"null赋值: 基本类型的取值范围是有限的，不能表示空值或null。使用包装类可以使得变量可以被赋值为null，方便更好地表示一个变量无值的状态。\",\"面向对象：Java是一种面向对象的语言，基本类型不是对象。如果使用基本类型，就无法访问其对象方法和属性。使用包装类可以让基本类型像一个对象一样使用。\",\"方法重载：Java不允许在方法中使用同名的不同类型的参数。因为基本类型的参数值之间无法进行隐式转换，所以需要使用包装类来为这些基本类型提供一个相应的对象类型，以便方法可以在这些对象类型之间进行选择。\",\"其他一些功能：包装类还提供了许多其他功能，比如数学运算、类型转换和字符串解析等。\",\"Java提供了对应的包装类来对基本类型进行包装，例如Integer、Character、Float、Double等等。这些包装类实现了相应类型的对象类型，提供了访问基本类型数据的方法。\",\"对于包装类，还有一些需要注意的点：\",\"包装类都是不可变的，一旦创建，其值就不能被修改。\",\"包装类的值比较应该使用equals()方法而不是==，因为包装类对象在使用==比较时，比较的是引用而不是值，这可能导致意外的结果。\",\"在自动装箱和拆箱时，Java会自动调用相应的包装类方法。\",\"例如，以下代码演示了使用包装类实现基本类型的自动装箱和拆箱：\",\"Integer i = 10; // 自动装箱 int j = i; // 自动拆箱 \",\"在这个例子中，编译器会自动将10包装成一个Integer对象，并将其赋值给i。在下一行，编译器又将i自动拆箱成int值，然后赋值给j。\"]},\"246\":{\"h\":\"如何理解java中的多态\",\"t\":[\"在 Java 中，多态是面向对象编程的一个核心概念，它允许我们使用父类的引用变量来引用子类的对象实例。多态主要体现在方法的重写和方法的动态绑定上。\",\"具体来说，可以通过以下几个方面来理解 Java 中的多态：\",\"父类引用指向子类对象实例。这样做的好处是可以通过统一的接口来操作不同的子类对象，实现了代码的灵活性和扩展性。\",\"方法的重写：子类可以重写（覆盖）从父类继承过来的方法。当使用父类引用指向子类对象时，通过父类引用调用重写的方法时，实际上会调用子类中的方法，这就实现了运行时的动态绑定。\",\"动态绑定：Java 的方法调用是基于运行时类型而不是编译时类型。也就是说，当调用一个对象的方法时，实际调用的是该对象的实际类型中定义的方法。这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象，实现了多态性的特性。\",\"多态性是继承的一个重要应用，它让我们可以使用父类的引用变量来引用不同子类的对象，并根据实际对象的类型来执行对应的方法。这样做的好处是实现了代码的灵活性、可扩展性和易维护性。\",\"例如，假设有一个抽象类 Animal 和它的两个子类 Cat 和 Dog，它们都有一个共同的方法 makeSound()：\",\"abstract class Animal { public abstract void makeSound(); } class Cat extends Animal { @Override public void makeSound() { System.out.println(\\\"Meow!\\\"); } } class Dog extends Animal { @Override public void makeSound() { System.out.println(\\\"Woof!\\\"); } } \",\"现在我们可以通过 Animal 类的引用变量来引用 Cat 或 Dog 对象，并根据实际对象的类型来调用 makeSound() 方法：\",\"Animal animal1 = new Cat(); Animal animal2 = new Dog(); animal1.makeSound(); // 输出 \\\"Meow!\\\" animal2.makeSound(); // 输出 \\\"Woof!\\\" \",\"在这个例子中，我们使用父类 Animal 的引用变量 animal1 和 animal2 分别引用了 Cat 和 Dog 对象。当调用 makeSound() 方法时，由于动态绑定的机制，实际上调用的是 Cat 和 Dog 对象中重写的 makeSound() 方法。\",\"需要注意的是在使用父类引用的变量去调用方法时，只能调用父类中声明的方法和子类中重写了父类的方法。要调用子类特有的方法，需要将父类引用的变量进行转换成子类的类型。\"]},\"247\":{\"h\":\"\"},\"248\":{\"h\":\"谈谈final、finally、finalize的区别\"},\"249\":{\"h\":\"java基础高频面试题2\"},\"250\":{\"h\":\"\\\"==\\\" 和 \\\"equals\\\" 的区别\",\"t\":[\"\\\"==\\\" 和 \\\"equals\\\" 都可以用于比较 Java 中的对象，但是它们之间有一些区别。\"]},\"251\":{\"h\":\"关系操作符号“==”\",\"t\":[\"基本数据类型\",\"在Java中有八种基本数据类型：\",\"浮点型：float(4 byte), double(8 byte)\",\"整型：byte(1 byte), short(2 byte), int(4 byte) , long(8 byte)\",\"字符型: char(2 byte)\",\"布尔型: boolean(JVM规范没有明确规定其所占的空间大小，仅规定其只能够取字面值”true”和”false”)\",\"对于基本数据类型的变量，变量直接存储的是“值”。因此，在使用关系操作符 “== ”来进行比较时，比较的就是“值”本身。要注意的是，浮点型和整型都是有符号类型的（最高位仅用于表示正负，不参与计算【以 byte 为例，其范围为 -2^7 ~ 2^7 - 1，-0即-128】），而char是无符号类型的（所有位均参与计算，所以char类型取值范围为0~2^16-1）。\",\"举个例子：\",\"int a = 5; int b = 5; System.out.println(a == b); // true \",\"引用类型变量\",\"在Java中，引用类型的变量存储的并不是“值”本身，而是与其关联的对象在内存中的地址。如果使用== 操作符去判断引用类型的变量，则比较的内容是判断两个变量的引用是否相等，即它们是否指向同一个对象。如果两个变量的引用指向同一个对象，那么它们之间的 == 比较结果为 true。如果两个引用指向不同的对象，那么它们之间的 ==比较结果为 false。例如：\",\"String str1 = \\\"abc\\\"; String str2 = \\\"abc\\\"; String str3 = new String(\\\"abc\\\"); System.out.println(str1 == str2); // true System.out.println(str1 == str3); // false \",\"在上述示例中，str1 和 str2 都指向常量池中的同一个字符串对象，因此它们之间的 == 比较结果为 true。而 str3 则指向一个新创建的字符串对象，所以它们之间的 == 比较结果为 false。\"]},\"252\":{\"h\":\"\\\"equals\\\"\",\"t\":[\"在初学Java的时候，很多人会说在比较对象的时候，“==”操作符是比较两个变量的内存地址，equals()是比较对象的内容，其实不然。\",\"在Object类中，equals()方法是比较两个对象的内存地址是否相等，代码如下：\",\"public boolean equals(Object obj){ return (this == obj); } \",\"为什么会有人把equals方法当做是比较两个内容的比较呢？是因为在String、Double等封装类中，已经重写了(ov了Object类的equals()方法。比如在String内中，它比较的是对字符串内容的比较：\",\"public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } \",\"在String类的方法中，先比较的是字符串地址是否相等，如果相等，则字符串内容肯定是相等；然后地址不相等，则比较字符串内容是否相等。\",\"在实际的开发中，我们对对象内容的比较，通常都需要重写equals()方法。当我们重写equals()方法，需要遵循以下几个规则：\",\"自反性：对于任何非null的引用值x，x.equals(x)应返回true。\",\"对称性：对于任何非null的引用值x和y，如果x.equals(y)返回true，则y.equals(x)也应返回true。\",\"传递性：对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，则x.equals(z)也应返回true。\",\"一致性：对于任何非null的引用值x和y，如果用于比较的对象信息没有被修改，则x.equals(y)的多次调用应始终返回相同的结果。\",\"非空性：对于任何非null的引用值x，x.equals(null)应返回false。\"]},\"253\":{\"h\":\"\\\"equals\\\" 和hashcode的关系\",\"t\":[\"当我们在重写equals()方法时，通常也需要重写hashCode()方法。这是因为我们在使用基于散列的数据结构，比如如哈希表，以及一些集合类（如HashSet、HashMap）时，hashCode()方法的返回值将被用作对象的索引。\",\"当我们重写equals()方法时，经常选择使用对象的一些属性进行比较，以确定两个对象是否相等。在这种情况下，为了保持一致性，我们需要使用相同的属性来计算hashCode()值。\",\"如果我们没有重写hashCode()方法，那么hashCode()的默认行为是使用对象的内存地址计算哈希码，这与equals()方法的比较内容无关。这将导致具有相等内容的对象，通过hashCode()方法计算出来的哈希码可能不相等，这将导致在存储和查找对象时出现问题。\",\"所以，正确地重写hashCode()方法是很重要的。以下是一些在重写hashCode()方法时需要注意的规则：\",\"一致性：在对象的生命周期中，只要对象的属性没有发生改变，那么hashCode()应始终返回相同的值。\",\"相等性：如果两个对象根据equals()方法比较相等，那么它们的hashCode()方法应返回相同的值。\",\"分布均匀性：尽量避免不同对象返回相同的hashCode()值，以减少哈希冲突的概率，提高散列存储结构的性能。\",\"一种常用的方式来重写hashCode()方法是，根据对象的每个属性计算一个哈希码，然后将这些哈希码组合在一起，以获得最终的哈希码。这可以通过使用乘法和加法等算法来实现。如果某个属性可以为null，则需要特殊处理，以避免空指针异常。\",\"比如在String类中，hashCode()方法的定义如下：\",\" public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i < value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; } \"]},\"254\":{\"h\":\"java中的异常处理机制\",\"t\":[\"Java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况，以确保程序的正常执行。\",\"异常类层次结构\",\"在Java中，Exception、Error和Throwable是一个类层次结构中的相关类。\",\" <<class>> Throwable ---------------- | | <<class>> <<class>> Exception Error | ------------------ | | checked unchecked \",\"Throwable是所有异常类的根类，它位于异常类的最顶层。它定义了可以被抛出和捕获的异常对象的基本功能。Throwable有两个重要的子类：Exception和Error。\",\"Exception是可控制的异常类，通常表示程序中可预见的异常情况，可以被捕获并进行相应处理。它是Throwable的一个子类。\",\"Exception又分为两种类型：checked异常和unchecked异常。checked异常需要在代码中进行处理或声明，否则编译器会报错；unchecked异常不要求在代码中进行处理或声明。\",\"自定义异常：Java允许开发者自定义异常类，以便更好地抽象和组织程序中可能发生的异常情况。自定义异常类通常继承自Exception或RuntimeException类\",\"Error是不可控制的严重问题的异常类，通常表示系统的严重错误或问题，大多数情况下不会被程序显式地捕获和处理，而是由Java运行时环境（JVM）来处理。Error也是Throwable的一个子类。\",\"异常处理语句\",\"Java语言中提供了一些列的异常处理关键字和处理模板。\",\"抛出异常，使用throw语句。可以使用throw语句在程序中主动抛出异常，从而触发异常处理机制。\",\"声明异常：使用throws关键字，在方法签名中明确指定可能抛出的异常类型，这样调用者就能清楚地知道需要处理哪些异常。\",\"捕获异常，常使用try-catch-finally异常处理语句模板 \",\"try块：try块用于包裹可能发生异常的代码片段。当try块中的代码发生异常时，异常将被抛出，程序流程将跳转到catch块或finally块。\",\"catch块：catch块用于捕获并处理指定类型的异常。catch块可以捕获多个异常类型，并按照顺序处理异常。\",\"finally块：finally块用于定义无论是否发生异常都需要执行的代码，例如释放资源。finally块在try块或catch块执行完毕后执行。\",\"举个例子，演示了try-catch-finally的用法：\",\"public class ExceptionExample { public static void main(String[] args) { try { int result = divide(10, 0); System.out.println(\\\"结果：\\\" + result); } catch (ArithmeticException e) { System.out.println(\\\"除零错误：\\\" + e.getMessage()); } finally { System.out.println(\\\"执行finally块\\\"); } } public static int divide(int num1, int num2) { return num1 / num2; } } \",\"在上述代码中，定义了一个divide方法，用于计算两个数的除法操作。由于除数为0会产生算术异常（ArithmeticException），我们使用try-catch语句对可能发生异常的代码块进行了包裹。\",\"在try代码块中，我们调用了divide方法并将结果存储在result变量中。\",\"如果在此过程中发生了异常，程序会立即跳转到catch代码块中，并执行与异常类型匹配的处理代码。在\",\"无论是否发生异常，finally代码块中的代码始终会执行。\",\"执行上述代码，输出如下：\",\"除零错误：/ by zero 执行finally块 \",\"Java的异常处理机制是Java程序设计中非常重要的一个方面，它能够有效地处理程序中可能发生的异常情况，并提供了良好的可读性和可维护性。通过合理地使用try-catch-finally块，对异常进行合适的处理，防止程序因为出现异常而奔溃，是程序的稳定性和健壮性的一种保护机制。\"]},\"255\":{\"h\":\"JDK、JRE、JVM的区别和联系\",\"t\":[\"JDK（Java Development Kit）是Java开发工具包，提供了一套完整的开发工具，包括编译器（javac）、调试器（jdb）、打包工具（jar）等。使用JDK可以进行Java应用程序的开发和构建，生成可执行的Java应用程序。JDK还提供了各种开发文档和示例代码，帮助开发者学习和使用Java。\",\"JRE（Java Runtime Environment）是Java运行时环境，是在目标机器上运行Java应用程序所需的最小环境。它包含了JVM（Java Virtual Machine）和Java类库。当用户在目标机器上运行Java应用程序时，需要先安装JRE。JRE只提供了Java应用程序的运行环境，不包含开发工具。\",\"JVM（Java Virtual Machine）是Java虚拟机，是Java平台的核心部分。它是一个抽象的计算机，可以在不同的操作系统上运行Java程序，实现了Java的跨平台特性。JVM解析Java字节码，并将其转换为底层操作系统可以执行的机器码。它还具有内存管理、垃圾回收等功能，确保Java应用程序的安全、高效执行。\",\"他们之间的关系如下：\",\"JDK包含JRE，因为在开发Java应用程序时需要运行Java程序来进行测试和调试。\",\"JRE包含JVM，因为在运行Java应用程序时需要虚拟机来解释和执行Java字节码。\"]},\"256\":{\"h\":\"final关键字详解\"},\"257\":{\"h\":\"final关键字的基本用法\",\"t\":[\"final关键字，用于表示不可变，表示变量或者方法定义后不能被修改或者重写。final关键字可以用于修饰类、方法和变量。\",\"修饰类：当类被声明为final时，表明该类不能被继承。它是一个最终类，不能有子类继承它。\",\"public final class FinalTest { } \",\"修饰方法: 当方法被声明为final时，该方法不能被子类重写。子类只能继承父类中的final方法，但不能修改其实现。\",\"public class FinalMethodDemo { public final void test(){ System.out.println(\\\"test\\\"); } static class FinalMethodeDemo2 extends FinalMethodDemo{ //编译不通过 @Override public void test(){ System.out.println(\\\"test\\\"); } } } \",\"FinalMethodeDemo2是不能重新它的父类FinalMethodDemo的final方法的，编译的时候会报错。idea会提示错误，如下图所示：\",\"修饰变量: 当变量被声明为final时，该变量的值不能被修改，即它成为一个常量。一旦被赋值，就不能再更改。\",\"对于实例变量（成员变量），可以在代码块中赋值，也可以在构造函数中赋值，一旦赋值就不能被改变：\",\" private final String s1=\\\"s1\\\"; // { // s1=\\\"s1\\\"; //在代码快中赋值 // } private static final String s2; static { s2=\\\"s2\\\"; //在静态代码快中赋值 } private final String s3; //在构造函数中赋值 public FinalTest(String s3) { this.s3 = s3; } \",\"对于被final修饰的局部变量，在使用前必须赋值。\",\" public void test2(){ final String s; s=\\\"ss\\\"; System.out.println(s);//在使用final变量前必须赋值 } \",\"如果被final修饰的变量时引用类型，则在变量初始化后，就不能再指向另一个对象了，但是变量的值是可以被修改的。示例代码如下：\",\"public class FinalObject { public static void main(String[] args) { final int[] arrays=new int[]{1,2,3}; // arrays=null; 非法 final Person person=new Person(\\\"sam\\\",1); person.setAge(2); // person=null; 非法 } static class Person { private String Name; private int age; public Person(String name, int age) { Name = name; this.age = age; } public String getName() { return Name; } public void setName(String name) { Name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } } \",\"final关键字的使用可以增加代码的可读性，提高代码的安全性，以及优化性能。它可以在合适的场景中使用，例如常量、线程安全等需要不可变性的情况。\"]},\"258\":{\"h\":\"为什么内部类引用的外部变量必须用final修饰\",\"t\":[\"JDK1.8之后，如果将局部变量（或表达式）传递给匿名内部类或Lambda表达式作为捕捉的变量，它们会被隐式地视为final，是不可以被更改的。\",\"为什么会这样呢？\",\"public abstract class Task { public abstract void run(); } public class FinalDemo { public void run1(final String taskname) { Task task = new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname +\\\" run\\\"); } }; task.run(); } public void run2(final String taskname) { new Task() { @Override public void run() { System.out.println(\\\"taskname=\\\" + taskname+\\\" run\\\"); } }.run(); } public static void main(String[] args) { FinalDemo demo = new FinalDemo(); demo.run1(\\\"task1\\\"); demo.run2(\\\"task2\\\"); } } \",\"首先，内部类和外部类其实是处于同一个级别，反编译中可以看到都是对象级别的类文件，内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁。\",\"如果外部类的方法中的变量不定义final，那么当外部类方法执行完毕的时候，这个局部变量肯定也就被GC了，然而内部类的某个方法还没有执行完，这个时候他所引用的外部变量已经找不到了。\",\"如果定义为final，java会将这个变量复制一份作为成员变量内置于内部类中(反编译class文件中可以看到)，这样的话，由于final所修饰的值始终无法改变，所以这个变量所指向的内存区域就不会变。\"]},\"259\":{\"h\":\"谈谈final、finally、finalize的区别\",\"t\":[\"final是Java中的修饰符，可以用来修饰类、方法和变量，表示不可改变的\",\"修饰类：当类被声明为final时，该类不能被继承，成为最终类。\",\"修饰方法：当方法被声明为final时，该方法不能被子类重写，成为最终方法。\",\"修饰变量：当变量被声明为final时，该变量的值一旦被赋值，不能被修改，成为常量。\",\"finally：finally是Java中的关键字，用于异常处理的最后一个代码块，在try-catch语句中使用。无论是否发生异常，finally块中的代码都会被执行。\",\"try { // 可能会发生异常的代码 } catch (Exception e) { // 异常处理逻辑 } finally { // 最终会执行的代码块 } \",\"finally块通常用于释放资源、关闭连接等必须执行的操作，以确保代码的可靠性。即使在try块或catch块中出现return语句，finally块中的代码也会在方法返回之前执行。\",\"finalize：finalize是一个方法，它是在对象被垃圾回收器回收之前调用的。每个类都可以重写finalize方法来执行对象的清理操作。\",\"需要注意的是，finalize方法已经过时，不推荐使用了。因为垃圾回收器的工作是由Java虚拟机自动处理的，无法保证finalize方法的及时执行。更好的做法是使用try-finally或其他资源管理机制来确保资源的释放。\",\"@Override protected void finalize() throws Throwable { // 进行资源释放或清理操作 super.finalize(); } \"]},\"260\":{\"h\":\"finally语句到底是在return之前还是之后执行？\",\"t\":[\"在回答这个问题前，先来说一下finally语句是不会被执行的情况：\",\"try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要条件是：相应的try语句一定被执行到。\",\"在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，finally语句也不会被执行到。\",\"finally语句到底是在return之前还是之后执行？\",\"当没有发生异常时：如果在try块中没有发生异常，finally语句将在try块执行完毕后立即执行。然后，程序将继续执行后续的代码。finally块中的代码将在return语句执行之后、方法返回之前执行。\",\"请看下面的示例代码：\",\"public class FinalReturn1 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a = 1; try { return a; } finally { a = 2; //idea提示：The value 2 assigned to 'a' is never used System.out.println(\\\"Finally block executed.\\\"); } } } \",\"在这个示例中，无论try块中是否发生异常，finally块中的代码都会被执行。控制台会输出以下内容：\",\"Finally block executed. 1 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在catch中再次使用了return操作，则会覆盖try里面的return操作。\",\"package io.github.forezp.javabasiclab.finaltest; public class FinalReturn2 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 2 \",\"当发生异常时：如果在try块中发生了异常，会根据异常类型在catch块中进行匹配，然后执行相应的catch块。之后，无论是否有匹配的catch块，finally语句块都将执行。如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\",\"public class FinalReturn3 { public static void main(String[] args) { System.out.println(myMethod()); } public static int myMethod() { int a=1; try { int result = 10 / 0; // 抛出异常 return a; } catch (ArithmeticException e) { System.out.println(\\\"ArithmeticException caught.\\\"); a=2; return a; } finally { System.out.println(\\\"Finally block executed.\\\"); a=3; return 4; } } } \",\"控制台会输出以下内容：\",\"ArithmeticException caught. Finally block executed. 4 \",\"总结来说，finally语句在Java中用于定义一段无论是否发生异常都会执行的代码块。它在try块或catch块中的代码执行完毕后立即执行，并且在方法返回之前被执行。\",\"在try或catch块中使用return语句时，finally块中的代码也会在return语句执行后执行。(finally语句中没有使用return操作)\",\"如果在finally中再次使用了return操作，则会覆盖之前try或者catch里面的return操作。\"]}},\"dirtCount\":0,\"index\":[[\"控制台会输出以下内容\",{\"1\":{\"260\":3}}],[\"控制台打出的结果如下\",{\"1\":{\"87\":1}}],[\"成为常量\",{\"1\":{\"259\":1}}],[\"成为最终方法\",{\"1\":{\"259\":1}}],[\"成为最终类\",{\"1\":{\"259\":1}}],[\"成员变量\",{\"1\":{\"207\":1,\"257\":1}}],[\"反编译class文件中可以看到\",{\"1\":{\"258\":1}}],[\"反编译中可以看到都是对象级别的类文件\",{\"1\":{\"258\":1}}],[\"反转等\",{\"1\":{\"174\":1}}],[\"修饰变量\",{\"1\":{\"257\":1,\"259\":1}}],[\"修饰方法\",{\"1\":{\"257\":1,\"259\":1}}],[\"修饰类\",{\"1\":{\"257\":1,\"259\":1}}],[\"修改为当前的\",{\"1\":{\"186\":1}}],[\"修改某个键对应的值\",{\"1\":{\"176\":1}}],[\"修改列表中的元素\",{\"1\":{\"174\":1}}],[\"修改元素\",{\"1\":{\"174\":1}}],[\"他们之间的关系如下\",{\"1\":{\"255\":1}}],[\"确保java应用程序的安全\",{\"1\":{\"255\":1}}],[\"确定当前告警应该如何处理\",{\"1\":{\"162\":1}}],[\"垃圾回收等功能\",{\"1\":{\"255\":1}}],[\"帮助开发者学习和使用java\",{\"1\":{\"255\":1}}],[\"生成可执行的java应用程序\",{\"1\":{\"255\":1}}],[\"打包工具\",{\"1\":{\"255\":1}}],[\"打开\",{\"1\":{\"232\":2,\"233\":2,\"234\":2}}],[\"打开一个\",{\"1\":{\"227\":1}}],[\"调试器\",{\"1\":{\"255\":1}}],[\"调用\",{\"1\":{\"198\":1,\"232\":2,\"233\":1,\"236\":1}}],[\"调用元素的\",{\"1\":{\"185\":1}}],[\"捕获异常\",{\"1\":{\"254\":1}}],[\"捕获并外部化对象的内部状态\",{\"1\":{\"68\":1}}],[\"声明异常\",{\"1\":{\"254\":1}}],[\"声明了抽象方法\",{\"1\":{\"241\":1}}],[\"抛出异常\",{\"1\":{\"254\":1,\"260\":2}}],[\"传递给匿名内部类或lambda表达式作为捕捉的变量\",{\"1\":{\"258\":1}}],[\"传递性\",{\"1\":{\"252\":1}}],[\"传递一个集合参数的构造函数\",{\"1\":{\"207\":1}}],[\"先来说一下finally语句是不会被执行的情况\",{\"1\":{\"260\":1}}],[\"先比较的是字符串地址是否相等\",{\"1\":{\"252\":1}}],[\"先了解这些核心概念\",{\"1\":{\"158\":1}}],[\"仅规定其只能够取字面值\",{\"1\":{\"251\":1}}],[\"布尔型\",{\"1\":{\"251\":1}}],[\"布局与功能禁用\",{\"0\":{\"7\":1}}],[\"整型\",{\"1\":{\"251\":1}}],[\"整数0\",{\"1\":{\"214\":1}}],[\"浮点型和整型都是有符号类型的\",{\"1\":{\"251\":1}}],[\"浮点型\",{\"1\":{\"251\":1}}],[\"谈谈final\",{\"0\":{\"248\":1,\"259\":1}}],[\"假设有一个抽象类\",{\"1\":{\"246\":1}}],[\"覆盖\",{\"1\":{\"246\":1}}],[\"覆盖需要删除的元素\",{\"1\":{\"184\":1}}],[\"父类引用指向子类对象实例\",{\"1\":{\"246\":1}}],[\"泛型支持\",{\"1\":{\"245\":1}}],[\"易于理解和调试\",{\"1\":{\"244\":1}}],[\"替换等操作\",{\"1\":{\"243\":1}}],[\"鼓励使用组合和接口实现代码的复用和扩展\",{\"1\":{\"242\":1}}],[\"倾向于组合而非继承\",{\"1\":{\"242\":1}}],[\"菱形继承问题\",{\"1\":{\"242\":1}}],[\"尽量避免不同对象返回相同的hashcode\",{\"1\":{\"253\":1}}],[\"尽量以通俗易懂的语言和代码案例去讲述\",{\"1\":{\"64\":1}}],[\"尽管多继承在某些情况下可能很有用\",{\"1\":{\"242\":1}}],[\"又需要进行多种类型的实现\",{\"1\":{\"241\":1}}],[\"又被叫做最小知识原则\",{\"1\":{\"70\":1}}],[\"车类等\",{\"1\":{\"241\":1}}],[\"构造方法\",{\"1\":{\"241\":1}}],[\"构造函数\",{\"0\":{\"189\":1,\"197\":1,\"207\":1}}],[\"之后\",{\"1\":{\"241\":1,\"260\":2}}],[\"区别如下\",{\"1\":{\"241\":1}}],[\"私有方法在接口中定义一些辅助方法\",{\"1\":{\"241\":1}}],[\"私有方法\",{\"1\":{\"241\":1}}],[\"及以上版本\",{\"1\":{\"241\":3}}],[\"及划分责任和算法\",{\"1\":{\"68\":1}}],[\"引用类型的变量存储的并不是\",{\"1\":{\"251\":1}}],[\"引用类型变量\",{\"1\":{\"251\":1}}],[\"引用了\",{\"1\":{\"241\":1}}],[\"引入一个适配器类兼容现有目标类\",{\"1\":{\"83\":1}}],[\"普通方法\",{\"1\":{\"241\":1}}],[\"子类只能继承父类中的final方法\",{\"1\":{\"257\":1}}],[\"子类可以重写\",{\"1\":{\"246\":1}}],[\"子类可以选择性地重写或调用父类的普通方法\",{\"1\":{\"241\":1}}],[\"子类必须实现抽象类中的抽象方法\",{\"1\":{\"241\":1}}],[\"子类的方法名称和父类完全相同\",{\"1\":{\"240\":1}}],[\"子类通过重写父类的方法来修改或者扩展父类方法的行为\",{\"1\":{\"240\":1}}],[\"顺序来区分调用了哪个方法\",{\"1\":{\"240\":1}}],[\"各个客户端的数据已经提前拷贝到内存中\",{\"1\":{\"238\":1}}],[\"各种reader一层套一层\",{\"1\":{\"85\":1}}],[\"依次启动服务端程序和客户端程序\",{\"1\":{\"237\":1}}],[\"依赖反转原则\",{\"1\":{\"70\":1}}],[\"块中关闭\",{\"1\":{\"237\":1}}],[\"服务端打印如下\",{\"1\":{\"237\":1}}],[\"服务端代码\",{\"0\":{\"236\":1}}],[\"服务端使用serversocketchannel和selector\",{\"1\":{\"235\":1}}],[\"服务器端成功接收信息\",{\"1\":{\"236\":2,\"237\":3}}],[\"服务器端不关闭不停接收客户端的数据\",{\"1\":{\"235\":1}}],[\"服务器端编程能力\",{\"1\":{\"233\":1}}],[\"服务器端的通道之一\",{\"1\":{\"233\":1}}],[\"服务器ip\",{\"1\":{\"232\":1}}],[\"案列介绍\",{\"0\":{\"235\":1}}],[\"案例实战\",{\"0\":{\"92\":1,\"106\":1}}],[\"轮询到连接事件时便会触发内核中的\",{\"1\":{\"238\":1}}],[\"轮询和处理\",{\"1\":{\"236\":1}}],[\"轮询事件\",{\"1\":{\"234\":2}}],[\"轮询就绪事件\",{\"1\":{\"229\":1}}],[\"事件发生\",{\"1\":{\"234\":1}}],[\"事件\",{\"1\":{\"234\":2}}],[\"管理注册的\",{\"1\":{\"234\":1}}],[\"绑定端口并设置非阻塞模式\",{\"1\":{\"233\":1}}],[\"绑定端口\",{\"1\":{\"233\":1}}],[\"示例代码如下\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"236\":1,\"237\":1,\"257\":1}}],[\"配合选择器一起使用可以实现高效的多路复用\",{\"1\":{\"232\":1,\"233\":1}}],[\"配置讲解\",{\"0\":{\"163\":1}}],[\"配置文件中包含了4个部分\",{\"1\":{\"162\":1}}],[\"配置和启动alertmanager\",{\"1\":{\"157\":1}}],[\"配置请求的p95耗时\",{\"1\":{\"156\":1}}],[\"配置的表达式如下\",{\"1\":{\"156\":2}}],[\"配置grafana视图\",{\"0\":{\"156\":1}}],[\"配置完成后\",{\"1\":{\"155\":1}}],[\"配置完成后保存\",{\"1\":{\"127\":1}}],[\"配置如下\",{\"1\":{\"155\":1}}],[\"配置prometheus采集\",{\"0\":{\"155\":1}}],[\"配置prometheus采集node\",{\"1\":{\"122\":1}}],[\"配置界面的路径和配置如下\",{\"1\":{\"127\":1}}],[\"配置信息如下\",{\"1\":{\"125\":1}}],[\"配置\",{\"0\":{\"15\":1},\"1\":{\"163\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"1\":1,\"2\":1}}],[\"避免了为每个通道创建一个线程的开销\",{\"1\":{\"229\":1}}],[\"避免出现一些无意义的计算\",{\"1\":{\"170\":1}}],[\"避免出现对业务的影响\",{\"1\":{\"121\":1}}],[\"连接事件会被交由多路复用器管理\",{\"1\":{\"238\":1}}],[\"连接远程服务器\",{\"1\":{\"232\":2}}],[\"连接\",{\"1\":{\"229\":1,\"234\":1}}],[\"连上了usb接口\",{\"1\":{\"82\":1}}],[\"保持上界不变\",{\"1\":{\"228\":1}}],[\"保证在迭代过程中对集合的修改不会产生错误的结果\",{\"1\":{\"186\":1}}],[\"保证了线程安全\",{\"1\":{\"243\":1}}],[\"保证了存储的键值对的分布合理性和查询性能的稳定性\",{\"1\":{\"201\":1}}],[\"保证了这些对象之间的兼容性\",{\"1\":{\"103\":1}}],[\"保证了mac电脑对外接口的简单性\",{\"1\":{\"83\":1}}],[\"准备继续写入数据\",{\"1\":{\"228\":1}}],[\"准备重新读取缓冲区中的数据\",{\"1\":{\"228\":1}}],[\"准备写入数据到缓冲区\",{\"1\":{\"228\":1}}],[\"准备读取缓冲区中的数据\",{\"1\":{\"228\":1}}],[\"切换为写入模式\",{\"1\":{\"228\":1}}],[\"切换为读取模式\",{\"1\":{\"228\":3}}],[\"切换为读取模式逐个字节输出\",{\"1\":{\"227\":1}}],[\"切换缓冲区为写入模式\",{\"1\":{\"227\":1}}],[\"切换缓冲区为读取模式\",{\"1\":{\"227\":1}}],[\"关系操作符号\",{\"0\":{\"251\":1}}],[\"关键字修饰\",{\"1\":{\"241\":1}}],[\"关闭连接等必须执行的操作\",{\"1\":{\"259\":1}}],[\"关闭连接\",{\"1\":{\"233\":1}}],[\"关闭\",{\"1\":{\"233\":2}}],[\"关闭通道\",{\"1\":{\"232\":2,\"233\":1}}],[\"关闭通道和文件\",{\"1\":{\"227\":2}}],[\"关于这些扩展\",{\"1\":{\"17\":1}}],[\"逐个字节读取并输出\",{\"1\":{\"227\":1}}],[\"协议进行网络数据的读写操作\",{\"1\":{\"226\":1}}],[\"协议进行网络连接\",{\"1\":{\"226\":1}}],[\"高效执行\",{\"1\":{\"255\":1}}],[\"高效的数据传输\",{\"1\":{\"226\":1}}],[\"高性能的网络服务器\",{\"1\":{\"225\":1,\"229\":1}}],[\"特别是在面对大量连接的场景下\",{\"1\":{\"225\":1}}],[\"非法\",{\"1\":{\"257\":2}}],[\"非空性\",{\"1\":{\"252\":1}}],[\"非阻塞\",{\"1\":{\"234\":1}}],[\"非阻塞模式\",{\"1\":{\"225\":1,\"226\":1,\"232\":2,\"233\":1}}],[\"非同步\",{\"1\":{\"225\":1}}],[\"非常容易的打包和部署\",{\"1\":{\"119\":1}}],[\"选择器selecotor组件\",{\"1\":{\"230\":1}}],[\"选择器是\",{\"1\":{\"225\":1}}],[\"选择器\",{\"1\":{\"225\":1}}],[\"像web服务器那样\",{\"1\":{\"225\":1}}],[\"版本中引入的新的\",{\"1\":{\"225\":1}}],[\"获得当前目录中的文件列表\",{\"1\":{\"223\":1}}],[\"获取文件对应的\",{\"1\":{\"227\":1}}],[\"获取当前文件的路径名\",{\"1\":{\"223\":1}}],[\"获取位值\",{\"1\":{\"215\":2}}],[\"获取指定位置的元素\",{\"1\":{\"193\":1}}],[\"获取下一个元素并返回\",{\"1\":{\"186\":1}}],[\"获取键对应的值\",{\"1\":{\"176\":1}}],[\"获取键值对数量\",{\"1\":{\"176\":1}}],[\"获取\",{\"1\":{\"175\":1,\"176\":2}}],[\"获取集合的大小\",{\"1\":{\"175\":1}}],[\"获取集合大小等\",{\"1\":{\"175\":1}}],[\"获取列表的大小\",{\"1\":{\"174\":1}}],[\"获取元素\",{\"0\":{\"200\":1},\"1\":{\"174\":1}}],[\"获取和操作列表中的元素\",{\"1\":{\"174\":1}}],[\"获取通过热加载的方式重新加载配置文件\",{\"1\":{\"163\":1}}],[\"获取最近五分钟的样本\",{\"1\":{\"148\":1}}],[\"获取请求次数最多的5个请求\",{\"1\":{\"146\":1}}],[\"获取昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"139\":1}}],[\"获取了prometheus\",{\"1\":{\"137\":1}}],[\"判断指定文件是否存在\",{\"1\":{\"223\":1}}],[\"判断元素是否存在\",{\"1\":{\"175\":1}}],[\"何时使用转换流\",{\"1\":{\"223\":1}}],[\"到writer转换的桥梁\",{\"1\":{\"223\":1}}],[\"极其类似\",{\"1\":{\"223\":1}}],[\"转换流的特点\",{\"1\":{\"223\":1}}],[\"转换等计算\",{\"1\":{\"136\":1}}],[\"转变为reader\",{\"1\":{\"223\":1}}],[\"库中用于写入字符数据的抽象类\",{\"1\":{\"223\":1}}],[\"库中用于写入字节数据的抽象类\",{\"1\":{\"223\":1}}],[\"库中用于读取字符数据的抽象类\",{\"1\":{\"223\":1}}],[\"模型的开发方式\",{\"1\":{\"225\":1}}],[\"模式\",{\"1\":{\"223\":1}}],[\"模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤\",{\"1\":{\"68\":1}}],[\"模板模式\",{\"1\":{\"68\":1}}],[\"纯洁的decorator\",{\"1\":{\"223\":1}}],[\"纯洁\",{\"1\":{\"223\":1}}],[\"却让其更\",{\"1\":{\"223\":1}}],[\"部分\",{\"1\":{\"223\":1}}],[\"已经重写了\",{\"1\":{\"252\":1}}],[\"已经被废弃了\",{\"1\":{\"223\":1}}],[\"已经被deprecated\",{\"1\":{\"223\":1}}],[\"已解决\",{\"1\":{\"163\":1}}],[\"几乎实现相近的功能\",{\"1\":{\"223\":1}}],[\"几分钟\",{\"1\":{\"163\":1}}],[\"词法分析部分\",{\"1\":{\"223\":1}}],[\"好像更不入流了\",{\"1\":{\"223\":1}}],[\"看起来也是可以的\",{\"1\":{\"223\":1}}],[\"至于什么时候分行\",{\"1\":{\"223\":1}}],[\"紫色的虚线部分代表这些流一般要搭配使用\",{\"1\":{\"223\":1}}],[\"红色的部分就是不对应部分\",{\"1\":{\"223\":1}}],[\"等待事件就绪\",{\"1\":{\"236\":1}}],[\"等待1分钟\",{\"1\":{\"164\":1}}],[\"等\",{\"1\":{\"223\":2,\"229\":1,\"255\":1}}],[\"缓冲区buffer\",{\"1\":{\"230\":1}}],[\"缓冲区\",{\"1\":{\"225\":1}}],[\"缓冲输出流\",{\"1\":{\"223\":1}}],[\"缓冲输入流\",{\"1\":{\"223\":1}}],[\"缓冲流\",{\"1\":{\"221\":1}}],[\"被重写的方法具有以下的特点\",{\"1\":{\"240\":1}}],[\"被许多具体的子类继承和实现\",{\"1\":{\"223\":4}}],[\"被称为time\",{\"1\":{\"130\":1}}],[\"输入字节流inputstream\",{\"1\":{\"223\":1}}],[\"输出部分的bufferedoutputstream\",{\"1\":{\"223\":1}}],[\"输出字节流outputstream\",{\"1\":{\"223\":1}}],[\"输出\",{\"1\":{\"215\":2,\"246\":2}}],[\"输出如下\",{\"1\":{\"103\":1,\"110\":1,\"254\":1}}],[\"字段以及构造方法\",{\"1\":{\"241\":1}}],[\"字符型\",{\"1\":{\"251\":1}}],[\"字符串文件路径\",{\"1\":{\"223\":1}}],[\"字符数组\",{\"1\":{\"223\":1}}],[\"字符到字节的桥梁\",{\"1\":{\"223\":1}}],[\"字符输出流writer\",{\"1\":{\"223\":1}}],[\"字符输入流reader\",{\"1\":{\"223\":1}}],[\"字符缓冲流\",{\"1\":{\"221\":2}}],[\"字符流和字节流之间相互转换\",{\"1\":{\"223\":1}}],[\"字符流与字节流转换\",{\"1\":{\"223\":1}}],[\"字符流的输入与输出的对应\",{\"1\":{\"223\":1}}],[\"字符流的由来\",{\"1\":{\"221\":1}}],[\"字符流以字符为单位\",{\"1\":{\"221\":1}}],[\"字符流\",{\"1\":{\"221\":2}}],[\"字节到字符的桥梁\",{\"1\":{\"223\":1}}],[\"字节缓冲流\",{\"1\":{\"221\":2}}],[\"字节流的输入与输出的对应\",{\"1\":{\"223\":1}}],[\"字节流能处理所有类型的数据\",{\"1\":{\"221\":1}}],[\"字节流以字节\",{\"1\":{\"221\":1}}],[\"字节流和字符流的区别\",{\"1\":{\"221\":1}}],[\"字节流\",{\"1\":{\"221\":2}}],[\"字节\",{\"1\":{\"214\":1}}],[\"网络通信能力\",{\"1\":{\"232\":1}}],[\"网络通信的通道之一\",{\"1\":{\"232\":1}}],[\"网络通信和对象序列化等功能\",{\"1\":{\"220\":1}}],[\"网络传输等操作的类和接口\",{\"1\":{\"220\":1}}],[\"剔除重复数字后的元素个数\",{\"1\":{\"217\":1}}],[\"质数\",{\"1\":{\"217\":1}}],[\"随后演示了\",{\"1\":{\"228\":1}}],[\"随机数的范围在1到1亿之间\",{\"1\":{\"216\":1}}],[\"随着元素的不断添加\",{\"1\":{\"180\":1}}],[\"现在我们可以通过\",{\"1\":{\"246\":1}}],[\"现在要求写出一种算法\",{\"1\":{\"216\":1}}],[\"现在有1千万个随机数\",{\"1\":{\"216\":1}}],[\"现在使用责任链模式去模拟一个向公司借款的流程\",{\"1\":{\"92\":1}}],[\"操作的核心组件之一\",{\"1\":{\"226\":1}}],[\"操作的效率\",{\"1\":{\"225\":1,\"234\":1}}],[\"操作完成时同时执行其他任务\",{\"1\":{\"225\":1}}],[\"操作都是基于通道进行的\",{\"1\":{\"225\":1}}],[\"操作\",{\"1\":{\"215\":1,\"225\":2,\"226\":1,\"229\":3,\"234\":1}}],[\"操作符是比较两个变量的内存地址\",{\"1\":{\"252\":1}}],[\"操作符去判断引用类型的变量\",{\"1\":{\"251\":1}}],[\"操作符\",{\"0\":{\"140\":1},\"1\":{\"151\":1}}],[\"清除位\",{\"1\":{\"215\":2}}],[\"清空缓冲区\",{\"1\":{\"227\":1,\"228\":1}}],[\"清空\",{\"1\":{\"176\":1}}],[\"清空集合\",{\"1\":{\"175\":1}}],[\"清空列表\",{\"1\":{\"174\":1}}],[\"第2天是休息日\",{\"1\":{\"214\":1}}],[\"第二个构造函数可以穿入一个collection接口的实现类对象\",{\"1\":{\"189\":1}}],[\"位置表示下一个要读取或写入的元素索引\",{\"1\":{\"228\":1}}],[\"位置\",{\"1\":{\"228\":1}}],[\"位运算等操作\",{\"1\":{\"215\":1}}],[\"位运算操作\",{\"1\":{\"215\":1}}],[\"位长是一个byte整数的8倍\",{\"1\":{\"214\":1}}],[\"位\",{\"1\":{\"214\":3}}],[\"理论上\",{\"1\":{\"214\":1}}],[\"若数字是\",{\"1\":{\"214\":1}}],[\"若为\",{\"1\":{\"199\":1}}],[\"休息日记为0\",{\"1\":{\"214\":1}}],[\"股票的的交易日记为1\",{\"1\":{\"214\":1}}],[\"唯一性的集合实现\",{\"1\":{\"211\":1}}],[\"既保存了数组查询和修改元素效率快的优点\",{\"1\":{\"204\":1}}],[\"底层数据结构\",{\"0\":{\"204\":1}}],[\"建议使用stringbuffer来保证线程安全\",{\"1\":{\"243\":1}}],[\"建议使用stringbuffer或stringbuilder\",{\"1\":{\"243\":1}}],[\"建议使用concurrenthashmap\",{\"1\":{\"201\":1}}],[\"建一个first\",{\"1\":{\"164\":1}}],[\"节点是否为红黑树节点\",{\"1\":{\"200\":1}}],[\"节点是否与传入的键匹配\",{\"1\":{\"200\":1}}],[\"节点与传入的键不匹配\",{\"1\":{\"200\":1}}],[\"节点\",{\"1\":{\"200\":1}}],[\"节点不为空\",{\"1\":{\"200\":1}}],[\"节点的数据为指定的元素\",{\"1\":{\"190\":1}}],[\"变量直接存储的是\",{\"1\":{\"251\":1}}],[\"变量都包含了\",{\"1\":{\"213\":1}}],[\"变量\",{\"1\":{\"200\":2}}],[\"`value`\",{\"1\":{\"198\":1}}],[\"处理写事件\",{\"1\":{\"234\":1,\"236\":1}}],[\"处理读事件\",{\"1\":{\"234\":1,\"236\":1}}],[\"处理接受连接事件\",{\"1\":{\"234\":1}}],[\"处理具体的\",{\"1\":{\"234\":1}}],[\"处理事件\",{\"1\":{\"234\":1}}],[\"处理就绪事件\",{\"1\":{\"229\":1}}],[\"处理二进制数据\",{\"1\":{\"223\":2}}],[\"处理对象不同\",{\"1\":{\"221\":1}}],[\"处理类的实现类handlera\",{\"1\":{\"91\":1}}],[\"处理类handler\",{\"1\":{\"91\":1}}],[\"处\",{\"1\":{\"199\":1}}],[\"处有键值对\",{\"1\":{\"198\":1,\"200\":1}}],[\"索引位置没有键值对\",{\"1\":{\"198\":1}}],[\"存在及合理\",{\"1\":{\"223\":1}}],[\"存入map中\",{\"1\":{\"198\":1}}],[\"存储元素过程\",{\"0\":{\"198\":1}}],[\"存储arraylist元素的数组缓冲区\",{\"1\":{\"180\":1}}],[\"存储采集到的数据\",{\"1\":{\"157\":1}}],[\"存储了node\",{\"1\":{\"128\":1}}],[\"把元素存储在hashmap对象中\",{\"1\":{\"198\":1}}],[\"负载因子为0\",{\"1\":{\"197\":1}}],[\"负责创建一族相关的具体产品对象\",{\"1\":{\"102\":1}}],[\"负责创建实例对象的类\",{\"1\":{\"96\":1}}],[\"然而内部类的某个方法还没有执行完\",{\"1\":{\"258\":1}}],[\"然而\",{\"1\":{\"193\":1}}],[\"然后执行相应的catch块\",{\"1\":{\"260\":2}}],[\"然后将这些哈希码组合在一起\",{\"1\":{\"253\":1}}],[\"然后将apistatinterceptor注册到webmvcconfigurer中\",{\"1\":{\"154\":1}}],[\"然后地址不相等\",{\"1\":{\"252\":1}}],[\"然后赋值给j\",{\"1\":{\"245\":1}}],[\"然后进入一个无限循环\",{\"1\":{\"236\":1,\"237\":1}}],[\"然后创建一个\",{\"1\":{\"227\":1,\"237\":1}}],[\"然后创建一个handlerinterceptoradapter的拦截器\",{\"1\":{\"154\":1}}],[\"然后使用put\",{\"1\":{\"198\":1}}],[\"然后使用装饰器模式\",{\"1\":{\"87\":1}}],[\"然后获取节点\",{\"1\":{\"192\":1}}],[\"然后调用\",{\"1\":{\"191\":1,\"192\":1}}],[\"然后再次调用\",{\"1\":{\"186\":1}}],[\"然后根据哈希值计算出索引位置\",{\"1\":{\"200\":1}}],[\"然后根据\",{\"1\":{\"186\":1}}],[\"然后遍历这些\",{\"1\":{\"229\":1}}],[\"然后遍历\",{\"1\":{\"184\":1}}],[\"然后用案例讲解了这些类的使用\",{\"1\":{\"177\":1}}],[\"然后用\",{\"1\":{\"164\":1}}],[\"然后通过\",{\"1\":{\"228\":1,\"236\":2}}],[\"然后通过命令行的方式的启动它\",{\"1\":{\"161\":1}}],[\"然后通过配置文件的形式来具体讲解\",{\"1\":{\"158\":1}}],[\"然后\",{\"1\":{\"153\":1,\"154\":1,\"228\":1,\"260\":1}}],[\"然后在浏览器上访问http\",{\"1\":{\"154\":1}}],[\"然后在springboot的配置文件application\",{\"1\":{\"153\":1}}],[\"然后在grafana展示node\",{\"1\":{\"122\":1}}],[\"然后去grafana官方网站的dashboard社区找一个node\",{\"1\":{\"127\":1}}],[\"然后getinstance\",{\"1\":{\"74\":1}}],[\"置为\",{\"1\":{\"192\":1}}],[\"否则编译器会报错\",{\"1\":{\"254\":1}}],[\"否则称为合数\",{\"1\":{\"217\":1}}],[\"否则返回\",{\"1\":{\"200\":1,\"209\":1,\"210\":1}}],[\"否则使用循环遍历链表中的其他节点进行查找\",{\"1\":{\"200\":1}}],[\"否则\",{\"1\":{\"192\":2}}],[\"否则将匹配不到\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"找到对应的节点并返回\",{\"1\":{\"191\":2}}],[\"找到第一个相等的元素\",{\"1\":{\"185\":1}}],[\"找到第一个值为\",{\"1\":{\"185\":1}}],[\"异常处理逻辑\",{\"1\":{\"259\":1}}],[\"异常处理语句\",{\"1\":{\"254\":1}}],[\"异常将被抛出\",{\"1\":{\"254\":1}}],[\"异常类层次结构\",{\"1\":{\"254\":1}}],[\"异常\",{\"1\":{\"191\":1,\"192\":1}}],[\"说明索引位于链表的后半段\",{\"1\":{\"191\":1}}],[\"说明索引位于链表的前半段\",{\"1\":{\"191\":1}}],[\"说明链表为空链表\",{\"1\":{\"190\":1}}],[\"说的简单一点就是多写\",{\"1\":{\"64\":1}}],[\"前向节点为链表的当前尾节点\",{\"1\":{\"190\":1}}],[\"前提条件是两个告警的alertname\",{\"1\":{\"163\":1}}],[\"没有实例变量和构造方法\",{\"1\":{\"241\":1}}],[\"没有方法体\",{\"1\":{\"241\":2}}],[\"没有重写了eat方法\",{\"1\":{\"240\":1}}],[\"没有任何的代码\",{\"1\":{\"189\":1}}],[\"没有必要将多个事情给一个角色做完\",{\"1\":{\"83\":1}}],[\"头结点和尾节点\",{\"1\":{\"188\":1}}],[\"三个实例变量\",{\"1\":{\"188\":2}}],[\"链表转treenode\",{\"1\":{\"198\":2}}],[\"链表中的每个节点\",{\"1\":{\"188\":1}}],[\"链接\",{\"1\":{\"7\":1,\"19\":1}}],[\"利用\",{\"1\":{\"186\":1}}],[\"属性\",{\"1\":{\"199\":1,\"244\":1}}],[\"属性表示预期的修改次数\",{\"1\":{\"186\":1}}],[\"属性表示上一个元素的索引\",{\"1\":{\"186\":1}}],[\"属性表示下一个元素的索引\",{\"1\":{\"186\":1}}],[\"属于方法的重载\",{\"1\":{\"240\":1}}],[\"属于创建型设计模式的一种\",{\"1\":{\"95\":1}}],[\"属于懒汉模式\",{\"1\":{\"76\":1}}],[\"迭代器在每次访问元素之前会检查\",{\"1\":{\"186\":1}}],[\"迭代器源码解析\",{\"0\":{\"186\":1}}],[\"迭代器模式\",{\"1\":{\"68\":1}}],[\"赋值为newsize\",{\"1\":{\"184\":1}}],[\"正确地重写hashcode\",{\"1\":{\"253\":1}}],[\"正是由于重载和重写\",{\"1\":{\"240\":1}}],[\"正常情况下新的数组大小是旧数组的1\",{\"1\":{\"183\":1}}],[\"正如mac电脑一样\",{\"1\":{\"83\":1}}],[\"个字节\",{\"1\":{\"214\":1}}],[\"个字节就可以了\",{\"1\":{\"214\":1}}],[\"个数字\",{\"1\":{\"214\":2}}],[\"个位\",{\"1\":{\"213\":1,\"215\":1}}],[\"个\",{\"1\":{\"183\":1,\"214\":1}}],[\"空数组\",{\"1\":{\"183\":1}}],[\"扩大一倍\",{\"1\":{\"199\":1}}],[\"扩容是在grow\",{\"1\":{\"183\":1}}],[\"扩容\",{\"0\":{\"183\":1,\"199\":1}}],[\"扩展\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"17\":1}}],[\"描述了一个类应该具备的行为\",{\"1\":{\"241\":1}}],[\"描述\",{\"1\":{\"182\":1}}],[\"带参构造函数接收初始容量\",{\"1\":{\"197\":1}}],[\"带有collection参数的构造函数\",{\"1\":{\"181\":1}}],[\"带初始化容量大小参数\",{\"1\":{\"181\":1}}],[\"注册到\",{\"1\":{\"234\":2}}],[\"注册到一个\",{\"1\":{\"234\":1}}],[\"注册通道\",{\"1\":{\"229\":1}}],[\"注意几点\",{\"1\":{\"241\":1}}],[\"注意\",{\"1\":{\"180\":1,\"223\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"42\":1}}],[\"任何\",{\"1\":{\"180\":1}}],[\"任务列表\",{\"0\":{\"26\":1}}],[\"适用于需要同时处理多个\",{\"1\":{\"234\":1}}],[\"适用于需要使用非阻塞\",{\"1\":{\"232\":1,\"233\":1}}],[\"适用于对随机访问的需求较多\",{\"1\":{\"180\":1}}],[\"适配者类无论出现什么新功能\",{\"1\":{\"83\":1}}],[\"适配器只有同时实现或者持有目标接口和被适配的对象\",{\"1\":{\"82\":1}}],[\"适配器类只要不影响目标类的接口功能\",{\"1\":{\"83\":1}}],[\"适配器类adapter\",{\"1\":{\"81\":1}}],[\"适配器类即将要进行适配的抽象类或接口\",{\"1\":{\"81\":1}}],[\"适配器可以让不兼容的两个类一起协同工作\",{\"1\":{\"81\":1}}],[\"适配器模式的定义是\",{\"1\":{\"81\":1}}],[\"适配器模式就是将旧代码和新程序的中间的转换角色\",{\"1\":{\"81\":1}}],[\"适配器模式\",{\"0\":{\"81\":1},\"1\":{\"67\":1,\"69\":1}}],[\"读取数据\",{\"1\":{\"232\":1,\"233\":1}}],[\"读取prometheus的指标时序\",{\"1\":{\"128\":1}}],[\"读写数据\",{\"1\":{\"232\":1,\"233\":1}}],[\"读写模式切换\",{\"1\":{\"228\":1}}],[\"读写单位不同\",{\"1\":{\"221\":1}}],[\"读\",{\"1\":{\"179\":1,\"195\":1,\"203\":1,\"213\":1}}],[\"容量\",{\"1\":{\"228\":1}}],[\"容量大小动态可以变化\",{\"1\":{\"179\":1}}],[\"容器的size+1\",{\"1\":{\"182\":1}}],[\"容易陷入\",{\"1\":{\"148\":1}}],[\"序列化\",{\"1\":{\"179\":1,\"188\":1}}],[\"复制\",{\"1\":{\"179\":1}}],[\"常使用try\",{\"1\":{\"254\":1}}],[\"常量\",{\"1\":{\"241\":1}}],[\"常用的工具类\",{\"1\":{\"223\":1}}],[\"常用的\",{\"1\":{\"176\":1}}],[\"常见的buffer覆盖了能通过io发送的基本数据类型\",{\"1\":{\"225\":1}}],[\"常见的应用是那些需要对海量数据进行一些统计工作的时候\",{\"1\":{\"216\":1}}],[\"常见的映射实现类有\",{\"1\":{\"173\":1}}],[\"常见的队列实现类有\",{\"1\":{\"173\":1}}],[\"常见的集实现类有\",{\"1\":{\"173\":1}}],[\"常见的集合接口包括\",{\"1\":{\"173\":1}}],[\"常见的列表实现类有\",{\"1\":{\"173\":1}}],[\"常见的逻辑运算符如下\",{\"1\":{\"141\":1}}],[\"按键查找值等\",{\"1\":{\"176\":1}}],[\"键值对数量\",{\"1\":{\"176\":1}}],[\"键的唯一性\",{\"1\":{\"176\":1}}],[\"键是唯一的\",{\"1\":{\"176\":1}}],[\"检查\",{\"1\":{\"176\":1,\"186\":2,\"209\":1}}],[\"检查集合中是否包含某个元素\",{\"1\":{\"175\":1}}],[\"检查列表中是否包含某个元素\",{\"1\":{\"174\":1}}],[\"快速查找\",{\"1\":{\"175\":1,\"176\":1}}],[\"快速的装载和卸载装饰器\",{\"1\":{\"88\":1}}],[\"添加失败\",{\"1\":{\"208\":1}}],[\"添加和删除操作的时间复杂度为\",{\"1\":{\"204\":1}}],[\"添加键值对到\",{\"1\":{\"176\":1}}],[\"添加\",{\"1\":{\"175\":1}}],[\"添加操作会失败并返回\",{\"1\":{\"175\":1}}],[\"添加重复元素时\",{\"1\":{\"175\":1}}],[\"添加元素的源码如下\",{\"1\":{\"182\":1}}],[\"添加元素到集合中\",{\"1\":{\"175\":1}}],[\"添加元素到列表中\",{\"1\":{\"174\":1}}],[\"添加元素\",{\"0\":{\"182\":1,\"208\":1},\"1\":{\"174\":1,\"182\":1}}],[\"且具有相同的参数和返回结构类型\",{\"1\":{\"240\":1}}],[\"且发生了哈希冲突\",{\"1\":{\"198\":1,\"200\":1}}],[\"且\",{\"1\":{\"196\":1}}],[\"且不允许包含重复的元素\",{\"1\":{\"175\":1}}],[\"且只支持浮点数指标\",{\"1\":{\"130\":1}}],[\"循环或\",{\"1\":{\"174\":1}}],[\"增强的\",{\"1\":{\"174\":1}}],[\"增加了语言的复杂性和理解上的困惑\",{\"1\":{\"242\":1}}],[\"增加了写入字符的效率\",{\"1\":{\"223\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"100\":1}}],[\"增加告警规则的配置\",{\"1\":{\"164\":1}}],[\"增加采集node\",{\"1\":{\"125\":1}}],[\"增加项目的依赖\",{\"1\":{\"113\":1}}],[\"增加新的观察者\",{\"1\":{\"107\":1}}],[\"增加新的产品和新的工厂非常容易\",{\"1\":{\"100\":1}}],[\"增加系统的复杂性\",{\"1\":{\"103\":1}}],[\"遍历位集合\",{\"1\":{\"215\":1}}],[\"遍历链表或红黑树的过程中\",{\"1\":{\"198\":1,\"200\":1}}],[\"遍历链表\",{\"1\":{\"198\":1}}],[\"遍历和删元素对象\",{\"1\":{\"176\":1}}],[\"遍历和删除集合中的元素\",{\"1\":{\"175\":1}}],[\"遍历\",{\"1\":{\"176\":1,\"199\":1}}],[\"遍历集合中的元素\",{\"1\":{\"175\":1}}],[\"遍历列表中的元素\",{\"1\":{\"174\":1}}],[\"遍历列表\",{\"1\":{\"174\":1}}],[\"遍历等\",{\"1\":{\"173\":1}}],[\"排序\",{\"1\":{\"174\":1}}],[\"元素的顺序可以根据插入和删除操作的顺序动态改变\",{\"1\":{\"174\":1}}],[\"虽然可以自动扩容\",{\"1\":{\"217\":1}}],[\"虽然可能会造成一定资源开销和浪费\",{\"1\":{\"74\":1}}],[\"虽然它不是collection\",{\"1\":{\"173\":1}}],[\"散列\",{\"1\":{\"173\":1}}],[\"队列\",{\"1\":{\"173\":1}}],[\"集\",{\"1\":{\"173\":1}}],[\"集合框架中用于存储单列数据\",{\"1\":{\"203\":1}}],[\"集合框架中用于存储双列数据的散列表\",{\"1\":{\"195\":1}}],[\"集合框架中比较常用的用于存储单列数据的容器\",{\"1\":{\"179\":1}}],[\"集合接口\",{\"1\":{\"173\":1}}],[\"集合是\",{\"1\":{\"173\":1}}],[\"列表操作\",{\"1\":{\"174\":1}}],[\"列表\",{\"1\":{\"173\":1}}],[\"删除文件和目录等方法\",{\"1\":{\"223\":1}}],[\"删除指定位置的元素等等\",{\"1\":{\"193\":1}}],[\"删除某个键值对\",{\"1\":{\"176\":1}}],[\"删除键值对\",{\"1\":{\"176\":1}}],[\"删除列表中的元素\",{\"1\":{\"174\":1}}],[\"删除元素\",{\"0\":{\"184\":1,\"210\":1},\"1\":{\"174\":1,\"175\":1}}],[\"删除操作\",{\"1\":{\"173\":1}}],[\"删除\",{\"1\":{\"173\":1,\"174\":1,\"243\":1}}],[\"框架的类的思维导图如下\",{\"1\":{\"173\":1}}],[\"框架的根接口\",{\"1\":{\"173\":1}}],[\"框架的一些关键概念\",{\"1\":{\"173\":1}}],[\"编译的时候会报错\",{\"1\":{\"257\":1}}],[\"编译不通过\",{\"1\":{\"257\":1}}],[\"编译器又将i自动拆箱成int值\",{\"1\":{\"245\":1}}],[\"编译器会自动将10包装成一个integer对象\",{\"1\":{\"245\":1}}],[\"编译是通过方法的不同的参数来确定方法\",{\"1\":{\"240\":1}}],[\"编程语言用于处理输入和输出的标准库\",{\"1\":{\"220\":1}}],[\"编程语言中用于存储和操作对象的框架\",{\"1\":{\"173\":1}}],[\"编辑此页链接\",{\"1\":{\"7\":1}}],[\"表明该类不能被继承\",{\"1\":{\"257\":1}}],[\"表明hashset支持序列\",{\"1\":{\"203\":1,\"213\":1}}],[\"表明hashmap支持序列\",{\"1\":{\"195\":1}}],[\"表明hashmap支持克隆\",{\"1\":{\"195\":1,\"203\":1,\"213\":1}}],[\"表明arraylist支持序列\",{\"1\":{\"179\":1}}],[\"表明arraylist支持克隆\",{\"1\":{\"179\":1}}],[\"表明arraylist支持随机访问\",{\"1\":{\"179\":1}}],[\"表达式的含义是计算每分钟handler=\",{\"1\":{\"172\":1}}],[\"表示不可改变的\",{\"1\":{\"259\":1}}],[\"表示变量或者方法定义后不能被修改或者重写\",{\"1\":{\"257\":1}}],[\"表示文件或目录的抽象类\",{\"1\":{\"221\":1}}],[\"表示实际用于存储位信息的\",{\"1\":{\"215\":1}}],[\"表示删除成功\",{\"1\":{\"210\":1}}],[\"表示删除操作是否成功\",{\"1\":{\"210\":1}}],[\"表示已经存在相同的元素\",{\"1\":{\"208\":1}}],[\"表示添加操作是否成功\",{\"1\":{\"208\":1}}],[\"表示添加成功\",{\"1\":{\"208\":1}}],[\"表示添加元素是否成功\",{\"1\":{\"208\":1}}],[\"表示值的类型\",{\"1\":{\"196\":1}}],[\"表示键的类型\",{\"1\":{\"196\":1}}],[\"表示插入操作成功\",{\"1\":{\"190\":1}}],[\"表示\",{\"1\":{\"184\":1,\"209\":1,\"215\":1}}],[\"表示聚合的级别和规则标签的输出\",{\"1\":{\"171\":1}}],[\"表示小于0\",{\"1\":{\"134\":2}}],[\"表示的是当前系统文件系统中磁盘可用的字节数\",{\"1\":{\"133\":1}}],[\"该变量的值一旦被赋值\",{\"1\":{\"259\":1}}],[\"该变量的值不能被修改\",{\"1\":{\"257\":1}}],[\"该对象在实例化时\",{\"1\":{\"223\":1}}],[\"该对象既可以对文件进行读操作\",{\"1\":{\"223\":1}}],[\"该对象只能操作文件\",{\"1\":{\"223\":1}}],[\"该对象特点\",{\"1\":{\"223\":1}}],[\"该对象并不是流体系中的一员\",{\"1\":{\"223\":1}}],[\"该方法不能被子类重写\",{\"1\":{\"257\":1,\"259\":1}}],[\"该方法将返回\",{\"1\":{\"229\":1}}],[\"该方法将需要删除元素的位置\",{\"1\":{\"184\":1}}],[\"该方法用于判断\",{\"1\":{\"185\":1}}],[\"该方法用于删除指定的元素\",{\"1\":{\"184\":1}}],[\"该表达式的计算时间间隔为1分钟\",{\"1\":{\"172\":1}}],[\"该类不能被继承\",{\"1\":{\"259\":1}}],[\"该类使用抽象工厂模式创建不同的产品对象\",{\"1\":{\"103\":1}}],[\"该类的职责是唯一的\",{\"1\":{\"70\":1}}],[\"应始终返回相同的值\",{\"1\":{\"253\":1}}],[\"应返回false\",{\"1\":{\"252\":1}}],[\"应返回true\",{\"1\":{\"252\":1}}],[\"应该属于字符流的范围\",{\"1\":{\"223\":1}}],[\"应该遵循通用的方式\",{\"1\":{\"171\":1}}],[\"应用非常的广泛\",{\"1\":{\"195\":1}}],[\"应对面试应该是足够的\",{\"1\":{\"69\":1}}],[\"命名冲突\",{\"1\":{\"242\":1}}],[\"命名规范\",{\"0\":{\"171\":1}}],[\"命令模式\",{\"1\":{\"68\":1}}],[\"警报规则的名称必须是有效的标签值\",{\"1\":{\"169\":1}}],[\"警告容器\",{\"1\":{\"19\":1}}],[\"记录为\",{\"1\":{\"214\":2}}],[\"记录规则的名称必须是有效的指标名称\",{\"1\":{\"169\":1}}],[\"记录和告警规则存在于规则组中\",{\"1\":{\"169\":1}}],[\"预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多\",{\"1\":{\"168\":1}}],[\"预测指标变化趋势\",{\"0\":{\"149\":1}}],[\"预测系统磁盘在6个小时之后的剩余情况\",{\"1\":{\"133\":1}}],[\"qq\",{\"1\":{\"167\":1}}],[\"queue\",{\"1\":{\"173\":3}}],[\"querying\",{\"1\":{\"151\":1}}],[\"quantile函数进行计算\",{\"1\":{\"150\":1}}],[\"quantile函数在prometheus\",{\"1\":{\"135\":1}}],[\"quantile\",{\"1\":{\"134\":1,\"146\":2,\"150\":3,\"156\":1}}],[\"quantile=\",{\"1\":{\"124\":5,\"135\":5}}],[\"参数的顺序也可以不同\",{\"1\":{\"240\":1}}],[\"参数的个数也可以不同\",{\"1\":{\"240\":1}}],[\"参数的类型可以不同\",{\"1\":{\"240\":1}}],[\"参数的配置会在以后的文章中讲解\",{\"1\":{\"163\":1}}],[\"参考\",{\"0\":{\"218\":1}}],[\"参考文档\",{\"0\":{\"167\":1}}],[\"发送的告警消息的json格式如下\",{\"1\":{\"166\":1}}],[\"发布者对象可以对所有的观察者发送消息\",{\"1\":{\"107\":1}}],[\"发布者publisher\",{\"1\":{\"105\":1}}],[\"显示告警消息已经收到\",{\"1\":{\"165\":1}}],[\"允许单个线程同时监听多个通道的事件\",{\"1\":{\"229\":1}}],[\"允许单个线程处理多个通道\",{\"1\":{\"225\":1}}],[\"允许将读取的字节推回输入流中\",{\"1\":{\"223\":1}}],[\"允许包含重复的元素\",{\"1\":{\"174\":1}}],[\"允许元素的重复\",{\"1\":{\"174\":1}}],[\"允许重复元素\",{\"1\":{\"173\":1}}],[\"允许用户指定要附加到告警上的一组附加标签\",{\"1\":{\"164\":1}}],[\"允许prometheus运行\",{\"1\":{\"123\":1}}],[\"评估时间相同\",{\"1\":{\"169\":1}}],[\"评估等待时间\",{\"1\":{\"164\":1}}],[\"评论\",{\"1\":{\"7\":1,\"45\":1}}],[\"$value\",{\"1\":{\"164\":1}}],[\"禁止规则会静音与一组匹配器匹配的警报\",{\"1\":{\"163\":1}}],[\"禁用\",{\"2\":{\"9\":1}}],[\"禁用了如下功能\",{\"1\":{\"7\":1}}],[\"禁用展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"源码解析\",{\"0\":{\"206\":1}}],[\"源码如下\",{\"1\":{\"189\":1}}],[\"源码下载\",{\"0\":{\"80\":1,\"84\":1,\"89\":1}}],[\"源\",{\"1\":{\"163\":1}}],[\"即使在try块或catch块中出现return语句\",{\"1\":{\"259\":1}}],[\"即它成为一个常量\",{\"1\":{\"257\":1}}],[\"即它们是否指向同一个对象\",{\"1\":{\"251\":1}}],[\"即当一个类同时继承自两个具有共同父类的类时\",{\"1\":{\"242\":1}}],[\"即当前插入的节点即为头节点\",{\"1\":{\"190\":1}}],[\"即在没有数据可读或可写时并不会阻塞线程\",{\"1\":{\"226\":1}}],[\"即覆盖原有的内容\",{\"1\":{\"223\":1}}],[\"即把bit为true的元素复制到另一个数组\",{\"1\":{\"217\":1}}],[\"即总共能表示的位的数量\",{\"1\":{\"215\":1}}],[\"即表示\",{\"1\":{\"209\":1}}],[\"即是否存在指定的元素\",{\"1\":{\"209\":1}}],[\"即达到了负载因子阈值\",{\"1\":{\"198\":1}}],[\"即\",{\"1\":{\"192\":6}}],[\"即将\",{\"1\":{\"190\":1}}],[\"即判断\",{\"1\":{\"186\":2}}],[\"即常数时间\",{\"1\":{\"180\":1}}],[\"即alertmanager通过http接口调用来发送告警消息\",{\"1\":{\"163\":1}}],[\"即一个指标代表一种含义\",{\"1\":{\"130\":1}}],[\"邮箱等\",{\"1\":{\"163\":1}}],[\"微信\",{\"1\":{\"163\":1}}],[\"再次切换为读取模式\",{\"1\":{\"228\":1}}],[\"再次写入数据\",{\"1\":{\"228\":1}}],[\"再次发送通知前等待的时间\",{\"1\":{\"163\":1}}],[\"再通过\",{\"1\":{\"227\":1}}],[\"再比如下面的查询语句的可以输出结果\",{\"1\":{\"141\":1}}],[\"或表达式\",{\"1\":{\"258\":1}}],[\"或\",{\"1\":{\"246\":1}}],[\"或接受\",{\"1\":{\"229\":1}}],[\"或直接迭代bitset中bit为true的元素iterate\",{\"1\":{\"217\":1}}],[\"或等待同一组告警采集更多初始告警后一起发送\",{\"1\":{\"163\":1}}],[\"或者结合两者的特点使用混合编程\",{\"1\":{\"244\":1}}],[\"或者是参数的顺序不同\",{\"1\":{\"240\":1}}],[\"或者参数的类型不同\",{\"1\":{\"240\":1}}],[\"或者从通道写入到缓冲区\",{\"1\":{\"226\":1}}],[\"或者fileinputstream\",{\"1\":{\"223\":1}}],[\"或者红黑树\",{\"1\":{\"196\":1}}],[\"或者重启的进程的时候重置为0\",{\"1\":{\"131\":1}}],[\"或者静态的配置文件\",{\"1\":{\"120\":1}}],[\"或者被称为被观察者\",{\"1\":{\"105\":1}}],[\"或者访问资源配置文件的reader\",{\"1\":{\"72\":1}}],[\"默认被\",{\"1\":{\"241\":1}}],[\"默认方法\",{\"1\":{\"241\":2}}],[\"默认为64\",{\"1\":{\"196\":1,\"198\":1,\"217\":1}}],[\"默认为8\",{\"1\":{\"196\":1,\"198\":1}}],[\"默认会初始化容量大小为defaultcapacity\",{\"1\":{\"181\":1}}],[\"默认alertname\",{\"1\":{\"163\":1}}],[\"默认的配置文件如下\",{\"1\":{\"162\":1}}],[\"合理设置抑制规则可以减少垃圾告警的产生\",{\"1\":{\"162\":1}}],[\"接受连接等事件\",{\"1\":{\"234\":1}}],[\"接受连接\",{\"1\":{\"233\":3}}],[\"接着通过\",{\"1\":{\"237\":1}}],[\"接着\",{\"1\":{\"228\":1}}],[\"接着将节点\",{\"1\":{\"192\":1}}],[\"接收人一般配合告警路由使用\",{\"1\":{\"162\":1}}],[\"接收人是一个抽象的概念\",{\"1\":{\"162\":1}}],[\"接收人\",{\"1\":{\"162\":1}}],[\"接口只提供方法的声明\",{\"1\":{\"241\":1}}],[\"接口也可以包含默认方法和静态方法\",{\"1\":{\"241\":1}}],[\"接口还为多重继承提供了解决方案\",{\"1\":{\"241\":1}}],[\"接口中的常量默认是静态常量\",{\"1\":{\"241\":1}}],[\"接口中的元素按照插入的顺序存储\",{\"1\":{\"174\":1}}],[\"接口animal\",{\"1\":{\"241\":1}}],[\"接口定义中可以包含常量\",{\"1\":{\"241\":1}}],[\"接口定义了常用的操作方法\",{\"1\":{\"176\":1}}],[\"接口定义了很多常用的方法\",{\"1\":{\"174\":1}}],[\"接口可以被类实现\",{\"1\":{\"241\":1}}],[\"接口使用interface关键字定义的\",{\"1\":{\"241\":1}}],[\"接口继承自\",{\"1\":{\"175\":1}}],[\"接口是集合框架中用于存储键值对\",{\"1\":{\"176\":1}}],[\"接口是\",{\"1\":{\"174\":1,\"175\":1}}],[\"接口\",{\"0\":{\"174\":1},\"1\":{\"161\":1,\"174\":1,\"175\":2,\"179\":2,\"186\":1,\"188\":1,\"241\":7}}],[\"接口的设计可以更好地支持代码的组织和抽象\",{\"1\":{\"242\":1}}],[\"接口的优点在于它提供了一种灵活的方式来定义类之间的契约和行为\",{\"1\":{\"241\":1}}],[\"接口的默认方法可以被实现该接口的类直接使用\",{\"1\":{\"241\":1}}],[\"接口的实现类有\",{\"1\":{\"176\":1}}],[\"接口的主要特点如下\",{\"1\":{\"176\":1}}],[\"接口的主要特点包括\",{\"1\":{\"174\":1,\"175\":1}}],[\"接口的子接口之一\",{\"1\":{\"175\":1}}],[\"接口的继承接口之一\",{\"1\":{\"174\":1}}],[\"接口的p90耗时\",{\"1\":{\"150\":1}}],[\"接口的数据\",{\"1\":{\"137\":1}}],[\"接口如戏\",{\"1\":{\"126\":1}}],[\"接口互相隔离\",{\"1\":{\"70\":1}}],[\"接口隔离原则\",{\"1\":{\"70\":1}}],[\"全局配置\",{\"1\":{\"162\":1}}],[\"抑制允许根据另一组警报的存在来静音一组警报\",{\"1\":{\"163\":1}}],[\"抑制规则\",{\"1\":{\"162\":1}}],[\"抑制是当某一告警已经发出\",{\"1\":{\"160\":1}}],[\"抑制\",{\"0\":{\"160\":1}}],[\"抑制和静默等核心功能\",{\"1\":{\"157\":1,\"158\":1}}],[\"则在变量初始化后\",{\"1\":{\"257\":1}}],[\"则需要特殊处理\",{\"1\":{\"253\":1}}],[\"则需要将旧的键值对重新分布到新的\",{\"1\":{\"199\":1}}],[\"则x\",{\"1\":{\"252\":2}}],[\"则y\",{\"1\":{\"252\":1}}],[\"则比较字符串内容是否相等\",{\"1\":{\"252\":1}}],[\"则比较的内容是判断两个变量的引用是否相等\",{\"1\":{\"251\":1}}],[\"则字符串内容肯定是相等\",{\"1\":{\"252\":1}}],[\"则指向一个新创建的字符串对象\",{\"1\":{\"251\":1}}],[\"则调用红黑树节点的\",{\"1\":{\"200\":1}}],[\"则判断\",{\"1\":{\"200\":1}}],[\"则首先检查\",{\"1\":{\"200\":1}}],[\"则按链表或红黑树的规则进行处理\",{\"1\":{\"199\":1}}],[\"则表示删除操作成功\",{\"1\":{\"210\":1}}],[\"则表示\",{\"1\":{\"199\":1}}],[\"则更新其对应的值为新的\",{\"1\":{\"198\":2}}],[\"则直接将键值对存储在该位置\",{\"1\":{\"198\":1}}],[\"则部分链表节点会转换为红黑树\",{\"1\":{\"196\":1}}],[\"则将链表转换为红黑树\",{\"1\":{\"198\":1}}],[\"则将新的键值对插入到链表或红黑树的头部\",{\"1\":{\"198\":1}}],[\"则将尾节点指向\",{\"1\":{\"192\":1}}],[\"则将头节点指向\",{\"1\":{\"192\":1}}],[\"则抛出\",{\"1\":{\"191\":1,\"192\":1}}],[\"则返回被删除的值\",{\"1\":{\"210\":1}}],[\"则返回对应的节点\",{\"1\":{\"200\":1}}],[\"则返回对应的值\",{\"1\":{\"200\":1}}],[\"则返回\",{\"1\":{\"185\":1,\"200\":2,\"209\":1}}],[\"则返回singleton\",{\"1\":{\"75\":1}}],[\"则遍历该位置上的链表或红黑树进行查找操作\",{\"1\":{\"200\":1}}],[\"则遍历该位置上的链表或红黑树进行操作\",{\"1\":{\"198\":1}}],[\"则遍历\",{\"1\":{\"185\":2}}],[\"则报indexoutofboundsexception异常\",{\"1\":{\"185\":1}}],[\"则进行初始化\",{\"1\":{\"183\":1}}],[\"则对空数组进行初始化\",{\"1\":{\"183\":1}}],[\"则扩容\",{\"1\":{\"182\":1}}],[\"则默认是global\",{\"1\":{\"169\":1}}],[\"则会覆盖之前try或者catch里面的return操作\",{\"1\":{\"260\":2}}],[\"则会覆盖try里面的return操作\",{\"1\":{\"260\":1}}],[\"则会进行缩容操作\",{\"1\":{\"180\":1}}],[\"则会创建一个新的更大容量的数组\",{\"1\":{\"180\":1}}],[\"则会把标签添加到新的序列中\",{\"1\":{\"169\":1}}],[\"则会出现几百上千的告警消息\",{\"1\":{\"159\":1}}],[\"则向alertmanager发送告警消息\",{\"1\":{\"157\":1}}],[\"起到了时序数据库的作用\",{\"1\":{\"157\":1}}],[\"路由\",{\"1\":{\"158\":1}}],[\"路由分发\",{\"1\":{\"157\":1}}],[\"路径导航\",{\"1\":{\"7\":1,\"45\":1}}],[\"完全可以从io\",{\"1\":{\"223\":1}}],[\"完全匹配\",{\"1\":{\"141\":1}}],[\"完成键值对的重新分布后\",{\"1\":{\"199\":1}}],[\"完整的代码如下\",{\"1\":{\"154\":1}}],[\"统计请求的次数和请求耗时\",{\"1\":{\"154\":1}}],[\"统一全局的访问点控制\",{\"1\":{\"72\":1}}],[\"另一种是使用prometheus的java客户端\",{\"1\":{\"152\":1}}],[\"另外在新生成的指标上添加一个新的标签region\",{\"1\":{\"172\":1}}],[\"另外如果没有配置groups的interval配置\",{\"1\":{\"169\":1}}],[\"另外一种是预计算规则recording\",{\"1\":{\"168\":1}}],[\"另外也可以筛选出handler\",{\"1\":{\"137\":1}}],[\"另外\",{\"1\":{\"134\":1}}],[\"详细内容可以查看官方网站\",{\"1\":{\"151\":1}}],[\"详情\",{\"0\":{\"58\":1,\"62\":1}}],[\"详情容器\",{\"1\":{\"19\":1}}],[\"来处理\",{\"1\":{\"254\":1}}],[\"来进行比较时\",{\"1\":{\"251\":1}}],[\"来解决多继承的需要\",{\"1\":{\"242\":1}}],[\"来解析\",{\"1\":{\"16\":1}}],[\"来声明\",{\"1\":{\"241\":1}}],[\"来确保连接已经建立\",{\"1\":{\"237\":1}}],[\"来监听多个\",{\"1\":{\"236\":1}}],[\"来支持高效的\",{\"1\":{\"225\":1}}],[\"来记录\",{\"1\":{\"214\":1}}],[\"来存储元素\",{\"1\":{\"211\":1}}],[\"来实现接口\",{\"1\":{\"241\":1}}],[\"来实现快速失败机制\",{\"1\":{\"186\":1}}],[\"来实现的\",{\"1\":{\"186\":1}}],[\"来预测主机可用磁盘空间的是否在24个小时候被占满\",{\"1\":{\"149\":1}}],[\"长度为\",{\"1\":{\"199\":1}}],[\"长尾问题\",{\"1\":{\"148\":2}}],[\"长期趋势分析\",{\"1\":{\"121\":1}}],[\"≤\",{\"1\":{\"146\":2}}],[\"φ\",{\"1\":{\"146\":2,\"150\":1}}],[\"得到的结果是\",{\"1\":{\"145\":2}}],[\"举例子讲解\",{\"1\":{\"145\":1}}],[\"举个简单的例子\",{\"1\":{\"240\":1}}],[\"举个简单的例子来说明吧\",{\"1\":{\"214\":1}}],[\"举个简单的示例\",{\"1\":{\"175\":1}}],[\"举个例子演示如何使用\",{\"1\":{\"174\":1,\"176\":1}}],[\"举个例子\",{\"1\":{\"130\":1,\"251\":1,\"254\":1}}],[\"举个现实例子\",{\"1\":{\"81\":1}}],[\"忽略\",{\"1\":{\"144\":1}}],[\"匹配\",{\"1\":{\"144\":1}}],[\"求素数\",{\"1\":{\"217\":1}}],[\"求一个字符串包含的char\",{\"1\":{\"217\":1}}],[\"求并集\",{\"1\":{\"143\":1}}],[\"求交集\",{\"1\":{\"143\":1}}],[\"逻辑运算符作用于两个瞬时向量之间\",{\"1\":{\"143\":1}}],[\"逻辑运算符\",{\"0\":{\"143\":1}}],[\"右侧的表达式也有一个handler=\",{\"1\":{\"141\":1}}],[\"左侧的标签条目和右侧的标签条目必须要相同\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"幂运算\",{\"1\":{\"141\":1}}],[\"^\",{\"1\":{\"141\":1,\"198\":1}}],[\"取消注册或更新事件\",{\"1\":{\"229\":1}}],[\"取模\",{\"1\":{\"141\":1}}],[\"取反操作\",{\"1\":{\"137\":1}}],[\"乘\",{\"1\":{\"141\":1}}],[\"减小链表的大小\",{\"1\":{\"192\":1}}],[\"减少内存占用\",{\"1\":{\"180\":1}}],[\"减少同步创建实例的开销\",{\"1\":{\"75\":1}}],[\"减\",{\"1\":{\"141\":1}}],[\"数据的读写以及关闭操作\",{\"1\":{\"233\":1}}],[\"数据的读写以及连接的关闭操作\",{\"1\":{\"232\":1}}],[\"数据可视化\",{\"1\":{\"121\":1}}],[\"数组来记录数据\",{\"1\":{\"214\":1}}],[\"数组赋值给\",{\"1\":{\"199\":1,\"200\":1}}],[\"数组对应的位置\",{\"1\":{\"199\":1}}],[\"数组中查找并返回对应的节点\",{\"1\":{\"200\":1}}],[\"数组中找到对应的索引位置\",{\"1\":{\"200\":1}}],[\"数组中重新计算\",{\"1\":{\"199\":1}}],[\"数组中\",{\"1\":{\"199\":1}}],[\"数组中的索引位置\",{\"1\":{\"198\":1}}],[\"数组进行存储\",{\"1\":{\"199\":1}}],[\"数组长度\",{\"1\":{\"199\":1}}],[\"数组的大小\",{\"1\":{\"215\":1}}],[\"数组的引用赋值给一个临时变量\",{\"1\":{\"199\":1}}],[\"数组的长度大于阈值\",{\"1\":{\"198\":1}}],[\"数组的长度\",{\"1\":{\"198\":2}}],[\"数组是否为\",{\"1\":{\"199\":1}}],[\"数组\",{\"1\":{\"183\":1,\"199\":3,\"223\":4}}],[\"数学操作符\",{\"0\":{\"141\":1}}],[\"怎么查询呢\",{\"1\":{\"139\":1}}],[\"天\",{\"1\":{\"138\":1,\"214\":1}}],[\"小于链表大小的一半\",{\"1\":{\"191\":1}}],[\"小时\",{\"1\":{\"138\":1}}],[\"小结\",{\"1\":{\"137\":1}}],[\"秒\",{\"1\":{\"138\":1}}],[\"外\",{\"1\":{\"138\":1}}],[\"外观模式\",{\"1\":{\"67\":1}}],[\"范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围\",{\"1\":{\"138\":1}}],[\"范围向量查询\",{\"0\":{\"138\":1}}],[\"|=\",{\"1\":{\"217\":1}}],[\"||\",{\"1\":{\"183\":1,\"197\":1,\"198\":2,\"199\":1,\"200\":2}}],[\"|2\",{\"1\":{\"171\":3}}],[\"|value2\",{\"1\":{\"137\":1}}],[\"|\",{\"1\":{\"137\":1,\"169\":1,\"188\":24,\"215\":36,\"237\":1,\"254\":5}}],[\"~3h\",{\"1\":{\"163\":1}}],[\"~5m\",{\"1\":{\"163\":1}}],[\"~0s\",{\"1\":{\"163\":1}}],[\"~\",{\"1\":{\"137\":3,\"163\":1,\"251\":1}}],[\"查找指定位置元素的时间复杂度为o\",{\"1\":{\"185\":1}}],[\"查找元素\",{\"0\":{\"185\":1,\"209\":1}}],[\"查找匹配的元素\",{\"1\":{\"184\":1}}],[\"查询的是昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"139\":1}}],[\"查询的是当前时间的过去五分钟的数据\",{\"1\":{\"139\":1}}],[\"查询五分钟前的最新值\",{\"1\":{\"139\":1}}],[\"查询当前时间的最新值\",{\"1\":{\"139\":1}}],[\"查询语句为\",{\"1\":{\"137\":1}}],[\"查看详情\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"瞬时向量查询和范围向量查询的表达式中\",{\"1\":{\"139\":1}}],[\"瞬时向量查询\",{\"0\":{\"137\":1}}],[\"计算出新数组的长度\",{\"1\":{\"199\":1}}],[\"计算出键值对在\",{\"1\":{\"198\":1}}],[\"计算hash的源码如下\",{\"1\":{\"198\":1}}],[\"计算handler=\",{\"1\":{\"150\":1}}],[\"计算p99耗时的表达式如下\",{\"1\":{\"150\":1}}],[\"计算分位数\",{\"0\":{\"150\":1}}],[\"计算counter的增长率\",{\"0\":{\"148\":1}}],[\"计算的结果会产生一条新的时间序列\",{\"1\":{\"136\":1}}],[\"计划\",{\"1\":{\"26\":2}}],[\"聚合完后的结果会生成根据聚合标签生成一个新的序列\",{\"1\":{\"146\":1}}],[\"聚合函数\",{\"0\":{\"146\":1}}],[\"聚合\",{\"1\":{\"136\":1}}],[\"过滤\",{\"1\":{\"136\":1}}],[\"过多的观察者会影响性能\",{\"1\":{\"107\":1}}],[\"函数中进行\",{\"1\":{\"183\":1}}],[\"函数\",{\"1\":{\"151\":1,\"238\":2}}],[\"函数格式为\",{\"1\":{\"150\":1}}],[\"函数的格式如下\",{\"1\":{\"149\":1}}],[\"函数的内容\",{\"1\":{\"132\":1}}],[\"函数计算出其值的分位数\",{\"1\":{\"134\":1}}],[\"6400\",{\"1\":{\"217\":1}}],[\"64\",{\"1\":{\"213\":1,\"214\":1,\"215\":1}}],[\"600\",{\"1\":{\"145\":4}}],[\"60\",{\"1\":{\"134\":1,\"148\":1,\"150\":1}}],[\"6\",{\"1\":{\"133\":1,\"135\":1,\"145\":3,\"214\":1,\"223\":1}}],[\"除零错误\",{\"1\":{\"254\":2}}],[\"除此之外都使用字节流\",{\"1\":{\"221\":1}}],[\"除0以外\",{\"1\":{\"217\":1}}],[\"除\",{\"1\":{\"141\":1}}],[\"除非进程重启重置\",{\"1\":{\"132\":1}}],[\"除了使用increase函数计算增量外\",{\"1\":{\"148\":1}}],[\"除了prometheus很多组件是可选的\",{\"1\":{\"119\":1}}],[\"除了以上的solid\",{\"1\":{\"70\":1}}],[\"摘要\",{\"1\":{\"131\":1}}],[\"直方图\",{\"1\":{\"131\":1}}],[\"直接采集的jobs和exporters\",{\"1\":{\"120\":1}}],[\"状态值\",{\"1\":{\"131\":1}}],[\"状态模式设计的初衷是应对同一个对象里不同状态变化时的不同行为的变化\",{\"1\":{\"68\":1}}],[\"状态模式\",{\"1\":{\"68\":1}}],[\"仪表盘\",{\"1\":{\"131\":1}}],[\"初始位置为\",{\"1\":{\"228\":1}}],[\"初始值为零\",{\"1\":{\"132\":1}}],[\"初始值为0\",{\"1\":{\"131\":1}}],[\"初始化对象\",{\"1\":{\"75\":1}}],[\"累加器\",{\"0\":{\"132\":1},\"1\":{\"131\":1}}],[\"值都可以容纳\",{\"1\":{\"215\":1}}],[\"值以及指向下一个\",{\"1\":{\"196\":1}}],[\"值可以重复\",{\"1\":{\"176\":1}}],[\"值\",{\"1\":{\"130\":1,\"184\":1,\"198\":2,\"251\":3,\"253\":2}}],[\"值和一个或者是多个key\",{\"1\":{\"117\":1}}],[\"8之后\",{\"1\":{\"258\":1}}],[\"8bit\",{\"1\":{\"221\":1}}],[\"85\",{\"1\":{\"176\":3}}],[\"80\",{\"1\":{\"176\":2}}],[\"8080\",{\"1\":{\"153\":3,\"154\":1,\"163\":1,\"232\":1,\"233\":1,\"236\":1,\"237\":2}}],[\"8\",{\"1\":{\"134\":1,\"150\":1,\"183\":1,\"196\":1,\"217\":4,\"223\":1,\"236\":1,\"241\":3,\"251\":2}}],[\"817\",{\"1\":{\"130\":2}}],[\"822\",{\"1\":{\"130\":2}}],[\"82\",{\"1\":{\"130\":2}}],[\"82033736e+08\",{\"1\":{\"124\":1}}],[\"时会指定容量\",{\"1\":{\"228\":1}}],[\"时\",{\"1\":{\"163\":1,\"208\":1,\"232\":1,\"233\":1,\"234\":1,\"253\":1}}],[\"时间复杂度为\",{\"1\":{\"180\":1}}],[\"时间位移操作\",{\"0\":{\"139\":1}}],[\"时间范围除了支持分钟\",{\"1\":{\"138\":1}}],[\"时间范围通过时间范围选择器\",{\"1\":{\"138\":1}}],[\"时间戳精度为毫秒\",{\"1\":{\"130\":1}}],[\"时间戳\",{\"1\":{\"130\":1}}],[\"时间序列\",{\"1\":{\"130\":1}}],[\"时间序列是指标\",{\"1\":{\"130\":1}}],[\"时序数据使用http协议采集\",{\"1\":{\"118\":1}}],[\"搜索成功后\",{\"1\":{\"127\":1}}],[\"搜索地址\",{\"1\":{\"127\":1}}],[\"登陆成功后\",{\"1\":{\"127\":1}}],[\"密码为admin\",{\"1\":{\"127\":1}}],[\"密码加密的文章\",{\"0\":{\"10\":1}}],[\"地址为localhost\",{\"1\":{\"127\":1}}],[\"进程发送\",{\"1\":{\"161\":1}}],[\"进入grafana的页面\",{\"1\":{\"127\":1}}],[\"进入grafana官网下载安装包\",{\"1\":{\"127\":1}}],[\"进入到grafana的安装目录\",{\"1\":{\"127\":1}}],[\"进行资源释放或清理操作\",{\"1\":{\"259\":1}}],[\"进行连接服务器端\",{\"1\":{\"237\":1}}],[\"进行基本操作的示例代码\",{\"1\":{\"228\":1}}],[\"进行文件读写操作的基本示例\",{\"1\":{\"227\":1}}],[\"进行网络数据的读写操作\",{\"1\":{\"226\":1}}],[\"进行\",{\"1\":{\"226\":1}}],[\"进行排序\",{\"1\":{\"217\":1}}],[\"进行数据的发送和接收\",{\"1\":{\"237\":1}}],[\"进行数据的转换或者功能的增强\",{\"1\":{\"85\":1}}],[\"进行数字排序\",{\"1\":{\"217\":1}}],[\"进行比较\",{\"1\":{\"210\":1}}],[\"进行全局的计算频次的设置\",{\"1\":{\"169\":1}}],[\"进行定义\",{\"1\":{\"138\":1}}],[\"进行引用\",{\"1\":{\"44\":2}}],[\"炫酷的展示数据的可视化仪表盘\",{\"1\":{\"127\":1}}],[\"流操作的数据需要编码或解码时\",{\"1\":{\"223\":1}}],[\"流\",{\"1\":{\"220\":1}}],[\"流行的\",{\"1\":{\"127\":1}}],[\"流程图\",{\"0\":{\"31\":1}}],[\"重写是根据方法的名称和参数列表进行区分\",{\"1\":{\"240\":1}}],[\"重写是指子类对父类方法的重写\",{\"1\":{\"240\":1}}],[\"重写\",{\"1\":{\"240\":1}}],[\"重载方法可以有不同的返回类型\",{\"1\":{\"240\":1}}],[\"重载方法在编译时静态地绑定\",{\"1\":{\"240\":1}}],[\"重载是根据方法的参数列表进行区分\",{\"1\":{\"240\":1}}],[\"重载是针对于同个类中\",{\"1\":{\"240\":1}}],[\"重载有以下的特点\",{\"1\":{\"240\":1}}],[\"重载的方法的返回结果的类型也可以是不同的\",{\"1\":{\"240\":1}}],[\"重载的方法通过调用时的参数的类型或者数量\",{\"1\":{\"240\":1}}],[\"重载指的是在一个类中定义多个方法\",{\"1\":{\"240\":1}}],[\"重载\",{\"1\":{\"240\":2}}],[\"重载与重写的区别\",{\"0\":{\"240\":1}}],[\"重置位置为\",{\"1\":{\"228\":1}}],[\"重置位置和上界\",{\"1\":{\"228\":3}}],[\"重复元素\",{\"1\":{\"175\":1}}],[\"重新是发生在子类和父类的继承关系之间\",{\"1\":{\"240\":1}}],[\"重新的方法必须具有相同的访问修饰词或者更宽松的访问级别\",{\"1\":{\"240\":1}}],[\"重新启动alertmanager\",{\"1\":{\"163\":1}}],[\"重新启动prometheus\",{\"1\":{\"172\":1}}],[\"重新启动prometheus或者热加载\",{\"1\":{\"155\":1}}],[\"重新启动prometheus的程序\",{\"1\":{\"125\":1}}],[\"重新加载一下配置\",{\"1\":{\"155\":1}}],[\"重要的内容\",{\"1\":{\"25\":1}}],[\"95\",{\"1\":{\"156\":1,\"176\":4}}],[\"9400\",{\"1\":{\"154\":2,\"155\":1}}],[\"9999\",{\"1\":{\"217\":1}}],[\"99\",{\"1\":{\"150\":1}}],[\"9\",{\"1\":{\"130\":1,\"150\":1,\"223\":1,\"241\":1}}],[\"9100\",{\"1\":{\"125\":2}}],[\"90\",{\"1\":{\"176\":2}}],[\"909\",{\"1\":{\"164\":1}}],[\"9093\",{\"1\":{\"124\":1,\"163\":1,\"165\":1}}],[\"9090\",{\"1\":{\"123\":1,\"124\":2,\"125\":2,\"126\":1,\"146\":1,\"150\":10,\"164\":2}}],[\"9000\",{\"1\":{\"92\":2}}],[\"启动多路复用器时\",{\"1\":{\"238\":1}}],[\"启动alertmanager可以使用以下命令\",{\"1\":{\"162\":1}}],[\"启动命令如下\",{\"1\":{\"127\":1}}],[\"启动grafana\",{\"1\":{\"127\":1}}],[\"启动node\",{\"1\":{\"125\":1}}],[\"启动成功后\",{\"1\":{\"123\":1,\"127\":1}}],[\"磁盘\",{\"1\":{\"125\":1}}],[\"内部类不会因为定义在方法中就会随着方法的执行完毕而跟随外部类被销毁\",{\"1\":{\"258\":1}}],[\"内部类和外部类其实是处于同一个级别\",{\"1\":{\"258\":1}}],[\"内部的\",{\"1\":{\"207\":1}}],[\"内部定义的节点类\",{\"1\":{\"188\":1}}],[\"内部\",{\"1\":{\"180\":1}}],[\"内存\",{\"1\":{\"125\":1}}],[\"内容如下\",{\"1\":{\"124\":1,\"164\":1}}],[\"内容\",{\"1\":{\"16\":1}}],[\"700\",{\"1\":{\"217\":1}}],[\"75f\",{\"1\":{\"207\":1}}],[\"75的\",{\"1\":{\"197\":1}}],[\"75\",{\"1\":{\"124\":1,\"135\":1}}],[\"745e\",{\"1\":{\"124\":1}}],[\"7\",{\"1\":{\"124\":1,\"153\":1,\"215\":2,\"217\":2,\"223\":1}}],[\"423\",{\"1\":{\"217\":1}}],[\"48\",{\"1\":{\"214\":1}}],[\"489234e+06\",{\"1\":{\"124\":1}}],[\"4h\",{\"1\":{\"163\":1}}],[\"44\",{\"1\":{\"154\":1}}],[\"4<\",{\"1\":{\"153\":1}}],[\"404\",{\"1\":{\"145\":4}}],[\"4\",{\"1\":{\"124\":1,\"127\":2,\"134\":1,\"150\":1,\"166\":1,\"174\":1,\"180\":1,\"223\":1,\"225\":1,\"241\":1,\"251\":2,\"260\":2}}],[\"47\",{\"1\":{\"123\":2}}],[\"支持双向操作\",{\"1\":{\"226\":1}}],[\"支持非阻塞\",{\"1\":{\"225\":1}}],[\"支持对集合进行顺序迭代\",{\"1\":{\"186\":1}}],[\"支持快速访问\",{\"1\":{\"179\":1}}],[\"支持的逻辑运算符如下\",{\"1\":{\"143\":1}}],[\"支持多种类型的采集\",{\"1\":{\"124\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"27\":1}}],[\"周\",{\"1\":{\"138\":1}}],[\"周期性采集监控目标\",{\"1\":{\"124\":1}}],[\"周边生态非常的丰富\",{\"1\":{\"117\":1}}],[\"访问列表中的元素\",{\"1\":{\"174\":1}}],[\"访问alertmanager的界面\",{\"1\":{\"165\":1}}],[\"访问prometheus的告警页面界面\",{\"1\":{\"164\":1}}],[\"访问prometheus的规则文件界面\",{\"1\":{\"164\":1}}],[\"访问prometheus的网页\",{\"1\":{\"125\":1}}],[\"访问http\",{\"1\":{\"123\":1,\"125\":1}}],[\"访问者模式是以行为\",{\"1\":{\"68\":1}}],[\"访问者模式\",{\"1\":{\"68\":1}}],[\"笔者是mac\",{\"1\":{\"127\":1}}],[\"笔者是mac电脑\",{\"1\":{\"123\":1}}],[\"笔者这里下载mac版本的\",{\"1\":{\"123\":1}}],[\"笔者作为多年面试官\",{\"1\":{\"69\":1}}],[\"安装prometheus\",{\"0\":{\"123\":1}}],[\"安装成功后\",{\"1\":{\"122\":1}}],[\"安全与隐私\",{\"1\":{\"123\":1}}],[\"安全\",{\"1\":{\"74\":1}}],[\"安全的在\",{\"1\":{\"19\":1}}],[\"包装类的值比较应该使用equals\",{\"1\":{\"245\":1}}],[\"包装类都是不可变的\",{\"1\":{\"245\":1}}],[\"包装类还提供了许多其他功能\",{\"1\":{\"245\":1}}],[\"包实现了基于\",{\"1\":{\"237\":1}}],[\"包实现的简单的基于\",{\"1\":{\"236\":1}}],[\"包\",{\"1\":{\"223\":1}}],[\"包的结构\",{\"1\":{\"223\":1}}],[\"包中去除\",{\"1\":{\"223\":1}}],[\"包括编译器\",{\"1\":{\"255\":1}}],[\"包括文件读写\",{\"1\":{\"225\":1}}],[\"包括文件名\",{\"1\":{\"223\":1}}],[\"包括设置位\",{\"1\":{\"215\":1}}],[\"包括在链表的头部或尾部插入元素\",{\"1\":{\"193\":1}}],[\"包括了最常见的list\",{\"1\":{\"177\":1}}],[\"包括消息的去重\",{\"1\":{\"158\":1}}],[\"包括两个标签uri\",{\"1\":{\"154\":2}}],[\"包括prometheus\",{\"1\":{\"122\":1}}],[\"包含了5种设计模式\",{\"1\":{\"66\":1}}],[\"包含\",{\"1\":{\"19\":1}}],[\"以确保代码的可靠性\",{\"1\":{\"259\":1}}],[\"以确保程序的正常执行\",{\"1\":{\"254\":1}}],[\"以确定两个对象是否相等\",{\"1\":{\"253\":1}}],[\"以避免空指针异常\",{\"1\":{\"253\":1}}],[\"以避免产生并发修改异常\",{\"1\":{\"186\":1}}],[\"以获得最终的哈希码\",{\"1\":{\"253\":1}}],[\"以减少哈希冲突的概率\",{\"1\":{\"253\":1}}],[\"以下代码演示了使用包装类实现基本类型的自动装箱和拆箱\",{\"1\":{\"245\":1}}],[\"以下是一些在重写hashcode\",{\"1\":{\"253\":1}}],[\"以下是一些常见的\",{\"1\":{\"226\":1}}],[\"以下是一些常用的\",{\"1\":{\"215\":1}}],[\"以下是一个接口的示例\",{\"1\":{\"241\":1}}],[\"以下是一个抽象类的示例\",{\"1\":{\"241\":1}}],[\"以下是一个使用\",{\"1\":{\"227\":1}}],[\"以下是对其源码的解析\",{\"1\":{\"186\":1}}],[\"以实现高效的\",{\"1\":{\"229\":1}}],[\"以上示例演示了\",{\"1\":{\"228\":1}}],[\"以上示例演示了如何使用\",{\"1\":{\"227\":1}}],[\"以上示例代码演示了\",{\"1\":{\"215\":1}}],[\"以读写模式\",{\"1\":{\"227\":1}}],[\"以后每次遇到换行时会在下一行添加一个行号\",{\"1\":{\"223\":1}}],[\"以后的版本中\",{\"1\":{\"196\":1}}],[\"以此类推\",{\"1\":{\"214\":1}}],[\"以填补被删除元素的空缺\",{\"1\":{\"180\":1}}],[\"以键值对\",{\"1\":{\"173\":1}}],[\"以无序的方式存储对象的集合\",{\"1\":{\"173\":1}}],[\"以有序的方式存储对象的集合\",{\"1\":{\"173\":1}}],[\"以及优化性能\",{\"1\":{\"257\":1}}],[\"以及一些集合类\",{\"1\":{\"253\":1}}],[\"以及默认方法\",{\"1\":{\"241\":1}}],[\"以及文件操作\",{\"1\":{\"220\":1}}],[\"以及常见的实现类\",{\"1\":{\"177\":1}}],[\"以及判断\",{\"1\":{\"176\":1}}],[\"以及判断集合是否为空\",{\"1\":{\"175\":1}}],[\"以及添加\",{\"1\":{\"176\":1}}],[\"以及告警的接受方式可以通过alertmanager的配置文件进行配置\",{\"1\":{\"159\":1}}],[\"以及服务运行状态等直观的信息\",{\"1\":{\"121\":1}}],[\"以\",{\"1\":{\"134\":2,\"251\":1}}],[\"以便更好地抽象和组织程序中可能发生的异常情况\",{\"1\":{\"254\":1}}],[\"以便方法可以在这些对象类型之间进行选择\",{\"1\":{\"245\":1}}],[\"以便在中断期间仅发送一组互连警报中最相关的警报\",{\"1\":{\"163\":1}}],[\"以便以后可以恢复\",{\"1\":{\"68\":1}}],[\"以便\",{\"1\":{\"13\":1}}],[\"资源使用情况\",{\"1\":{\"121\":1}}],[\"故障分析与定位\",{\"1\":{\"121\":1}}],[\"监控多个\",{\"1\":{\"234\":1}}],[\"监控系统需要迅速反应并通知管理员\",{\"1\":{\"121\":1}}],[\"监控对象的发现\",{\"1\":{\"120\":1}}],[\"两个版本的系统运行资源使用情况的差异如何\",{\"1\":{\"121\":1}}],[\"两者都是开闭原则的具体实现规范\",{\"1\":{\"70\":1}}],[\"例如常量\",{\"1\":{\"257\":1}}],[\"例如释放资源\",{\"1\":{\"254\":1}}],[\"例如integer\",{\"1\":{\"245\":1}}],[\"例如添加键值对\",{\"1\":{\"176\":1}}],[\"例如添加元素\",{\"1\":{\"175\":1}}],[\"例如有以下的指标prometheus\",{\"1\":{\"150\":1}}],[\"例如下面的查询语句不会输出任何结果\",{\"1\":{\"141\":1}}],[\"例如go\",{\"1\":{\"135\":1}}],[\"例如0\",{\"1\":{\"134\":1}}],[\"例如prometheus的服务的\",{\"1\":{\"134\":1}}],[\"例如prometheus\",{\"1\":{\"132\":1,\"158\":1}}],[\"例如\",{\"1\":{\"121\":1,\"133\":1,\"134\":1,\"138\":1,\"148\":1,\"149\":1,\"160\":1,\"171\":1,\"174\":1,\"245\":1,\"246\":1,\"251\":1}}],[\"例如代理私有方法\",{\"1\":{\"113\":1}}],[\"去查了指定的码表\",{\"1\":{\"221\":1}}],[\"去掉\",{\"1\":{\"171\":1}}],[\"去prometheus官网下载prometheus\",{\"1\":{\"123\":1}}],[\"去重\",{\"1\":{\"120\":1}}],[\"去提供获取对象的服务\",{\"1\":{\"74\":1}}],[\"健康对象包含\",{\"1\":{\"120\":1}}],[\"架构\",{\"0\":{\"120\":1}}],[\"大多数情况下不会被程序显式地捕获和处理\",{\"1\":{\"254\":1}}],[\"大多数prometheus组件都是使用go语言写的\",{\"1\":{\"119\":1}}],[\"大部分\",{\"1\":{\"225\":1}}],[\"大于\",{\"1\":{\"199\":1}}],[\"大于等于链表大小的一半\",{\"1\":{\"191\":1}}],[\"大量的类\",{\"1\":{\"100\":1}}],[\"恢复等管理\",{\"1\":{\"119\":1}}],[\"静默提供了一个标签匹配的设置\",{\"1\":{\"161\":1}}],[\"静默\",{\"0\":{\"161\":1},\"1\":{\"119\":1,\"120\":1}}],[\"静态方法在接口中提供了一些与接口相关的工具方法\",{\"1\":{\"241\":1}}],[\"静态方法\",{\"1\":{\"241\":2}}],[\"静态方法用来返回其所属类的一个相同实例\",{\"1\":{\"73\":1}}],[\"静态代理的优点是简单易懂\",{\"1\":{\"109\":1}}],[\"静态代理需要手动创建一个代理类\",{\"1\":{\"109\":1}}],[\"静态代理\",{\"0\":{\"109\":1}}],[\"静态对象用来存储对象自身的属性和方法\",{\"1\":{\"73\":1}}],[\"用作其他类的基类\",{\"1\":{\"241\":1}}],[\"用户数统计等等\",{\"1\":{\"216\":1}}],[\"用来读取数据\",{\"1\":{\"236\":1}}],[\"用来存储位信息\",{\"1\":{\"215\":1}}],[\"用来连接上一个节点和下一个节点\",{\"1\":{\"193\":1}}],[\"用来抓取和存储时序数据的\",{\"1\":{\"119\":1}}],[\"用increase函数算出五分钟的增量\",{\"1\":{\"148\":1}}],[\"用于异常处理的最后一个代码块\",{\"1\":{\"259\":1}}],[\"用于计算两个数的除法操作\",{\"1\":{\"254\":1}}],[\"用于计算是否有时间序列满足该条件\",{\"1\":{\"164\":1}}],[\"用于定义一组合同类型的操作\",{\"1\":{\"241\":1}}],[\"用于定义一些全局的公共参数\",{\"1\":{\"162\":1}}],[\"用于描述一种通用的概念\",{\"1\":{\"241\":1}}],[\"用于实例化抽象类的对象\",{\"1\":{\"241\":1}}],[\"用于实现类的多态性\",{\"1\":{\"241\":2}}],[\"用于构建类的继承层级结构\",{\"1\":{\"241\":1}}],[\"用于多路复用非阻塞\",{\"1\":{\"234\":1}}],[\"用于与客户端进行通信\",{\"1\":{\"233\":1}}],[\"用于高效地进行数据读写操作\",{\"1\":{\"228\":1}}],[\"用于在同一程序中进行线程间通信\",{\"1\":{\"226\":1}}],[\"用于在运行时扩展java类和实现动态代理\",{\"1\":{\"113\":1}}],[\"用于监听和接收客户端的连接请求\",{\"1\":{\"226\":1}}],[\"用于通过\",{\"1\":{\"226\":2}}],[\"用于对文件进行读写操作\",{\"1\":{\"226\":1}}],[\"用于对数据进行读取和写入操作\",{\"1\":{\"226\":1}}],[\"用于对象之间的一对多的依赖关系\",{\"1\":{\"104\":1}}],[\"用于对象的实例化\",{\"1\":{\"66\":1}}],[\"用于从文件中读取字符数据的流\",{\"1\":{\"221\":1}}],[\"用于从文件中读取字节数据的流\",{\"1\":{\"221\":1}}],[\"用于从源中读取字符数据\",{\"1\":{\"221\":1}}],[\"用于从源中读取字节数据\",{\"1\":{\"221\":1}}],[\"用于提供更高效的字符写入功能\",{\"1\":{\"221\":1}}],[\"用于提供更高效的字符读取功能\",{\"1\":{\"221\":1}}],[\"用于提供更高效的字节写入功能\",{\"1\":{\"221\":1}}],[\"用于提供更高效的字节读取功能\",{\"1\":{\"221\":1}}],[\"用于将字符数据写入文件的流\",{\"1\":{\"221\":1}}],[\"用于将字符数据写入目标\",{\"1\":{\"221\":1}}],[\"用于将字节数据写入文件的流\",{\"1\":{\"221\":1}}],[\"用于将字节数据写入目标\",{\"1\":{\"221\":1}}],[\"用于创建一个空的\",{\"1\":{\"207\":1}}],[\"用于创建产品对象的接口\",{\"1\":{\"99\":1}}],[\"用于获取指定位置的元素\",{\"1\":{\"185\":1}}],[\"用于存储键值对\",{\"1\":{\"201\":1}}],[\"用于存储元素\",{\"1\":{\"180\":1}}],[\"用于存储不重复的元素\",{\"1\":{\"175\":1}}],[\"用于添加\",{\"1\":{\"174\":1}}],[\"用于表示不可变\",{\"1\":{\"257\":1}}],[\"用于表示有序的元素集合\",{\"1\":{\"174\":1}}],[\"用于表示只有当触发条件持续一段时间后才发送告警\",{\"1\":{\"164\":1}}],[\"用于保存元素并控制元素的插入\",{\"1\":{\"173\":1}}],[\"用于处理不同类型的集合\",{\"1\":{\"173\":1}}],[\"用于指定一组附加信息\",{\"1\":{\"164\":1}}],[\"用于指标数据的统计\",{\"1\":{\"154\":1}}],[\"用于等待抑制告警\",{\"1\":{\"163\":1}}],[\"用于向alertmanager发送告警消息\",{\"1\":{\"157\":1}}],[\"用于统计请求的耗时\",{\"1\":{\"154\":1}}],[\"用于统计请求的数量\",{\"1\":{\"154\":1}}],[\"用于java程序的指标暴露\",{\"1\":{\"154\":1}}],[\"用于求分位数\",{\"1\":{\"131\":1}}],[\"用于解耦对象的实例化过程\",{\"1\":{\"66\":1}}],[\"采用的数据模型是单值模型\",{\"1\":{\"130\":1}}],[\"采用装饰器模式能够快速的扩展功能\",{\"1\":{\"88\":1}}],[\"采集了node\",{\"1\":{\"128\":1}}],[\"采集node\",{\"0\":{\"125\":1},\"1\":{\"157\":1}}],[\"采集监控对象的指标\",{\"1\":{\"120\":1}}],[\"采集目标可以使用服务发现的方式\",{\"1\":{\"118\":1}}],[\"通信结束后\",{\"1\":{\"232\":1,\"233\":1}}],[\"通道是一个用于读写数据的对象\",{\"1\":{\"225\":1}}],[\"通道\",{\"1\":{\"225\":1,\"226\":1}}],[\"通道和非阻塞\",{\"1\":{\"225\":1}}],[\"通配符进行模糊匹配查询\",{\"1\":{\"137\":1}}],[\"通常表示系统的严重错误或问题\",{\"1\":{\"254\":1}}],[\"通常表示程序中可预见的异常情况\",{\"1\":{\"254\":1}}],[\"通常也需要重写hashcode\",{\"1\":{\"253\":1}}],[\"通常都需要重写equals\",{\"1\":{\"252\":1}}],[\"通常需要遵循以下步骤\",{\"1\":{\"232\":1,\"233\":1,\"234\":1}}],[\"通常设置为3小时或更长时间\",{\"1\":{\"163\":1}}],[\"通常是抽象方法\",{\"1\":{\"241\":1}}],[\"通常是将\",{\"1\":{\"199\":1}}],[\"通常是webhook\",{\"1\":{\"157\":1}}],[\"通常是pull模式\",{\"1\":{\"118\":1}}],[\"通常使用以下的关键字\",{\"1\":{\"145\":1}}],[\"通常情况下\",{\"1\":{\"135\":1}}],[\"通常15\",{\"1\":{\"120\":1}}],[\"通过合理地使用try\",{\"1\":{\"254\":1}}],[\"通过hashcode\",{\"1\":{\"253\":1}}],[\"通过父类引用调用重写的方法时\",{\"1\":{\"246\":1}}],[\"通过关键字\",{\"1\":{\"241\":2}}],[\"通过无限循环不断调用\",{\"1\":{\"236\":1}}],[\"通过返回的\",{\"1\":{\"233\":1}}],[\"通过适当地使用这些方法\",{\"1\":{\"228\":1}}],[\"通过上界来限制读写的范围\",{\"1\":{\"228\":1}}],[\"通过内部的指针来操作字符数组中的数据\",{\"1\":{\"223\":1}}],[\"通过使用\",{\"1\":{\"211\":1,\"229\":1}}],[\"通过调用静态的\",{\"1\":{\"232\":1,\"233\":1}}],[\"通过调用\",{\"1\":{\"208\":1,\"229\":2,\"234\":3}}],[\"通过链表和红黑树的形式来解决\",{\"1\":{\"201\":1}}],[\"通过实现接口\",{\"1\":{\"241\":1}}],[\"通过实现\",{\"1\":{\"186\":1}}],[\"通过这种方式\",{\"1\":{\"180\":1}}],[\"通过这种直方图可以很方便的统计请求耗时分布的真实状态\",{\"1\":{\"134\":1}}],[\"通过rule\",{\"1\":{\"172\":1}}],[\"通过recording\",{\"1\":{\"171\":1}}],[\"通过向alertmanager\",{\"1\":{\"161\":1}}],[\"通过配置文件去配置一些配置\",{\"1\":{\"161\":1}}],[\"通过alertmanager的配置可以忽略与该集群有关的其它告警功能\",{\"1\":{\"160\":1}}],[\"通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态\",{\"1\":{\"148\":1}}],[\"通过instant\",{\"1\":{\"138\":1}}],[\"通过以下表达式可以选择最近5分钟内的所有样本数据\",{\"1\":{\"138\":1}}],[\"通过拉prometheus的配置热更新接口\",{\"1\":{\"126\":1}}],[\"通过可视化仪表盘能够直接获取系统的运行状态\",{\"1\":{\"121\":1}}],[\"通过监控能够方便的对系统进行跟踪和比较\",{\"1\":{\"121\":1}}],[\"通过对不同监控监控以及历史数据的分析\",{\"1\":{\"121\":1}}],[\"通过对磁盘空间增长率的判断\",{\"1\":{\"121\":1}}],[\"通过对监控样本数据的持续收集和统计\",{\"1\":{\"121\":1}}],[\"通过prometheus建立完善的监控体系\",{\"1\":{\"121\":1}}],[\"通过了内置的告警规则计算\",{\"1\":{\"120\":1}}],[\"通过中间层push\",{\"1\":{\"118\":1}}],[\"通过包装不同的装饰器组合来满足自己的业务需求\",{\"1\":{\"88\":1}}],[\"通过共享对象池技术\",{\"1\":{\"67\":1}}],[\"通过复制原有的实例来创建新的实例\",{\"1\":{\"66\":1}}],[\"通过\",{\"1\":{\"15\":1,\"18\":1,\"130\":1,\"196\":1,\"204\":1,\"207\":1,\"227\":1,\"228\":3,\"229\":2,\"232\":3,\"233\":2}}],[\"指标数据如下\",{\"1\":{\"154\":1}}],[\"指标的名称是监控样本的标识\",{\"1\":{\"136\":1}}],[\"指标的类型\",{\"0\":{\"131\":1}}],[\"指标名将会被删除\",{\"1\":{\"141\":1}}],[\"指标名和标签名的命名需要满足\",{\"1\":{\"130\":1}}],[\"指标名称的定义可以参考下面一小节\",{\"1\":{\"169\":1}}],[\"指标名称\",{\"1\":{\"130\":1}}],[\"指标是由指标名和标签组成\",{\"1\":{\"130\":1}}],[\"指标是单值模型\",{\"1\":{\"130\":1}}],[\"指标在不同时间有不同的值\",{\"1\":{\"130\":1}}],[\"指标在不同时间下的值\",{\"1\":{\"130\":1}}],[\"指标定义如下\",{\"1\":{\"130\":1}}],[\"指标\",{\"1\":{\"118\":1,\"130\":1}}],[\"指南\",{\"0\":{\"48\":1,\"52\":1}}],[\"白盒监控\",{\"1\":{\"118\":1}}],[\"云平台配合\",{\"1\":{\"117\":1}}],[\"云原生计算基金会\",{\"1\":{\"117\":1}}],[\"能通过tcp读写网络中的数据\",{\"1\":{\"225\":1}}],[\"能通过udp读写网络中的数据\",{\"1\":{\"225\":1}}],[\"能更好地与容器平台\",{\"1\":{\"117\":1}}],[\"能够更高效地处理多个连接的读写事件\",{\"1\":{\"238\":1}}],[\"能够保证即使某个连接阻塞\",{\"1\":{\"238\":1}}],[\"能够与服务器端建立连接\",{\"1\":{\"237\":1}}],[\"能够同时处理多个客户端连接\",{\"1\":{\"236\":1}}],[\"能够实现高性能的并发\",{\"1\":{\"234\":1}}],[\"能够实现不同产品族的兼容性和高度可扩展性\",{\"1\":{\"103\":1}}],[\"能够找到并解决根源问题\",{\"1\":{\"121\":1}}],[\"能够快速的扩展现有类的功能\",{\"1\":{\"88\":1}}],[\"能够熟练使用设计模式\",{\"1\":{\"69\":1}}],[\"同样的方式\",{\"1\":{\"192\":1}}],[\"同样的\",{\"1\":{\"154\":1}}],[\"同操作运算符一样\",{\"1\":{\"142\":1,\"143\":1}}],[\"同理\",{\"1\":{\"137\":1}}],[\"同年6月正式发布1\",{\"1\":{\"117\":1}}],[\"同时提供了更好的可维护性和扩展性\",{\"1\":{\"242\":1}}],[\"同时将位置设置为\",{\"1\":{\"228\":2}}],[\"同时在另一个方向上写入数据\",{\"1\":{\"226\":1}}],[\"同时还封装了一个缓冲区\",{\"1\":{\"223\":1}}],[\"同时还实现了deque\",{\"1\":{\"188\":1}}],[\"同时还实现了\",{\"1\":{\"179\":1}}],[\"同时更新\",{\"1\":{\"186\":1}}],[\"同时prometheus读取告警规则文件\",{\"1\":{\"157\":1}}],[\"同时prometheus作为一个时序数据库\",{\"1\":{\"128\":1}}],[\"同时\",{\"1\":{\"107\":1,\"180\":1,\"201\":1,\"225\":1}}],[\"同时它具有以下的缺点\",{\"1\":{\"103\":1}}],[\"同时它是线程安全的\",{\"1\":{\"75\":1}}],[\"同时有不会影响原有的公民\",{\"1\":{\"88\":1}}],[\"告警规则的名称\",{\"1\":{\"164\":1}}],[\"告警路由\",{\"1\":{\"162\":1}}],[\"告警时间间隔\",{\"1\":{\"159\":1}}],[\"告警分组\",{\"1\":{\"159\":1}}],[\"告警消息的处理程序alertmanager\",{\"1\":{\"157\":1}}],[\"告警发送\",{\"1\":{\"157\":1}}],[\"告警语句的配置\",{\"1\":{\"136\":1}}],[\"告警\",{\"1\":{\"121\":1}}],[\"告警管理等一系列工具包\",{\"1\":{\"117\":1}}],[\"告警计算\",{\"1\":{\"117\":1}}],[\"最高位仅用于表示正负\",{\"1\":{\"251\":1}}],[\"最多返回interger的软最大值\",{\"1\":{\"183\":1}}],[\"最新的操作函数在前\",{\"1\":{\"171\":1}}],[\"最好创建一个目录专门存储告警规则文件\",{\"1\":{\"164\":1}}],[\"最终会执行的代码块\",{\"1\":{\"259\":1}}],[\"最终根据上面的表达式得到的指标的名称是instance\",{\"1\":{\"171\":1}}],[\"最终我的配置修改成如下\",{\"1\":{\"163\":1}}],[\"最终将消息发送给第三方组件\",{\"1\":{\"157\":1}}],[\"最终的技术架构如下\",{\"1\":{\"115\":1}}],[\"最后修改时间\",{\"1\":{\"223\":1}}],[\"最后返回删除节点的数据域\",{\"1\":{\"192\":1}}],[\"最后使用是rate操作\",{\"1\":{\"171\":1}}],[\"最后webhook发送给告警平台\",{\"1\":{\"157\":1}}],[\"最后\",{\"1\":{\"82\":1,\"184\":1,\"190\":1,\"191\":1,\"199\":1,\"227\":1,\"228\":1}}],[\"kit\",{\"1\":{\"255\":1}}],[\"k++\",{\"1\":{\"217\":1}}],[\"kobe\",{\"1\":{\"198\":1}}],[\"keyiterator\",{\"1\":{\"234\":4}}],[\"key\",{\"1\":{\"166\":1,\"173\":1,\"176\":3,\"198\":17,\"199\":1,\"200\":20,\"204\":1,\"234\":4,\"236\":21}}],[\"keyborad\",{\"1\":{\"82\":1}}],[\"keyboard\",{\"1\":{\"82\":5}}],[\"k\",{\"1\":{\"146\":2,\"196\":1,\"198\":6,\"200\":6,\"217\":1}}],[\"kafka\",{\"1\":{\"115\":1}}],[\"旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统\",{\"1\":{\"115\":1}}],[\"本质上是对其它流的综合运用的一个工具而已\",{\"1\":{\"223\":1}}],[\"本质其实就是基于字节流读取时\",{\"1\":{\"221\":1}}],[\"本身\",{\"1\":{\"251\":2}}],[\"本身又是字符流\",{\"1\":{\"223\":1}}],[\"本身内部实现还是带缓冲的\",{\"1\":{\"223\":1}}],[\"本身就不应该出现在inputstream\",{\"1\":{\"223\":1}}],[\"本篇文章主要讲解如何在springboot项目中使用prometheus监控\",{\"1\":{\"152\":1}}],[\"本篇文章为系列教程\",{\"1\":{\"115\":1}}],[\"本文主要介绍了nio的一些基本组件\",{\"1\":{\"230\":1}}],[\"本文的源码为jdk18\",{\"1\":{\"180\":1}}],[\"本文介绍了java中的collection框架\",{\"1\":{\"177\":1}}],[\"本文使用webhook的方式\",{\"1\":{\"163\":1}}],[\"本文快速的讲解了promql的查询\",{\"1\":{\"151\":1}}],[\"本文是prometheus环境的搭建和安装\",{\"1\":{\"122\":1}}],[\"本页面就是一个示例\",{\"1\":{\"7\":1}}],[\"概览\",{\"0\":{\"114\":1}}],[\"拦截静态方法等\",{\"1\":{\"113\":1}}],[\"更好的做法是使用try\",{\"1\":{\"259\":1}}],[\"更加灵活和高效\",{\"1\":{\"225\":1}}],[\"更灵活地满足额外需求\",{\"1\":{\"113\":1}}],[\"更新为\",{\"1\":{\"190\":1}}],[\"更新\",{\"1\":{\"186\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"45\":1}}],[\"更新时间\",{\"1\":{\"7\":1}}],[\"更新计划\",{\"0\":{\"1\":1,\"2\":1}}],[\"测试cglib\",{\"1\":{\"113\":1}}],[\"测试类\",{\"1\":{\"97\":1}}],[\"结果\",{\"1\":{\"254\":1}}],[\"结合使用\",{\"1\":{\"229\":1}}],[\"结论\",{\"1\":{\"221\":1}}],[\"结构\",{\"1\":{\"196\":1}}],[\"结构型设计模式是多个对象实例的结合或者组装\",{\"1\":{\"67\":1}}],[\"结构型设计模式和行为型设计模式\",{\"1\":{\"65\":1}}],[\"结构型模式\",{\"0\":{\"67\":1}}],[\"结束cglib拦截\",{\"1\":{\"113\":2}}],[\"执行上述代码\",{\"1\":{\"254\":1}}],[\"执行上面代码输出\",{\"1\":{\"205\":1}}],[\"执行finally块\",{\"1\":{\"254\":2}}],[\"执行启动命令\",{\"1\":{\"123\":1}}],[\"执行解压\",{\"1\":{\"123\":1}}],[\"执行结果如下\",{\"1\":{\"113\":1,\"240\":1}}],[\"执行目标对象的方法\",{\"1\":{\"113\":1}}],[\"执行测试类\",{\"1\":{\"87\":1}}],[\"开发者可以实现高并发\",{\"1\":{\"229\":1}}],[\"开启httpserver\",{\"1\":{\"154\":1}}],[\"开始cglib拦截\",{\"1\":{\"113\":2}}],[\"开闭原则\",{\"1\":{\"70\":1}}],[\"工作流程包括\",{\"1\":{\"157\":1}}],[\"工具类\",{\"1\":{\"113\":1}}],[\"工厂类负责了两个职责\",{\"1\":{\"97\":1}}],[\"工厂类包含了所有产品对象的创建逻辑\",{\"1\":{\"97\":1}}],[\"工厂类包含了必要的逻辑判断\",{\"1\":{\"97\":1}}],[\"工厂类根据客户端传入的参数来创建相应的产品对象\",{\"1\":{\"96\":1}}],[\"工厂类\",{\"1\":{\"96\":1,\"97\":1}}],[\"工厂模式\",{\"0\":{\"94\":1}}],[\"工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"101\":1}}],[\"工厂方法模式包含以下角色\",{\"1\":{\"99\":1}}],[\"工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题\",{\"1\":{\"98\":1}}],[\"工厂方法模式\",{\"0\":{\"98\":1},\"1\":{\"66\":1,\"69\":1,\"98\":1}}],[\"维护一个目标对象\",{\"1\":{\"113\":1}}],[\"性能较好\",{\"1\":{\"243\":1}}],[\"性能\",{\"1\":{\"243\":1}}],[\"性能高\",{\"1\":{\"113\":1}}],[\"性能开销\",{\"1\":{\"112\":1}}],[\"性能监控等\",{\"1\":{\"112\":1}}],[\"缺点\",{\"1\":{\"112\":1}}],[\"灵活性\",{\"1\":{\"112\":1}}],[\"灵活性非常高\",{\"1\":{\"107\":1}}],[\"动态绑定\",{\"1\":{\"246\":1}}],[\"动态代理只能对接口进行代理\",{\"1\":{\"112\":1}}],[\"动态代理可以在运行时动态生成代理类\",{\"1\":{\"112\":1}}],[\"动态代理可以使用\",{\"1\":{\"111\":1}}],[\"动态代理的步骤是先实现invocationhandler接口\",{\"1\":{\"112\":1}}],[\"动态代理的优点是避免了手动创建代理类的麻烦\",{\"1\":{\"112\":1}}],[\"动态代理是使用java的反射机制来实现动态代理\",{\"1\":{\"112\":1}}],[\"动态代理是在运行时自动生成代理类并将方法调用转发到实际对象\",{\"1\":{\"112\":1}}],[\"动态代理机制和cglib动态代理\",{\"1\":{\"111\":1}}],[\"动态代理\",{\"0\":{\"111\":1,\"112\":1}}],[\"动态地实例化具体的产品类\",{\"1\":{\"97\":1}}],[\"远程调用\",{\"1\":{\"108\":1}}],[\"综上所述\",{\"1\":{\"107\":1,\"193\":1}}],[\"消息发布者publisher接口\",{\"1\":{\"106\":1}}],[\"观察者收到消息后可以做出响应\",{\"1\":{\"107\":1}}],[\"观察者会执行该方法\",{\"1\":{\"105\":1}}],[\"观察者observer\",{\"1\":{\"105\":1}}],[\"观察者模式是一种实用并且简单的设计模式\",{\"1\":{\"107\":1}}],[\"观察者模式也有一些缺点\",{\"1\":{\"107\":1}}],[\"观察者模式符合开闭原则\",{\"1\":{\"107\":1}}],[\"观察者模式的核心思想是将观察者对象注册到发布者对象中\",{\"1\":{\"107\":1}}],[\"观察者模式在软件开发中有非常多的应用\",{\"1\":{\"105\":1}}],[\"观察者模式uml图\",{\"0\":{\"105\":1}}],[\"观察者模式\",{\"0\":{\"104\":1},\"1\":{\"68\":1,\"69\":1,\"104\":1}}],[\"比特表的逻辑长度\",{\"1\":{\"214\":1}}],[\"比特的逻辑索引是非负整数\",{\"1\":{\"214\":1}}],[\"比较结果为\",{\"1\":{\"251\":3}}],[\"比较的就是\",{\"1\":{\"251\":1}}],[\"比较的是引用而不是值\",{\"1\":{\"245\":1}}],[\"比较操作符\",{\"0\":{\"142\":1}}],[\"比较困难\",{\"1\":{\"103\":1}}],[\"比如如哈希表\",{\"1\":{\"253\":1}}],[\"比如在string类中\",{\"1\":{\"253\":1}}],[\"比如在string内中\",{\"1\":{\"252\":1}}],[\"比如在以下的代码中\",{\"1\":{\"85\":1}}],[\"比如数学运算\",{\"1\":{\"245\":1}}],[\"比如读\",{\"1\":{\"234\":1}}],[\"比如日志分析\",{\"1\":{\"216\":1}}],[\"比如日志记录\",{\"1\":{\"112\":1}}],[\"比如第1天是交易日\",{\"1\":{\"214\":1}}],[\"比如说有这么个场景\",{\"1\":{\"214\":1}}],[\"比如将告警消息发送给运维人员的邮箱\",{\"1\":{\"166\":1}}],[\"比如用于描述告警详细信息的文字等\",{\"1\":{\"164\":1}}],[\"比如当发生severity=critical的告警时\",{\"1\":{\"163\":1}}],[\"比如按照alertname\",{\"1\":{\"163\":1}}],[\"比如配置每分钟的请求量\",{\"1\":{\"156\":1}}],[\"比如计算最近5分钟的请求次数\",{\"1\":{\"148\":1}}],[\"比如prometheus\",{\"1\":{\"146\":1}}],[\"比如p99\",{\"1\":{\"131\":1}}],[\"比如有以下的时间序列的样本\",{\"1\":{\"145\":1}}],[\"比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算\",{\"1\":{\"144\":1}}],[\"比如查询handler为\",{\"1\":{\"137\":1}}],[\"比如\",{\"1\":{\"137\":1,\"139\":1,\"142\":1,\"159\":1,\"208\":1,\"210\":1,\"238\":1}}],[\"比如我们求某个请求耗时的平均值\",{\"1\":{\"134\":1}}],[\"比如我们的mac电脑需要连接usb接口的键盘\",{\"1\":{\"81\":1}}],[\"比如node\",{\"1\":{\"133\":1}}],[\"比如求最近5分钟prometheus发生了多少次请求\",{\"1\":{\"132\":1}}],[\"比如主机的cpu\",{\"1\":{\"125\":1}}],[\"比如从k8s\",{\"1\":{\"124\":1}}],[\"比如可以将指标数据展示在grafana上\",{\"1\":{\"120\":1}}],[\"比如可以先使用加密装饰器\",{\"1\":{\"87\":1}}],[\"比如email\",{\"1\":{\"120\":1}}],[\"比如对消息的去重\",{\"1\":{\"119\":1}}],[\"比如对某一次请求进行不同的规则的校验\",{\"1\":{\"90\":1}}],[\"比如虚拟机\",{\"1\":{\"119\":1}}],[\"比如k8s系统\",{\"1\":{\"118\":1}}],[\"比如int\",{\"1\":{\"245\":1}}],[\"比如influxdb\",{\"1\":{\"118\":1}}],[\"比如id生成器\",{\"1\":{\"72\":1}}],[\"比如访问控制\",{\"1\":{\"108\":1}}],[\"比如发布者维护的观察者对象是无顺序的\",{\"1\":{\"107\":1}}],[\"比如家具厂除了生产沙发\",{\"1\":{\"101\":1}}],[\"比如sofa的生产\",{\"1\":{\"101\":1}}],[\"比如handle\",{\"1\":{\"91\":1}}],[\"比如使用类final关键字的类\",{\"1\":{\"86\":1}}],[\"比如案例中keyboard\",{\"1\":{\"82\":1}}],[\"比如图中的键盘\",{\"1\":{\"81\":1}}],[\"比如拓展坞类实现了目标接口typec接口\",{\"1\":{\"81\":1}}],[\"比如typec接口\",{\"1\":{\"81\":1}}],[\"比如工具类\",{\"1\":{\"72\":1}}],[\"客户端打印如下\",{\"1\":{\"237\":1}}],[\"客户端代码\",{\"0\":{\"237\":1}}],[\"客户端代码与具体产品的创建实现了解耦\",{\"1\":{\"103\":1}}],[\"客户端使用socketchannel\",{\"1\":{\"235\":1}}],[\"客户端和服务器端的实现\",{\"1\":{\"232\":1}}],[\"客户端通过抽象工厂来创建产品对象\",{\"1\":{\"100\":1}}],[\"椅子\",{\"1\":{\"101\":1}}],[\"无参构造函数创建一个初始容量为16\",{\"1\":{\"197\":1}}],[\"无参构造函数和带初始容量和负载因子的构造函数\",{\"1\":{\"197\":1}}],[\"无参构造函数\",{\"1\":{\"181\":1,\"207\":1}}],[\"无固定顺序\",{\"1\":{\"176\":1}}],[\"无序性\",{\"1\":{\"175\":1}}],[\"无需依赖接口\",{\"1\":{\"113\":1}}],[\"无需修改已有代码\",{\"1\":{\"100\":1}}],[\"无法保证finalize方法的及时执行\",{\"1\":{\"259\":1}}],[\"无法代理实现类的方法\",{\"1\":{\"112\":1}}],[\"无法使用动态代理\",{\"1\":{\"112\":1}}],[\"无论try块中是否发生异常\",{\"1\":{\"260\":1}}],[\"无论是否有匹配的catch块\",{\"1\":{\"260\":2}}],[\"无论是否发生异常\",{\"1\":{\"254\":1,\"259\":1}}],[\"无论是在前期的需求分析\",{\"1\":{\"64\":1}}],[\"无论面对什么的环境\",{\"1\":{\"64\":1}}],[\"具备良好的扩展性\",{\"1\":{\"100\":1}}],[\"具体来说\",{\"1\":{\"246\":1}}],[\"具体的对象体现\",{\"1\":{\"223\":1}}],[\"具体的迭代顺序可能因实现类或元素的插入顺序而不同\",{\"1\":{\"176\":1}}],[\"具体的排列顺序可能因实现类或元素的添加顺序而不同\",{\"1\":{\"175\":1}}],[\"具体的配置介绍如下\",{\"1\":{\"124\":1}}],[\"具体表达式格式如下\",{\"1\":{\"172\":1}}],[\"具体预处理生成指标的表达式\",{\"1\":{\"169\":1}}],[\"具体命令如下\",{\"1\":{\"126\":1}}],[\"具体如下\",{\"1\":{\"124\":1}}],[\"具体使用java\",{\"1\":{\"112\":1}}],[\"具体代码如下\",{\"1\":{\"110\":1}}],[\"具体观察者是观察者的具体实现\",{\"1\":{\"105\":1}}],[\"具体观察者\",{\"1\":{\"105\":1}}],[\"具体主题是主题的具体实现\",{\"1\":{\"105\":1}}],[\"具体主题\",{\"1\":{\"105\":1}}],[\"具体工厂类的代码更加简洁\",{\"1\":{\"100\":1}}],[\"具体工厂\",{\"1\":{\"99\":1,\"102\":1,\"103\":1}}],[\"具体产品类\",{\"1\":{\"96\":1,\"99\":1,\"102\":1,\"103\":1}}],[\"具体实现如下\",{\"1\":{\"87\":1}}],[\"符合单一职责原则\",{\"1\":{\"100\":1}}],[\"符合开闭原则\",{\"1\":{\"93\":1,\"103\":1}}],[\"违反了单一职责原则\",{\"1\":{\"97\":1}}],[\"系统扩展性好\",{\"1\":{\"97\":1}}],[\"系统出错\",{\"1\":{\"93\":1}}],[\"运行以上代码\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"运行时会被系统拒绝运行\",{\"1\":{\"123\":1}}],[\"运行代码输出\",{\"1\":{\"112\":1}}],[\"运行代码\",{\"1\":{\"110\":1}}],[\"运行代码处理结果如下\",{\"1\":{\"92\":1}}],[\"运行上面的代码\",{\"1\":{\"103\":1}}],[\"运行结果如下\",{\"1\":{\"97\":1,\"106\":1}}],[\"由1和0组成\",{\"1\":{\"214\":1}}],[\"由node\",{\"1\":{\"127\":1}}],[\"由于final所修饰的值始终无法改变\",{\"1\":{\"258\":1}}],[\"由于除数为0会产生算术异常\",{\"1\":{\"254\":1}}],[\"由于动态绑定的机制\",{\"1\":{\"246\":1}}],[\"由于动态代理是在运行时动态生成代理类\",{\"1\":{\"112\":1}}],[\"由于string是不可变的\",{\"1\":{\"243\":1}}],[\"由于\",{\"1\":{\"180\":1}}],[\"由于prometheus是使用周期性的采集数据\",{\"1\":{\"121\":1}}],[\"由工厂类创建的对象的抽象类或接口\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"由拓展坞去做usb或者是hdmi接口的转换\",{\"1\":{\"83\":1}}],[\"抽象方法\",{\"1\":{\"241\":1}}],[\"抽象方法必须在非抽象子类中被重写实现\",{\"1\":{\"241\":1}}],[\"抽象方法只有方法签名\",{\"1\":{\"241\":1}}],[\"抽象类和接口是java中用于实现抽象和多态性的两个关键概念\",{\"1\":{\"241\":1}}],[\"抽象类和接口的区别\",{\"0\":{\"241\":1}}],[\"抽象类vs接口\",{\"1\":{\"241\":1}}],[\"抽象类通常为其子类提供一个通用的模板\",{\"1\":{\"241\":1}}],[\"抽象类通过使用关键字\",{\"1\":{\"241\":1}}],[\"抽象类用于定义通用的属性和行为\",{\"1\":{\"241\":1}}],[\"抽象类\",{\"1\":{\"221\":4,\"241\":7}}],[\"抽象主题接口类\",{\"1\":{\"109\":1}}],[\"抽象工厂的uml图如下\",{\"1\":{\"102\":1}}],[\"抽象工厂\",{\"0\":{\"101\":1},\"1\":{\"99\":1,\"102\":1,\"103\":1}}],[\"抽象工厂模式提供了一种创建一族相关对象的方法\",{\"1\":{\"103\":1}}],[\"抽象工厂模式包含以下角色\",{\"1\":{\"102\":1}}],[\"抽象工厂模式\",{\"1\":{\"66\":1,\"69\":1,\"101\":1}}],[\"抽象产品类\",{\"1\":{\"96\":1,\"99\":1,\"102\":1,\"103\":1}}],[\"返回true\",{\"1\":{\"252\":2}}],[\"返回的值应该是固定的占位符对象\",{\"1\":{\"210\":1}}],[\"返回一个对应的\",{\"1\":{\"233\":1}}],[\"返回一个布尔值\",{\"1\":{\"208\":1}}],[\"返回一个具体的产品对象sofa\",{\"1\":{\"99\":1}}],[\"返回节点的数据域\",{\"1\":{\"191\":1}}],[\"返回其索引值\",{\"1\":{\"185\":2}}],[\"返回值只会包含该时间序列的最新值的一个样本\",{\"1\":{\"138\":1}}],[\"返回不同类的实例对象\",{\"1\":{\"95\":1}}],[\"返回顶部按钮\",{\"1\":{\"7\":1,\"45\":1}}],[\"根据对象的每个属性计算一个哈希码\",{\"1\":{\"253\":1}}],[\"根据就绪的事件类型执行相应的处理逻辑\",{\"1\":{\"229\":1}}],[\"根据码表映射字符\",{\"1\":{\"221\":1}}],[\"根据\",{\"1\":{\"200\":1,\"234\":1}}],[\"根据键的值与链表或红黑树的键进行比较\",{\"1\":{\"198\":2,\"200\":1}}],[\"根据传入的\",{\"1\":{\"198\":1,\"200\":1}}],[\"根据传入参数的不同\",{\"1\":{\"95\":1}}],[\"根据索引获取对应的节点\",{\"1\":{\"191\":1,\"192\":1}}],[\"根据实际情况\",{\"1\":{\"163\":1}}],[\"根据实际的情况做设计和优化\",{\"1\":{\"93\":1}}],[\"根据标签匹配\",{\"1\":{\"162\":1}}],[\"根据客户端传入的参数来创建相应的产品对象sofa\",{\"1\":{\"97\":1}}],[\"根据借款金额的不同\",{\"1\":{\"92\":1}}],[\"很多人会说在比较对象的时候\",{\"1\":{\"252\":1}}],[\"很明显就是一个装饰器\",{\"1\":{\"223\":1}}],[\"很可能淹没掉一些其他的告警消息\",{\"1\":{\"159\":1}}],[\"很难去排查\",{\"1\":{\"93\":1}}],[\"很好的避免了现有类和适配者类的耦合\",{\"1\":{\"83\":1}}],[\"总结来说\",{\"1\":{\"238\":1,\"260\":1}}],[\"总结\",{\"0\":{\"128\":1,\"151\":1,\"177\":1,\"193\":1,\"201\":1,\"211\":1,\"230\":1},\"1\":{\"240\":1}}],[\"总之\",{\"1\":{\"93\":1}}],[\"总共有23种设计模式\",{\"1\":{\"65\":1}}],[\"制定不同的处理流程\",{\"1\":{\"93\":1}}],[\"降低逻辑单元之间的耦合度\",{\"1\":{\"93\":1}}],[\"每隔一秒向服务器端发送一条消息\",{\"1\":{\"237\":1}}],[\"每次对string进行修改时都要创建一个新的对象\",{\"1\":{\"243\":1}}],[\"每次对string进行修改操作都会创建一个新的string对象\",{\"1\":{\"243\":1}}],[\"每次读取后位置也会递增\",{\"1\":{\"228\":1}}],[\"每次写入后位置会自动递增\",{\"1\":{\"228\":1}}],[\"每位可对应一天的数据\",{\"1\":{\"214\":1}}],[\"每个类都可以重写finalize方法来执行对象的清理操作\",{\"1\":{\"259\":1}}],[\"每个对象都有自己的状态\",{\"1\":{\"244\":1}}],[\"每个对象都是某个类的实例\",{\"1\":{\"244\":1}}],[\"每个模块都包含一系列的操作步骤\",{\"1\":{\"244\":1}}],[\"每个\",{\"1\":{\"196\":1,\"213\":1,\"215\":1}}],[\"每个节点有前向和后向两个指针\",{\"1\":{\"193\":1}}],[\"每个键值对都是一个条目\",{\"1\":{\"176\":1}}],[\"每个键都是唯一的\",{\"1\":{\"173\":1}}],[\"每个recording\",{\"1\":{\"169\":1}}],[\"每个部分包含的可配置的参数很多\",{\"1\":{\"163\":1}}],[\"每个prometheus都是单节点设计的\",{\"1\":{\"121\":1}}],[\"每个方法对应一个具体产品类的创建方法\",{\"1\":{\"102\":1}}],[\"每个具体产品都需要一个具体工厂类来创建\",{\"1\":{\"100\":1}}],[\"每个逻辑单元的功能都是解藕的\",{\"1\":{\"93\":1}}],[\"每个逻辑单元组成了链中的一环\",{\"1\":{\"93\":1}}],[\"每种设计模式有非常多的应用\",{\"1\":{\"69\":1}}],[\"每种类型的设计模式又包含了多种设计模式\",{\"1\":{\"65\":1}}],[\"金额太大\",{\"1\":{\"92\":1}}],[\"520277367\",{\"1\":{\"218\":1}}],[\"5d\",{\"1\":{\"217\":1}}],[\"5倍\",{\"1\":{\"183\":1}}],[\"5763175\",{\"1\":{\"167\":1}}],[\"5782e\",{\"1\":{\"124\":1}}],[\"51cto\",{\"1\":{\"167\":1}}],[\"512\",{\"1\":{\"87\":2}}],[\"5h\",{\"1\":{\"149\":1}}],[\"501\",{\"1\":{\"145\":1}}],[\"5001\",{\"1\":{\"162\":1}}],[\"500\",{\"1\":{\"145\":5}}],[\"5000\",{\"1\":{\"92\":1}}],[\"5m\",{\"1\":{\"132\":1,\"133\":1,\"138\":1,\"139\":3,\"148\":5,\"162\":2,\"163\":2,\"171\":3}}],[\"5\",{\"1\":{\"124\":1,\"135\":1,\"146\":1,\"148\":1,\"154\":3,\"215\":1,\"223\":1,\"251\":2}}],[\"5<\",{\"1\":{\"113\":1}}],[\"财物权限不够\",{\"1\":{\"92\":2}}],[\"财务\",{\"1\":{\"92\":1}}],[\"审批不通过\",{\"1\":{\"92\":1}}],[\"审批通过\",{\"1\":{\"92\":1}}],[\"审批拒绝\",{\"1\":{\"92\":1}}],[\"里面有具体的处理逻辑\",{\"1\":{\"92\":1}}],[\"里氏代换原则是继承复用的基石\",{\"1\":{\"70\":1}}],[\"里氏替换原则\",{\"1\":{\"70\":1}}],[\"继承了aproval\",{\"1\":{\"92\":1}}],[\"经常选择使用对象的一些属性进行比较\",{\"1\":{\"253\":1}}],[\"经常需要新的项目中需要对老代码进行适配才能用\",{\"1\":{\"81\":1}}],[\"经理权限不够\",{\"1\":{\"92\":2}}],[\"经理审批通过\",{\"1\":{\"92\":1}}],[\"经历\",{\"1\":{\"92\":1}}],[\"后向节点为\",{\"1\":{\"190\":1}}],[\"后面的文章将以案例的形式介绍socketchannel\",{\"1\":{\"230\":1}}],[\"后面的元素向前移动\",{\"1\":{\"184\":1}}],[\"后面的值会覆盖前面的值\",{\"1\":{\"176\":1}}],[\"后面加一些功能\",{\"1\":{\"88\":1}}],[\"后使用压缩解压装饰器\",{\"1\":{\"87\":1}}],[\"满足单一职责的原则\",{\"1\":{\"88\":1}}],[\"满足里氏替换原则\",{\"1\":{\"83\":1}}],[\"希望继承原有类的功能\",{\"1\":{\"88\":1}}],[\"达到不同的效果\",{\"1\":{\"88\":1}}],[\"解决这些冲突需要额外的语法规则和解析过程\",{\"1\":{\"242\":1}}],[\"解析\",{\"1\":{\"192\":1}}],[\"解缩后的内容为\",{\"1\":{\"87\":2}}],[\"解密后\",{\"1\":{\"87\":2}}],[\"解释器模式\",{\"1\":{\"68\":1}}],[\"压缩后的内容为\",{\"1\":{\"87\":2}}],[\"压缩解压装饰器\",{\"1\":{\"87\":1}}],[\"+name2\",{\"1\":{\"240\":1}}],[\"+name1\",{\"1\":{\"240\":1}}],[\"+name\",{\"1\":{\"240\":1}}],[\"++counter\",{\"1\":{\"217\":1}}],[\"++j\",{\"1\":{\"199\":1}}],[\"++bincount\",{\"1\":{\"198\":1}}],[\"+sum\",{\"1\":{\"141\":1}}],[\"+prometheus\",{\"1\":{\"141\":1}}],[\"+inf\",{\"1\":{\"134\":1,\"154\":1}}],[\"+obj\",{\"1\":{\"106\":1}}],[\"+\",{\"1\":{\"97\":1,\"103\":1,\"112\":2,\"141\":1,\"153\":1,\"154\":1,\"174\":4,\"175\":3,\"176\":9,\"181\":1,\"182\":2,\"183\":8,\"184\":1,\"186\":1,\"188\":18,\"191\":3,\"192\":3,\"197\":2,\"199\":1,\"207\":1,\"215\":19,\"217\":4,\"228\":2,\"237\":2,\"253\":1,\"254\":2,\"258\":3}}],[\"+rw\",{\"1\":{\"87\":1}}],[\"+filereaderwriter\",{\"1\":{\"87\":1}}],[\"+text\",{\"1\":{\"87\":1}}],[\"+=\",{\"1\":{\"87\":1,\"217\":1}}],[\"udp\",{\"1\":{\"226\":1}}],[\"utf\",{\"1\":{\"236\":1}}],[\"utm\",{\"1\":{\"218\":1}}],[\"util\",{\"1\":{\"106\":2,\"174\":2,\"175\":2,\"176\":2,\"215\":1,\"217\":3,\"236\":1,\"237\":1}}],[\"updated\",{\"1\":{\"174\":4,\"175\":2,\"176\":2}}],[\"up\",{\"1\":{\"171\":1}}],[\"url\",{\"1\":{\"162\":1,\"163\":1}}],[\"uri\",{\"1\":{\"154\":4,\"156\":2}}],[\"uri=request\",{\"1\":{\"154\":1}}],[\"uri=\",{\"1\":{\"153\":3,\"154\":15}}],[\"unread\",{\"1\":{\"223\":1}}],[\"unlink\",{\"1\":{\"192\":4}}],[\"unless\",{\"1\":{\"143\":1}}],[\"unchecked异常不要求在代码中进行处理或声明\",{\"1\":{\"254\":1}}],[\"unchecked\",{\"1\":{\"186\":1,\"254\":1}}],[\"unknown\",{\"1\":{\"153\":1,\"154\":1}}],[\"union\",{\"1\":{\"143\":1}}],[\"usually\",{\"1\":{\"163\":3}}],[\"user\",{\"1\":{\"153\":1,\"154\":1}}],[\"users\",{\"1\":{\"87\":1}}],[\"used\",{\"1\":{\"124\":1,\"217\":4,\"260\":1}}],[\"use\",{\"1\":{\"124\":1,\"171\":1}}],[\"us\",{\"1\":{\"97\":1}}],[\"uml图如下\",{\"1\":{\"105\":1}}],[\"uml图\",{\"0\":{\"86\":1,\"96\":1,\"99\":1,\"102\":1}}],[\"uml\",{\"1\":{\"81\":1,\"109\":1}}],[\"加\",{\"1\":{\"141\":1}}],[\"加减密装饰器和压缩解缩的装饰器\",{\"1\":{\"87\":1}}],[\"加密后\",{\"1\":{\"87\":2}}],[\"加密装饰器\",{\"1\":{\"87\":1}}],[\"加密展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"嵌套了两个装饰器\",{\"1\":{\"87\":1}}],[\"写\",{\"1\":{\"229\":1,\"234\":1}}],[\"写数据未指定位置\",{\"1\":{\"223\":1}}],[\"写入数据到缓冲区\",{\"1\":{\"228\":1}}],[\"写入数据\",{\"1\":{\"223\":1,\"232\":1,\"233\":1}}],[\"写一个接口如下\",{\"1\":{\"166\":1}}],[\"写一个观察者接口observer\",{\"1\":{\"106\":1}}],[\"写一个客户端实现类\",{\"1\":{\"110\":1}}],[\"写一个客户端用于测试\",{\"1\":{\"100\":1}}],[\"写一个客户端\",{\"1\":{\"97\":1}}],[\"写一个客户端测试类\",{\"1\":{\"87\":1,\"106\":1}}],[\"写一个测试类\",{\"1\":{\"92\":1,\"103\":1,\"113\":1,\"240\":1}}],[\"写作日期为\",{\"1\":{\"43\":1}}],[\"<<class>>\",{\"1\":{\"254\":3}}],[\"<<\",{\"1\":{\"199\":2,\"217\":3}}],[\"<duration>\",{\"1\":{\"169\":1}}],[\"<dependency>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"<rfc3339>\",{\"1\":{\"166\":2}}],[\"<resolved|firing>\",{\"1\":{\"166\":2}}],[\"<object>\",{\"1\":{\"166\":5}}],[\"<int>\",{\"1\":{\"166\":1}}],[\"<string>\",{\"1\":{\"166\":5}}],[\"<scope>test<\",{\"1\":{\"153\":1}}],[\"<version>1\",{\"1\":{\"153\":1,\"154\":3}}],[\"<vector\",{\"1\":{\"146\":1}}],[\"<groupid>io\",{\"1\":{\"153\":1,\"154\":3}}],[\"<groupid>org\",{\"1\":{\"153\":2}}],[\"<groupid>cglib<\",{\"1\":{\"113\":1}}],[\"<label\",{\"1\":{\"146\":1}}],[\"<artifactid>prometheus\",{\"1\":{\"154\":3}}],[\"<artifactid>micrometer\",{\"1\":{\"153\":1}}],[\"<artifactid>spring\",{\"1\":{\"153\":2}}],[\"<artifactid>cglib<\",{\"1\":{\"113\":1}}],[\"<aggr\",{\"1\":{\"146\":1}}],[\"<=\",{\"1\":{\"142\":1,\"183\":2,\"197\":1}}],[\"<\",{\"1\":{\"87\":2,\"92\":2,\"106\":1,\"113\":1,\"130\":1,\"142\":1,\"149\":1,\"153\":3,\"154\":3,\"183\":2,\"184\":2,\"185\":2,\"186\":1,\"191\":3,\"192\":1,\"197\":1,\"199\":2,\"215\":1,\"217\":10,\"253\":1}}],[\"woof\",{\"1\":{\"246\":2}}],[\"wordsinuse\",{\"1\":{\"215\":2}}],[\"words\",{\"1\":{\"215\":3}}],[\"we\",{\"1\":{\"171\":1}}],[\"webmvcconfigurer\",{\"1\":{\"154\":1}}],[\"webconfig\",{\"1\":{\"154\":1}}],[\"web\",{\"1\":{\"126\":2,\"153\":1,\"154\":2,\"162\":2,\"163\":2}}],[\"webhook\",{\"0\":{\"166\":1},\"1\":{\"120\":1,\"162\":1,\"163\":2,\"166\":7}}],[\"www\",{\"1\":{\"167\":1}}],[\"wuhan\",{\"1\":{\"164\":1,\"172\":1}}],[\"wangwu\",{\"1\":{\"240\":1}}],[\"warning\",{\"1\":{\"162\":1,\"163\":2}}],[\"wait\",{\"1\":{\"162\":1,\"163\":6}}],[\"w\",{\"1\":{\"138\":1,\"228\":1}}],[\"windows系统和mac系统\",{\"1\":{\"125\":1}}],[\"windows\",{\"1\":{\"123\":1}}],[\"without\",{\"1\":{\"146\":1,\"171\":4}}],[\"without|by\",{\"1\":{\"146\":1}}],[\"with\",{\"1\":{\"87\":1,\"146\":1,\"180\":1,\"181\":1}}],[\"which\",{\"1\":{\"163\":2}}],[\"while\",{\"1\":{\"87\":2,\"199\":1,\"200\":1,\"227\":2,\"228\":3,\"232\":1,\"233\":1,\"234\":2,\"236\":5,\"237\":2,\"252\":1}}],[\"where\",{\"1\":{\"28\":1}}],[\"writer\",{\"1\":{\"221\":1,\"223\":1}}],[\"write\",{\"1\":{\"87\":10,\"227\":2,\"229\":1,\"232\":2,\"233\":1,\"234\":1,\"236\":4,\"237\":1}}],[\"也返回true\",{\"1\":{\"252\":1}}],[\"也应返回true\",{\"1\":{\"252\":2}}],[\"也不会影响其他连接的数据已就绪的读写事件\",{\"1\":{\"238\":1}}],[\"也不会频繁创建对象\",{\"1\":{\"76\":1}}],[\"也能进行写操作\",{\"1\":{\"223\":1}}],[\"也保存了链表在添加和删除元素时效率快的特点\",{\"1\":{\"204\":1}}],[\"也支持动态扩容和再散列\",{\"1\":{\"201\":1}}],[\"也就是说\",{\"1\":{\"246\":1}}],[\"也就是说linkedlist可以被当做队列使用\",{\"1\":{\"188\":1}}],[\"也就是能够根据需求\",{\"1\":{\"88\":1}}],[\"也查询handler不为\",{\"1\":{\"137\":1}}],[\"也适合高度动态的面向服务的体系结构的监视\",{\"1\":{\"121\":1}}],[\"也让代码扩展变得非常困难\",{\"1\":{\"107\":1}}],[\"也称为静态工厂方法模式\",{\"1\":{\"95\":1}}],[\"也有可能影响系统的性能\",{\"1\":{\"93\":1}}],[\"也可以在构造函数中赋值\",{\"1\":{\"257\":1}}],[\"也可以认为是一个辅助工具\",{\"1\":{\"223\":1}}],[\"也可以从尾结点遍历到头结点\",{\"1\":{\"188\":1}}],[\"也可以进行模糊匹配\",{\"1\":{\"137\":1}}],[\"也可以配置静态采集任务\",{\"1\":{\"124\":1}}],[\"也可以是consul\",{\"1\":{\"120\":1}}],[\"也可以是短生命周期的任务推送到pushgateway的指标\",{\"1\":{\"120\":1}}],[\"也可以是一个抽象类\",{\"1\":{\"91\":1}}],[\"也可以通过静态的配置去发现采集目标\",{\"1\":{\"118\":1}}],[\"也可以使用\",{\"1\":{\"137\":1}}],[\"也可以使用多个标签值进行进行查询\",{\"1\":{\"137\":1}}],[\"也可以使用push模式\",{\"1\":{\"118\":1}}],[\"也可以使用第三方时序数据去存储\",{\"1\":{\"118\":1}}],[\"也可以深入到进程内部关键点的监控\",{\"1\":{\"118\":1}}],[\"也可以用它来向观察者发送消息\",{\"1\":{\"106\":1}}],[\"也可以根据需求快速的删除一些逻辑单元\",{\"1\":{\"93\":1}}],[\"也可以读取文件的字符\",{\"1\":{\"87\":1}}],[\"也可以把他们的顺序对调\",{\"1\":{\"87\":1}}],[\"做下面的增强功能\",{\"1\":{\"87\":1}}],[\"装饰模式不改变原有类的结构\",{\"1\":{\"86\":1}}],[\"装饰器非常的灵活\",{\"1\":{\"86\":1}}],[\"装饰器componentdecoratorb和componentdecoratora\",{\"1\":{\"86\":1}}],[\"装饰器模式的主角\",{\"1\":{\"223\":1}}],[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能\",{\"1\":{\"67\":1,\"85\":1}}],[\"装饰器模式经常使用到以下场景\",{\"1\":{\"86\":1}}],[\"装饰器模式\",{\"0\":{\"85\":1},\"1\":{\"67\":1,\"69\":1}}],[\"什么是time\",{\"0\":{\"130\":1}}],[\"什么是prometheus\",{\"0\":{\"117\":1}}],[\"什么是单例模式\",{\"0\":{\"72\":1}}],[\"什么时候使用装饰器模式\",{\"1\":{\"86\":1}}],[\"组内的规则以固定的时间间隔按顺序运行\",{\"1\":{\"169\":1}}],[\"组成了链式的执行顺序\",{\"1\":{\"90\":1}}],[\"组件\",{\"0\":{\"119\":1}}],[\"组件实现类componentimpl\",{\"1\":{\"86\":1}}],[\"组件component\",{\"1\":{\"86\":1}}],[\"组合优先原则\",{\"1\":{\"70\":1}}],[\"组合模式\",{\"1\":{\"67\":1}}],[\"相应的try语句一定被执行到\",{\"1\":{\"260\":1}}],[\"相等性\",{\"1\":{\"253\":1}}],[\"相对于传统的\",{\"1\":{\"225\":1}}],[\"相对于简单工厂\",{\"1\":{\"100\":1}}],[\"相同的元素可以出现在列表的不同位置\",{\"1\":{\"174\":1}}],[\"相比之下\",{\"1\":{\"244\":1}}],[\"相比\",{\"1\":{\"238\":1}}],[\"相比java动态代理而言更为复杂\",{\"1\":{\"113\":1}}],[\"相比java动态代理\",{\"1\":{\"113\":1}}],[\"相比直接调用实现类的方法\",{\"1\":{\"112\":1}}],[\"相当于对原有的类进行类一个包装\",{\"1\":{\"85\":1}}],[\"相关信息\",{\"1\":{\"15\":1}}],[\"互不干扰\",{\"1\":{\"83\":1}}],[\"拓展新的适配者类功能\",{\"1\":{\"83\":1}}],[\"拓展坞将typec接口转换成usb接口\",{\"1\":{\"82\":1}}],[\"拓展坞适配器\",{\"1\":{\"82\":1}}],[\"难以维护\",{\"1\":{\"83\":1}}],[\"首先打开一个\",{\"1\":{\"236\":1}}],[\"首先通过\",{\"1\":{\"227\":1}}],[\"首先将\",{\"1\":{\"200\":1}}],[\"首先会检查当前的\",{\"1\":{\"199\":1}}],[\"首先我们先创建一个hashmap对象\",{\"1\":{\"198\":1}}],[\"首先保存节点\",{\"1\":{\"192\":1}}],[\"首先创建一个\",{\"1\":{\"237\":1}}],[\"首先创建一个容量为\",{\"1\":{\"228\":1}}],[\"首先创建一个新的节点\",{\"1\":{\"190\":1}}],[\"首先创建一个审批抽象类aproval\",{\"1\":{\"92\":1}}],[\"首先检查\",{\"1\":{\"186\":1}}],[\"首先调用\",{\"1\":{\"186\":1}}],[\"首先\",{\"1\":{\"83\":1,\"87\":1,\"184\":1,\"198\":1,\"200\":1,\"258\":1}}],[\"新数组已经将就数据拷贝\",{\"1\":{\"183\":1}}],[\"新建一个recoding\",{\"1\":{\"172\":1}}],[\"新建一个springboot项目\",{\"1\":{\"153\":1}}],[\"新增产品族\",{\"1\":{\"103\":1}}],[\"新增一族产品时\",{\"1\":{\"103\":1}}],[\"新增一个逻辑功能\",{\"1\":{\"93\":1}}],[\"新写一个方法就可以将需要适配的类进行转换\",{\"1\":{\"83\":1}}],[\"新的序列名称为record中的值\",{\"1\":{\"169\":1}}],[\"新的软件开发模式\",{\"1\":{\"64\":1}}],[\"新的工具\",{\"1\":{\"64\":1}}],[\"新的框架\",{\"1\":{\"64\":1}}],[\"才能进行适配工作\",{\"1\":{\"82\":1}}],[\"才会初始化内部类\",{\"1\":{\"76\":1}}],[\"zero\",{\"1\":{\"254\":1}}],[\"zhihu\",{\"1\":{\"218\":1}}],[\"zhuanlan\",{\"1\":{\"218\":1}}],[\"z0\",{\"1\":{\"130\":1}}],[\"za\",{\"1\":{\"130\":2}}],[\"zxvf\",{\"1\":{\"123\":1,\"127\":1}}],[\"zkt5tvq5eu1zoxnktuzrt1q6zu17ddlhqkvfsennot4=\",{\"1\":{\"87\":1}}],[\"z\",{\"1\":{\"82\":2,\"130\":1,\"252\":2}}],[\"y和z\",{\"1\":{\"252\":1}}],[\"yunlzheng\",{\"1\":{\"167\":1}}],[\"yml去配置所有的告警规则文件\",{\"1\":{\"164\":1}}],[\"yml的文件\",{\"1\":{\"164\":1,\"172\":1}}],[\"yml中\",{\"1\":{\"125\":1}}],[\"yml\",{\"1\":{\"124\":3,\"162\":1,\"164\":1,\"172\":2}}],[\"y\",{\"1\":{\"82\":5,\"138\":1,\"252\":3}}],[\"xor\",{\"1\":{\"215\":1}}],[\"xpost\",{\"1\":{\"126\":1}}],[\"x\",{\"1\":{\"82\":5,\"191\":8,\"192\":25,\"252\":4}}],[\"实例\",{\"1\":{\"229\":1}}],[\"实际调用的是该对象的实际类型中定义的方法\",{\"1\":{\"246\":1}}],[\"实际上调用的是\",{\"1\":{\"246\":1}}],[\"实际上会调用子类中的方法\",{\"1\":{\"246\":1}}],[\"实际上是使用\",{\"1\":{\"204\":1}}],[\"实际的文章内容\",{\"1\":{\"10\":1}}],[\"实战\",{\"0\":{\"172\":1}}],[\"实现接口的类必须提供所有抽象方法的具体实现\",{\"1\":{\"241\":1}}],[\"实现方式\",{\"1\":{\"241\":1}}],[\"实现方式有两种\",{\"1\":{\"152\":1}}],[\"实现类也可以重写接口的默认方法\",{\"1\":{\"241\":1}}],[\"实现高效的多路复用\",{\"1\":{\"232\":1,\"233\":1}}],[\"实现高效的数据处理\",{\"1\":{\"228\":1}}],[\"实现的\",{\"1\":{\"204\":1}}],[\"实现\",{\"1\":{\"186\":1}}],[\"实现代理如下\",{\"1\":{\"112\":1}}],[\"实现被代理对象的接口\",{\"1\":{\"109\":1}}],[\"实现抽象工厂类中定义的工厂方法makesofa\",{\"1\":{\"99\":1}}],[\"实现了java的跨平台特性\",{\"1\":{\"255\":1}}],[\"实现了多态性的特性\",{\"1\":{\"246\":1}}],[\"实现了代码的灵活性和扩展性\",{\"1\":{\"246\":1}}],[\"实现了零拷贝的优化功能\",{\"1\":{\"238\":1}}],[\"实现了高效的数据传输\",{\"1\":{\"226\":1}}],[\"实现了动态调整数组容量\",{\"1\":{\"180\":1}}],[\"实现了\",{\"1\":{\"179\":1,\"241\":1}}],[\"实现了抽象主题类\",{\"1\":{\"110\":1}}],[\"实现了抽象主题类的方法\",{\"1\":{\"109\":1}}],[\"实现了抽象接口类\",{\"1\":{\"109\":1}}],[\"实现了抽象工厂\",{\"1\":{\"103\":1}}],[\"实现了抽象工厂接口\",{\"1\":{\"102\":1}}],[\"实现了抽象产品类的属性和方法\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"实现了itypec的目标接口接口\",{\"1\":{\"82\":1}}],[\"实现了usb接口\",{\"1\":{\"81\":1}}],[\"持有适配者的类keyboard\",{\"1\":{\"81\":1}}],[\"目前支持linux系统\",{\"1\":{\"125\":1}}],[\"目前提供了linux\",{\"1\":{\"123\":1}}],[\"目标警报和源警报在相等列表中的标签名称必须具有相同的标签值\",{\"1\":{\"163\":1}}],[\"目标\",{\"1\":{\"163\":1}}],[\"目标类和适配者类是通过适配器进行交互的\",{\"1\":{\"83\":1}}],[\"目标类和适配者类各司其职\",{\"1\":{\"83\":1}}],[\"目标类target\",{\"1\":{\"81\":1}}],[\"目标接口itypec\",{\"1\":{\"82\":1}}],[\"目录\",{\"0\":{\"5\":1}}],[\"从父类继承过来的方法\",{\"1\":{\"246\":1}}],[\"从缓冲区重新读取数据\",{\"1\":{\"228\":1}}],[\"从缓冲区读取剩余数据\",{\"1\":{\"228\":1}}],[\"从缓冲区读取部分数据\",{\"1\":{\"228\":1}}],[\"从缓冲区读取数据\",{\"1\":{\"228\":2}}],[\"从文件中读取数据\",{\"1\":{\"227\":1}}],[\"从文件中读取数据到缓冲区\",{\"1\":{\"227\":1}}],[\"从文件中读写数据\",{\"1\":{\"225\":1}}],[\"从尾节点开始向前遍历\",{\"1\":{\"191\":2}}],[\"从头节点开始向后遍历\",{\"1\":{\"191\":2}}],[\"从集合中删除元素\",{\"1\":{\"175\":1}}],[\"从而触发异常处理机制\",{\"1\":{\"254\":1}}],[\"从而达到类似多继承的效果\",{\"1\":{\"242\":1}}],[\"从而达到以下目的\",{\"1\":{\"121\":1}}],[\"从而使得一个实现类有不同接口的多态性\",{\"1\":{\"241\":1}}],[\"从而提高了系统的吞吐量和响应速度\",{\"1\":{\"225\":1}}],[\"从而提高整个系统的性能\",{\"1\":{\"72\":1}}],[\"从而导致一些系统问题\",{\"1\":{\"159\":1}}],[\"从而能够对问题进行快速的处理或者提前预防问题的发生\",{\"1\":{\"121\":1}}],[\"从2012年开始由前google工程师以开源软件的形式进行研发\",{\"1\":{\"117\":1}}],[\"从uml图上可以得出\",{\"1\":{\"105\":1}}],[\"从上面的图中可以看出java\",{\"1\":{\"223\":1}}],[\"从上面的\",{\"1\":{\"109\":1}}],[\"从上面的分析原因我们可以得出\",{\"1\":{\"93\":1}}],[\"从上面的使用场景\",{\"1\":{\"93\":1}}],[\"从该uml中中\",{\"1\":{\"91\":1}}],[\"从\",{\"1\":{\"81\":1}}],[\"给键盘使用\",{\"1\":{\"81\":1}}],[\"给用于定义语言的语法规则表示\",{\"1\":{\"68\":1}}],[\"今天这一讲\",{\"1\":{\"81\":1}}],[\"gitbook\",{\"1\":{\"167\":1}}],[\"github\",{\"1\":{\"80\":2,\"92\":2,\"106\":5,\"125\":1,\"154\":1,\"236\":1,\"237\":1,\"260\":1}}],[\"g\",{\"1\":{\"166\":1}}],[\"gloabl配置\",{\"1\":{\"163\":1}}],[\"global\",{\"1\":{\"124\":4,\"162\":2,\"163\":1,\"169\":1}}],[\"gauge类型的指标主要反映的是当前的状态\",{\"1\":{\"133\":1}}],[\"gauge仪表盘\",{\"0\":{\"133\":1}}],[\"gauge\",{\"1\":{\"124\":4,\"131\":1,\"153\":1}}],[\"garbage\",{\"1\":{\"124\":1,\"135\":1}}],[\"gateway是用来短暂存储push类型指标的\",{\"1\":{\"119\":1}}],[\"gateway\",{\"1\":{\"118\":1}}],[\"gc\",{\"1\":{\"124\":9,\"135\":10}}],[\"go1\",{\"1\":{\"124\":1}}],[\"goroutines\",{\"1\":{\"124\":4}}],[\"go\",{\"1\":{\"124\":25,\"135\":9}}],[\"gz\",{\"1\":{\"123\":1,\"127\":2}}],[\"greeting\",{\"1\":{\"240\":4}}],[\"greater\",{\"1\":{\"142\":2}}],[\"growth\",{\"1\":{\"183\":2}}],[\"grow\",{\"1\":{\"182\":1,\"183\":3}}],[\"group执行的时间间隔\",{\"1\":{\"169\":1}}],[\"group的名称\",{\"1\":{\"169\":1}}],[\"group可以配置两个参数\",{\"1\":{\"169\":1}}],[\"grouplabels\",{\"1\":{\"166\":2}}],[\"groupkey\",{\"1\":{\"166\":2}}],[\"groups\",{\"1\":{\"164\":1,\"169\":2,\"172\":1}}],[\"grouped\",{\"1\":{\"163\":1}}],[\"group\",{\"0\":{\"145\":1},\"1\":{\"145\":3,\"146\":1,\"162\":3,\"163\":9,\"166\":1}}],[\"groupid>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"grass\",{\"1\":{\"240\":2}}],[\"grapes\",{\"1\":{\"174\":3}}],[\"graph\",{\"1\":{\"125\":1}}],[\"grafna的安装\",{\"1\":{\"122\":1}}],[\"grafana作为数据展示前端\",{\"1\":{\"128\":1}}],[\"grafana的默认登陆用户名admin\",{\"1\":{\"127\":1}}],[\"grafana有很多配置项在conf目录下default\",{\"1\":{\"127\":1}}],[\"grafana可以完美的和prometheus结合\",{\"1\":{\"127\":1}}],[\"grafana是一个开源的\",{\"1\":{\"127\":1}}],[\"grafana安装\",{\"0\":{\"127\":1}}],[\"grafana\",{\"1\":{\"115\":1,\"127\":6}}],[\"generatorurl\",{\"1\":{\"166\":2}}],[\"generation\",{\"1\":{\"113\":1}}],[\"getmessage\",{\"1\":{\"254\":1}}],[\"getage\",{\"1\":{\"257\":1}}],[\"getarea\",{\"1\":{\"241\":4}}],[\"getattribute\",{\"1\":{\"154\":1}}],[\"getchannel\",{\"1\":{\"227\":2}}],[\"getclassloader\",{\"1\":{\"112\":1}}],[\"getclass\",{\"1\":{\"112\":2,\"113\":1,\"181\":1}}],[\"gettreenode\",{\"1\":{\"200\":2}}],[\"getvalue\",{\"1\":{\"176\":2}}],[\"getkey\",{\"1\":{\"176\":2}}],[\"getrequesturi\",{\"1\":{\"154\":1}}],[\"getproxyinstance\",{\"1\":{\"113\":2}}],[\"getinterfaces\",{\"1\":{\"112\":1}}],[\"getinstance\",{\"1\":{\"74\":1,\"75\":1,\"78\":1,\"79\":1}}],[\"get\",{\"0\":{\"191\":1},\"1\":{\"106\":1,\"145\":6,\"153\":3,\"171\":1,\"174\":2,\"176\":2,\"185\":2,\"188\":2,\"191\":4,\"200\":3,\"215\":4,\"217\":4,\"227\":1,\"228\":8,\"236\":1,\"237\":1}}],[\"getnode\",{\"1\":{\"200\":4}}],[\"getname\",{\"1\":{\"97\":4,\"103\":3,\"112\":2,\"257\":1}}],[\"getnextapproval\",{\"1\":{\"92\":3}}],[\"getdecoder\",{\"1\":{\"87\":2}}],[\"getencoder\",{\"1\":{\"87\":2}}],[\"getbytes\",{\"1\":{\"87\":2,\"227\":1,\"232\":1,\"233\":1,\"236\":2,\"237\":1}}],[\"getsingleton\",{\"1\":{\"76\":1}}],[\"get­instance\",{\"1\":{\"73\":1}}],[\"下面我们来分析其中一个常用的构造函数\",{\"1\":{\"207\":1}}],[\"下面是一个使用\",{\"1\":{\"228\":1}}],[\"下面是hashset的类结构图\",{\"1\":{\"203\":1}}],[\"下面是\",{\"1\":{\"192\":1,\"200\":1,\"208\":1,\"209\":1,\"210\":1}}],[\"下面是java\",{\"1\":{\"173\":1}}],[\"下面是懒汉模式的线程安全的\",{\"1\":{\"79\":1}}],[\"下面是最简单的懒汉模式的单列模式\",{\"1\":{\"78\":1}}],[\"下一个节点和上一个节点\",{\"1\":{\"188\":1}}],[\"下一个元素的索引\",{\"1\":{\"186\":1}}],[\"下一篇\",{\"1\":{\"7\":1}}],[\"下载地址\",{\"1\":{\"162\":1}}],[\"下载地址为\",{\"1\":{\"125\":1}}],[\"下载地址为https\",{\"1\":{\"123\":1}}],[\"下载并解压成功后\",{\"1\":{\"127\":1}}],[\"下载命令如下\",{\"1\":{\"127\":1}}],[\"下载完成后\",{\"1\":{\"123\":1,\"125\":1}}],[\"下图是prometheus和它周边生态组件的架构图\",{\"1\":{\"120\":1}}],[\"懒汉模式\",{\"0\":{\"78\":1,\"79\":1}}],[\"jdb\",{\"1\":{\"255\":1}}],[\"jdk1\",{\"1\":{\"258\":1}}],[\"jdk包含jre\",{\"1\":{\"255\":1}}],[\"jdk还提供了各种开发文档和示例代码\",{\"1\":{\"255\":1}}],[\"jdk\",{\"0\":{\"255\":1},\"1\":{\"196\":1,\"225\":1,\"255\":1}}],[\"jdk动态代理\",{\"1\":{\"112\":1}}],[\"jre包含jvm\",{\"1\":{\"255\":1}}],[\"jre只提供了java应用程序的运行环境\",{\"1\":{\"255\":1}}],[\"jre\",{\"0\":{\"255\":1},\"1\":{\"255\":1}}],[\"j\",{\"1\":{\"199\":7,\"217\":9,\"245\":1}}],[\"jar\",{\"1\":{\"255\":1}}],[\"james\",{\"1\":{\"198\":2}}],[\"java会将这个变量复制一份作为成员变量内置于内部类中\",{\"1\":{\"258\":1}}],[\"java会自动调用相应的包装类方法\",{\"1\":{\"245\":1}}],[\"javac\",{\"1\":{\"255\":1}}],[\"java语言中提供了一些列的异常处理关键字和处理模板\",{\"1\":{\"254\":1}}],[\"java允许开发者自定义异常类\",{\"1\":{\"254\":1}}],[\"java中的异常处理机制旨在捕获和处理程序中可能发生的异常情况\",{\"1\":{\"254\":1}}],[\"java中的异常处理机制\",{\"0\":{\"254\":1}}],[\"java不允许在方法中使用同名的不同类型的参数\",{\"1\":{\"245\":1}}],[\"java不支持多继承是为了避免多继承带来的上述问题\",{\"1\":{\"242\":1}}],[\"java是一种面向对象的语言\",{\"1\":{\"245\":1}}],[\"java的异常处理机制是java程序设计中非常重要的一个方面\",{\"1\":{\"254\":1}}],[\"java的泛型不支持基本类型\",{\"1\":{\"245\":1}}],[\"java的设计理念是\",{\"1\":{\"242\":1}}],[\"java基础高频面试题2\",{\"0\":{\"249\":1}}],[\"java基础高频面试题1\",{\"0\":{\"239\":1}}],[\"java基本类型\",{\"1\":{\"245\":1}}],[\"java基本类型为什么需要包装类\",{\"0\":{\"245\":1}}],[\"java选择了单继承并使用了接口\",{\"1\":{\"242\":1}}],[\"java支持多实现\",{\"1\":{\"241\":1}}],[\"java只支持单继承\",{\"1\":{\"241\":1}}],[\"javabasiclab\",{\"1\":{\"236\":1,\"237\":1,\"260\":1}}],[\"javaio的类图结构如下\",{\"1\":{\"222\":1}}],[\"java流类图结构\",{\"0\":{\"222\":1}}],[\"java提供了对应的包装类来对基本类型进行包装\",{\"1\":{\"245\":1}}],[\"java提供了bitset来实现位图\",{\"1\":{\"213\":1}}],[\"java提供了java\",{\"1\":{\"112\":1}}],[\"javax\",{\"1\":{\"154\":2}}],[\"java动态代理不需要任何依赖\",{\"1\":{\"112\":1}}],[\"java动态代理是基于反射生产的一个代理类\",{\"1\":{\"112\":1}}],[\"java后端技术\",{\"0\":{\"0\":1}}],[\"java\",{\"0\":{\"0\":1,\"112\":1,\"173\":1,\"219\":1,\"223\":1,\"224\":1,\"231\":1},\"1\":{\"80\":3,\"92\":2,\"106\":7,\"111\":1,\"112\":3,\"173\":4,\"174\":3,\"175\":2,\"176\":2,\"179\":1,\"180\":1,\"195\":1,\"201\":1,\"203\":1,\"215\":1,\"217\":2,\"220\":3,\"221\":1,\"223\":3,\"225\":13,\"226\":2,\"227\":3,\"228\":3,\"232\":1,\"233\":1,\"234\":1,\"236\":11,\"237\":7,\"241\":4,\"246\":3,\"250\":1,\"255\":4}}],[\"jieshao\",{\"1\":{\"238\":1}}],[\"ji\",{\"1\":{\"167\":1}}],[\"jianshu\",{\"1\":{\"167\":1}}],[\"jvm解析java字节码\",{\"1\":{\"255\":1}}],[\"jvm的区别和联系\",{\"0\":{\"255\":1}}],[\"jvm\",{\"1\":{\"254\":1,\"255\":1}}],[\"jvm规范没有明确规定其所占的空间大小\",{\"1\":{\"251\":1}}],[\"jvm是用于暴露jvm相关的指标\",{\"1\":{\"154\":1}}],[\"jvm<\",{\"1\":{\"154\":1}}],[\"jvm在执行类的初始化的时候\",{\"1\":{\"76\":1}}],[\"job=\",{\"1\":{\"133\":1,\"146\":1,\"149\":1,\"150\":10,\"171\":9}}],[\"job\",{\"1\":{\"124\":1,\"125\":2,\"146\":2,\"155\":1,\"169\":2,\"171\":2}}],[\"延迟初始化\",{\"1\":{\"76\":1}}],[\"有animal的父类\",{\"1\":{\"240\":1}}],[\"有无限个\",{\"1\":{\"217\":1}}],[\"有8\",{\"1\":{\"214\":1}}],[\"有两种构造函数\",{\"1\":{\"197\":1}}],[\"有两个greeting方法\",{\"1\":{\"240\":1}}],[\"有两个标签分别是instance和path\",{\"1\":{\"171\":1}}],[\"有两个目标\",{\"1\":{\"64\":1}}],[\"有一个eat的方法\",{\"1\":{\"240\":1}}],[\"有一个对象数组\",{\"1\":{\"180\":1}}],[\"有一个核心的抽象处理方法handle\",{\"1\":{\"92\":1}}],[\"有序性\",{\"1\":{\"174\":1}}],[\"有1828个请求\",{\"1\":{\"134\":1}}],[\"有1827个请求\",{\"1\":{\"134\":1}}],[\"有相同指标名和标签构成的\",{\"1\":{\"130\":1}}],[\"有着非常大的创新\",{\"1\":{\"118\":1}}],[\"有以下的角色\",{\"1\":{\"105\":1}}],[\"有以下的优点在\",{\"1\":{\"76\":1}}],[\"有很多同类型的产品生产\",{\"1\":{\"101\":1}}],[\"伪代码的2\",{\"1\":{\"75\":1}}],[\"伪代码如下\",{\"1\":{\"75\":1}}],[\"当发生异常时\",{\"1\":{\"260\":2}}],[\"当发布者发布消息\",{\"1\":{\"105\":1}}],[\"当没有发生异常时\",{\"1\":{\"260\":1}}],[\"当变量被声明为final时\",{\"1\":{\"257\":1,\"259\":1}}],[\"当方法被声明为final时\",{\"1\":{\"257\":1,\"259\":1}}],[\"当类被声明为final时\",{\"1\":{\"257\":1,\"259\":1}}],[\"当用户在目标机器上运行java应用程序时\",{\"1\":{\"255\":1}}],[\"当try块中的代码发生异常时\",{\"1\":{\"254\":1}}],[\"当我们在重写equals\",{\"1\":{\"253\":1}}],[\"当我们重写equals\",{\"1\":{\"252\":1,\"253\":1}}],[\"当使用父类引用指向子类对象时\",{\"1\":{\"246\":1}}],[\"当字符串不需要修改时\",{\"1\":{\"243\":1}}],[\"当字节和字符之间有转换动作时\",{\"1\":{\"223\":1}}],[\"当需要对字符串进行频繁的修改时\",{\"1\":{\"243\":1}}],[\"当需要频繁修改字符串时会产生大量的垃圾对象\",{\"1\":{\"243\":1}}],[\"当需要扩展新的功能\",{\"1\":{\"93\":1}}],[\"当一个类从多个父类继承相同名称的属性或方法时\",{\"1\":{\"242\":1}}],[\"当\",{\"1\":{\"238\":1}}],[\"当有新连接到来时\",{\"1\":{\"236\":1}}],[\"当有通道有感兴趣的事件发生时\",{\"1\":{\"229\":1}}],[\"当然输出部分也没有必要需要它了\",{\"1\":{\"223\":1}}],[\"当然actuator有很多内置的指标\",{\"1\":{\"153\":1}}],[\"当返回值不为\",{\"1\":{\"208\":1}}],[\"当调用一个对象的方法时\",{\"1\":{\"246\":1}}],[\"当调用\",{\"1\":{\"208\":1,\"210\":1,\"238\":1,\"246\":1}}],[\"当添加元素时\",{\"1\":{\"180\":1}}],[\"当创建\",{\"1\":{\"180\":1}}],[\"当对指标用作除法\",{\"1\":{\"171\":1}}],[\"当对counter类型使用rate或者是irate操作\",{\"1\":{\"171\":1}}],[\"当对象发生改变时\",{\"1\":{\"104\":1}}],[\"当存在与另一组匹配器匹配的警报\",{\"1\":{\"163\":1}}],[\"当启动告警恢复逻辑时\",{\"1\":{\"163\":1}}],[\"当告警消息没有endts这个时间戳参数时\",{\"1\":{\"163\":1}}],[\"当集群不可用访问出发了告警\",{\"1\":{\"160\":1}}],[\"当中\",{\"1\":{\"148\":1}}],[\"当比较运算符左右与两个瞬时向量之间\",{\"1\":{\"142\":1,\"143\":1}}],[\"当问题发生后\",{\"1\":{\"121\":1}}],[\"当系统出现或者即将出现故障时\",{\"1\":{\"121\":1}}],[\"当借款金额大于10000元\",{\"1\":{\"92\":1}}],[\"当借款金额大于1000元小于5000元\",{\"1\":{\"92\":1}}],[\"当借款金额大于5000元小于10000元\",{\"1\":{\"92\":1}}],[\"当借款金额小于1000元\",{\"1\":{\"92\":1}}],[\"当声明对象的引用为volatile后\",{\"1\":{\"75\":1}}],[\"当线程1在执行上面伪代码时\",{\"1\":{\"75\":1}}],[\"线程不安全\",{\"0\":{\"78\":1,\"79\":1}}],[\"线程2访问的将是个还没初始化完毕的对象\",{\"1\":{\"75\":1}}],[\"线程2调用getsingleton方法\",{\"1\":{\"75\":1}}],[\"线程1执行到第3步时\",{\"1\":{\"75\":1}}],[\"线程安全等需要不可变性的情况\",{\"1\":{\"257\":1}}],[\"线程安全性\",{\"1\":{\"243\":1}}],[\"线程安全\",{\"0\":{\"74\":1,\"75\":1,\"76\":1},\"1\":{\"76\":1}}],[\">>>\",{\"1\":{\"198\":1}}],[\">>\",{\"1\":{\"183\":1,\"191\":1,\"217\":1}}],[\">=\",{\"1\":{\"142\":1,\"183\":1,\"185\":1,\"186\":2,\"191\":1,\"192\":1,\"198\":2,\"199\":2,\"217\":3}}],[\">\",{\"1\":{\"130\":1,\"142\":1,\"164\":1,\"181\":1,\"183\":2,\"184\":1,\"191\":1,\"197\":1,\"199\":1,\"200\":1,\"236\":1,\"253\":1}}],[\"><\",{\"1\":{\"130\":2}}],[\">2\",{\"1\":{\"75\":1}}],[\">3\",{\"1\":{\"75\":1}}],[\"步骤变为1\",{\"1\":{\"75\":1}}],[\"因为垃圾回收器的工作是由java虚拟机自动处理的\",{\"1\":{\"259\":1}}],[\"因为在运行java应用程序时需要虚拟机来解释和执行java字节码\",{\"1\":{\"255\":1}}],[\"因为在开发java应用程序时需要运行java程序来进行测试和调试\",{\"1\":{\"255\":1}}],[\"因为包装类对象在使用==比较时\",{\"1\":{\"245\":1}}],[\"因为基本类型的参数值之间无法进行隐式转换\",{\"1\":{\"245\":1}}],[\"因为数据编码的不同\",{\"1\":{\"221\":1}}],[\"因为\",{\"1\":{\"204\":1,\"209\":1,\"210\":1}}],[\"因为每个节点需要额外的存储空间来保存前向和后向指针\",{\"1\":{\"193\":1}}],[\"因为需要从头部或尾部开始遍历链表\",{\"1\":{\"193\":1}}],[\"因为只需要修改节点的指针\",{\"1\":{\"193\":1}}],[\"因为它是双链表结构\",{\"1\":{\"189\":1}}],[\"因为它是通过生成子类来代理目标类\",{\"1\":{\"113\":1}}],[\"因为太基础了\",{\"1\":{\"177\":1}}],[\"因为左侧的表达式有一个handler=\",{\"1\":{\"141\":1}}],[\"因为两个handler标签值不一样\",{\"1\":{\"141\":1}}],[\"因为重排序并不影响运行结果\",{\"1\":{\"75\":1}}],[\"因此在频繁修改字符串的场景下\",{\"1\":{\"243\":1}}],[\"因此它们之间的\",{\"1\":{\"251\":1}}],[\"因此它和非阻塞的通道\",{\"1\":{\"229\":1}}],[\"因此它可以在一个方向上读取数据\",{\"1\":{\"226\":1}}],[\"因此包含了一些常用的方法\",{\"1\":{\"175\":1}}],[\"因此可以借助于\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"13\":1,\"180\":1,\"238\":1,\"251\":1}}],[\"设计目的\",{\"1\":{\"241\":1}}],[\"设计上每个比特都是一个布尔值\",{\"1\":{\"214\":1}}],[\"设计模式的几种原则\",{\"0\":{\"70\":1}}],[\"设计模式有23种\",{\"1\":{\"69\":1}}],[\"设计模式有哪些类型\",{\"0\":{\"65\":1}}],[\"设计模式可以分为三种类型\",{\"1\":{\"65\":1}}],[\"设计模式是软件开发的一种指导思想\",{\"1\":{\"64\":1}}],[\"设计模式面试概述\",{\"0\":{\"64\":1}}],[\"设置位\",{\"1\":{\"215\":1}}],[\"设置为\",{\"1\":{\"190\":2}}],[\"设置回调函数\",{\"1\":{\"113\":1}}],[\"设置父类\",{\"1\":{\"113\":1}}],[\"设置singleton指向刚分配的内存空间\",{\"1\":{\"75\":1}}],[\"31\",{\"1\":{\"253\":1}}],[\"365\",{\"1\":{\"214\":3}}],[\"3600\",{\"1\":{\"133\":1,\"149\":1}}],[\"37843943\",{\"1\":{\"167\":1}}],[\"3776\",{\"1\":{\"150\":6}}],[\"3775\",{\"1\":{\"150\":1}}],[\"3773\",{\"1\":{\"150\":1}}],[\"3769\",{\"1\":{\"150\":1}}],[\"3767\",{\"1\":{\"150\":1}}],[\"34\",{\"1\":{\"145\":1}}],[\"3884e\",{\"1\":{\"135\":1}}],[\"3000\",{\"1\":{\"236\":1}}],[\"30\",{\"1\":{\"145\":2}}],[\"3030\",{\"1\":{\"127\":1}}],[\"30s\",{\"1\":{\"120\":1,\"162\":1,\"163\":2}}],[\"32\",{\"1\":{\"124\":1}}],[\"356\",{\"1\":{\"217\":1}}],[\"35\",{\"1\":{\"124\":1}}],[\"3的重排序在多线程中将被禁止\",{\"1\":{\"75\":1}}],[\"3\",{\"1\":{\"75\":1,\"82\":1,\"124\":1,\"134\":1,\"145\":1,\"150\":1,\"175\":1,\"176\":1,\"205\":3,\"215\":7,\"217\":1,\"223\":1,\"237\":1,\"257\":1}}],[\"需要先安装jre\",{\"1\":{\"255\":1}}],[\"需要遵循以下几个规则\",{\"1\":{\"252\":1}}],[\"需要将父类引用的变量进行转换成子类的类型\",{\"1\":{\"246\":1}}],[\"需要包装类的原因有以下几个方面\",{\"1\":{\"245\":1}}],[\"需要取消注册或更新感兴趣的事件\",{\"1\":{\"229\":1}}],[\"需要进行同步处理或使用线程安全的替代品\",{\"1\":{\"211\":1}}],[\"需要进行扩容操作\",{\"1\":{\"198\":1}}],[\"需要注意的是在使用父类引用的变量去调用方法时\",{\"1\":{\"246\":1}}],[\"需要注意的是虽然抽象类shape具有构造函数\",{\"1\":{\"241\":1}}],[\"需要注意的是\",{\"1\":{\"186\":1,\"201\":1,\"229\":1,\"241\":1,\"259\":1}}],[\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率\",{\"1\":{\"148\":1}}],[\"需要全局唯一\",{\"1\":{\"169\":1}}],[\"需要修改alertmanager的配置文件\",{\"1\":{\"162\":1}}],[\"需要修改抽象工厂的接口和具体工厂类\",{\"1\":{\"103\":1}}],[\"需要创建两个指标\",{\"1\":{\"154\":1}}],[\"需要为grafana配置prometheus的数据源\",{\"1\":{\"127\":1}}],[\"需要打开系统偏好设置\",{\"1\":{\"123\":1}}],[\"需要对问题进行调查和处理\",{\"1\":{\"121\":1}}],[\"需要对真实的代理对象的功能需要做一下加强\",{\"1\":{\"112\":1}}],[\"需要额外依赖\",{\"1\":{\"113\":1}}],[\"需要做性能测试\",{\"1\":{\"107\":1}}],[\"需要做更多的工作\",{\"1\":{\"107\":1}}],[\"需要权衡一下利弊\",{\"1\":{\"93\":1}}],[\"需要总裁审批\",{\"1\":{\"92\":2}}],[\"需要cfo审批\",{\"1\":{\"92\":1}}],[\"需要经理审批\",{\"1\":{\"92\":3}}],[\"需要不同的审批角色\",{\"1\":{\"92\":1}}],[\"需要扩展功能的时候\",{\"1\":{\"88\":1}}],[\"需要被适配的接口的实现类\",{\"1\":{\"82\":1}}],[\"需要被适配的接口usb接口\",{\"1\":{\"82\":1}}],[\"需要被适配器转换的对象\",{\"1\":{\"81\":1}}],[\"需要把typec接口转换成usb接口\",{\"1\":{\"81\":1}}],[\"需要第一次调用getsingleton\",{\"1\":{\"76\":1}}],[\"需要如下几步\",{\"1\":{\"75\":1}}],[\"需要表示全局唯一的对象\",{\"1\":{\"72\":1}}],[\"nio的特点是由底层原理决定的\",{\"1\":{\"238\":1}}],[\"nio底层原理\",{\"0\":{\"238\":1}}],[\"nio案列实战\",{\"0\":{\"231\":1}}],[\"nio中的一些主要channel的实现\",{\"1\":{\"225\":1}}],[\"nio\",{\"1\":{\"225\":10,\"226\":2,\"227\":2,\"228\":3,\"229\":1,\"232\":1,\"233\":1,\"234\":1,\"236\":10,\"237\":6,\"238\":5}}],[\"nio学习总结\",{\"0\":{\"224\":1}}],[\"n\",{\"1\":{\"180\":2,\"198\":1,\"199\":2,\"200\":4,\"252\":3}}],[\"nul\",{\"1\":{\"190\":1}}],[\"null赋值\",{\"1\":{\"245\":1}}],[\"null\",{\"1\":{\"75\":2,\"78\":1,\"79\":1,\"87\":11,\"97\":1,\"112\":1,\"184\":4,\"185\":5,\"190\":4,\"192\":12,\"198\":7,\"199\":19,\"200\":14,\"208\":3,\"210\":1,\"236\":4,\"237\":2,\"252\":1}}],[\"num2\",{\"1\":{\"254\":2}}],[\"num1\",{\"1\":{\"254\":2}}],[\"numerator\",{\"1\":{\"171\":1}}],[\"number\",{\"1\":{\"124\":4,\"146\":2}}],[\"nginx\",{\"1\":{\"119\":1}}],[\"noblocking\",{\"1\":{\"238\":1}}],[\"nosuchelementexception\",{\"1\":{\"186\":1}}],[\"no\",{\"1\":{\"171\":1}}],[\"none\",{\"1\":{\"153\":3}}],[\"notification\",{\"1\":{\"163\":4}}],[\"notify\",{\"1\":{\"106\":7}}],[\"not\",{\"1\":{\"142\":1,\"183\":1}}],[\"node<k\",{\"1\":{\"198\":2,\"199\":6,\"200\":5}}],[\"node<>\",{\"1\":{\"190\":1}}],[\"node<e>\",{\"1\":{\"190\":1,\"191\":3,\"192\":4}}],[\"node\",{\"1\":{\"115\":1,\"122\":1,\"125\":4,\"133\":4,\"149\":2,\"188\":7,\"191\":4,\"192\":2,\"196\":4,\"199\":2}}],[\"name2\",{\"1\":{\"240\":1}}],[\"name1\",{\"1\":{\"240\":1}}],[\"names\",{\"1\":{\"175\":14}}],[\"name=lisi\",{\"1\":{\"153\":2,\"154\":1}}],[\"name+\",{\"1\":{\"106\":1}}],[\"name\",{\"1\":{\"106\":4,\"124\":1,\"125\":2,\"130\":1,\"153\":4,\"154\":6,\"155\":1,\"162\":1,\"163\":1,\"164\":1,\"169\":2,\"172\":1,\"175\":4,\"176\":4,\"240\":1,\"257\":8}}],[\"never\",{\"1\":{\"260\":1}}],[\"nextsetbit\",{\"1\":{\"217\":4}}],[\"next指向当前节点后一个节点\",{\"1\":{\"188\":1}}],[\"next\",{\"1\":{\"186\":3,\"188\":2,\"190\":2,\"191\":1,\"192\":18,\"198\":2,\"199\":9,\"200\":2,\"234\":1,\"236\":1}}],[\"nextapproval\",{\"1\":{\"92\":5}}],[\"net\",{\"1\":{\"167\":1,\"236\":1,\"237\":1}}],[\"newtab\",{\"1\":{\"199\":6}}],[\"newthr\",{\"1\":{\"199\":2}}],[\"newcap\",{\"1\":{\"199\":6}}],[\"newcapacity\",{\"1\":{\"183\":2}}],[\"newnode\",{\"1\":{\"190\":9,\"198\":2}}],[\"newsize实际上是减一了\",{\"1\":{\"184\":1}}],[\"newsize\",{\"1\":{\"184\":4}}],[\"newlength\",{\"1\":{\"183\":2}}],[\"newproxyinstance\",{\"1\":{\"112\":1}}],[\"new\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"82\":2,\"85\":2,\"87\":18,\"92\":3,\"97\":3,\"100\":2,\"103\":3,\"106\":3,\"110\":2,\"112\":2,\"113\":3,\"154\":1,\"163\":1,\"174\":1,\"175\":1,\"176\":1,\"181\":2,\"183\":2,\"186\":5,\"190\":1,\"191\":1,\"192\":1,\"197\":2,\"199\":1,\"207\":3,\"215\":2,\"217\":8,\"225\":1,\"227\":1,\"232\":1,\"233\":1,\"236\":2,\"237\":6,\"241\":1,\"246\":2,\"251\":1,\"258\":3}}],[\"可变性\",{\"1\":{\"243\":1}}],[\"可变大小\",{\"1\":{\"174\":1}}],[\"可维护性和可扩展性\",{\"1\":{\"242\":1}}],[\"可对读取到的字符数据经过指定编码转换成字节\",{\"1\":{\"223\":1}}],[\"可对读取到的字节数据经过指定编码转换成字符\",{\"1\":{\"223\":1}}],[\"可重复性\",{\"1\":{\"174\":1}}],[\"可选参数\",{\"1\":{\"164\":1}}],[\"可选\",{\"1\":{\"154\":2}}],[\"可用通过prometheus的内置函数计算最近5分钟node\",{\"1\":{\"133\":1}}],[\"可增可减\",{\"1\":{\"131\":1}}],[\"可拓展性\",{\"1\":{\"112\":1}}],[\"可扩展性和易维护性\",{\"1\":{\"246\":1}}],[\"可扩展性和重用性\",{\"1\":{\"244\":1}}],[\"可扩展性很强\",{\"1\":{\"107\":1}}],[\"可扩展和可维护的链式处理的机制\",{\"1\":{\"93\":1}}],[\"可复用\",{\"1\":{\"83\":1}}],[\"可能在继承链中得到两个相同的父类实例\",{\"1\":{\"242\":1}}],[\"可能在某一时刻访问量突增\",{\"1\":{\"148\":1}}],[\"可能会发生异常的代码\",{\"1\":{\"259\":1}}],[\"可能会产生命名冲突\",{\"1\":{\"242\":1}}],[\"可能会同时存在多个实例的创建\",{\"1\":{\"78\":1}}],[\"可能需要移动大量元素\",{\"1\":{\"180\":1}}],[\"可能有很多人比较疑惑\",{\"1\":{\"83\":1}}],[\"可能问的少一些\",{\"1\":{\"75\":1}}],[\"可以对其进行修改\",{\"1\":{\"243\":1}}],[\"可以对时间序列提供丰富的查询\",{\"1\":{\"136\":1}}],[\"可以被捕获并进行相应处理\",{\"1\":{\"254\":1}}],[\"可以被多个线程同时访问而不会导致错误\",{\"1\":{\"243\":1}}],[\"可以被类实现\",{\"1\":{\"241\":1}}],[\"可以被继承\",{\"1\":{\"241\":1}}],[\"可以包含普通方法的实现\",{\"1\":{\"241\":1}}],[\"可以包含普通方法和抽象方法\",{\"1\":{\"241\":1}}],[\"可以包含抽象方法\",{\"1\":{\"241\":1}}],[\"可以直接通过接口名调用\",{\"1\":{\"241\":1}}],[\"可以直接通过接口名直接访问\",{\"1\":{\"241\":1}}],[\"可以直接将数据从缓冲区读取到通道\",{\"1\":{\"226\":1}}],[\"可以进行服务器的初始化\",{\"1\":{\"233\":1}}],[\"可以进行连接的建立\",{\"1\":{\"232\":1}}],[\"可以与选择器\",{\"1\":{\"233\":1}}],[\"可以实现在单个线程中处理多个通道的\",{\"1\":{\"229\":1}}],[\"可以有构造方法\",{\"1\":{\"241\":1}}],[\"可以有实例变量和构造方法\",{\"1\":{\"241\":1}}],[\"可以有效地管理缓冲区的状态\",{\"1\":{\"228\":1}}],[\"可以有以下几个配置项\",{\"1\":{\"169\":1}}],[\"可以存储不同类型的数据\",{\"1\":{\"228\":1}}],[\"可以同时处理多个通道的\",{\"1\":{\"226\":1}}],[\"可以以非阻塞的方式进行读写操作\",{\"1\":{\"226\":1}}],[\"可以监听新进来的tcp连接\",{\"1\":{\"225\":1}}],[\"可以非阻塞地进行读写操作\",{\"1\":{\"225\":1}}],[\"可以说是一个达到此功能\",{\"1\":{\"223\":1}}],[\"可以认为是一个工具类\",{\"1\":{\"223\":1}}],[\"可以减少实际写入操作对底层资源的访问\",{\"1\":{\"223\":1}}],[\"可以减少实际读取操作对底层资源的访问\",{\"1\":{\"223\":1}}],[\"可以处理二进制和文本数据\",{\"1\":{\"220\":1}}],[\"可以从头结点遍历到尾结点\",{\"1\":{\"188\":1}}],[\"可以将多个\",{\"1\":{\"234\":1}}],[\"可以将缓冲区中未读完的数据移到缓冲区的开头\",{\"1\":{\"228\":1}}],[\"可以将集合中的数据全部添加到新创建的hashset集合中\",{\"1\":{\"207\":1}}],[\"可以将hashset以流的形式通过objesctinputstream\",{\"1\":{\"203\":1,\"213\":1}}],[\"可以将hashmap以流的形式通过objectinputstream\",{\"1\":{\"195\":1}}],[\"可以将arraylist以流的形式通过objectinputstream\",{\"1\":{\"179\":1}}],[\"可以将上面的结果除以300\",{\"1\":{\"148\":1}}],[\"可以添加或删除元素\",{\"1\":{\"174\":1}}],[\"可以看到已经有一条告警消息已经发送给alertmanager\",{\"1\":{\"164\":1}}],[\"可以看到的规则状态如下\",{\"1\":{\"164\":1}}],[\"可以看到alertmanager的界面\",{\"1\":{\"163\":1}}],[\"可以看到有两个指标http\",{\"1\":{\"154\":1}}],[\"可以在代码块中赋值\",{\"1\":{\"257\":1}}],[\"可以在不同的操作系统上运行java程序\",{\"1\":{\"255\":1}}],[\"可以在原有对象的基础上进行修改\",{\"1\":{\"243\":1}}],[\"可以在等待\",{\"1\":{\"225\":1}}],[\"可以在新生成的指标上额外加一些标签\",{\"1\":{\"169\":1}}],[\"可以在运行时重新加载其配置\",{\"1\":{\"161\":1}}],[\"可以在grafana上查询\",{\"1\":{\"137\":1}}],[\"可以停止重复发送由此告警引发的其它告警的机制\",{\"1\":{\"160\":1}}],[\"可以得到\",{\"1\":{\"153\":1}}],[\"可以得到prometheus的监控指标\",{\"1\":{\"124\":1}}],[\"可以用来修饰类\",{\"1\":{\"259\":1}}],[\"可以用来聚合耽搁瞬时向量\",{\"1\":{\"146\":1}}],[\"可以用单线程处理多个\",{\"1\":{\"234\":1}}],[\"可以用于读取和写入数据\",{\"1\":{\"226\":1}}],[\"可以用于构建高并发\",{\"1\":{\"225\":1}}],[\"可以用于多线程下载或多个线程同时写数据到文件\",{\"1\":{\"223\":1}}],[\"可以用topk函数\",{\"1\":{\"146\":1}}],[\"可以应用于one\",{\"1\":{\"144\":1}}],[\"可以使用throw语句在程序中主动抛出异常\",{\"1\":{\"254\":1}}],[\"可以使用stringbuilder来获得更好的性能\",{\"1\":{\"243\":1}}],[\"可以使用string\",{\"1\":{\"243\":1}}],[\"可以使用\",{\"1\":{\"171\":1,\"241\":1}}],[\"可以使用如下表达式\",{\"1\":{\"149\":1}}],[\"可以使用rate函数计算速率\",{\"1\":{\"148\":1}}],[\"可以使用以下的表达式进行计算\",{\"1\":{\"148\":1}}],[\"可以使用increase函数计算增量数据\",{\"1\":{\"148\":1}}],[\"可以使用范围矢量查询\",{\"1\":{\"138\":1}}],[\"可以使用完全匹配\",{\"1\":{\"137\":1}}],[\"可以使用通配符\",{\"1\":{\"124\":1}}],[\"可以筛选出handler=\",{\"1\":{\"137\":1}}],[\"可以很容易一段时间的增量数据\",{\"1\":{\"132\":1}}],[\"可以让开发者轻松的实现监控大盘\",{\"1\":{\"127\":1}}],[\"可以访问prometheus自身的监控指标的暴露端点\",{\"1\":{\"124\":1}}],[\"可以配置多种分发方式\",{\"1\":{\"120\":1}}],[\"可以是k8s的集群的服务发现\",{\"1\":{\"120\":1}}],[\"可以是一个接口\",{\"1\":{\"91\":1}}],[\"可以和开源组件grafana无缝对接\",{\"1\":{\"118\":1}}],[\"可以通过以下几个方面来理解\",{\"1\":{\"246\":1}}],[\"可以通过抽象类的引用变量来指向它的实现类的实例\",{\"1\":{\"241\":1}}],[\"可以通过调用\",{\"1\":{\"229\":1}}],[\"可以通过\",{\"1\":{\"228\":1,\"232\":1,\"233\":1}}],[\"可以通过对象的思想来操作文件和文件夹\",{\"1\":{\"223\":1}}],[\"可以通过动态代理实现一些横切关注点\",{\"1\":{\"112\":1}}],[\"可以通过顺序组合包装的方式来附加扩张功能\",{\"1\":{\"87\":1}}],[\"可以动态地添加和删除观察者\",{\"1\":{\"107\":1}}],[\"可以动态的扩展责任链中的逻辑单元\",{\"1\":{\"93\":1}}],[\"可以利用发布者向所有的观察者发送消息\",{\"1\":{\"107\":1}}],[\"可以向它注册观察者对象\",{\"1\":{\"106\":1}}],[\"可以创建一系列相关的产品对象\",{\"1\":{\"103\":1}}],[\"可以方便地创建出不同的产品对象\",{\"1\":{\"100\":1}}],[\"可以灵活的控制责任链中逻辑单元的处理顺序\",{\"1\":{\"93\":1}}],[\"可以根据问题的性质和需求选择使用面向过程或面向对象的编程方法\",{\"1\":{\"244\":1}}],[\"可以根据客户端的需求\",{\"1\":{\"97\":1}}],[\"可以根据不同的需求\",{\"1\":{\"93\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"13\":1}}],[\"可以写一个handler即可\",{\"1\":{\"93\":1}}],[\"可以快速判断一个元素是否存在于集合中\",{\"1\":{\"175\":1}}],[\"可以快速的装载和卸载逻辑单元\",{\"1\":{\"93\":1}}],[\"可以快速组合\",{\"1\":{\"88\":1}}],[\"可以快速装载和卸载增强功能\",{\"1\":{\"88\":1}}],[\"可以增加新的装饰器\",{\"1\":{\"88\":1}}],[\"可以按照需要使用不同装饰器组合\",{\"1\":{\"86\":1}}],[\"可以按照方法去构造对象\",{\"1\":{\"66\":1}}],[\"可以做到移植可复用\",{\"1\":{\"83\":1}}],[\"可以调用客户端对它们调用\",{\"1\":{\"82\":1}}],[\"可以节约系统的资源\",{\"1\":{\"72\":1}}],[\"可以极大程度的提高我们写代码的质量\",{\"1\":{\"69\":1}}],[\"近几年由于八股文泛滥\",{\"1\":{\"75\":1}}],[\"双重检查模式\",{\"1\":{\"75\":1}}],[\"双重检查\",{\"0\":{\"75\":1}}],[\"类通过使用关键字\",{\"1\":{\"241\":1}}],[\"类提供了读写数据的方法\",{\"1\":{\"225\":1}}],[\"类内部维护了一个\",{\"1\":{\"215\":1}}],[\"类的引用变量来引用\",{\"1\":{\"246\":1}}],[\"类的多态性得到了充分的展现\",{\"1\":{\"240\":1}}],[\"类的uml图如下图所示\",{\"1\":{\"215\":1}}],[\"类的构造函数有两个重载的构造函数\",{\"1\":{\"189\":1}}],[\"类型转换和字符串解析等\",{\"1\":{\"245\":1}}],[\"类型的引用变量\",{\"1\":{\"241\":1}}],[\"类型的数组\",{\"1\":{\"215\":1}}],[\"类型包括\",{\"1\":{\"228\":1}}],[\"类型\",{\"1\":{\"214\":1,\"226\":1}}],[\"类结构关系\",{\"0\":{\"213\":1}}],[\"类结构图\",{\"0\":{\"203\":1}}],[\"类有多个构造函数\",{\"1\":{\"207\":1}}],[\"类\",{\"1\":{\"196\":2}}],[\"类来存储键值对\",{\"1\":{\"196\":1}}],[\"类是\",{\"1\":{\"188\":2}}],[\"类实现了\",{\"1\":{\"186\":1,\"241\":1}}],[\"类似于mysql的sql查询语句\",{\"1\":{\"136\":1}}],[\"类似于kubernetes是从google的brog系统演变而来\",{\"1\":{\"117\":1}}],[\"类似于中介\",{\"1\":{\"108\":1}}],[\"类加载是加锁的\",{\"1\":{\"74\":1}}],[\"类和对象如何交互\",{\"1\":{\"68\":1}}],[\"自反性\",{\"1\":{\"252\":1}}],[\"自动拆箱\",{\"1\":{\"245\":1}}],[\"自动装箱\",{\"1\":{\"245\":1}}],[\"自动创建hugryinstance的静态实例\",{\"1\":{\"74\":1}}],[\"自定义异常类通常继承自exception或runtimeexception类\",{\"1\":{\"254\":1}}],[\"自定义异常\",{\"1\":{\"254\":1}}],[\"自定义标签\",{\"1\":{\"164\":1}}],[\"自定义标题\",{\"1\":{\"19\":5}}],[\"自定义它们\",{\"1\":{\"45\":1}}],[\"自定义对齐\",{\"0\":{\"22\":1}}],[\"自定义容器\",{\"0\":{\"19\":1}}],[\"会通过位置来确定当前要操作的数据元素\",{\"1\":{\"228\":1}}],[\"会从头开始写\",{\"1\":{\"223\":1}}],[\"会自动创建\",{\"1\":{\"223\":1}}],[\"会增加一个行号\",{\"1\":{\"223\":1}}],[\"会得到相应的行号\",{\"1\":{\"223\":1}}],[\"会去除掉重复的值\",{\"1\":{\"207\":1}}],[\"会根据异常类型在catch块中进行匹配\",{\"1\":{\"260\":2}}],[\"会根据当前的\",{\"1\":{\"199\":1}}],[\"会根据需要自动进行扩容\",{\"1\":{\"180\":1}}],[\"会调用\",{\"1\":{\"184\":1,\"199\":1}}],[\"会判断是否需要缩小数组容量\",{\"1\":{\"180\":1}}],[\"会将新的\",{\"1\":{\"199\":1}}],[\"会将collection的元素copy到elementdata成员变量中\",{\"1\":{\"181\":1}}],[\"会将删除位置后面的元素向前移动一个位置\",{\"1\":{\"180\":1}}],[\"会将计算结果输出到新的向量上\",{\"1\":{\"141\":1}}],[\"会检查当前数组容量是否足够\",{\"1\":{\"180\":1}}],[\"会初始化一个初始容量的数组\",{\"1\":{\"180\":1}}],[\"会屏蔽掉severity=warning的告警\",{\"1\":{\"163\":1}}],[\"会统计当前指标的记录总数\",{\"1\":{\"134\":1}}],[\"会周期性的去采集指标\",{\"1\":{\"120\":1}}],[\"会带来一定的性能开销\",{\"1\":{\"112\":1}}],[\"会导致一些并发问题\",{\"1\":{\"201\":1}}],[\"会导致一定的资源开销和性能下降\",{\"1\":{\"79\":1}}],[\"会导致类的数量增加\",{\"1\":{\"100\":1}}],[\"会进行加锁初始化\",{\"1\":{\"76\":1}}],[\"会在程序的类的加载过程中\",{\"1\":{\"74\":1}}],[\"会使用\",{\"1\":{\"16\":1}}],[\"只要对象的属性没有发生改变\",{\"1\":{\"253\":1}}],[\"只要是处理纯文本数据\",{\"1\":{\"221\":1}}],[\"只关心添加操作是否成功\",{\"1\":{\"208\":1}}],[\"只使用键来判断元素的唯一性\",{\"1\":{\"207\":1}}],[\"只能调用父类中声明的方法和子类中重写了父类的方法\",{\"1\":{\"246\":1}}],[\"只能使用对象类型\",{\"1\":{\"245\":1}}],[\"只能包含抽象方法的声明\",{\"1\":{\"241\":1}}],[\"只能包含常量和抽象方法\",{\"1\":{\"241\":1}}],[\"只能在接口内部被调用\",{\"1\":{\"241\":1}}],[\"只能在原有的基础功能之上做进一步增强\",{\"1\":{\"86\":1}}],[\"只能用作基类或父类来使用\",{\"1\":{\"241\":1}}],[\"只能求到最大的耗时和平均耗时\",{\"1\":{\"153\":1}}],[\"只不过summary是已经在客户端已经计算好的数据\",{\"1\":{\"135\":1}}],[\"只增不减\",{\"1\":{\"131\":1}}],[\"只需要增加相应的具体产品类和工厂类即可\",{\"1\":{\"103\":1}}],[\"只需要修改工厂类的逻辑判断即可\",{\"1\":{\"97\":1}}],[\"只需要财务审批\",{\"1\":{\"92\":1}}],[\"只有第一次调用getsingleton\",{\"1\":{\"75\":1}}],[\"只有当子类可以替换基类\",{\"1\":{\"70\":1}}],[\"只允许通过getinstance\",{\"1\":{\"74\":1}}],[\"推荐\",{\"0\":{\"74\":1,\"75\":1,\"76\":1}}],[\"饿汉模式类似于spring框架初始化bean实例\",{\"1\":{\"74\":1}}],[\"饿汉模式\",{\"0\":{\"74\":1}}],[\"其范围为\",{\"1\":{\"251\":1}}],[\"其值就不能被修改\",{\"1\":{\"245\":1}}],[\"其封装了字节流\",{\"1\":{\"223\":1}}],[\"其子类pushbackreader\",{\"1\":{\"223\":1}}],[\"其实不然\",{\"1\":{\"252\":1}}],[\"其实是做不到\",{\"1\":{\"153\":1}}],[\"其实在存储的时候是并没有存储的\",{\"1\":{\"131\":1}}],[\"其中是一个无参的构造函数\",{\"1\":{\"189\":1}}],[\"其中\",{\"1\":{\"180\":1}}],[\"其中prometheus\",{\"1\":{\"154\":1}}],[\"其中micrometer\",{\"1\":{\"153\":1}}],[\"其中job为采集任务\",{\"1\":{\"146\":1}}],[\"其无法反应在时间窗口内样本数据的突发变化\",{\"1\":{\"148\":1}}],[\"其他一些功能\",{\"1\":{\"245\":1}}],[\"其他例子\",{\"1\":{\"171\":1}}],[\"其他常见的函数\",{\"0\":{\"147\":1}}],[\"其他操作系统应该没有这个问题\",{\"1\":{\"123\":1}}],[\"其他\",{\"0\":{\"77\":1}}],[\"其代码实现如下\",{\"1\":{\"73\":1}}],[\"其次才考虑使用继承关系来实现\",{\"1\":{\"70\":1}}],[\"防止程序因为出现异常而奔溃\",{\"1\":{\"254\":1}}],[\"防止对象的频繁创建\",{\"1\":{\"72\":1}}],[\"防止它频繁的被创建或者被销毁\",{\"1\":{\"72\":1}}],[\"就不能再指向另一个对象了\",{\"1\":{\"257\":1}}],[\"就不能再更改\",{\"1\":{\"257\":1}}],[\"就无法访问其对象方法和属性\",{\"1\":{\"245\":1}}],[\"就需要将其包装成相应的对象类型\",{\"1\":{\"245\":1}}],[\"就遍历处理相应的事件类型\",{\"1\":{\"236\":1}}],[\"就优先考虑使用字符流\",{\"1\":{\"221\":1}}],[\"就搞定\",{\"1\":{\"214\":1}}],[\"就可以具体的执行告警逻辑\",{\"1\":{\"166\":1}}],[\"就可以看到本机的资源dashboard\",{\"1\":{\"127\":1}}],[\"就可以看到各个目录的磁盘剩余字节数了\",{\"1\":{\"125\":1}}],[\"就可以进行配置的热更新\",{\"1\":{\"126\":1}}],[\"就可以采集node\",{\"1\":{\"125\":1}}],[\"就可以查看node\",{\"1\":{\"125\":1}}],[\"就可以访问prometheus页面了\",{\"1\":{\"123\":1}}],[\"就能够提供给其他对象在各个地方使用\",{\"1\":{\"72\":1}}],[\"就是printstream\",{\"1\":{\"223\":1}}],[\"就是\",{\"1\":{\"214\":1}}],[\"就是一个对象应该尽量对外少暴露\",{\"1\":{\"70\":1}}],[\"就是将实例化工作交给子类完成\",{\"1\":{\"66\":1,\"98\":1}}],[\"让其他的对象可以访问这个实例\",{\"1\":{\"72\":1}}],[\"迪米特法则\",{\"1\":{\"70\":1}}],[\"简介\",{\"0\":{\"220\":1,\"225\":1}}],[\"简单示例\",{\"0\":{\"205\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"96\":1}}],[\"简单工厂模式是一种常见的设计模式\",{\"1\":{\"97\":1}}],[\"简单工厂模式提供一个简单的工厂类\",{\"1\":{\"95\":1}}],[\"简单工厂模式\",{\"1\":{\"95\":1}}],[\"简单工厂\",{\"0\":{\"95\":1}}],[\"简单的说就是要求对抽象接口进行编程\",{\"1\":{\"70\":1}}],[\"简称\",{\"1\":{\"70\":5}}],[\"程序将继续执行后续的代码\",{\"1\":{\"260\":1}}],[\"程序会立即跳转到catch代码块中\",{\"1\":{\"254\":1}}],[\"程序流程将跳转到catch块或finally块\",{\"1\":{\"254\":1}}],[\"程序由相互作用的对象组成\",{\"1\":{\"244\":1}}],[\"程序按照一定的顺序执行这些步骤来完成任务\",{\"1\":{\"244\":1}}],[\"程序被分解为可重用的功能模块\",{\"1\":{\"244\":1}}],[\"程序要依赖于抽象接口\",{\"1\":{\"70\":1}}],[\"程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的\",{\"1\":{\"70\":1}}],[\"due\",{\"1\":{\"166\":1}}],[\"duration\",{\"1\":{\"124\":10,\"134\":13,\"135\":11,\"141\":1,\"150\":13}}],[\"distinguishing\",{\"1\":{\"171\":1}}],[\"divide\",{\"1\":{\"171\":1,\"254\":2}}],[\"division\",{\"1\":{\"141\":1}}],[\"dimensions\",{\"1\":{\"146\":7}}],[\"dip\",{\"1\":{\"70\":1}}],[\"db中\",{\"1\":{\"131\":1}}],[\"dl\",{\"1\":{\"127\":1}}],[\"date\",{\"1\":{\"166\":2}}],[\"datagramchannel\",{\"1\":{\"225\":1,\"226\":1}}],[\"dataoutputstream\",{\"1\":{\"223\":1}}],[\"datainputstream\",{\"1\":{\"223\":1}}],[\"data\",{\"1\":{\"87\":8,\"227\":2,\"232\":2,\"233\":2,\"236\":2}}],[\"dashboards\",{\"1\":{\"127\":1}}],[\"darwin\",{\"1\":{\"123\":2,\"127\":2}}],[\"dog=new\",{\"1\":{\"240\":1}}],[\"dog\",{\"1\":{\"240\":3,\"241\":8,\"246\":6}}],[\"dog继承了animal父类\",{\"1\":{\"240\":1}}],[\"double等封装类中\",{\"1\":{\"252\":1}}],[\"double等等\",{\"1\":{\"245\":1}}],[\"double等\",{\"1\":{\"245\":1}}],[\"doublebuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"double\",{\"1\":{\"199\":1,\"223\":2,\"225\":1,\"241\":4,\"251\":1}}],[\"docs\",{\"1\":{\"151\":1,\"166\":1}}],[\"download\",{\"1\":{\"123\":1,\"162\":1}}],[\"downloads\",{\"1\":{\"87\":1}}],[\"do\",{\"1\":{\"110\":2,\"112\":1,\"113\":1,\"199\":1,\"200\":1}}],[\"dos\",{\"1\":{\"87\":3}}],[\"demo\",{\"1\":{\"240\":2,\"241\":1,\"258\":3}}],[\"demo=new\",{\"1\":{\"240\":1}}],[\"denominator\",{\"1\":{\"171\":1}}],[\"details\",{\"1\":{\"167\":1}}],[\"deduplicate\",{\"1\":{\"166\":1}}],[\"development\",{\"1\":{\"255\":1}}],[\"dev\",{\"1\":{\"162\":1,\"163\":3}}],[\"deviation\",{\"1\":{\"146\":1}}],[\"defaultcapacity\",{\"1\":{\"180\":1,\"181\":2,\"183\":1}}],[\"default\",{\"1\":{\"163\":3,\"169\":1,\"183\":1,\"197\":1,\"199\":1,\"241\":1}}],[\"defaultvalue\",{\"1\":{\"153\":1,\"154\":1}}],[\"deflater\",{\"1\":{\"87\":1}}],[\"deflateroutputstream\",{\"1\":{\"87\":2}}],[\"del\",{\"1\":{\"145\":1}}],[\"delta\",{\"1\":{\"133\":1}}],[\"decompress\",{\"1\":{\"87\":2}}],[\"decode\",{\"1\":{\"87\":4}}],[\"design\",{\"1\":{\"80\":2,\"92\":2,\"106\":5}}],[\"description\",{\"1\":{\"164\":1}}],[\"desc\",{\"1\":{\"28\":1}}],[\"dependency>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"dependency\",{\"1\":{\"70\":1}}],[\"d\",{\"1\":{\"70\":1,\"138\":1,\"228\":1}}],[\"基于promql表达式告警触发条件\",{\"1\":{\"164\":1}}],[\"基于5小时的样本数据\",{\"1\":{\"149\":1}}],[\"基本数据类型\",{\"1\":{\"251\":1}}],[\"基本类型不是对象\",{\"1\":{\"245\":1}}],[\"基本类型的取值范围是有限的\",{\"1\":{\"245\":1}}],[\"基本的\",{\"1\":{\"228\":1}}],[\"基本查询格式是\",{\"1\":{\"146\":1}}],[\"基本功能实现类和不同的装饰器只实现自己的独一的功能\",{\"1\":{\"88\":1}}],[\"基本上也遵循solid\",{\"1\":{\"70\":1}}],[\"基类功能可以被复用\",{\"1\":{\"70\":1}}],[\"软件功能在不受影响时\",{\"1\":{\"70\":1}}],[\"ov了object类的equals\",{\"1\":{\"252\":1}}],[\"overwrittingdemo\",{\"1\":{\"240\":1}}],[\"overlodingdemo\",{\"1\":{\"240\":3}}],[\"overloading\",{\"1\":{\"240\":2}}],[\"overriding\",{\"1\":{\"240\":2}}],[\"override\",{\"1\":{\"82\":2,\"87\":6,\"92\":3,\"97\":2,\"100\":2,\"103\":3,\"106\":3,\"110\":2,\"112\":1,\"113\":1,\"154\":4,\"240\":1,\"241\":2,\"246\":2,\"257\":1,\"258\":2,\"259\":1}}],[\"overflow\",{\"1\":{\"183\":2}}],[\"over\",{\"1\":{\"146\":7,\"217\":2,\"242\":1}}],[\"oldthr\",{\"1\":{\"199\":2}}],[\"oldtab\",{\"1\":{\"199\":8}}],[\"oldcap\",{\"1\":{\"199\":11}}],[\"oldcapacity\",{\"1\":{\"183\":5}}],[\"oldlength\",{\"1\":{\"183\":7}}],[\"ok\",{\"1\":{\"154\":17,\"166\":1}}],[\"op\",{\"1\":{\"229\":4,\"234\":2,\"236\":2}}],[\"op>\",{\"1\":{\"146\":1}}],[\"operations\",{\"1\":{\"171\":2}}],[\"operation\",{\"1\":{\"110\":9,\"112\":3,\"113\":1}}],[\"open\",{\"1\":{\"70\":1,\"229\":1,\"232\":2,\"233\":2,\"234\":2,\"236\":2,\"237\":1}}],[\"one\",{\"1\":{\"144\":3,\"145\":2}}],[\"on\",{\"1\":{\"144\":1}}],[\"oriented\",{\"1\":{\"244\":1}}],[\"ordering\",{\"1\":{\"217\":1}}],[\"orderedarray\",{\"1\":{\"217\":3}}],[\"order\",{\"1\":{\"199\":1}}],[\"orange\",{\"1\":{\"174\":3}}],[\"org\",{\"1\":{\"154\":2}}],[\"or\",{\"1\":{\"142\":2,\"143\":1,\"163\":3,\"171\":1,\"215\":3}}],[\"offset\",{\"0\":{\"139\":1},\"1\":{\"139\":2,\"217\":2}}],[\"of\",{\"1\":{\"124\":6,\"130\":1,\"131\":1,\"135\":2,\"146\":2,\"163\":2,\"166\":1,\"183\":1}}],[\"observe\",{\"1\":{\"154\":1}}],[\"observer2\",{\"1\":{\"106\":2}}],[\"observer1\",{\"1\":{\"106\":2}}],[\"observerimpl\",{\"1\":{\"106\":4}}],[\"observer接口的实现类observerimpl的代码如下\",{\"1\":{\"106\":1}}],[\"observer\",{\"1\":{\"104\":1,\"105\":1,\"106\":7}}],[\"obeserver2\",{\"1\":{\"106\":5}}],[\"obj\",{\"1\":{\"106\":3,\"252\":2}}],[\"objectoutputstream\",{\"1\":{\"223\":1}}],[\"objectoutputstream来写\",{\"1\":{\"179\":1,\"195\":1,\"203\":1,\"213\":1}}],[\"objectinputstream\",{\"1\":{\"223\":1}}],[\"objects\",{\"1\":{\"185\":1}}],[\"object\",{\"1\":{\"106\":5,\"112\":10,\"113\":7,\"154\":3,\"180\":1,\"181\":3,\"182\":1,\"183\":3,\"184\":5,\"185\":6,\"186\":1,\"198\":1,\"200\":6,\"209\":2,\"210\":1,\"244\":1,\"252\":2}}],[\"outputstreamwriter\",{\"1\":{\"223\":2}}],[\"outputstream\",{\"1\":{\"221\":1,\"223\":1}}],[\"output\",{\"1\":{\"220\":1}}],[\"outofmemoryerror\",{\"1\":{\"183\":1}}],[\"outcome=\",{\"1\":{\"153\":3}}],[\"out\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"174\":10,\"175\":7,\"176\":9,\"205\":1,\"215\":3,\"217\":11,\"223\":2,\"227\":1,\"228\":8,\"236\":5,\"237\":2,\"240\":5,\"241\":5,\"246\":2,\"251\":3,\"254\":3,\"257\":3,\"258\":2,\"260\":8}}],[\"ocp\",{\"1\":{\"70\":1}}],[\"o\",{\"1\":{\"70\":1,\"106\":3,\"113\":1,\"127\":1,\"180\":2,\"184\":5,\"185\":9,\"204\":1,\"209\":5,\"210\":4,\"225\":8,\"226\":2,\"228\":2,\"229\":3,\"232\":3,\"233\":3,\"234\":7,\"236\":1,\"237\":1,\"238\":3}}],[\"原来的string对象不会被改变\",{\"1\":{\"243\":1}}],[\"原始内容\",{\"1\":{\"87\":2}}],[\"原有的类不支持继承\",{\"1\":{\"86\":1}}],[\"原则\",{\"1\":{\"70\":2}}],[\"原型模式\",{\"1\":{\"66\":1}}],[\"面向过程更适合简单的任务和算法\",{\"1\":{\"244\":1}}],[\"面向过程和面向对象都有各自的优点和适用场景\",{\"1\":{\"244\":1}}],[\"面向过程的关注点主要在于解决问题的步骤和流程\",{\"1\":{\"244\":1}}],[\"面向过程是一种基于步骤和函数的编程方法\",{\"1\":{\"244\":1}}],[\"面向过程\",{\"1\":{\"244\":1}}],[\"面向对象\",{\"1\":{\"245\":1}}],[\"面向对象更适合复杂的应用\",{\"1\":{\"244\":1}}],[\"面向对象的关注点主要在于构建对象的结构和定义对象的行为\",{\"1\":{\"244\":1}}],[\"面向对象是一种基于对象和类的编程方法\",{\"1\":{\"244\":1}}],[\"面向对象还有以下的基本原则\",{\"1\":{\"70\":1}}],[\"面向对象有个solid原则\",{\"1\":{\"70\":1}}],[\"面试官不会考察每一种设计模式\",{\"1\":{\"69\":1}}],[\"面试过程中常问的设计模式\",{\"0\":{\"69\":1}}],[\"掌握好以上的几种设计模式\",{\"1\":{\"69\":1}}],[\"熟练使用23种设计模式是高阶程序员必须掌握的技能\",{\"1\":{\"69\":1}}],[\"作为缓冲区\",{\"1\":{\"227\":1}}],[\"作为值存储在\",{\"1\":{\"208\":1}}],[\"作为键\",{\"1\":{\"208\":1}}],[\"作为新的\",{\"1\":{\"199\":1}}],[\"作为新一代的监控系统\",{\"1\":{\"118\":1}}],[\"作为参数\",{\"1\":{\"197\":1,\"208\":1,\"209\":1,\"210\":1}}],[\"作为扩展对象功能的出发点\",{\"1\":{\"68\":1}}],[\"作者设置为\",{\"1\":{\"43\":1}}],[\"某个数据库出现网络故障\",{\"1\":{\"159\":1}}],[\"某个类在全局只有一个实例对象\",{\"1\":{\"66\":1}}],[\"某一个操作\",{\"1\":{\"68\":1}}],[\"责任链模式可以提供一种灵活\",{\"1\":{\"93\":1}}],[\"责任链模式将处理逻辑放在链式的逻辑单元中处理\",{\"1\":{\"93\":1}}],[\"责任链模式有两个角色\",{\"1\":{\"91\":1}}],[\"责任链模式的uml图\",{\"0\":{\"91\":1}}],[\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理\",{\"1\":{\"90\":1}}],[\"责任链模式在软件开发中\",{\"1\":{\"90\":1}}],[\"责任链模式\",{\"0\":{\"90\":1},\"1\":{\"68\":1,\"69\":1}}],[\"并执行与异常类型匹配的处理代码\",{\"1\":{\"254\":1}}],[\"并按照顺序处理异常\",{\"1\":{\"254\":1}}],[\"并实现相关接口\",{\"1\":{\"241\":1}}],[\"并实现了抽象方法\",{\"1\":{\"241\":1}}],[\"并实现了事件的注册\",{\"1\":{\"236\":1}}],[\"并实现了handle\",{\"1\":{\"92\":3}}],[\"并重写了eat方法\",{\"1\":{\"240\":1}}],[\"并重新读取缓冲区中的数据\",{\"1\":{\"228\":1}}],[\"并接收服务器端的响应\",{\"1\":{\"237\":1}}],[\"并向其中放入要发送给客户端的数据\",{\"1\":{\"236\":1}}],[\"并向客户端发送\",{\"1\":{\"236\":1}}],[\"并向审批流的第一角色handle\",{\"1\":{\"92\":1}}],[\"并注册到\",{\"1\":{\"236\":1}}],[\"并创建一个\",{\"1\":{\"236\":1}}],[\"并根据实际对象的类型来调用\",{\"1\":{\"246\":1}}],[\"并根据实际对象的类型来执行对应的方法\",{\"1\":{\"246\":1}}],[\"并根据不同的事件类型进行处理\",{\"1\":{\"236\":1}}],[\"并根据事件类型进行监听\",{\"1\":{\"234\":1}}],[\"并设置为非阻塞模式\",{\"1\":{\"233\":1}}],[\"并指定感兴趣的事件\",{\"1\":{\"229\":1}}],[\"并再次使用\",{\"1\":{\"228\":1}}],[\"并使用\",{\"1\":{\"228\":2}}],[\"并使它们可以互换\",{\"1\":{\"68\":1}}],[\"并通过\",{\"1\":{\"227\":2,\"228\":1}}],[\"并通过案例进行了实战\",{\"1\":{\"151\":1}}],[\"并不是在原始中有这样一个行号\",{\"1\":{\"223\":1}}],[\"并不需要改变原有的逻辑功能\",{\"1\":{\"93\":1}}],[\"并具有很好的性能特性\",{\"1\":{\"211\":1}}],[\"并返回接收结果给客户端\",{\"1\":{\"235\":1}}],[\"并返回旧的值\",{\"1\":{\"208\":1}}],[\"并返回一个布尔值\",{\"1\":{\"208\":1,\"209\":1,\"210\":1}}],[\"并存储到新的\",{\"1\":{\"199\":1}}],[\"并进行删除操作\",{\"1\":{\"192\":1}}],[\"并增加链表的大小\",{\"1\":{\"190\":1}}],[\"并支持在迭代过程中通过迭代器的\",{\"1\":{\"186\":1}}],[\"并已bean的形式注册\",{\"1\":{\"154\":1}}],[\"并没有差别\",{\"1\":{\"131\":1}}],[\"并展示在监控大盘上\",{\"1\":{\"128\":1}}],[\"并将其转换为底层操作系统可以执行的机器码\",{\"1\":{\"255\":1}}],[\"并将其设置为非阻塞模式\",{\"1\":{\"236\":1,\"237\":1}}],[\"并将其注册到\",{\"1\":{\"236\":1}}],[\"并将其赋值给i\",{\"1\":{\"245\":1}}],[\"并将其赋值给\",{\"1\":{\"207\":1}}],[\"并将上界设置为容量\",{\"1\":{\"228\":1}}],[\"并将上界设置为当前位置\",{\"1\":{\"228\":1}}],[\"并将数据写入到文件中\",{\"1\":{\"227\":1}}],[\"并将数据的结果存储在新的时间序列中\",{\"1\":{\"169\":1}}],[\"并将一个固定的对象作为\",{\"1\":{\"204\":1}}],[\"并将对应位置的第一个节点赋值给\",{\"1\":{\"200\":1}}],[\"并将键值对插入到对应索引位置\",{\"1\":{\"199\":1}}],[\"并将节点\",{\"1\":{\"192\":2}}],[\"并将\",{\"1\":{\"186\":1}}],[\"并将最后一个位置上的元素清空\",{\"1\":{\"184\":1}}],[\"并将原有元素复制到新数组中\",{\"1\":{\"180\":1}}],[\"并将计算结果保存在一组新的时间序列上\",{\"1\":{\"168\":1}}],[\"并将告警消息发送给alertmanager\",{\"1\":{\"120\":1}}],[\"并将指标存储在主机的磁盘中\",{\"1\":{\"120\":1}}],[\"并将实际对象的方法调用转发给它\",{\"1\":{\"109\":1}}],[\"并在接受到连接请求时创建对应的\",{\"1\":{\"233\":1}}],[\"并在intercept方法中实现真实对象的功能增强\",{\"1\":{\"113\":1}}],[\"并在主题实现类的对象的operation\",{\"1\":{\"110\":1}}],[\"并在状态改变时通知观察者\",{\"1\":{\"105\":1}}],[\"并隐藏在代理后面可能其他类的实现\",{\"1\":{\"109\":1}}],[\"并且在方法返回之前被执行\",{\"1\":{\"260\":1}}],[\"并且在有数据可读或可写的通道上进行处理\",{\"1\":{\"234\":1}}],[\"并且y\",{\"1\":{\"252\":1}}],[\"并且提供了更灵活的类组合方式\",{\"1\":{\"242\":1}}],[\"并且能够避免阻塞影响其他连接的特点成为了非常重要的优势\",{\"1\":{\"238\":1}}],[\"并且接收服务器端发送的反馈消息\",{\"1\":{\"237\":1}}],[\"并且设置为非阻塞模式\",{\"1\":{\"236\":1}}],[\"并且无法更改\",{\"1\":{\"228\":1}}],[\"并且\",{\"1\":{\"198\":1}}],[\"并且元素小于default\",{\"1\":{\"183\":1}}],[\"并且可以与选择器\",{\"1\":{\"232\":1}}],[\"并且可以通过索引进行访问和操作\",{\"1\":{\"174\":1}}],[\"并且可以根据需要快速的组合逻辑单元\",{\"1\":{\"93\":1}}],[\"并且是求百分数\",{\"1\":{\"171\":1}}],[\"并且体现出更好的灵敏度\",{\"1\":{\"148\":1}}],[\"并且于2015年对外发布早期版本\",{\"1\":{\"117\":1}}],[\"并且发布者发布消息也是无顺序的\",{\"1\":{\"107\":1}}],[\"并定义了观察者接收到通知后的具体行为\",{\"1\":{\"105\":1}}],[\"并可以动态添加观察者或者删除观察者\",{\"1\":{\"105\":1}}],[\"并能自由组合包装各种装饰器\",{\"1\":{\"88\":1}}],[\"并持有主题实现类的对象\",{\"1\":{\"110\":1}}],[\"并持有readerwriter的实现类filereaderwriter\",{\"1\":{\"87\":2}}],[\"并持有装饰器componentdecoratorb\",{\"1\":{\"86\":1}}],[\"并持有组件实现类componentimpl\",{\"1\":{\"86\":1}}],[\"并提供了良好的可读性和可维护性\",{\"1\":{\"254\":1}}],[\"并提供了一系列方法来管理数据的读写\",{\"1\":{\"228\":1}}],[\"并提供了一行一行写入字符的方法\",{\"1\":{\"223\":1}}],[\"并提供了高效的缓冲流和便捷的文件操作\",{\"1\":{\"220\":1}}],[\"并提供一个方法\",{\"1\":{\"72\":1}}],[\"并提供解释器来处理句子中的语法\",{\"1\":{\"68\":1}}],[\"所管理的所有就绪的\",{\"1\":{\"229\":1}}],[\"所\",{\"1\":{\"179\":1}}],[\"所用到开源组件如下\",{\"1\":{\"115\":1}}],[\"所有位均参与计算\",{\"1\":{\"251\":1}}],[\"所有元素都会被映射到\",{\"1\":{\"204\":1}}],[\"所有依赖于它的对象都会收到通知\",{\"1\":{\"104\":1}}],[\"所有这些都不会违反封装\",{\"1\":{\"68\":1}}],[\"所以这个变量所指向的内存区域就不会变\",{\"1\":{\"258\":1}}],[\"所以这个resolve\",{\"1\":{\"163\":1}}],[\"所以char类型取值范围为0~2^16\",{\"1\":{\"251\":1}}],[\"所以需要使用包装类来为这些基本类型提供一个相应的对象类型\",{\"1\":{\"245\":1}}],[\"所以如果想要在泛型中使用一个基本类型的值\",{\"1\":{\"245\":1}}],[\"所以不会因为某个连接的阻塞而影响其他连接的读写事件的处理\",{\"1\":{\"238\":1}}],[\"所以在定义接口方法时不需要添加关键字\",{\"1\":{\"241\":1}}],[\"所以在构造的时候需要传入字节流对象进来\",{\"1\":{\"223\":1}}],[\"所以在接下来的文章会从源码和java\",{\"1\":{\"177\":1}}],[\"所以\",{\"1\":{\"208\":1,\"209\":1,\"210\":1,\"253\":1}}],[\"所以hashset具有了abstractset和set的功能\",{\"1\":{\"203\":1}}],[\"所以hashmap具有了abstractmap和map的功能\",{\"1\":{\"195\":1}}],[\"所以默认的初始化大小为10\",{\"1\":{\"181\":1}}],[\"所以随机访问元素的时间复杂度为\",{\"1\":{\"180\":1}}],[\"所以arraylist具有了abstractlist和list的功能\",{\"1\":{\"179\":1}}],[\"所以arraylist\",{\"1\":{\"179\":1}}],[\"所以能够输出\",{\"1\":{\"141\":1}}],[\"所以可以通过标签进行对指标的筛选\",{\"1\":{\"136\":1}}],[\"所以下载的是mac版本的\",{\"1\":{\"127\":1}}],[\"所以只能实现接口的方式进行代理\",{\"1\":{\"112\":1}}],[\"所以我们在实际的使用过程中\",{\"1\":{\"93\":1}}],[\"所以它们之间的\",{\"1\":{\"251\":1}}],[\"所以它天然的保证了\",{\"1\":{\"204\":1}}],[\"所以它的level可以命名为instance\",{\"1\":{\"171\":1}}],[\"所以它属于线程安全的懒汉模式\",{\"1\":{\"76\":1}}],[\"所以它是线程安全的\",{\"1\":{\"74\":1}}],[\"所以jvm是允许的\",{\"1\":{\"75\":1}}],[\"所以还是比较推荐的\",{\"1\":{\"74\":1}}],[\"所以设计模式是程序员的一项基本功\",{\"1\":{\"64\":1}}],[\"备忘录模式\",{\"1\":{\"68\":1}}],[\"而是由java运行时环境\",{\"1\":{\"254\":1}}],[\"而是与其关联的对象在内存中的地址\",{\"1\":{\"251\":1}}],[\"而是采用灵活的单一结构\",{\"1\":{\"108\":1}}],[\"而char是无符号类型的\",{\"1\":{\"251\":1}}],[\"而且同一个接口可以被多个类实现\",{\"1\":{\"241\":1}}],[\"而且不需要修改现有的代码\",{\"1\":{\"93\":1}}],[\"而重写方法必须具有相同的返回类型\",{\"1\":{\"240\":1}}],[\"而重写方法在运行时动态地绑定\",{\"1\":{\"240\":1}}],[\"而字符流只能处理字符类型的数据\",{\"1\":{\"221\":1}}],[\"而有了对字符进行高效操作的流对象\",{\"1\":{\"221\":1}}],[\"而值则被忽略\",{\"1\":{\"209\":1,\"210\":1}}],[\"而\",{\"1\":{\"207\":1,\"251\":1}}],[\"而应该使用迭代器的\",{\"1\":{\"186\":1}}],[\"而对插入和删除操作效率要求不高的场景\",{\"1\":{\"180\":1}}],[\"而abstractlist内部已经实现了获取iterator和listiterator的方法\",{\"1\":{\"179\":1}}],[\"而使用prometheus的java客户端是可以做到分位耗时的\",{\"1\":{\"153\":1}}],[\"而标签组是监控样本的多个维度特征的反应\",{\"1\":{\"136\":1}}],[\"而histogram则会消耗更多服务端的的资源\",{\"1\":{\"135\":1}}],[\"而histogram是通过histogram\",{\"1\":{\"135\":1}}],[\"而个别情况可能导致请求耗时超过了5s\",{\"1\":{\"134\":1}}],[\"而在样本数据采集的时候\",{\"1\":{\"131\":1}}],[\"而无需移动其他元素\",{\"1\":{\"193\":1}}],[\"而无需修改原有的代码\",{\"1\":{\"112\":1}}],[\"而无需指定具体实现类\",{\"1\":{\"66\":1,\"101\":1}}],[\"而java是不允许多继承的\",{\"1\":{\"112\":1}}],[\"而动态代理在各种框架\",{\"1\":{\"109\":1}}],[\"而不会创建新的对象\",{\"1\":{\"243\":1}}],[\"而不是使用summary\",{\"1\":{\"135\":1}}],[\"而不是通过实现接口\",{\"1\":{\"113\":1}}],[\"而不是直接交互\",{\"1\":{\"68\":1}}],[\"而不需要了解具体的实现类\",{\"1\":{\"100\":1}}],[\"而子类也能够在基类的基础上增加新的行为\",{\"1\":{\"70\":1}}],[\"而设计模式是基于对象实例的\",{\"1\":{\"70\":1}}],[\"定义的\",{\"1\":{\"241\":1}}],[\"定义的类\",{\"1\":{\"241\":1}}],[\"定义recoding\",{\"0\":{\"169\":1}}],[\"定义了常量\",{\"1\":{\"241\":1}}],[\"定义了makesofa\",{\"1\":{\"103\":1}}],[\"定义了一个divide方法\",{\"1\":{\"254\":1}}],[\"定义了一个接收发布者消息的方法\",{\"1\":{\"105\":1}}],[\"定义了一个工厂方法makesofa\",{\"1\":{\"99\":1}}],[\"定义了一系列可以创建不同产品对象的方法\",{\"1\":{\"102\":1}}],[\"定义了产品类的属性和方法\",{\"1\":{\"96\":1,\"99\":1,\"102\":1}}],[\"定义文件的写入或者读取的路径\",{\"1\":{\"87\":1}}],[\"定义一个抽象主题类\",{\"1\":{\"110\":1}}],[\"定义一个抽象产品类\",{\"1\":{\"97\":1}}],[\"定义一个接口ifactory\",{\"1\":{\"100\":1}}],[\"定义一个写入的字符串text\",{\"1\":{\"87\":1}}],[\"定义一个目标接口readerwriter\",{\"1\":{\"87\":1}}],[\"定义一系列算法\",{\"1\":{\"68\":1}}],[\"定义目标的方法\",{\"1\":{\"86\":1}}],[\"定义对象之间的一对多依赖关系\",{\"1\":{\"68\":1}}],[\"不包含开发工具\",{\"1\":{\"255\":1}}],[\"不包含方法的实现\",{\"1\":{\"241\":1}}],[\"不参与计算\",{\"1\":{\"251\":1}}],[\"不断轮询\",{\"1\":{\"236\":1}}],[\"不满意就放入缓冲区\",{\"1\":{\"223\":1}}],[\"不允许存在重复的键\",{\"1\":{\"204\":1}}],[\"不允许重复\",{\"1\":{\"176\":1}}],[\"不允许重复元素\",{\"1\":{\"173\":1}}],[\"不同于arraylist可以存储重复元素\",{\"1\":{\"203\":1}}],[\"不同的重载方法可以返回不同的结果\",{\"1\":{\"240\":1}}],[\"不同的是\",{\"1\":{\"238\":1}}],[\"不同的产品由不同的工厂创建\",{\"1\":{\"100\":1}}],[\"不同的逻辑单元的处理逻辑不耦合\",{\"1\":{\"93\":1}}],[\"不同的装饰器有不同的功能\",{\"1\":{\"86\":1}}],[\"不同的角色做不同的事\",{\"1\":{\"83\":1}}],[\"不能有子类继承它\",{\"1\":{\"257\":1}}],[\"不能有构造方法\",{\"1\":{\"241\":1}}],[\"不能表示空值或null\",{\"1\":{\"245\":1}}],[\"不能实例化对象\",{\"1\":{\"241\":1}}],[\"不能被修改\",{\"1\":{\"259\":1}}],[\"不能被实现类调用\",{\"1\":{\"241\":1}}],[\"不能被其他自然数整除\",{\"1\":{\"217\":1}}],[\"不能在多个线程中操作同一个hashmap\",{\"1\":{\"201\":1}}],[\"不能东一榔头西一棒槌\",{\"1\":{\"64\":1}}],[\"不为\",{\"1\":{\"190\":1}}],[\"不需要初始化容量长度等\",{\"1\":{\"189\":1}}],[\"不需要修改已有的代码\",{\"1\":{\"107\":1}}],[\"不建议直接使用\",{\"1\":{\"186\":1}}],[\"不会包含重复的元素\",{\"1\":{\"175\":1}}],[\"不会输出结果\",{\"1\":{\"141\":1,\"142\":1,\"143\":1}}],[\"不重复性\",{\"1\":{\"175\":1}}],[\"不仅可以监控系统的一些状态\",{\"1\":{\"118\":1}}],[\"不支持自身方法调用\",{\"1\":{\"113\":1}}],[\"不推荐使用了\",{\"1\":{\"259\":1}}],[\"不推荐\",{\"0\":{\"78\":1,\"79\":1}}],[\"不提供全局的共享变量\",{\"1\":{\"72\":1}}],[\"不要对实现进行编程\",{\"1\":{\"70\":1}}],[\"不要依赖于具体实现\",{\"1\":{\"70\":1}}],[\"不暴露该对象的内部结构\",{\"1\":{\"68\":1}}],[\"一致性\",{\"1\":{\"252\":1,\"253\":1}}],[\"一旦赋值就不能被改变\",{\"1\":{\"257\":1}}],[\"一旦被赋值\",{\"1\":{\"257\":1}}],[\"一旦创建\",{\"1\":{\"245\":1}}],[\"一旦创建就不能被修改\",{\"1\":{\"243\":1}}],[\"一旦有就绪的事件\",{\"1\":{\"236\":1}}],[\"一起使用\",{\"1\":{\"232\":1,\"233\":1}}],[\"一样可以踢出io\",{\"1\":{\"223\":1}}],[\"一次可能读多个字节\",{\"1\":{\"221\":1}}],[\"一条告警规则主要由以下几部分组成\",{\"1\":{\"164\":1}}],[\"一条成功发送的告警\",{\"1\":{\"163\":1}}],[\"一组已发送初始通知的告警接收到新告警后\",{\"1\":{\"163\":1}}],[\"一组告警第一次发送之前等待的时间\",{\"1\":{\"163\":1}}],[\"一种常用的方式来重写hashcode\",{\"1\":{\"253\":1}}],[\"一种先进先出\",{\"1\":{\"173\":1}}],[\"一种是告警告警规则表达式\",{\"1\":{\"168\":1}}],[\"一种是使用springboot自带的spring\",{\"1\":{\"152\":1}}],[\"一种遍历访问聚合对象中各个元素的方法\",{\"1\":{\"68\":1}}],[\"一对多或者多对一\",{\"1\":{\"144\":1}}],[\"一对一\",{\"1\":{\"144\":1}}],[\"一共有53个\",{\"1\":{\"137\":1}}],[\"一般设置为5分钟或更多\",{\"1\":{\"163\":1}}],[\"一般设置为0秒\",{\"1\":{\"163\":1}}],[\"一般counter类型的指标建议以\",{\"1\":{\"132\":1}}],[\"一般静态代理使用的比较少\",{\"1\":{\"109\":1}}],[\"一般情况下\",{\"1\":{\"86\":1,\"204\":1}}],[\"一般来讲\",{\"1\":{\"86\":1}}],[\"一般常见的考察的面试模式如下\",{\"1\":{\"69\":1}}],[\"一个类只能继承一个抽象类\",{\"1\":{\"241\":1}}],[\"一个类可以实现多个接口\",{\"1\":{\"241\":3,\"242\":1}}],[\"一个类对另一个类的依赖应该建立在最小的接口范围内\",{\"1\":{\"70\":1}}],[\"一个大于1的自然数\",{\"1\":{\"217\":1}}],[\"一个long整数占64比特\",{\"1\":{\"214\":1}}],[\"一个固定的占位符对象\",{\"1\":{\"208\":1}}],[\"一个好的命名规范可以一目了然的知道规则的含义\",{\"1\":{\"170\":1}}],[\"一个简单版的prometheus的架构图如下\",{\"1\":{\"157\":1}}],[\"一个时序数据包含了一个时间戳\",{\"1\":{\"117\":1}}],[\"一个组件可以有很多个装饰器\",{\"1\":{\"86\":1}}],[\"一个拥有\",{\"1\":{\"23\":1}}],[\"策略让算法独立于使用它的客户端而变化\",{\"1\":{\"68\":1}}],[\"策略模式\",{\"1\":{\"68\":1}}],[\"封装每个算法\",{\"1\":{\"68\":1}}],[\"封装对象的创建过程\",{\"1\":{\"66\":1}}],[\"行为型模式\",{\"0\":{\"68\":1}}],[\"使开发者能够更好地利用系统资源\",{\"1\":{\"225\":1}}],[\"使得一个类可以具备多种类型的行为\",{\"1\":{\"241\":1}}],[\"使得发布者和观察者互不影响\",{\"1\":{\"107\":1}}],[\"使得可以用不同的请求来进行参数化\",{\"1\":{\"68\":1}}],[\"使系统能够更好地应对变化和复杂性\",{\"1\":{\"93\":1}}],[\"使用jdk可以进行java应用程序的开发和构建\",{\"1\":{\"255\":1}}],[\"使用throws关键字\",{\"1\":{\"254\":1}}],[\"使用throw语句\",{\"1\":{\"254\":1}}],[\"使用包装类可以让基本类型像一个对象一样使用\",{\"1\":{\"245\":1}}],[\"使用包装类可以使得变量可以被赋值为null\",{\"1\":{\"245\":1}}],[\"使用接口可以避免命名冲突和菱形继承问题\",{\"1\":{\"242\":1}}],[\"使用多路复用器\",{\"1\":{\"238\":1}}],[\"使用多个节点去采集相通的监控对象可以做到高可用\",{\"1\":{\"121\":1}}],[\"使用场景\",{\"0\":{\"216\":1},\"1\":{\"243\":1}}],[\"使用代码示例如下\",{\"1\":{\"205\":1}}],[\"使用迭代器\",{\"1\":{\"174\":1}}],[\"使用\",{\"1\":{\"174\":5,\"198\":1,\"214\":1,\"234\":1,\"236\":1,\"237\":2,\"238\":2}}],[\"使用prometheus\",{\"0\":{\"154\":1}}],[\"使用prometheus明显是不合适的\",{\"1\":{\"121\":1}}],[\"使用spring\",{\"0\":{\"153\":1}}],[\"使用group\",{\"1\":{\"145\":1}}],[\"使用以下的查询\",{\"1\":{\"145\":1}}],[\"使用上面的vector\",{\"1\":{\"144\":1}}],[\"使用标签筛选数据的使用\",{\"1\":{\"137\":1}}],[\"使用le标签表示小于的意思\",{\"1\":{\"134\":1}}],[\"使用了prometheus\",{\"1\":{\"134\":1}}],[\"使用counter类型的指标\",{\"1\":{\"132\":1}}],[\"使用观察者模式有以下的收益\",{\"1\":{\"107\":1}}],[\"使用工厂方法模式的缺点是\",{\"1\":{\"100\":1}}],[\"使用工厂方法模式的好处是\",{\"1\":{\"100\":1}}],[\"使用责任链有以下的优点\",{\"1\":{\"93\":1}}],[\"使用责任链模式可以将一个大而复杂的判断逻辑\",{\"1\":{\"93\":1}}],[\"使用责任链的原因有\",{\"1\":{\"93\":1}}],[\"使用装饰器模式有以下的优点\",{\"1\":{\"88\":1}}],[\"使用案例\",{\"0\":{\"87\":1}}],[\"使用到了包装器模式\",{\"1\":{\"85\":1}}],[\"使用适配器模式有以下的优点\",{\"1\":{\"83\":1}}],[\"使用适配器模式有什么收益\",{\"0\":{\"83\":1}}],[\"使用内部类的模式\",{\"1\":{\"76\":1}}],[\"使用内部类模式\",{\"0\":{\"76\":1}}],[\"使用双重检查来判断实例是否初始化\",{\"1\":{\"75\":1}}],[\"使用同步代码块来保证线程的安全\",{\"1\":{\"75\":1}}],[\"使用单例模式有什么好处呢\",{\"1\":{\"72\":1}}],[\"使用指南\",{\"1\":{\"43\":2},\"2\":{\"6\":1,\"8\":1,\"11\":1,\"40\":1,\"46\":1,\"47\":1}}],[\"使的多个对象都有处理这个请求的机会\",{\"1\":{\"68\":1}}],[\"使它们都可以独立\",{\"1\":{\"67\":1}}],[\"桥接模式\",{\"1\":{\"67\":1}}],[\"将数据从特定区域零拷贝到用户空间\",{\"1\":{\"238\":1}}],[\"将数据写入文件\",{\"1\":{\"227\":1}}],[\"将网卡中所有连接的读写事件数据以链表的形式一次性拷贝到内存中的特定区域\",{\"1\":{\"238\":1}}],[\"将其打印到控制台\",{\"1\":{\"236\":1}}],[\"将需要监听的通道注册到\",{\"1\":{\"229\":1}}],[\"将所有未读完的数据移到缓冲区的开头\",{\"1\":{\"228\":1}}],[\"将字符写入到文件中\",{\"1\":{\"223\":1}}],[\"将字节流转换为字符流\",{\"1\":{\"223\":1}}],[\"将两个或者多个输入流当成一个输入流依次读取\",{\"1\":{\"223\":1}}],[\"将bytearray对象转化为bitset\",{\"1\":{\"217\":1}}],[\"将bitset对象转化为bytearray\",{\"1\":{\"217\":1}}],[\"将1到1亿之间没有在随机数中的数求出来\",{\"1\":{\"216\":1}}],[\"将40亿个不同数据进行排序等\",{\"1\":{\"216\":1}}],[\"将每个非空的位置上的键值对重新计算哈希值\",{\"1\":{\"199\":1}}],[\"将节点\",{\"1\":{\"192\":2}}],[\"将链表的尾节点\",{\"1\":{\"190\":1}}],[\"将当前尾节点\",{\"1\":{\"190\":1}}],[\"将collection中的元素都添加到linkedlist中\",{\"1\":{\"189\":1}}],[\"将collection的按照index位置开始的所有元素添加到集合中\",{\"1\":{\"182\":1}}],[\"将collection的全部元素添加到集合中\",{\"1\":{\"182\":1}}],[\"将\",{\"1\":{\"184\":1,\"190\":1,\"234\":2}}],[\"将元素的放到索引位置\",{\"1\":{\"182\":1}}],[\"将元素添加到size的位置\",{\"1\":{\"182\":1}}],[\"将在添加第一个元素时扩展为default\",{\"1\":{\"180\":1}}],[\"将不会被添加进去\",{\"1\":{\"175\":1}}],[\"将会输出以下结果\",{\"1\":{\"174\":1,\"175\":1,\"176\":1}}],[\"将通过post的http请求发送下游程序\",{\"1\":{\"166\":1}}],[\"将告警消息按照某个标签分组\",{\"1\":{\"163\":1}}],[\"将得不到任何结果\",{\"1\":{\"145\":1}}],[\"将三个审批角色组成一个责任链模式的审批流\",{\"1\":{\"92\":1}}],[\"将目标类和适配的类解耦\",{\"1\":{\"83\":1}}],[\"将适配器这个角色进行高度抽象化\",{\"1\":{\"83\":1}}],[\"将请求的发送者和接收者解耦\",{\"1\":{\"68\":1}}],[\"将命令请求封装为一个对象\",{\"1\":{\"68\":1}}],[\"将一些步骤推迟到子类中\",{\"1\":{\"68\":1}}],[\"将对象组合成树形结构以表示整个部分的层次结构\",{\"1\":{\"67\":1}}],[\"将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"67\":1}}],[\"将抽象部分和实现部分分离\",{\"1\":{\"67\":1}}],[\"将类的接口转换为客户期望的另一个接口\",{\"1\":{\"67\":1,\"81\":1}}],[\"共享对象\",{\"1\":{\"67\":1}}],[\"享元模式\",{\"1\":{\"67\":1}}],[\"代理类\",{\"1\":{\"109\":1,\"110\":1}}],[\"代理对象可以控制客户端对真实对象的访问\",{\"1\":{\"108\":1}}],[\"代理模式分为静态代理和动态代码\",{\"1\":{\"109\":1}}],[\"代理模式常用于对已有功能的增强\",{\"1\":{\"108\":1}}],[\"代理模式是一种结构性模式\",{\"1\":{\"108\":1}}],[\"代理模式并没有做类似于装饰器模式多层嵌套\",{\"1\":{\"108\":1}}],[\"代理模式和装饰器模式类似\",{\"1\":{\"108\":1}}],[\"代理模式\",{\"0\":{\"108\":1},\"1\":{\"67\":1,\"69\":1}}],[\"代码的主要功能包括\",{\"1\":{\"237\":1}}],[\"代码的可扩展性和可复用性非常的强\",{\"1\":{\"88\":1}}],[\"代码示例\",{\"0\":{\"217\":1},\"1\":{\"240\":1}}],[\"代码会变得臃肿难以维护\",{\"1\":{\"109\":1}}],[\"代码如下\",{\"1\":{\"103\":4,\"106\":1,\"110\":1,\"112\":1,\"113\":2,\"198\":1,\"252\":1}}],[\"代码实现\",{\"0\":{\"82\":1,\"97\":1,\"100\":1,\"103\":1,\"110\":1}}],[\"代码编写\",{\"1\":{\"64\":1}}],[\"代码质量是设计出来的\",{\"1\":{\"64\":1}}],[\"代码演示\",{\"0\":{\"35\":1}}],[\"代码块\",{\"0\":{\"20\":1}}],[\"代码\",{\"1\":{\"19\":1}}],[\"形成一个更大的对象\",{\"1\":{\"67\":1}}],[\"但不能修改其实现\",{\"1\":{\"257\":1}}],[\"但它也带来了一些问题\",{\"1\":{\"242\":1}}],[\"但也有一些区别\",{\"1\":{\"241\":1}}],[\"但尽量在构造时指定估算大小\",{\"1\":{\"217\":1}}],[\"但在\",{\"1\":{\"208\":1}}],[\"但同时hashset和hashmap一样\",{\"1\":{\"204\":1}}],[\"但对于随机访问和占用内存方面可能存在劣势\",{\"1\":{\"193\":1}}],[\"但缺点是对于一些无法实现接口的类\",{\"1\":{\"112\":1}}],[\"但缺点是需要手动创建代理类\",{\"1\":{\"109\":1}}],[\"但现实生活中\",{\"1\":{\"101\":1}}],[\"但需要防止责任链模式有过多的处理逻辑单元\",{\"1\":{\"93\":1}}],[\"但又不方便继承\",{\"1\":{\"88\":1}}],[\"但此时singleton并还没初始化完毕\",{\"1\":{\"75\":1}}],[\"但是变量的值是可以被修改的\",{\"1\":{\"257\":1}}],[\"但是它们之间有一些区别\",{\"1\":{\"250\":1}}],[\"但是它是不能给被实例化的\",{\"1\":{\"241\":1}}],[\"但是没有实现\",{\"1\":{\"241\":1}}],[\"但是不同的返回结果不能作为方法重载的定义\",{\"1\":{\"240\":1}}],[\"但是不能返回结果的类型来定义方法的重载\",{\"1\":{\"240\":1}}],[\"但是不太推荐\",{\"1\":{\"77\":1}}],[\"但是参数的个数不同\",{\"1\":{\"240\":1}}],[\"但是java集合的源码或者手写java\",{\"1\":{\"177\":1}}],[\"但是其反应出的是瞬时增长率\",{\"1\":{\"148\":1}}],[\"但是通过计算在时间窗口内的平均增长率却无法反应出该问题\",{\"1\":{\"148\":1}}],[\"但是对于prometheus的底层数据来说\",{\"1\":{\"131\":1}}],[\"但是需要对值的控制字符进行转义\",{\"1\":{\"130\":1}}],[\"但是在进行插入和删除操作时\",{\"1\":{\"180\":1}}],[\"但是在大多数情况下\",{\"1\":{\"134\":1}}],[\"但是在使用它的时候需要注意它带来的一些缺点\",{\"1\":{\"107\":1}}],[\"但是在方法上加了锁\",{\"1\":{\"79\":1}}],[\"但是mac电脑只有typec接口\",{\"1\":{\"81\":1}}],[\"但是代码比双重检查模式简洁\",{\"1\":{\"76\":1}}],[\"但是由于简单\",{\"1\":{\"74\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"44\":1}}],[\"但由子类来决定要实例化哪个类\",{\"1\":{\"66\":1,\"98\":1}}],[\"它在try块或catch块中的代码执行完毕后立即执行\",{\"1\":{\"260\":1}}],[\"它还具有内存管理\",{\"1\":{\"255\":1}}],[\"它位于异常类的最顶层\",{\"1\":{\"254\":1}}],[\"它比较的是对字符串内容的比较\",{\"1\":{\"252\":1}}],[\"它让我们可以使用父类的引用变量来引用不同子类的对象\",{\"1\":{\"246\":1}}],[\"它允许我们使用父类的引用变量来引用子类的对象实例\",{\"1\":{\"246\":1}}],[\"它允许将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"108\":1}}],[\"它更直观\",{\"1\":{\"244\":1}}],[\"它不能被实例化\",{\"1\":{\"241\":1}}],[\"它首先创建一个\",{\"1\":{\"236\":1}}],[\"它先创建一个\",{\"1\":{\"236\":1}}],[\"它用于监听客户端的连接请求\",{\"1\":{\"233\":1}}],[\"它表示可以存储的最大数据量\",{\"1\":{\"228\":1}}],[\"它将字节流转变为字符流\",{\"1\":{\"223\":1}}],[\"它也是一个顶级父类\",{\"1\":{\"223\":2}}],[\"它们会被隐式地视为final\",{\"1\":{\"258\":1}}],[\"它们都有一个共同的方法\",{\"1\":{\"246\":1}}],[\"它们都是用于类的方法\",{\"1\":{\"240\":1}}],[\"它们之间有以下区别\",{\"1\":{\"243\":1}}],[\"它们有一些共同点\",{\"1\":{\"241\":1}}],[\"它们有转换作用\",{\"1\":{\"223\":1}}],[\"它们分别用于读写不同类型的数据\",{\"1\":{\"228\":1}}],[\"它们分别向char\",{\"1\":{\"223\":1}}],[\"它们分别向byte\",{\"1\":{\"223\":1}}],[\"它们分别将char\",{\"1\":{\"223\":1}}],[\"它们分别从byte\",{\"1\":{\"223\":1}}],[\"它们共同组成描述当前指标的特征\",{\"1\":{\"130\":1}}],[\"它提供了非阻塞的\",{\"1\":{\"232\":1}}],[\"它提供了更多的控制权和灵活性\",{\"1\":{\"225\":1}}],[\"它提供了处理文件\",{\"1\":{\"220\":1}}],[\"它提供了一种基于缓冲区\",{\"1\":{\"225\":1}}],[\"它提供了一组接口和类\",{\"1\":{\"173\":1}}],[\"它提供了一个创建一系列相关对象的接口\",{\"1\":{\"66\":1,\"101\":1}}],[\"它基于哈希表的数据结构\",{\"1\":{\"211\":1}}],[\"它调用\",{\"1\":{\"209\":1,\"210\":1}}],[\"它利用哈希函数将键映射到数组的索引位置\",{\"1\":{\"201\":1}}],[\"它拓展自\",{\"1\":{\"196\":1}}],[\"它包含了jvm\",{\"1\":{\"255\":1}}],[\"它包含了\",{\"1\":{\"188\":2}}],[\"它返回的是一个新的object\",{\"1\":{\"183\":1}}],[\"它继承自\",{\"1\":{\"179\":1}}],[\"它和其子类负责装饰其它reader\",{\"1\":{\"223\":1}}],[\"它和collection接口属于并列的关系\",{\"1\":{\"176\":1}}],[\"它和里氏替换原则相辅相成的\",{\"1\":{\"70\":1}}],[\"它定义了可以被抛出和捕获的异常对象的基本功能\",{\"1\":{\"254\":1}}],[\"它定义了集合的基本操作\",{\"1\":{\"173\":1}}],[\"它定义了一组方法的方法\",{\"1\":{\"241\":1}}],[\"它定义了一些方法\",{\"1\":{\"109\":1}}],[\"它定义了一个创建对象的接口\",{\"1\":{\"66\":1,\"98\":1}}],[\"它会含有endts这个时间戳参数\",{\"1\":{\"163\":1}}],[\"它可以在合适的场景中使用\",{\"1\":{\"257\":1}}],[\"它可以是一个邮箱也可以是微信\",{\"1\":{\"162\":1}}],[\"它可以把字符写入到文件中\",{\"1\":{\"87\":1}}],[\"它默认集成在spring\",{\"1\":{\"153\":1}}],[\"它同等于\",{\"1\":{\"146\":1}}],[\"它支持多种类型的数据库\",{\"1\":{\"127\":1}}],[\"它为主机暴露了硬件和内核相关的指标\",{\"1\":{\"125\":1}}],[\"它并不能保证数据的及时性和绝对正确性\",{\"1\":{\"121\":1}}],[\"它对多维数据收集和查询的支持是一个特别的优势\",{\"1\":{\"121\":1}}],[\"它既适合以机器为中心的监视\",{\"1\":{\"121\":1}}],[\"它能够有效地处理程序中可能发生的异常情况\",{\"1\":{\"254\":1}}],[\"它能够提高系统的可扩展性和灵活性\",{\"1\":{\"107\":1}}],[\"它能审批10000元以下的借款\",{\"1\":{\"92\":1}}],[\"它能审批5000元以下的借款\",{\"1\":{\"92\":1}}],[\"它维护了一个状态\",{\"1\":{\"105\":1}}],[\"它维护了一个观察者的列表\",{\"1\":{\"105\":1}}],[\"它具有更好的可维护性\",{\"1\":{\"244\":1}}],[\"它具有以下的优点\",{\"1\":{\"103\":1}}],[\"它具有如下的优点\",{\"1\":{\"97\":1}}],[\"它只能审批1000元以下的借款\",{\"1\":{\"92\":1}}],[\"它只提供typec接口\",{\"1\":{\"83\":1}}],[\"它有一个接收通知对象的方法\",{\"1\":{\"106\":1}}],[\"它有一个createsofa\",{\"1\":{\"100\":1}}],[\"它有一个抽象方法getname\",{\"1\":{\"97\":1}}],[\"它有一个核心的处理方法\",{\"1\":{\"91\":1}}],[\"它有读取和写入的功能\",{\"1\":{\"87\":1}}],[\"它实现了观察者的更新接口\",{\"1\":{\"105\":1}}],[\"它实现了readerwriter接口\",{\"1\":{\"87\":2}}],[\"它实现了目标接口\",{\"1\":{\"86\":3}}],[\"它是在对象被垃圾回收器回收之前调用的\",{\"1\":{\"259\":1}}],[\"它是throwable的一个子类\",{\"1\":{\"254\":1}}],[\"它是动态绑定来确定运行时对象的实际方法的调用\",{\"1\":{\"240\":1}}],[\"它是子类对父类的同名方法且具有相同的参数的重新实现\",{\"1\":{\"240\":1}}],[\"它是\",{\"1\":{\"226\":1}}],[\"它是collection框架的一部分\",{\"1\":{\"173\":1}}],[\"它是一个最终类\",{\"1\":{\"257\":1}}],[\"它是一个抽象的计算机\",{\"1\":{\"255\":1}}],[\"它是一个抽象类\",{\"1\":{\"223\":1}}],[\"它是一个对象数组\",{\"1\":{\"228\":1}}],[\"它是一个顶级父类\",{\"1\":{\"223\":1}}],[\"它是一个瞬时向量结果\",{\"1\":{\"138\":1}}],[\"它是一个基础能力\",{\"1\":{\"136\":1}}],[\"它是可增可减的\",{\"1\":{\"133\":1}}],[\"它是实现动态代理的关键\",{\"1\":{\"112\":1}}],[\"它是目标接口\",{\"1\":{\"86\":1}}],[\"它是为了解决具体的编码问题或者是解决某一类问题而产生的\",{\"1\":{\"64\":1}}],[\"它又称为包装器模式\",{\"1\":{\"85\":1}}],[\"它必须持有或者实现目标类和适配类的接口\",{\"1\":{\"81\":1}}],[\"它的方法都使用了synchronized关键字来进行同步\",{\"1\":{\"243\":1}}],[\"它的子类filewriter\",{\"1\":{\"223\":1}}],[\"它的源码如下\",{\"1\":{\"189\":1}}],[\"它的优点如下\",{\"1\":{\"112\":1}}],[\"它的uml图如下所示\",{\"1\":{\"81\":1}}],[\"它的所有依赖项都会自动得到通知和更新\",{\"1\":{\"68\":1}}],[\"它属于懒汉模式\",{\"1\":{\"75\":1}}],[\"创建\",{\"1\":{\"223\":1,\"228\":1,\"229\":1}}],[\"创建了一个新的\",{\"1\":{\"207\":1}}],[\"创建一个文件对象\",{\"1\":{\"227\":1}}],[\"创建一个新的\",{\"1\":{\"199\":1}}],[\"创建一个\",{\"1\":{\"174\":1,\"175\":1,\"176\":1,\"197\":1,\"228\":1}}],[\"创建子类对象代理\",{\"1\":{\"113\":1}}],[\"创建和业务逻辑判断\",{\"1\":{\"97\":1}}],[\"创建者模式\",{\"1\":{\"66\":1}}],[\"创建型设计模式\",{\"1\":{\"66\":1}}],[\"创建型模式\",{\"0\":{\"66\":1}}],[\"单一职责\",{\"1\":{\"83\":2}}],[\"单一职责原则\",{\"1\":{\"70\":1}}],[\"单例模式除了上面的写法\",{\"1\":{\"77\":1}}],[\"单例模式不需要对外提供构造方法\",{\"1\":{\"74\":1}}],[\"单例模式声明了一个名为\",{\"1\":{\"73\":1}}],[\"单例模式的实现\",{\"0\":{\"73\":1}}],[\"单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的\",{\"1\":{\"72\":1}}],[\"单例模式可以解决一个全局的使用的实例\",{\"1\":{\"72\":1}}],[\"单例模式在允许在全局中只存在一个实例\",{\"1\":{\"72\":1}}],[\"单例模式\",{\"0\":{\"71\":1},\"1\":{\"69\":1}}],[\"单列模式\",{\"1\":{\"66\":1}}],[\"单词\",{\"1\":{\"23\":1}}],[\"在回答这个问题前\",{\"1\":{\"260\":1}}],[\"在try或catch块中使用return语句时\",{\"1\":{\"260\":1}}],[\"在try块中有system\",{\"1\":{\"260\":1}}],[\"在try\",{\"1\":{\"259\":1}}],[\"在try代码块中\",{\"1\":{\"254\":1}}],[\"在静态代码快中赋值\",{\"1\":{\"257\":1}}],[\"在代码快中赋值\",{\"1\":{\"257\":1}}],[\"在方法签名中明确指定可能抛出的异常类型\",{\"1\":{\"254\":1}}],[\"在方法内部\",{\"1\":{\"208\":1,\"209\":1,\"210\":1}}],[\"在对象的生命周期中\",{\"1\":{\"253\":1}}],[\"在对hashmap对象查找元素的时候\",{\"1\":{\"200\":1}}],[\"在string类的方法中\",{\"1\":{\"252\":1}}],[\"在springboot的项目中增加springboot指标的采集\",{\"1\":{\"155\":1}}],[\"在springboot项目中\",{\"1\":{\"166\":1}}],[\"在springboot项目中的pom文件引入以下的依赖\",{\"1\":{\"154\":1}}],[\"在springboot项目中使用prometheus监控\",{\"0\":{\"152\":1}}],[\"在springboot项目创建一个测试接口\",{\"1\":{\"153\":1}}],[\"在object类中\",{\"1\":{\"252\":1}}],[\"在初学java的时候\",{\"1\":{\"252\":1}}],[\"在自动装箱和拆箱时\",{\"1\":{\"245\":1}}],[\"在实际的开发中\",{\"1\":{\"252\":1}}],[\"在实际的开发过程中是应用非常多的\",{\"1\":{\"66\":1}}],[\"在实际编程中\",{\"1\":{\"244\":1}}],[\"在面向对象编程中\",{\"1\":{\"244\":1}}],[\"在面向过程编程中\",{\"1\":{\"244\":1}}],[\"在面试过程中\",{\"1\":{\"69\":1}}],[\"在单线程环境中\",{\"1\":{\"243\":1}}],[\"在接口定义中\",{\"1\":{\"241\":1}}],[\"在接下来的文章中会逐步讲解这几种设计模式\",{\"1\":{\"69\":1}}],[\"在while循环中\",{\"1\":{\"237\":1}}],[\"在一个线程内处理多个\",{\"1\":{\"234\":1}}],[\"在使用final变量前必须赋值\",{\"1\":{\"257\":1}}],[\"在使用前必须赋值\",{\"1\":{\"257\":1}}],[\"在使用关系操作符\",{\"1\":{\"251\":1}}],[\"在使用\",{\"1\":{\"232\":1,\"233\":1,\"234\":1,\"238\":1}}],[\"在使用迭代器遍历\",{\"1\":{\"186\":1}}],[\"在读取模式下\",{\"1\":{\"228\":1}}],[\"在读取文件的字符之后\",{\"1\":{\"87\":2}}],[\"在写入模式下\",{\"1\":{\"228\":2}}],[\"在写入文件之前\",{\"1\":{\"87\":2}}],[\"在构造函数接收两种类型的参数\",{\"1\":{\"223\":1}}],[\"在构造函数中赋值\",{\"1\":{\"257\":1}}],[\"在构造函数中\",{\"1\":{\"207\":1}}],[\"在其源代码中明显使用了将fileinputstream\",{\"1\":{\"223\":1}}],[\"在最初写入时会有一个基准的行号\",{\"1\":{\"223\":1}}],[\"在输出部分没有对应的部分\",{\"1\":{\"223\":1}}],[\"在哪里分行是由改类主动确定的\",{\"1\":{\"223\":1}}],[\"在需要处理的数据范围比较大的场景下可以有效减少扩容的次数\",{\"1\":{\"214\":1}}],[\"在需要频繁插入和删除元素的场景下很有优势\",{\"1\":{\"193\":1}}],[\"在处理哈希冲突时\",{\"1\":{\"201\":1}}],[\"在上述代码中\",{\"1\":{\"254\":1}}],[\"在上述示例中\",{\"1\":{\"241\":1,\"251\":1}}],[\"在上述源码中\",{\"1\":{\"200\":1}}],[\"在上面的这个例子中\",{\"1\":{\"241\":1}}],[\"在上面的例子中\",{\"1\":{\"240\":1,\"241\":1}}],[\"在上面的关系图中可以看出\",{\"1\":{\"223\":1}}],[\"在上面的示例中\",{\"1\":{\"134\":1}}],[\"在上面讲解的操作符\",{\"1\":{\"144\":1}}],[\"在新的\",{\"1\":{\"199\":1}}],[\"在扩容操作中\",{\"1\":{\"199\":1}}],[\"在扩展性上\",{\"1\":{\"86\":1}}],[\"在插入新键值对后\",{\"1\":{\"198\":1}}],[\"在访问元素时相对较慢\",{\"1\":{\"193\":1}}],[\"在访问的时候需要锁占用\",{\"1\":{\"79\":1}}],[\"在指定位置插入元素\",{\"1\":{\"193\":1}}],[\"在获取到对应节点后\",{\"1\":{\"191\":1}}],[\"在通过\",{\"1\":{\"186\":1}}],[\"在制定位置添加元素\",{\"1\":{\"182\":1}}],[\"在进行数据读写时\",{\"1\":{\"228\":1}}],[\"在进行对象实例化时可指定操作模式\",{\"1\":{\"223\":1}}],[\"在进行扩容之前会将当前\",{\"1\":{\"199\":1}}],[\"在进行删除操作时\",{\"1\":{\"180\":1}}],[\"在进程内部计算告警规则\",{\"1\":{\"157\":1}}],[\"在\",{\"1\":{\"180\":1,\"190\":1,\"191\":1,\"192\":1,\"196\":1,\"204\":2,\"210\":1,\"214\":2,\"225\":2,\"226\":1,\"236\":5,\"237\":2,\"246\":1,\"254\":1}}],[\"在如今java面试八股文满天飞的时代\",{\"1\":{\"177\":1}}],[\"在文件中写一个指标聚合的表达式\",{\"1\":{\"172\":1}}],[\"在文件流的基础之上使用装饰器模式\",{\"1\":{\"87\":1}}],[\"在等待期间新产生告警的状态为pending\",{\"1\":{\"164\":1}}],[\"在每一个group中我们可以定义多个告警规则\",{\"1\":{\"164\":1}}],[\"在告警规则文件中\",{\"1\":{\"164\":1}}],[\"在浏览器中访问localhost\",{\"1\":{\"163\":1}}],[\"在浏览器上请求http\",{\"1\":{\"153\":1}}],[\"在浏览器上请求测试接口http\",{\"1\":{\"153\":1,\"154\":1}}],[\"在再次发送通知之前等待的时间\",{\"1\":{\"163\":1}}],[\"在此篇文章只讲解最基础的和几个重要的配置\",{\"1\":{\"163\":1}}],[\"在启动之前\",{\"1\":{\"162\":1}}],[\"在本篇文章中将会讲述prometheus告警与alertmanager实战\",{\"1\":{\"157\":1}}],[\"在本地部署的grafana页面导入node\",{\"1\":{\"127\":1}}],[\"在前面的文章已经讲解过prometheus采集数据和查询数据\",{\"1\":{\"157\":1}}],[\"在前面的文章介绍过如下prometheus自身的监控\",{\"1\":{\"130\":1}}],[\"在它内部进行告警消息的管理\",{\"1\":{\"157\":1}}],[\"在aftercompletion方法中\",{\"1\":{\"154\":1}}],[\"在项目中有一个测试接口\",{\"1\":{\"154\":1}}],[\"在项目中引入以下的依赖\",{\"1\":{\"153\":1}}],[\"在这种情况下\",{\"1\":{\"253\":1}}],[\"在这个示例中\",{\"1\":{\"260\":1}}],[\"在这个例子中\",{\"1\":{\"245\":1,\"246\":1}}],[\"在这个接口中\",{\"1\":{\"112\":1}}],[\"在这里有三个指标\",{\"1\":{\"153\":1}}],[\"在这里就不展开讲解了\",{\"1\":{\"153\":1}}],[\"在作用于两个瞬时向量之间\",{\"1\":{\"141\":1}}],[\"在很多场景下\",{\"1\":{\"134\":1}}],[\"在很多rpc框架\",{\"1\":{\"108\":1}}],[\"在下一行\",{\"1\":{\"245\":1}}],[\"在下一篇文章将会讲解\",{\"1\":{\"132\":1}}],[\"在下面的案例中\",{\"1\":{\"74\":1}}],[\"在注释中包含了指标的类型\",{\"1\":{\"131\":1}}],[\"在grafana中为springboot项目配置试图\",{\"1\":{\"156\":1}}],[\"在grafana执行\",{\"1\":{\"137\":1}}],[\"在grafana上查询指标\",{\"1\":{\"130\":1}}],[\"在gui中应用的比较多\",{\"1\":{\"105\":1}}],[\"在更改完配置以后\",{\"1\":{\"126\":1}}],[\"在查询框里输入node\",{\"1\":{\"125\":1}}],[\"在prehandle方法中记录请求的开始时间starttime\",{\"1\":{\"154\":1}}],[\"在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算\",{\"1\":{\"144\":1}}],[\"在prometheus的页面上可以查看新指标的数据\",{\"1\":{\"172\":1}}],[\"在prometheus的yaml配置文件中\",{\"1\":{\"172\":1}}],[\"在prometheus的配置文件中\",{\"1\":{\"164\":1}}],[\"在prometheus的配置文prometheus\",{\"1\":{\"125\":1}}],[\"在prometheus的启动程序的同级目录下面\",{\"1\":{\"164\":1}}],[\"在prometheus中配置告警规则\",{\"0\":{\"164\":1}}],[\"在prometheus\",{\"1\":{\"157\":2}}],[\"在prometheus启动的时候加上启动参数\",{\"1\":{\"126\":1}}],[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus\",{\"1\":{\"124\":1}}],[\"在pom文件中引入cglib包\",{\"1\":{\"113\":1}}],[\"在不同容量情况下系统的并发和负载变化如何\",{\"1\":{\"121\":1}}],[\"在不改变了componentimpl的情况下\",{\"1\":{\"86\":1}}],[\"在不改变已有类的功能的前提下进行批量扩展\",{\"1\":{\"68\":1}}],[\"在微服务的世界里\",{\"1\":{\"121\":1}}],[\"在某些情况下\",{\"1\":{\"112\":1}}],[\"在消息队列的场景有广泛的应用\",{\"1\":{\"105\":1}}],[\"在观察者模式中\",{\"1\":{\"105\":1}}],[\"在流程中有三个角色\",{\"1\":{\"92\":1}}],[\"在工作中\",{\"1\":{\"92\":1}}],[\"在讲解完具体案例后\",{\"1\":{\"88\":1}}],[\"在案例模仿javaio的文件流的写入和读取功能\",{\"1\":{\"87\":1}}],[\"在图中一共有三个角色\",{\"1\":{\"86\":1}}],[\"在java中有八种基本数据类型\",{\"1\":{\"251\":1}}],[\"在java中\",{\"1\":{\"242\":1,\"243\":1,\"251\":1,\"254\":1}}],[\"在java中创建一个对象\",{\"1\":{\"75\":1}}],[\"在java语言中并支持动态代理\",{\"1\":{\"108\":1}}],[\"在java的io源码中\",{\"1\":{\"85\":1}}],[\"在程序中\",{\"1\":{\"81\":1}}],[\"在多线程的情况下\",{\"1\":{\"76\":1}}],[\"在判断singleton==null时不为null\",{\"1\":{\"75\":1}}],[\"在系统中只需要初始化一个实例\",{\"1\":{\"72\":1}}],[\"在什么样的场景会使用到单列模式呢\",{\"1\":{\"72\":1}}],[\"在复用代码时\",{\"1\":{\"70\":1}}],[\"在操作中定义算法的框架\",{\"1\":{\"68\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"7\":1}}],[\"如在try语句之前就返回了\",{\"1\":{\"260\":1}}],[\"如hashset\",{\"1\":{\"253\":1}}],[\"如何理解java中的多态\",{\"0\":{\"246\":1}}],[\"如何理解面向过程和面向对象\",{\"0\":{\"244\":1}}],[\"如动物类\",{\"1\":{\"241\":1}}],[\"如读\",{\"1\":{\"229\":1}}],[\"如网络连接或文件\",{\"1\":{\"225\":1}}],[\"如图\",{\"1\":{\"238\":1}}],[\"如图片\",{\"1\":{\"221\":1}}],[\"如图所示\",{\"1\":{\"65\":1,\"81\":1}}],[\"如统计40亿个数据中没有出现的数据\",{\"1\":{\"216\":1}}],[\"如\",{\"1\":{\"211\":1,\"223\":2,\"229\":1}}],[\"如截取子列表\",{\"1\":{\"174\":1}}],[\"如添加\",{\"1\":{\"173\":1}}],[\"如list\",{\"1\":{\"173\":1}}],[\"如全局的smtp配置\",{\"1\":{\"162\":1}}],[\"如下图所示\",{\"1\":{\"196\":1,\"257\":1}}],[\"如下图\",{\"1\":{\"188\":1}}],[\"如下图的uml图\",{\"1\":{\"73\":1}}],[\"如下\",{\"1\":{\"154\":2,\"172\":1,\"225\":2}}],[\"如下表示prometheus\",{\"1\":{\"130\":1}}],[\"如果定义为final\",{\"1\":{\"258\":1}}],[\"如果外部类的方法中的变量不定义final\",{\"1\":{\"258\":1}}],[\"如果将局部变量\",{\"1\":{\"258\":1}}],[\"如果被final修饰的变量时引用类型\",{\"1\":{\"257\":1}}],[\"如果某个属性可以为null\",{\"1\":{\"253\":1}}],[\"如果某个通道的事件处理完成后\",{\"1\":{\"229\":1}}],[\"如果我们没有重写hashcode\",{\"1\":{\"253\":1}}],[\"如果我们想查询一个时间区间的样本\",{\"1\":{\"138\":1}}],[\"如果x\",{\"1\":{\"252\":2}}],[\"如果两个对象根据equals\",{\"1\":{\"253\":1}}],[\"如果两个引用指向不同的对象\",{\"1\":{\"251\":1}}],[\"如果两个变量的引用指向同一个对象\",{\"1\":{\"251\":1}}],[\"如果使用==\",{\"1\":{\"251\":1}}],[\"如果使用基本类型\",{\"1\":{\"245\":1}}],[\"如果使用相同的键插入多个值\",{\"1\":{\"176\":1}}],[\"如果一个类既需要作为其他类的基类\",{\"1\":{\"241\":1}}],[\"如果文件存在\",{\"1\":{\"223\":1}}],[\"如果除了1和它本身外\",{\"1\":{\"217\":1}}],[\"如果用于比较的对象信息没有被修改\",{\"1\":{\"252\":1}}],[\"如果用\",{\"1\":{\"214\":1}}],[\"如果相等\",{\"1\":{\"210\":1,\"252\":1}}],[\"如果删除成功\",{\"1\":{\"210\":1}}],[\"如果存在\",{\"1\":{\"209\":1}}],[\"如果在finally中再次使用了return操作\",{\"1\":{\"260\":2}}],[\"如果在catch中再次使用了return操作\",{\"1\":{\"260\":1}}],[\"如果在try块中发生了异常\",{\"1\":{\"260\":2}}],[\"如果在try块中没有发生异常\",{\"1\":{\"260\":1}}],[\"如果在此过程中发生了异常\",{\"1\":{\"254\":1}}],[\"如果在单线程环境下进行字符串操作\",{\"1\":{\"243\":1}}],[\"如果在多线程环境下执行字符串操作\",{\"1\":{\"243\":1}}],[\"如果在多线程环境下使用\",{\"1\":{\"211\":1}}],[\"如果在链表或红黑树中找到键对应的节点\",{\"1\":{\"200\":1}}],[\"如果在目标类中\",{\"1\":{\"83\":1}}],[\"如果匹配则直接返回\",{\"1\":{\"200\":1}}],[\"如果匹配到了\",{\"1\":{\"141\":1}}],[\"如果遍历完链表或红黑树仍未找到相同的键\",{\"1\":{\"200\":1}}],[\"如果\",{\"1\":{\"198\":1,\"199\":1,\"200\":2,\"208\":2,\"209\":1}}],[\"如果没有找到相同的键\",{\"1\":{\"198\":1}}],[\"如果没有配置\",{\"1\":{\"169\":1}}],[\"如果找到相同的键\",{\"1\":{\"198\":2,\"200\":1}}],[\"如果找到匹配的元素\",{\"1\":{\"184\":1}}],[\"如果头节点上treenode\",{\"1\":{\"198\":1}}],[\"如果该索引位置上没有键值对\",{\"1\":{\"200\":1}}],[\"如果该位置已经有键值对\",{\"1\":{\"199\":1}}],[\"如果该\",{\"1\":{\"198\":1}}],[\"如果链表长度超过了阈值\",{\"1\":{\"198\":1}}],[\"如果链表长度超过阈值\",{\"1\":{\"196\":1}}],[\"如果链表的尾节点\",{\"1\":{\"190\":2}}],[\"如果节点\",{\"1\":{\"192\":2}}],[\"如果索引\",{\"1\":{\"191\":2,\"198\":1,\"200\":1}}],[\"如果索引无效\",{\"1\":{\"191\":1,\"192\":1}}],[\"如果索引位于链表的后半段\",{\"1\":{\"191\":1}}],[\"如果索引位于链表的前半段\",{\"1\":{\"191\":1}}],[\"如果未找到指定元素\",{\"1\":{\"185\":1}}],[\"如果要操作的文件不存在\",{\"1\":{\"223\":1}}],[\"如果要查找的元素不为\",{\"1\":{\"185\":1}}],[\"如果要求分位耗时\",{\"1\":{\"153\":1}}],[\"如果是链表\",{\"1\":{\"198\":1}}],[\"如果是则抛出异常\",{\"1\":{\"186\":1}}],[\"如果是\",{\"1\":{\"185\":1,\"200\":1}}],[\"如果是想做与money相关的业务\",{\"1\":{\"121\":1}}],[\"如果index超出长度\",{\"1\":{\"185\":1}}],[\"如果超出了interger的软最大值则报错\",{\"1\":{\"183\":1}}],[\"如果elementdata是defaultcapacity\",{\"1\":{\"183\":1}}],[\"如果expr表达式的计算结果包含标签\",{\"1\":{\"169\":1}}],[\"如果数组容量过大且元素数量远小于容量的\",{\"1\":{\"180\":1}}],[\"如果labels配置中含有额外的标签也会放到新的timeseries中\",{\"1\":{\"169\":1}}],[\"如果判断需要发送消息给下游的webhook程序\",{\"1\":{\"166\":1}}],[\"如果告警消息符合匹配\",{\"1\":{\"161\":1}}],[\"如果系统发出成千上万条相同的告警消息\",{\"1\":{\"159\":1}}],[\"如果有告警发生\",{\"1\":{\"157\":1}}],[\"如果想计算所有的请求的总数\",{\"1\":{\"146\":1}}],[\"如果想查询五分钟前的数据\",{\"1\":{\"139\":1}}],[\"如果不相等则抛出异常\",{\"1\":{\"186\":1}}],[\"如果不为空数组\",{\"1\":{\"183\":1}}],[\"如果不够\",{\"1\":{\"180\":1}}],[\"如果不进行分组合并\",{\"1\":{\"159\":1}}],[\"如果不用ignoring修改器\",{\"1\":{\"145\":1}}],[\"如果不使用观察者模式来捕获一个被观察对象的属性变化\",{\"1\":{\"107\":1}}],[\"如果需要在多线程中操作同一个map\",{\"1\":{\"201\":1}}],[\"如果需要进行扩容操作\",{\"1\":{\"199\":1}}],[\"如果需要把证消息发送的顺序\",{\"1\":{\"107\":1}}],[\"如果需要增加新的产品类\",{\"1\":{\"97\":1}}],[\"如果处理链路过长\",{\"1\":{\"93\":1}}],[\"如果此时伪代码发生重排序\",{\"1\":{\"75\":1}}],[\"如果你不了解它\",{\"1\":{\"15\":1}}],[\"如果你是一个新手\",{\"1\":{\"14\":1}}],[\"分布均匀性\",{\"1\":{\"253\":1}}],[\"分布式系统和高性能计算等领域\",{\"1\":{\"225\":1}}],[\"分组是\",{\"1\":{\"159\":1}}],[\"分组是将同一组多个的相同的告警消息合并成一个高级消息\",{\"1\":{\"159\":1}}],[\"分组\",{\"0\":{\"159\":1},\"1\":{\"158\":1}}],[\"分组修改器可以一边的标签组赋值给另一边的查询结构\",{\"1\":{\"145\":1}}],[\"分组修改器可以实现many\",{\"1\":{\"145\":1}}],[\"分组修改器\",{\"0\":{\"145\":1}}],[\"分别引用了\",{\"1\":{\"246\":1}}],[\"分别表示节点的数据\",{\"1\":{\"188\":1}}],[\"分别表示链表的大小\",{\"1\":{\"188\":1}}],[\"分别为\",{\"1\":{\"153\":1,\"181\":1}}],[\"分别是\",{\"1\":{\"162\":1}}],[\"分别是code\",{\"1\":{\"146\":1}}],[\"分别是员工\",{\"1\":{\"92\":1}}],[\"分别是创建性型设计模式\",{\"1\":{\"65\":1}}],[\"分钟\",{\"1\":{\"138\":1}}],[\"分发\",{\"1\":{\"120\":1}}],[\"分成多个小的逻辑单元\",{\"1\":{\"93\":1}}],[\"分配内存空间\",{\"1\":{\"75\":1}}],[\"分类为\",{\"1\":{\"43\":1}}],[\"剩下的设计模式会在写完java面试系列文章之后做为补充\",{\"1\":{\"64\":1}}],[\"优先讲解面试过程中常见遇到的几种设计模式\",{\"1\":{\"64\":1}}],[\"那\",{\"1\":{\"214\":1}}],[\"那就是\",{\"1\":{\"214\":1}}],[\"那要记录一整年的数据\",{\"1\":{\"214\":1}}],[\"那prometheus不适合什么\",{\"1\":{\"121\":1}}],[\"那它的缺点是\",{\"1\":{\"97\":1}}],[\"那么当外部类方法执行完毕的时候\",{\"1\":{\"258\":1}}],[\"那么它们的hashcode\",{\"1\":{\"253\":1}}],[\"那么它们之间的\",{\"1\":{\"251\":2}}],[\"那么hashcode\",{\"1\":{\"253\":2}}],[\"那么在设计时可以考虑将类设计为抽象类\",{\"1\":{\"241\":1}}],[\"那么会将新的值替换旧的值\",{\"1\":{\"208\":1}}],[\"那么会返回\",{\"1\":{\"208\":1}}],[\"那么每秒的增量率\",{\"1\":{\"148\":1}}],[\"那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑\",{\"1\":{\"107\":1}}],[\"那么为什么还需要使用适配器模式呢\",{\"1\":{\"83\":1}}],[\"那么如何学习好设计模式呢\",{\"1\":{\"64\":1}}],[\"那为什么要使用volatile关键字来修饰静态的instance对象呢\",{\"1\":{\"75\":1}}],[\"那本系列教程将会讲述23种经典的设计模式\",{\"1\":{\"64\":1}}],[\"要注意的是\",{\"1\":{\"251\":1}}],[\"要调用子类特有的方法\",{\"1\":{\"246\":1}}],[\"要把键值对\",{\"1\":{\"198\":1}}],[\"要求springboot>=2\",{\"1\":{\"153\":1}}],[\"要做一些优化工作\",{\"1\":{\"107\":1}}],[\"要做到知其然并知其所以然\",{\"1\":{\"64\":1}}],[\"要尽量先使用组合关系来实现\",{\"1\":{\"70\":1}}],[\"要深挖技术背后的原因\",{\"1\":{\"64\":1}}],[\"刻意的去练习\",{\"1\":{\"64\":1}}],[\"都指向常量池中的同一个字符串对象\",{\"1\":{\"251\":1}}],[\"都可以用于比较\",{\"1\":{\"250\":1}}],[\"都可以通过以下配置\",{\"1\":{\"169\":1}}],[\"都包含两个引用\",{\"1\":{\"188\":1}}],[\"都是以当前时间为基准的\",{\"1\":{\"139\":1}}],[\"都是以time\",{\"1\":{\"131\":1}}],[\"都是在不改变同一个接口功能的前提下\",{\"1\":{\"108\":1}}],[\"都是在程序启动之初创建\",{\"1\":{\"74\":1}}],[\"都很方便替换\",{\"1\":{\"83\":1}}],[\"都会让程序员在技术的海洋里迷失\",{\"1\":{\"64\":1}}],[\"都需要良好的程序设计\",{\"1\":{\"64\":1}}],[\"多态性是继承的一个重要应用\",{\"1\":{\"246\":1}}],[\"多态主要体现在方法的重写和方法的动态绑定上\",{\"1\":{\"246\":1}}],[\"多态是面向对象编程的一个核心概念\",{\"1\":{\"246\":1}}],[\"多继承可能导致菱形继承问题\",{\"1\":{\"242\":1}}],[\"多继承是指一个类可以从多个父类继承属性和方法\",{\"1\":{\"242\":1}}],[\"多继承的支持\",{\"1\":{\"241\":1}}],[\"多路复用\",{\"1\":{\"234\":1}}],[\"多线程环境下需要额外的同步处理\",{\"1\":{\"214\":1}}],[\"多维的数据结构\",{\"1\":{\"118\":1}}],[\"多应用\",{\"1\":{\"64\":1}}],[\"多练\",{\"1\":{\"64\":1}}],[\"方便更好地表示一个变量无值的状态\",{\"1\":{\"245\":1}}],[\"方便统一管理和修改\",{\"1\":{\"72\":1}}],[\"方案二\",{\"0\":{\"154\":1}}],[\"方案一\",{\"0\":{\"153\":1}}],[\"方案设计\",{\"1\":{\"64\":1}}],[\"方法和变量\",{\"1\":{\"257\":1,\"259\":1}}],[\"方法和用法示例\",{\"1\":{\"215\":1}}],[\"方法应返回相同的值\",{\"1\":{\"253\":1}}],[\"方法比较相等\",{\"1\":{\"253\":1}}],[\"方法是\",{\"1\":{\"253\":1}}],[\"方法是很重要的\",{\"1\":{\"253\":1}}],[\"方法是比较两个对象的内存地址是否相等\",{\"1\":{\"252\":1}}],[\"方法计算出来的哈希码可能不相等\",{\"1\":{\"253\":1}}],[\"方法而不是==\",{\"1\":{\"245\":1}}],[\"方法重载\",{\"1\":{\"245\":1}}],[\"方法默认是抽象类并且是pulic方法\",{\"1\":{\"241\":1}}],[\"方法向客户端写入数据\",{\"1\":{\"236\":1}}],[\"方法从\",{\"1\":{\"236\":1}}],[\"方法从文件通道中读取数据到缓冲区\",{\"1\":{\"227\":1}}],[\"方法接收连接\",{\"1\":{\"236\":1}}],[\"方法接受一个对象\",{\"1\":{\"209\":1,\"210\":1}}],[\"方法接受一个元素\",{\"1\":{\"208\":1}}],[\"方法绑定服务器端口\",{\"1\":{\"233\":1}}],[\"方法关闭通道\",{\"1\":{\"232\":1}}],[\"方法设置为非阻塞模式\",{\"1\":{\"232\":1,\"233\":1}}],[\"方法创建一个\",{\"1\":{\"229\":1,\"234\":1}}],[\"方法读取部分数据\",{\"1\":{\"228\":1}}],[\"方法写入数据\",{\"1\":{\"228\":1}}],[\"方法写入数据到缓冲区\",{\"1\":{\"228\":1}}],[\"方法清空缓冲区\",{\"1\":{\"228\":1}}],[\"方法逐个字节读取数据并输出\",{\"1\":{\"228\":1}}],[\"方法切换为读取模式\",{\"1\":{\"228\":1}}],[\"方法演示\",{\"1\":{\"228\":2}}],[\"方法将要监听的事件和对应的事件处理器注册到\",{\"1\":{\"234\":1}}],[\"方法将缓冲区的位置重置为\",{\"1\":{\"228\":1}}],[\"方法将读取模式切换为写入模式\",{\"1\":{\"228\":1}}],[\"方法将写入模式切换为读取模式\",{\"1\":{\"228\":1}}],[\"方法将位置重置为标记位置\",{\"1\":{\"228\":1}}],[\"方法将当前位置设置为标记位置\",{\"1\":{\"228\":1}}],[\"方法将数据写入文件通道\",{\"1\":{\"227\":1}}],[\"方法将\",{\"1\":{\"210\":1}}],[\"方法将元素\",{\"1\":{\"208\":1}}],[\"方法将元素或集合添加到列表中\",{\"1\":{\"174\":1}}],[\"方法成功时\",{\"1\":{\"210\":1}}],[\"方法最终返回\",{\"1\":{\"209\":1}}],[\"方法最后根据\",{\"1\":{\"208\":1}}],[\"方法会根据指定键的哈希值和相等性判断\",{\"1\":{\"209\":1,\"210\":1}}],[\"方法会判断是否删除的是\",{\"1\":{\"184\":1}}],[\"方法时需要注意的规则\",{\"1\":{\"253\":1}}],[\"方法时\",{\"1\":{\"208\":1,\"246\":1,\"253\":2}}],[\"方法实现\",{\"1\":{\"241\":1}}],[\"方法实现的\",{\"1\":{\"208\":1,\"210\":1}}],[\"方法实现对列表的操作\",{\"1\":{\"174\":1}}],[\"方法的定义如下\",{\"1\":{\"253\":1}}],[\"方法的比较内容无关\",{\"1\":{\"253\":1}}],[\"方法的重写\",{\"1\":{\"246\":1}}],[\"方法的使用\",{\"1\":{\"228\":1}}],[\"方法的返回值将被用作对象的索引\",{\"1\":{\"253\":1}}],[\"方法的返回值\",{\"1\":{\"234\":1}}],[\"方法的返回值与固定的占位符对象\",{\"1\":{\"210\":1}}],[\"方法的返回结果\",{\"1\":{\"208\":1}}],[\"方法的结果\",{\"1\":{\"209\":1}}],[\"方法的简化版源码\",{\"1\":{\"200\":1}}],[\"方法的源码分析\",{\"1\":{\"209\":1,\"210\":1}}],[\"方法的源码\",{\"1\":{\"192\":1,\"208\":1}}],[\"方法的源码如下\",{\"1\":{\"190\":1,\"191\":1}}],[\"方法返回之前执行\",{\"1\":{\"260\":1}}],[\"方法返回\",{\"1\":{\"190\":1}}],[\"方法中\",{\"1\":{\"190\":1,\"191\":1,\"192\":1,\"236\":5,\"237\":1}}],[\"方法来轮询已注册的\",{\"1\":{\"234\":1}}],[\"方法来轮询监听注册的通道\",{\"1\":{\"229\":1}}],[\"方法来接受客户端的连接请求\",{\"1\":{\"233\":1}}],[\"方法来连接远程服务器\",{\"1\":{\"232\":1}}],[\"方法来打开一个\",{\"1\":{\"232\":1,\"233\":1}}],[\"方法来删除\",{\"1\":{\"210\":1}}],[\"方法来判断\",{\"1\":{\"209\":1}}],[\"方法来初始化\",{\"1\":{\"199\":1}}],[\"方法来执行元素的插入操作\",{\"1\":{\"190\":1}}],[\"方法来支持迭代\",{\"1\":{\"186\":1}}],[\"方法先调用\",{\"1\":{\"190\":1,\"191\":1,\"192\":1}}],[\"方法删除元素\",{\"1\":{\"186\":1}}],[\"方法删除指定元素或集合中的元素\",{\"1\":{\"174\":1}}],[\"方法移除元素后\",{\"1\":{\"186\":1}}],[\"方法检查索引是否有效\",{\"1\":{\"191\":1,\"192\":1}}],[\"方法检查\",{\"1\":{\"186\":2}}],[\"方法用于根据哈希值和键在\",{\"1\":{\"200\":1}}],[\"方法用于计算大于等于给定容量的最小\",{\"1\":{\"197\":1}}],[\"方法用于删除链表中指定索引处的元素\",{\"1\":{\"192\":1}}],[\"方法用于删除链表头部的元素\",{\"1\":{\"188\":1}}],[\"方法用于在链表的尾部添加元素\",{\"1\":{\"190\":1}}],[\"方法用于在链表尾部添加元素\",{\"1\":{\"188\":1}}],[\"方法用于返回链表的大小\",{\"1\":{\"188\":1}}],[\"方法用于获取链表中指定索引处的元素\",{\"1\":{\"191\":1}}],[\"方法用于获取指定索引位置上的元素\",{\"1\":{\"188\":1}}],[\"方法用于获取下一个元素\",{\"1\":{\"186\":1}}],[\"方法用于检查\",{\"1\":{\"186\":1,\"209\":1}}],[\"方法用于移除上一个元素\",{\"1\":{\"186\":1}}],[\"方法用于判断是否还有下一个元素\",{\"1\":{\"186\":1}}],[\"方法进行数据的写入\",{\"1\":{\"232\":1}}],[\"方法进行数据的读取\",{\"1\":{\"232\":1}}],[\"方法进行判断\",{\"1\":{\"204\":1}}],[\"方法进行查找操作\",{\"1\":{\"200\":1}}],[\"方法进行删除\",{\"1\":{\"186\":1}}],[\"方法进行元素的删除操作\",{\"1\":{\"186\":1}}],[\"方法进行比较\",{\"1\":{\"185\":1}}],[\"方法进行快速删除\",{\"1\":{\"184\":1}}],[\"方法首先判断要查找的元素是否为\",{\"1\":{\"185\":1}}],[\"方法内部调用了\",{\"1\":{\"185\":1}}],[\"方法名称相同\",{\"1\":{\"240\":1}}],[\"方法名\",{\"1\":{\"182\":1}}],[\"方法遍历列表中的元素\",{\"1\":{\"174\":1}}],[\"方法修改列表中指定位置的元素\",{\"1\":{\"174\":1}}],[\"方法获取到\",{\"1\":{\"229\":1}}],[\"方法获取元素或元素的索引\",{\"1\":{\"174\":1}}],[\"方法获取实例\",{\"1\":{\"74\":1}}],[\"方法之前和之后做了功能的增强\",{\"1\":{\"110\":1}}],[\"方法\",{\"0\":{\"190\":1,\"191\":1,\"192\":1},\"1\":{\"76\":1,\"92\":3,\"103\":1,\"184\":1,\"185\":2,\"191\":1,\"192\":1,\"198\":1,\"223\":1,\"241\":1,\"244\":1,\"246\":2,\"252\":3,\"253\":2}}],[\"方法才会初始化实例instance\",{\"1\":{\"75\":1}}],[\"方志朋\",{\"0\":{\"0\":1}}],[\"越来越体会到系统是运营出来的\",{\"1\":{\"64\":1}}],[\"还被广泛应用于大数据处理\",{\"1\":{\"225\":1}}],[\"还完全不影响io\",{\"1\":{\"223\":1}}],[\"还允许它存在只是为了保持版本的向下兼容而已\",{\"1\":{\"223\":1}}],[\"还未进行过初始化操作\",{\"1\":{\"199\":1}}],[\"还支持快复制\",{\"1\":{\"188\":1}}],[\"还还支持\",{\"1\":{\"138\":1}}],[\"还可以使用predict\",{\"1\":{\"133\":1}}],[\"还可以提升性能\",{\"1\":{\"75\":1}}],[\"还有一些需要注意的点\",{\"1\":{\"245\":1}}],[\"还有一系列其他的组件\",{\"1\":{\"119\":1}}],[\"还有其他的写法\",{\"1\":{\"77\":1}}],[\"还生产桌子\",{\"1\":{\"101\":1}}],[\"还是自己自己做的一些开源项目中\",{\"1\":{\"64\":1}}],[\"还不会编写\",{\"1\":{\"14\":1}}],[\"这也说明了finally语句被执行的必要条件是\",{\"1\":{\"260\":1}}],[\"这可以通过使用乘法和加法等算法来实现\",{\"1\":{\"253\":1}}],[\"这可能导致意外的结果\",{\"1\":{\"245\":1}}],[\"这可能会引起无限循环或抛出异常\",{\"1\":{\"113\":1}}],[\"这将导致在存储和查找对象时出现问题\",{\"1\":{\"253\":1}}],[\"这将导致具有相等内容的对象\",{\"1\":{\"253\":1}}],[\"这与equals\",{\"1\":{\"253\":1}}],[\"这就实现了运行时的动态绑定\",{\"1\":{\"246\":1}}],[\"这会触发内核中的\",{\"1\":{\"238\":1}}],[\"这段代码实现了一个基于\",{\"1\":{\"236\":1,\"237\":1}}],[\"这使得它非常适用于需要同时处理大量连接的网络编程场景\",{\"1\":{\"229\":1}}],[\"这使得它可以代理更多类型的类\",{\"1\":{\"113\":1}}],[\"这使得\",{\"1\":{\"193\":1}}],[\"这两个greeting方法有不同的参数个数\",{\"1\":{\"240\":1}}],[\"这两个流对象是字符体系中的成员\",{\"1\":{\"223\":1}}],[\"这两个类的uml图如下\",{\"1\":{\"188\":1}}],[\"这两个标签对于同一个实例来说基本不变\",{\"1\":{\"146\":1}}],[\"这允许在系统或服务之间建立依赖关系\",{\"1\":{\"163\":1}}],[\"这在系统出现大量故障的时候非常有用\",{\"1\":{\"159\":1}}],[\"这里简单罗列概括成几点\",{\"1\":{\"214\":1}}],[\"这里使用prometheus\",{\"1\":{\"148\":1}}],[\"这里我们以单例模式经典的懒汉式初始化方式为例\",{\"1\":{\"73\":1}}],[\"这几个handler构成了一个链式的处理顺序\",{\"1\":{\"91\":1}}],[\"这时我们需要一个拓展坞\",{\"1\":{\"81\":1}}],[\"这时程序会出错\",{\"1\":{\"75\":1}}],[\"这种动态绑定机制使得程序可以以统一的方式处理不同的子类对象\",{\"1\":{\"246\":1}}],[\"这种设计思想能够提高代码的可读性\",{\"1\":{\"242\":1}}],[\"这种结构使得在插入和删除元素时具有较高的效率\",{\"1\":{\"193\":1}}],[\"这种最常用\",{\"1\":{\"181\":1}}],[\"这种方式可以避免在时间窗口范围内的\",{\"1\":{\"148\":1}}],[\"这种情况下在多线程下是不安全的\",{\"1\":{\"78\":1}}],[\"这种双重检查模式经常在面试中被考察\",{\"1\":{\"75\":1}}],[\"这种模式称为饿汉模式\",{\"1\":{\"74\":1}}],[\"这种模式是在类加载的时候就完成了对象的实例化\",{\"1\":{\"74\":1}}],[\"这个时候他所引用的外部变量已经找不到了\",{\"1\":{\"258\":1}}],[\"这个局部变量肯定也就被gc了\",{\"1\":{\"258\":1}}],[\"这个程序使用\",{\"1\":{\"236\":1}}],[\"这个构造函数没有参数\",{\"1\":{\"207\":1}}],[\"这个过程称为扩容\",{\"1\":{\"180\":1}}],[\"这个文件是告警规则计算的配置\",{\"1\":{\"164\":1}}],[\"这个对于prometheus的告警消息来说\",{\"1\":{\"163\":1}}],[\"这个内置指标对请求耗时统计不是做的很好\",{\"1\":{\"153\":1}}],[\"这个平均值是不能反应的请求的真实状态\",{\"1\":{\"134\":1}}],[\"这个配置文件是prometheus启动的时候会读取的配置\",{\"1\":{\"124\":1}}],[\"这个页面提供了对prometheus数据的查询和告警信息的查询\",{\"1\":{\"123\":1}}],[\"这个数据结构包括一个指标名和一系列的键值对\",{\"1\":{\"118\":1}}],[\"这个代理类本身已经继承了jdk包中的proxy对象\",{\"1\":{\"112\":1}}],[\"这个职责是唯一引起该类变化的原因\",{\"1\":{\"70\":1}}],[\"这个原则在面试过程中会经常被问到\",{\"1\":{\"70\":1}}],[\"这组对象会将它们的交互委托给中介者对象\",{\"1\":{\"68\":1}}],[\"这样的语句\",{\"1\":{\"260\":1}}],[\"这样的话\",{\"1\":{\"258\":1}}],[\"这样finally语句就不会执行\",{\"1\":{\"260\":1}}],[\"这样调用者就能清楚地知道需要处理哪些异常\",{\"1\":{\"254\":1}}],[\"这样做的好处是实现了代码的灵活性\",{\"1\":{\"246\":1}}],[\"这样做的好处是可以通过统一的接口来操作不同的子类对象\",{\"1\":{\"246\":1}}],[\"这样可以兼顾抽象类和接口的优势\",{\"1\":{\"241\":1}}],[\"这样可以避免接受一些与实际问题相关的告警\",{\"1\":{\"160\":1}}],[\"这样一来\",{\"1\":{\"238\":1}}],[\"这样就可以管理多个网络连接\",{\"1\":{\"234\":1}}],[\"这样就降低了客户与实现模块间的耦合\",{\"1\":{\"70\":1}}],[\"这样真的一目了然\",{\"1\":{\"171\":1}}],[\"这样webhook的程序收到告警消息后\",{\"1\":{\"166\":1}}],[\"这样不仅增加了代码的耦合性\",{\"1\":{\"107\":1}}],[\"这样代码会非常的臃肿\",{\"1\":{\"83\":1}}],[\"这样当一个对象改变状态时\",{\"1\":{\"68\":1}}],[\"这样只会原地踏步走\",{\"1\":{\"64\":1}}],[\"这些包装类实现了相应类型的对象类型\",{\"1\":{\"245\":1}}],[\"这些抽象方法通常是定义了一组规范或者行为\",{\"1\":{\"241\":1}}],[\"这些方法只有方法签名\",{\"1\":{\"241\":1}}],[\"这些方法具有相同的方法名称\",{\"1\":{\"240\":1}}],[\"这些基本的io流类提供了在java程序中进行输入输出操作的基础功能\",{\"1\":{\"221\":1}}],[\"这些红黑树节点被实现为\",{\"1\":{\"196\":1}}],[\"这些操作符使用于瞬时向量的查询\",{\"1\":{\"141\":1}}],[\"这些类型的指标在存储的时候\",{\"1\":{\"131\":1}}],[\"这些组件构成了一个完整的监控系统\",{\"1\":{\"120\":1}}],[\"这些在流水线的处理类对象构成了一个单项链表结构\",{\"1\":{\"90\":1}}],[\"这些规则的执行有先后顺序\",{\"1\":{\"90\":1}}],[\"这些对象一般只提供具体的方法\",{\"1\":{\"72\":1}}],[\"这些年技术层出不穷\",{\"1\":{\"64\":1}}],[\"这些年无论是生产环境遇到的事故\",{\"1\":{\"64\":1}}],[\"这些都离不开设计模式的思想\",{\"1\":{\"64\":1}}],[\"这是因为我们在使用基于散列的数据结构\",{\"1\":{\"253\":1}}],[\"这是因为在\",{\"1\":{\"238\":1}}],[\"这是脚注内容\",{\"1\":{\"39\":1}}],[\"这是项目主页的案例\",{\"1\":{\"1\":1,\"2\":1}}],[\"功能和使用也非常相似\",{\"1\":{\"223\":1}}],[\"功能强大\",{\"1\":{\"113\":1}}],[\"功能限制\",{\"1\":{\"112\":1}}],[\"功能详情\",{\"1\":{\"59\":1,\"63\":1}}],[\"功能\",{\"0\":{\"56\":1,\"60\":1},\"1\":{\"57\":1,\"61\":1}}],[\"功能亮点\",{\"0\":{\"49\":1,\"53\":1}}],[\"few\",{\"1\":{\"163\":1}}],[\"fruit\",{\"1\":{\"174\":8}}],[\"fruits\",{\"1\":{\"174\":17}}],[\"from\",{\"1\":{\"171\":1,\"237\":5}}],[\"frontmatter\",{\"1\":{\"7\":1,\"15\":3,\"43\":1,\"45\":1}}],[\"front\",{\"1\":{\"1\":1,\"2\":1}}],[\"free\",{\"1\":{\"125\":1,\"133\":1,\"149\":1}}],[\"freed\",{\"1\":{\"124\":1}}],[\"flip\",{\"1\":{\"227\":3,\"228\":5,\"232\":1,\"233\":1,\"236\":3,\"237\":2}}],[\"flink\",{\"1\":{\"115\":1}}],[\"floatbuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"float\",{\"1\":{\"197\":2,\"225\":1,\"245\":2,\"251\":1}}],[\"float64类型的值\",{\"1\":{\"130\":1}}],[\"flush\",{\"1\":{\"87\":1}}],[\"furniturefactory\",{\"1\":{\"102\":1,\"103\":3}}],[\"factor\",{\"1\":{\"197\":2}}],[\"factory=new\",{\"1\":{\"100\":1}}],[\"factory\",{\"1\":{\"95\":1,\"97\":2,\"98\":1,\"101\":1,\"103\":3}}],[\"fastremove\",{\"1\":{\"184\":3}}],[\"false\",{\"1\":{\"175\":1,\"184\":1,\"209\":1,\"215\":1,\"217\":1,\"232\":2,\"233\":2,\"236\":2,\"237\":1,\"251\":4,\"252\":2}}],[\"failures\",{\"1\":{\"171\":8}}],[\"fangzhipeng\",{\"1\":{\"87\":3,\"106\":3}}],[\"filterreader\",{\"1\":{\"223\":1}}],[\"filechannelexample\",{\"1\":{\"227\":1}}],[\"filechannel\",{\"0\":{\"227\":1},\"1\":{\"225\":1,\"226\":1,\"227\":6}}],[\"file对象\",{\"1\":{\"223\":1}}],[\"file类保存文件或目录的各种元数据信息\",{\"1\":{\"223\":1}}],[\"file类是对文件系统中文件以及文件夹进行封装的对象\",{\"1\":{\"223\":1}}],[\"file类\",{\"1\":{\"223\":1}}],[\"fileoutputstream\",{\"1\":{\"221\":1,\"223\":1}}],[\"fileinputstream\",{\"1\":{\"221\":1,\"223\":1}}],[\"file=alertmanager\",{\"1\":{\"162\":1}}],[\"files定义recoding\",{\"1\":{\"172\":1}}],[\"filesystem\",{\"1\":{\"125\":1,\"133\":4,\"149\":1}}],[\"files是配置告警规则文件的路径\",{\"1\":{\"124\":1}}],[\"files\",{\"1\":{\"124\":1,\"164\":1,\"172\":1}}],[\"filewriter\",{\"1\":{\"87\":7,\"221\":1}}],[\"filenotfoundexception\",{\"1\":{\"87\":1}}],[\"filepath=\",{\"1\":{\"87\":1}}],[\"filepath\",{\"1\":{\"87\":8}}],[\"file\",{\"1\":{\"85\":1,\"87\":8,\"221\":1,\"227\":3}}],[\"filereaderwriter=new\",{\"1\":{\"87\":1}}],[\"filereaderwriter\",{\"1\":{\"87\":5}}],[\"filereader\",{\"1\":{\"85\":3,\"87\":7,\"221\":1,\"223\":1}}],[\"fifo\",{\"1\":{\"173\":1}}],[\"firstfruit\",{\"1\":{\"174\":2}}],[\"first\",{\"1\":{\"124\":1,\"164\":1,\"172\":1,\"174\":2,\"188\":2,\"190\":2,\"191\":1,\"192\":1,\"200\":14,\"228\":1}}],[\"finishconnect\",{\"1\":{\"237\":2}}],[\"finished\",{\"1\":{\"87\":1}}],[\"fingerprint\",{\"1\":{\"166\":3}}],[\"finalreturn3\",{\"1\":{\"260\":1}}],[\"finalreturn2\",{\"1\":{\"260\":1}}],[\"finalreturn1\",{\"1\":{\"260\":1}}],[\"finalize方法已经过时\",{\"1\":{\"259\":1}}],[\"finalize是一个方法\",{\"1\":{\"259\":1}}],[\"finalize\",{\"1\":{\"259\":3}}],[\"finalize的区别\",{\"0\":{\"248\":1,\"259\":1}}],[\"final是java中的修饰符\",{\"1\":{\"259\":1}}],[\"finaldemo\",{\"1\":{\"258\":3}}],[\"finalobject\",{\"1\":{\"257\":1}}],[\"finalmethodedemo2是不能重新它的父类finalmethoddemo的final方法的\",{\"1\":{\"257\":1}}],[\"finalmethodedemo2\",{\"1\":{\"257\":1}}],[\"finalmethoddemo\",{\"1\":{\"257\":2}}],[\"finaltest\",{\"1\":{\"257\":2,\"260\":1}}],[\"final关键字的使用可以增加代码的可读性\",{\"1\":{\"257\":1}}],[\"final关键字的基本用法\",{\"0\":{\"257\":1}}],[\"final关键字可以用于修饰类\",{\"1\":{\"257\":1}}],[\"final关键字\",{\"1\":{\"257\":1}}],[\"final关键字详解\",{\"0\":{\"256\":1}}],[\"finalbit\",{\"1\":{\"217\":2}}],[\"finally语句中没有使用return操作\",{\"1\":{\"260\":1}}],[\"finally语句在java中用于定义一段无论是否发生异常都会执行的代码块\",{\"1\":{\"260\":1}}],[\"finally语句块都将执行\",{\"1\":{\"260\":2}}],[\"finally语句将在try块执行完毕后立即执行\",{\"1\":{\"260\":1}}],[\"finally语句也不会被执行到\",{\"1\":{\"260\":1}}],[\"finally语句到底是在return之前还是之后执行\",{\"0\":{\"260\":1},\"1\":{\"260\":1}}],[\"finally或其他资源管理机制来确保资源的释放\",{\"1\":{\"259\":1}}],[\"finally是java中的关键字\",{\"1\":{\"259\":1}}],[\"finally代码块中的代码始终会执行\",{\"1\":{\"254\":1}}],[\"finally的用法\",{\"1\":{\"254\":1}}],[\"finally块中的代码也会在return语句执行后执行\",{\"1\":{\"260\":1}}],[\"finally块中的代码也会在方法返回之前执行\",{\"1\":{\"259\":1}}],[\"finally块中的代码将在return语句执行之后\",{\"1\":{\"260\":1}}],[\"finally块中的代码都会被执行\",{\"1\":{\"259\":1,\"260\":1}}],[\"finally块通常用于释放资源\",{\"1\":{\"259\":1}}],[\"finally块在try块或catch块执行完毕后执行\",{\"1\":{\"254\":1}}],[\"finally块用于定义无论是否发生异常都需要执行的代码\",{\"1\":{\"254\":1}}],[\"finally块\",{\"1\":{\"254\":2}}],[\"finally异常处理语句模板\",{\"1\":{\"254\":1}}],[\"finally\",{\"0\":{\"248\":1,\"259\":1},\"1\":{\"87\":2,\"236\":1,\"237\":2,\"254\":1,\"259\":2,\"260\":9}}],[\"final\",{\"1\":{\"76\":1,\"182\":1,\"184\":3,\"186\":1,\"192\":3,\"198\":2,\"200\":1,\"236\":3,\"241\":1,\"257\":8,\"258\":2}}],[\"found\",{\"1\":{\"184\":3}}],[\"foreach\",{\"1\":{\"174\":1}}],[\"forezp\",{\"1\":{\"80\":2,\"87\":1,\"92\":2,\"106\":5,\"154\":1,\"236\":1,\"237\":1,\"260\":1}}],[\"for\",{\"1\":{\"87\":2,\"106\":1,\"163\":5,\"164\":2,\"174\":4,\"175\":2,\"176\":4,\"184\":2,\"185\":2,\"191\":2,\"198\":3,\"199\":1,\"205\":1,\"215\":1,\"217\":14,\"253\":1}}],[\"foo\",{\"0\":{\"51\":1,\"55\":1,\"60\":1},\"1\":{\"61\":1}}],[\"block\",{\"1\":{\"260\":6}}],[\"blog\",{\"1\":{\"167\":2}}],[\"blue\",{\"1\":{\"241\":1}}],[\"bio\",{\"1\":{\"238\":1}}],[\"bits\",{\"1\":{\"217\":2}}],[\"bitset2bytearray\",{\"1\":{\"217\":1}}],[\"bitsetdemo\",{\"1\":{\"217\":1}}],[\"bitsetexample\",{\"1\":{\"215\":1}}],[\"bitset在设计上是非线程安全\",{\"1\":{\"214\":1}}],[\"bitset是可增长比特向量的一个实现\",{\"1\":{\"214\":1}}],[\"bitset是采用一个long型的数组来实现位图的\",{\"1\":{\"213\":1}}],[\"bitset顶部有一些关于其设计上的注释\",{\"1\":{\"214\":1}}],[\"bitset中底层的存储结构选用了long数组\",{\"1\":{\"214\":1}}],[\"bitset\",{\"1\":{\"214\":2,\"215\":25,\"217\":29}}],[\"bitset的简单使用\",{\"0\":{\"215\":1}}],[\"bitset的size属性与其实现有关\",{\"1\":{\"214\":1}}],[\"bitset的所有比特的初始化值为false\",{\"1\":{\"214\":1}}],[\"bitset的优点就是省内存\",{\"1\":{\"214\":1}}],[\"bitset的继承关系结构图如下\",{\"1\":{\"213\":1}}],[\"bitset介绍\",{\"0\":{\"214\":1}}],[\"bitset实现了serializable接口\",{\"1\":{\"213\":1}}],[\"bitset实现了cloneable接口\",{\"1\":{\"213\":1}}],[\"bitset使用讲解\",{\"0\":{\"212\":1}}],[\"bitlen\",{\"1\":{\"217\":2}}],[\"bitlen=bitset\",{\"1\":{\"217\":1}}],[\"bit\",{\"1\":{\"215\":5,\"217\":1}}],[\"bitindex\",{\"1\":{\"215\":4}}],[\"bind\",{\"1\":{\"233\":2,\"236\":1}}],[\"bincount\",{\"1\":{\"198\":3}}],[\"bin\",{\"1\":{\"127\":1}}],[\"break\",{\"1\":{\"184\":2,\"198\":2}}],[\"because\",{\"1\":{\"183\":1}}],[\"been\",{\"1\":{\"163\":2,\"166\":1}}],[\"bean\",{\"1\":{\"154\":1}}],[\"before\",{\"1\":{\"110\":2,\"112\":2,\"163\":2}}],[\"by\",{\"1\":{\"124\":1,\"141\":2,\"146\":4,\"150\":2,\"156\":2,\"162\":1,\"163\":3,\"169\":1,\"172\":1,\"254\":1}}],[\"bytebuffer\",{\"1\":{\"225\":1,\"227\":4,\"228\":7,\"232\":2,\"233\":2,\"236\":8,\"237\":4}}],[\"bytesread\",{\"1\":{\"227\":3,\"232\":1,\"233\":1,\"236\":4}}],[\"bytes的差值\",{\"1\":{\"133\":1}}],[\"bytes\",{\"1\":{\"124\":12,\"125\":1,\"133\":2,\"217\":8,\"237\":3}}],[\"bytearray2bitset\",{\"1\":{\"217\":1}}],[\"bytearrayinputstream\",{\"1\":{\"87\":1,\"223\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"87\":4,\"223\":1}}],[\"byte\",{\"1\":{\"87\":6,\"217\":4,\"221\":1,\"225\":1,\"228\":10,\"237\":2,\"251\":9}}],[\"buf\",{\"1\":{\"236\":19}}],[\"bufferexample\",{\"1\":{\"228\":1}}],[\"bufferedoutputstream\",{\"1\":{\"221\":1,\"223\":1}}],[\"bufferedinputstream\",{\"1\":{\"221\":1,\"223\":1}}],[\"buffered\",{\"1\":{\"221\":1}}],[\"bufferedwriter\",{\"1\":{\"87\":8,\"221\":1,\"223\":1}}],[\"bufferedreader\",{\"1\":{\"85\":2,\"87\":7,\"221\":1,\"223\":1}}],[\"bufferedreader和filereader都是使用到包装器模式\",{\"1\":{\"85\":1}}],[\"buffer\",{\"0\":{\"228\":1},\"1\":{\"225\":2,\"227\":11,\"228\":33,\"232\":7,\"233\":7,\"237\":13}}],[\"buildandstart\",{\"1\":{\"154\":1}}],[\"builder\",{\"1\":{\"154\":3}}],[\"bucket指标去统计\",{\"1\":{\"134\":1}}],[\"bucket\",{\"1\":{\"124\":1,\"134\":10,\"150\":13,\"154\":12,\"156\":1}}],[\"buck\",{\"1\":{\"124\":3}}],[\"b\",{\"1\":{\"87\":3,\"150\":1,\"251\":2}}],[\"bob\",{\"1\":{\"175\":7,\"176\":10}}],[\"book\",{\"1\":{\"167\":1}}],[\"boolean\",{\"1\":{\"154\":1,\"174\":1,\"175\":1,\"176\":1,\"182\":4,\"184\":1,\"185\":1,\"186\":1,\"190\":1,\"191\":1,\"192\":1,\"208\":1,\"209\":1,\"210\":1,\"215\":3,\"251\":1,\"252\":2}}],[\"boot<\",{\"1\":{\"153\":2}}],[\"boot\",{\"0\":{\"0\":1,\"153\":1},\"1\":{\"152\":1,\"153\":3}}],[\"bottomk\",{\"1\":{\"146\":1}}],[\"bout\",{\"1\":{\"87\":8}}],[\"banana\",{\"1\":{\"174\":2}}],[\"backlink\",{\"1\":{\"166\":1}}],[\"basiccontroller\",{\"1\":{\"153\":1}}],[\"basics\",{\"1\":{\"151\":1}}],[\"base64\",{\"1\":{\"87\":4}}],[\"baz\",{\"0\":{\"59\":1},\"1\":{\"50\":1,\"54\":1,\"58\":1}}],[\"bark\",{\"1\":{\"241\":1}}],[\"bar\",{\"0\":{\"50\":1,\"54\":1,\"56\":1},\"1\":{\"57\":1}}],[\"此篇文章不讲解这部分内容\",{\"1\":{\"127\":1}}],[\"此外\",{\"1\":{\"107\":1}}],[\"此种模式是不推荐的\",{\"1\":{\"79\":1}}],[\"此页面应当包含\",{\"1\":{\"45\":1}}],[\"此文字有脚注\",{\"1\":{\"24\":1}}],[\"徽章\",{\"1\":{\"44\":1}}],[\"徽章文字\",{\"1\":{\"44\":1}}],[\"pi\",{\"1\":{\"241\":1}}],[\"pipe\",{\"1\":{\"226\":2}}],[\"pipedwriter\",{\"1\":{\"223\":1}}],[\"pipedreader\",{\"1\":{\"223\":1}}],[\"pipedoutputstream\",{\"1\":{\"223\":1}}],[\"pipedinputstream\",{\"1\":{\"223\":1}}],[\"png\",{\"1\":{\"228\":1}}],[\"person=null\",{\"1\":{\"257\":1}}],[\"person=new\",{\"1\":{\"257\":1}}],[\"person\",{\"1\":{\"257\":5}}],[\"per\",{\"1\":{\"171\":4}}],[\"p\",{\"1\":{\"167\":1,\"198\":9,\"218\":1}}],[\"position\",{\"1\":{\"228\":1}}],[\"postmapping\",{\"1\":{\"166\":1}}],[\"post请求\",{\"1\":{\"161\":1}}],[\"posthandle\",{\"1\":{\"154\":1}}],[\"post\",{\"1\":{\"145\":6}}],[\"port\",{\"1\":{\"154\":1,\"236\":2}}],[\"population\",{\"1\":{\"146\":2}}],[\"power\",{\"1\":{\"141\":1}}],[\"plcmt=topnav\",{\"1\":{\"127\":1}}],[\"plugin\",{\"1\":{\"18\":1}}],[\"pg=community\",{\"1\":{\"127\":1}}],[\"puttreeval\",{\"1\":{\"198\":1}}],[\"put\",{\"1\":{\"145\":1,\"176\":4,\"183\":1,\"198\":4,\"208\":5,\"227\":1,\"228\":13,\"232\":1,\"233\":1,\"236\":2,\"237\":1}}],[\"pushbackinputstream\",{\"1\":{\"223\":2}}],[\"push\",{\"1\":{\"119\":1}}],[\"publisher=new\",{\"1\":{\"106\":1}}],[\"publisherimpl\",{\"1\":{\"106\":2}}],[\"publisher接口的实现类publisherimpl\",{\"1\":{\"106\":1}}],[\"publisher\",{\"1\":{\"106\":6}}],[\"public和abstract\",{\"1\":{\"241\":1}}],[\"public\",{\"1\":{\"44\":1,\"74\":2,\"75\":2,\"76\":2,\"78\":2,\"79\":2,\"82\":9,\"87\":15,\"92\":12,\"97\":8,\"100\":7,\"103\":9,\"106\":10,\"110\":9,\"112\":6,\"113\":7,\"153\":2,\"154\":8,\"166\":20,\"174\":2,\"175\":2,\"176\":2,\"180\":1,\"181\":3,\"182\":6,\"183\":1,\"184\":1,\"185\":3,\"186\":3,\"189\":2,\"190\":1,\"191\":1,\"192\":1,\"197\":2,\"200\":2,\"205\":1,\"207\":2,\"208\":1,\"209\":1,\"210\":1,\"215\":2,\"217\":6,\"227\":2,\"228\":2,\"236\":6,\"237\":3,\"240\":11,\"241\":12,\"246\":3,\"252\":2,\"253\":1,\"254\":3,\"257\":13,\"258\":8,\"260\":9}}],[\"path\",{\"1\":{\"171\":15}}],[\"pattern\",{\"1\":{\"80\":1,\"95\":1,\"98\":1,\"101\":1,\"104\":1}}],[\"param\",{\"1\":{\"207\":1,\"217\":2}}],[\"parameter\",{\"1\":{\"146\":1}}],[\"parti\",{\"1\":{\"167\":1}}],[\"page\",{\"1\":{\"164\":1}}],[\"pause\",{\"1\":{\"124\":1,\"135\":1}}],[\"package\",{\"1\":{\"92\":2,\"106\":5,\"154\":1,\"217\":1,\"236\":1,\"237\":1,\"260\":1}}],[\"present\",{\"1\":{\"208\":2,\"210\":3}}],[\"preserve\",{\"1\":{\"199\":1}}],[\"prev\",{\"1\":{\"188\":2,\"191\":1,\"192\":18}}],[\"prev指向当前节点前一个节点\",{\"1\":{\"188\":1}}],[\"preconditions\",{\"1\":{\"183\":1}}],[\"prefer\",{\"1\":{\"242\":1}}],[\"preferred\",{\"1\":{\"183\":1}}],[\"preflength\",{\"1\":{\"183\":4}}],[\"prefgrowth\",{\"1\":{\"183\":2}}],[\"prehandle\",{\"1\":{\"154\":1}}],[\"predict\",{\"1\":{\"133\":1,\"149\":3}}],[\"protected\",{\"1\":{\"259\":1}}],[\"programming\",{\"1\":{\"244\":2}}],[\"procedural\",{\"1\":{\"244\":1}}],[\"process\",{\"1\":{\"87\":1}}],[\"properties中开启prometheus的暴露接口\",{\"1\":{\"153\":1}}],[\"profiling\",{\"1\":{\"124\":1}}],[\"promql提供了另外一个灵敏度更高的函数irate\",{\"1\":{\"148\":1}}],[\"promql提供了两个向量匹配符号\",{\"1\":{\"144\":1}}],[\"promql还支持常见的比较运算符\",{\"1\":{\"142\":1}}],[\"promql支持常见的逻辑和数学操作符\",{\"1\":{\"141\":1}}],[\"promql被广泛应用于指标视图的配置\",{\"1\":{\"136\":1}}],[\"promql是prometheus提供的数据查询语言\",{\"1\":{\"136\":1}}],[\"promql快速入门\",{\"0\":{\"136\":1}}],[\"promql非常的强大和灵活\",{\"1\":{\"118\":1}}],[\"prometheus会定时的根据拉取expr定时表达式的数据\",{\"1\":{\"169\":1}}],[\"prometheus支持两种规则表达式\",{\"1\":{\"168\":1}}],[\"prometheus预处理计算\",{\"0\":{\"168\":1}}],[\"prometheus作为存储端\",{\"1\":{\"157\":1}}],[\"prometheus作为采集端\",{\"1\":{\"157\":1}}],[\"prometheus作为一个采集组件\",{\"1\":{\"128\":1}}],[\"prometheus告警与alertmanager实战\",{\"0\":{\"157\":1}}],[\"prometheuslab\",{\"1\":{\"154\":1}}],[\"prometheus官方提供了java客户端\",{\"1\":{\"154\":1}}],[\"prometheus依赖是将micrometer的指标转换成prometheus格式的指标\",{\"1\":{\"153\":1}}],[\"prometheus<\",{\"1\":{\"153\":1,\"154\":3}}],[\"prometheus的告警分为两部分内容\",{\"1\":{\"157\":1}}],[\"prometheus的时间序列是通过指标名和一组标签来唯一定义\",{\"1\":{\"136\":1}}],[\"prometheus的数据模型\",{\"0\":{\"129\":1}}],[\"prometheus每发生一个请求\",{\"1\":{\"132\":1}}],[\"prometheus定义来四种类型的指标\",{\"1\":{\"131\":1}}],[\"prometheus可以通过调用\",{\"1\":{\"130\":1}}],[\"prometheus可以很好地记录任何纯粹的数字时间序列\",{\"1\":{\"121\":1}}],[\"prometheus配置文件热更新\",{\"0\":{\"126\":1}}],[\"prometheus配置文件讲解\",{\"0\":{\"124\":1}}],[\"prometheus环境搭建\",{\"0\":{\"122\":1}}],[\"prometheus是为可靠性而设计的\",{\"1\":{\"121\":1}}],[\"prometheus是一个开源的监控系统\",{\"1\":{\"117\":1}}],[\"prometheus适用的场景\",{\"0\":{\"121\":1}}],[\"prometheus发现到监控目标后\",{\"1\":{\"120\":1}}],[\"prometheus通过时间序列来存储所有的数据的\",{\"1\":{\"130\":1}}],[\"prometheus通过时序数据来收集和存储指标\",{\"1\":{\"117\":1}}],[\"prometheus通过pull的方式去周期性\",{\"1\":{\"120\":1}}],[\"prometheus生态包含了一系列组件\",{\"1\":{\"119\":1}}],[\"prometheus提供非常的多的聚合函数\",{\"1\":{\"146\":1}}],[\"prometheus提供了http接口的方式让外部第三方访问数据\",{\"1\":{\"120\":1}}],[\"prometheus提供一些关键的特性\",{\"1\":{\"118\":1}}],[\"prometheus提供的特性\",{\"0\":{\"118\":1}}],[\"prometheus让监控从传统的黑盒子监控提升到了白盒监控\",{\"1\":{\"118\":1}}],[\"prometheus和传统的监控系统相比\",{\"1\":{\"118\":1}}],[\"prometheus受启发于google的brogmon监控系统\",{\"1\":{\"117\":1}}],[\"prometheus概述\",{\"0\":{\"116\":1}}],[\"prometheus\",{\"1\":{\"115\":1,\"119\":1,\"120\":1,\"123\":4,\"124\":1,\"125\":3,\"126\":1,\"130\":10,\"131\":3,\"132\":2,\"134\":12,\"137\":7,\"138\":1,\"139\":4,\"141\":3,\"146\":6,\"148\":4,\"150\":22,\"151\":2,\"153\":1,\"154\":4,\"157\":1,\"162\":1,\"164\":1,\"166\":1,\"167\":3,\"172\":2}}],[\"prometheus教程介绍\",{\"0\":{\"115\":1}}],[\"proxy\",{\"1\":{\"112\":2,\"113\":2}}],[\"proxyhandler\",{\"1\":{\"112\":4}}],[\"proxy类和java\",{\"1\":{\"112\":1}}],[\"priorityqueue\",{\"1\":{\"173\":1}}],[\"printwriter\",{\"1\":{\"223\":1}}],[\"printstream\",{\"1\":{\"223\":1}}],[\"printstacktrace\",{\"1\":{\"87\":7,\"227\":1,\"236\":2,\"237\":3}}],[\"print\",{\"1\":{\"217\":2,\"227\":1,\"228\":3,\"236\":1}}],[\"printf\",{\"1\":{\"217\":1}}],[\"println\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"174\":10,\"175\":7,\"176\":9,\"205\":1,\"215\":3,\"217\":8,\"228\":5,\"236\":4,\"237\":2,\"240\":5,\"241\":5,\"246\":2,\"251\":3,\"254\":3,\"257\":3,\"258\":2,\"260\":8}}],[\"principle\",{\"1\":{\"70\":5}}],[\"private\",{\"1\":{\"74\":2,\"75\":2,\"76\":3,\"78\":2,\"79\":2,\"82\":1,\"87\":7,\"92\":1,\"106\":2,\"110\":1,\"112\":1,\"113\":1,\"183\":3,\"184\":1,\"186\":1,\"190\":1,\"191\":3,\"192\":3,\"236\":3,\"241\":3,\"257\":5}}],[\"标签\",{\"1\":{\"141\":1}}],[\"标签为\",{\"1\":{\"43\":1}}],[\"标题和页面信息\",{\"1\":{\"45\":1}}],[\"标记\",{\"0\":{\"25\":1},\"1\":{\"228\":1}}],[\"日\",{\"1\":{\"43\":1}}],[\"月\",{\"1\":{\"43\":1}}],[\"年\",{\"1\":{\"43\":1,\"138\":1}}],[\"↩︎\",{\"1\":{\"39\":1}}],[\"幻灯片\",{\"0\":{\"39\":1}}],[\"幻灯片页\",{\"0\":{\"3\":1}}],[\"交互演示\",{\"0\":{\"37\":1,\"38\":1}}],[\"捐赠一杯咖啡\",{\"1\":{\"36\":1}}],[\"向服务器端发送消息\",{\"1\":{\"237\":1}}],[\"向缓冲区写入数据\",{\"1\":{\"228\":1}}],[\"向量匹配符号\",{\"0\":{\"144\":1}}],[\"向量里面的标签是左侧和右侧共同匹配的标签\",{\"1\":{\"141\":1}}],[\"向\",{\"1\":{\"36\":1}}],[\"样式化\",{\"0\":{\"36\":1}}],[\"导致不确定性\",{\"1\":{\"242\":1}}],[\"导致告警处理者漏处理一些告警消息\",{\"1\":{\"159\":1}}],[\"导致连接它的应用的几百个实例都出现异常\",{\"1\":{\"159\":1}}],[\"导致请求耗时的平均值远大于100ms\",{\"1\":{\"134\":1}}],[\"导致工厂类的代码会随着产品类型的增多而变得越来越复杂\",{\"1\":{\"97\":1}}],[\"导入成功后\",{\"1\":{\"127\":1}}],[\"导入文件\",{\"0\":{\"34\":1}}],[\"导航栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"−1\",{\"1\":{\"33\":1}}],[\"run2\",{\"1\":{\"258\":2}}],[\"run1\",{\"1\":{\"258\":2}}],[\"runtime\",{\"1\":{\"255\":1}}],[\"running\",{\"1\":{\"241\":1}}],[\"run\",{\"1\":{\"241\":1,\"258\":7}}],[\"rule规则文件的路径\",{\"1\":{\"172\":1}}],[\"rule产生的新的指标\",{\"1\":{\"171\":1}}],[\"rule的命令规范很重要\",{\"1\":{\"170\":1}}],[\"rule的最佳实践\",{\"0\":{\"170\":1}}],[\"rule的具体配置\",{\"1\":{\"169\":1}}],[\"rule的规则定义如下\",{\"1\":{\"169\":1}}],[\"rule类似\",{\"1\":{\"169\":1}}],[\"rule是预先计算成本较高的表达式\",{\"1\":{\"168\":1}}],[\"rules选项是recording\",{\"1\":{\"169\":1}}],[\"rules\",{\"0\":{\"169\":1},\"1\":{\"124\":2,\"162\":2,\"163\":3,\"164\":2,\"169\":1,\"172\":1}}],[\"rule\",{\"0\":{\"168\":1},\"1\":{\"124\":2,\"164\":4,\"167\":1,\"168\":1,\"169\":2,\"172\":5}}],[\"r\",{\"1\":{\"223\":1,\"228\":1}}],[\"robin\",{\"1\":{\"198\":1}}],[\"route配置\",{\"1\":{\"163\":1}}],[\"route\",{\"1\":{\"162\":2,\"163\":1}}],[\"right\",{\"1\":{\"145\":1}}],[\"radius\",{\"1\":{\"241\":6}}],[\"randomaccessfile\",{\"1\":{\"227\":5}}],[\"randomaccessfile类\",{\"1\":{\"223\":1}}],[\"randomaccess\",{\"1\":{\"179\":1,\"180\":1}}],[\"rangecheckforadd\",{\"1\":{\"182\":1}}],[\"range\",{\"0\":{\"138\":1},\"1\":{\"148\":1,\"149\":1}}],[\"ratio\",{\"1\":{\"171\":4}}],[\"rate1m\",{\"1\":{\"172\":1}}],[\"rate\",{\"1\":{\"148\":1,\"150\":2,\"171\":2,\"172\":1}}],[\"rate5m\",{\"1\":{\"145\":12,\"171\":12}}],[\"ray\",{\"0\":{\"63\":1},\"1\":{\"51\":1,\"55\":1,\"62\":1}}],[\"rw\",{\"1\":{\"87\":2,\"223\":1,\"227\":1}}],[\"remaining\",{\"1\":{\"237\":1}}],[\"removing\",{\"1\":{\"174\":2,\"176\":2}}],[\"removeall\",{\"1\":{\"174\":1}}],[\"remove\",{\"0\":{\"192\":1},\"1\":{\"174\":2,\"175\":1,\"176\":1,\"184\":3,\"186\":8,\"188\":2,\"192\":4,\"210\":10,\"234\":1,\"236\":1}}],[\"rewind\",{\"1\":{\"228\":4}}],[\"required\",{\"1\":{\"183\":1}}],[\"requestbody\",{\"1\":{\"166\":1}}],[\"requestparam\",{\"1\":{\"153\":1,\"154\":1}}],[\"requestmapping\",{\"1\":{\"153\":1,\"154\":1}}],[\"requests\",{\"1\":{\"130\":12,\"131\":4,\"132\":3,\"137\":8,\"138\":1,\"139\":4,\"141\":3,\"145\":5,\"146\":6,\"148\":5,\"153\":10,\"164\":1,\"169\":2,\"171\":10,\"172\":2}}],[\"request\",{\"1\":{\"91\":1,\"134\":13,\"141\":1,\"150\":13,\"154\":5,\"171\":8}}],[\"replace\",{\"1\":{\"181\":1}}],[\"repeat\",{\"1\":{\"162\":1,\"163\":2}}],[\"reverse\",{\"1\":{\"174\":1}}],[\"recvfrom\",{\"1\":{\"238\":1}}],[\"recoding\",{\"1\":{\"172\":1}}],[\"record\",{\"1\":{\"169\":2,\"171\":5,\"172\":1}}],[\"recording的计算规则和alert的计算规则\",{\"1\":{\"169\":1}}],[\"recording\",{\"0\":{\"168\":1,\"170\":1},\"1\":{\"168\":1,\"170\":1,\"172\":1}}],[\"receiver可以集成邮箱\",{\"1\":{\"163\":1}}],[\"receivers配置\",{\"1\":{\"163\":1}}],[\"receivers\",{\"1\":{\"162\":2,\"163\":1}}],[\"receiver\",{\"1\":{\"162\":1,\"163\":1,\"166\":2}}],[\"region\",{\"1\":{\"164\":1,\"172\":1}}],[\"registry\",{\"1\":{\"153\":2,\"154\":2}}],[\"register\",{\"1\":{\"106\":4,\"154\":2,\"234\":3,\"236\":2}}],[\"release\",{\"1\":{\"127\":1}}],[\"releases\",{\"1\":{\"125\":1}}],[\"reload\",{\"1\":{\"126\":1,\"161\":1}}],[\"reflect\",{\"1\":{\"112\":2}}],[\"realsubject\",{\"1\":{\"109\":1,\"110\":10,\"112\":4,\"113\":1}}],[\"readychannels\",{\"1\":{\"234\":2}}],[\"reader\",{\"1\":{\"221\":1,\"223\":1}}],[\"readerwriter的基本实现类是filereaderwriter\",{\"1\":{\"87\":1}}],[\"readerwriter\",{\"1\":{\"87\":21}}],[\"readline\",{\"1\":{\"87\":1}}],[\"read\",{\"1\":{\"87\":9,\"227\":3,\"229\":1,\"232\":2,\"233\":1,\"234\":1,\"236\":4,\"237\":1}}],[\"reset\",{\"1\":{\"228\":1}}],[\"resize\",{\"1\":{\"198\":1,\"199\":2}}],[\"resolve\",{\"1\":{\"162\":1,\"163\":2}}],[\"response\",{\"1\":{\"154\":3}}],[\"responsebody\",{\"1\":{\"153\":1,\"154\":1}}],[\"responsibility\",{\"1\":{\"70\":1}}],[\"resulting\",{\"1\":{\"146\":1}}],[\"result\",{\"1\":{\"87\":8,\"254\":2,\"260\":2}}],[\"returnvalue\",{\"1\":{\"113\":2}}],[\"return\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"87\":9,\"92\":1,\"97\":3,\"100\":2,\"103\":3,\"112\":1,\"113\":2,\"153\":1,\"154\":3,\"166\":1,\"182\":1,\"183\":7,\"184\":2,\"185\":5,\"186\":2,\"190\":1,\"191\":4,\"192\":3,\"198\":1,\"199\":1,\"200\":6,\"208\":1,\"209\":1,\"210\":1,\"217\":4,\"241\":1,\"252\":5,\"253\":1,\"254\":1,\"257\":2,\"260\":6}}],[\"r−i​\",{\"1\":{\"33\":1}}],[\"r−i+1\",{\"1\":{\"33\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"33\":1}}],[\"rgba\",{\"1\":{\"28\":1}}],[\"ωyω​\",{\"1\":{\"33\":2}}],[\"∂ωr∂r​\",{\"1\":{\"33\":1}}],[\"error也是throwable的一个子类\",{\"1\":{\"254\":1}}],[\"error是不可控制的严重问题的异常类\",{\"1\":{\"254\":1}}],[\"error\",{\"1\":{\"254\":1}}],[\"error和throwable是一个类层次结构中的相关类\",{\"1\":{\"254\":1}}],[\"errors\",{\"1\":{\"145\":7}}],[\"eating\",{\"1\":{\"241\":1}}],[\"eat\",{\"1\":{\"240\":8,\"241\":3}}],[\"epoll\",{\"1\":{\"238\":1}}],[\"es\",{\"1\":{\"184\":8}}],[\"e>\",{\"1\":{\"181\":1,\"182\":2,\"189\":1,\"207\":1}}],[\"empty\",{\"1\":{\"174\":2,\"175\":2,\"176\":2,\"180\":2,\"181\":6,\"183\":2}}],[\"elementdata的值为10\",{\"1\":{\"181\":1}}],[\"elementdata\",{\"1\":{\"180\":4,\"181\":10,\"182\":8,\"183\":7,\"184\":1,\"185\":3,\"186\":4}}],[\"element\",{\"1\":{\"174\":2,\"182\":3,\"188\":2,\"192\":3}}],[\"elements\",{\"1\":{\"146\":4}}],[\"else\",{\"1\":{\"92\":3,\"97\":1,\"181\":4,\"183\":4,\"184\":1,\"185\":1,\"190\":1,\"191\":1,\"192\":2,\"198\":2,\"199\":6,\"234\":2}}],[\"equal\",{\"1\":{\"142\":4,\"162\":1,\"163\":2}}],[\"equals\",{\"0\":{\"250\":1,\"252\":1,\"253\":1},\"1\":{\"97\":2,\"184\":1,\"185\":2,\"198\":2,\"200\":2,\"204\":1,\"250\":1,\"252\":12}}],[\"even\",{\"1\":{\"124\":1}}],[\"evaluation\",{\"1\":{\"124\":2,\"169\":2}}],[\"executed\",{\"1\":{\"260\":6}}],[\"externalurl\",{\"1\":{\"166\":2}}],[\"extends\",{\"1\":{\"92\":3,\"97\":2,\"103\":1,\"154\":1,\"180\":1,\"181\":1,\"182\":2,\"189\":1,\"207\":1,\"240\":2,\"241\":1,\"246\":2,\"257\":1}}],[\"ex\",{\"1\":{\"154\":1,\"186\":1}}],[\"exceptionexample\",{\"1\":{\"254\":1}}],[\"exception又分为两种类型\",{\"1\":{\"254\":1}}],[\"exception是可控制的异常类\",{\"1\":{\"254\":1}}],[\"exception和error\",{\"1\":{\"254\":1}}],[\"exception\",{\"1\":{\"154\":4,\"227\":1,\"254\":2,\"259\":1}}],[\"exception=\",{\"1\":{\"153\":3}}],[\"example\",{\"1\":{\"154\":4,\"169\":1}}],[\"exist\",{\"1\":{\"124\":1}}],[\"exit\",{\"1\":{\"87\":1,\"260\":2}}],[\"expectedmodcount\",{\"1\":{\"186\":7}}],[\"expr执行后生成新的指标的名称\",{\"1\":{\"169\":1}}],[\"expr\",{\"1\":{\"164\":2,\"169\":2,\"171\":5,\"172\":1}}],[\"expression>\",{\"1\":{\"146\":1}}],[\"exposure\",{\"1\":{\"153\":1}}],[\"exponentiation\",{\"1\":{\"141\":1}}],[\"expoter的指标时序\",{\"1\":{\"128\":1}}],[\"exporter暴露的端口指标\",{\"1\":{\"125\":1}}],[\"exporter的dashboard\",{\"1\":{\"127\":1}}],[\"exporter的面板\",{\"1\":{\"127\":1}}],[\"exporter的任务\",{\"1\":{\"125\":1}}],[\"exporter的端口为9100\",{\"1\":{\"125\":1}}],[\"exporter的指标了\",{\"1\":{\"125\":1}}],[\"exporter的指标\",{\"0\":{\"125\":1},\"1\":{\"122\":1,\"128\":1}}],[\"exporter是prometheus生态的一员\",{\"1\":{\"125\":1}}],[\"exporter采集的指标中\",{\"1\":{\"133\":1}}],[\"exporter采集的指标生产\",{\"1\":{\"127\":1}}],[\"exporter采集的指标\",{\"1\":{\"122\":1}}],[\"exporters是用来暴露或者导出被监控对象的指标的\",{\"1\":{\"119\":1}}],[\"exporter\",{\"1\":{\"115\":1,\"122\":1,\"125\":3,\"154\":2,\"157\":1}}],[\"expansiondockadapter并持有需要被适配的iusb接口\",{\"1\":{\"82\":1}}],[\"expansiondockadapter\",{\"1\":{\"82\":5}}],[\"entryset\",{\"1\":{\"176\":2}}],[\"entry<string\",{\"1\":{\"176\":2}}],[\"entry\",{\"1\":{\"176\":7}}],[\"entity\",{\"1\":{\"166\":1}}],[\"enterprise\",{\"1\":{\"127\":3}}],[\"env\",{\"1\":{\"164\":1}}],[\"environment\",{\"1\":{\"124\":1,\"255\":1}}],[\"endsat\",{\"1\":{\"166\":2}}],[\"endtime\",{\"1\":{\"154\":2}}],[\"endpoints\",{\"1\":{\"153\":1}}],[\"enable\",{\"1\":{\"126\":2}}],[\"en\",{\"1\":{\"113\":4}}],[\"encodetostring\",{\"1\":{\"87\":2}}],[\"encode\",{\"1\":{\"87\":2}}],[\"encryptionfilereaderwriter\",{\"1\":{\"87\":3}}],[\"encryptionfilereaderwriter是一个装饰器\",{\"1\":{\"87\":1}}],[\"enhancer\",{\"1\":{\"113\":2}}],[\"enhance\",{\"1\":{\"18\":1}}],[\"e\",{\"0\":{\"190\":2},\"1\":{\"87\":14,\"166\":1,\"182\":7,\"185\":1,\"186\":2,\"188\":3,\"190\":15,\"191\":1,\"192\":3,\"198\":7,\"199\":16,\"200\":13,\"208\":5,\"227\":2,\"228\":1,\"236\":4,\"237\":6,\"254\":2,\"259\":1,\"260\":2}}],[\"echarts\",{\"0\":{\"30\":1}}],[\"图中蓝色的为主要的对应部分\",{\"1\":{\"223\":1}}],[\"图中\",{\"1\":{\"81\":1,\"109\":1}}],[\"图表\",{\"0\":{\"29\":1}}],[\"图片增强\",{\"0\":{\"27\":1}}],[\"0即\",{\"1\":{\"251\":1}}],[\"025\",{\"1\":{\"154\":1}}],[\"01\",{\"1\":{\"154\":1}}],[\"0<\",{\"1\":{\"154\":3}}],[\"071374449\",{\"1\":{\"153\":1}}],[\"049234863\",{\"1\":{\"153\":1}}],[\"04\",{\"1\":{\"145\":2}}],[\"005\",{\"1\":{\"154\":1}}],[\"009242327\",{\"1\":{\"135\":1}}],[\"009608685\",{\"1\":{\"124\":1}}],[\"002707693\",{\"1\":{\"124\":1}}],[\"000421166\",{\"1\":{\"135\":1}}],[\"000194843\",{\"1\":{\"135\":1}}],[\"00013637\",{\"1\":{\"135\":1}}],[\"000123743\",{\"1\":{\"124\":1}}],[\"000251038\",{\"1\":{\"124\":1}}],[\"05\",{\"1\":{\"124\":2,\"135\":1,\"145\":3,\"154\":1}}],[\"0版本\",{\"1\":{\"117\":2,\"153\":1}}],[\"0\",{\"1\":{\"28\":1,\"87\":3,\"106\":1,\"124\":8,\"134\":5,\"135\":9,\"145\":6,\"146\":1,\"149\":1,\"150\":5,\"153\":9,\"154\":27,\"156\":1,\"162\":2,\"163\":2,\"164\":6,\"174\":1,\"181\":3,\"183\":5,\"184\":1,\"185\":3,\"186\":2,\"191\":2,\"192\":1,\"197\":2,\"198\":2,\"199\":7,\"200\":1,\"214\":1,\"215\":1,\"217\":16,\"228\":5,\"234\":1,\"236\":2,\"237\":7,\"252\":2,\"253\":3,\"254\":1,\"260\":4}}],[\"ss\",{\"1\":{\"257\":1}}],[\"ssc\",{\"1\":{\"236\":7}}],[\"sschannel\",{\"1\":{\"236\":2}}],[\"s=\",{\"1\":{\"257\":1}}],[\"s3\",{\"1\":{\"257\":4}}],[\"s2=\",{\"1\":{\"257\":1}}],[\"s2\",{\"1\":{\"257\":2}}],[\"s1\",{\"1\":{\"257\":2}}],[\"s1=\",{\"1\":{\"257\":2}}],[\"shape\",{\"1\":{\"241\":6}}],[\"sheep=new\",{\"1\":{\"240\":1}}],[\"sheep\",{\"1\":{\"240\":5}}],[\"sheep继承了animal父类\",{\"1\":{\"240\":1}}],[\"shortbuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"short\",{\"1\":{\"225\":1,\"251\":1}}],[\"showname\",{\"1\":{\"97\":2,\"100\":1,\"103\":3}}],[\"sleeping\",{\"1\":{\"241\":1}}],[\"sleep\",{\"1\":{\"237\":1,\"241\":3}}],[\"slack或者webhook等\",{\"1\":{\"162\":1}}],[\"slack配置等内容\",{\"1\":{\"162\":1}}],[\"sqrt\",{\"1\":{\"217\":1}}],[\"split\",{\"1\":{\"199\":1}}],[\"springboot\",{\"1\":{\"155\":1}}],[\"springboot已经有来micrometer的指标库\",{\"1\":{\"153\":1}}],[\"springframework\",{\"1\":{\"153\":2,\"154\":2}}],[\"spring事务等领域有着广泛的应用\",{\"1\":{\"108\":1}}],[\"spring\",{\"0\":{\"0\":3},\"1\":{\"108\":1}}],[\"sdk\",{\"1\":{\"157\":1}}],[\"sdks\",{\"1\":{\"119\":1}}],[\"sc\",{\"1\":{\"236\":10}}],[\"score\",{\"1\":{\"176\":8}}],[\"scores\",{\"1\":{\"176\":16}}],[\"scope>\",{\"1\":{\"153\":1}}],[\"scalar\",{\"1\":{\"149\":1,\"150\":1}}],[\"scrape\",{\"1\":{\"124\":4,\"125\":1,\"155\":1}}],[\"smallest\",{\"1\":{\"146\":1}}],[\"sam\",{\"1\":{\"198\":1,\"257\":1}}],[\"same\",{\"1\":{\"146\":1,\"163\":1}}],[\"sample由三部分组成\",{\"1\":{\"130\":1}}],[\"sample\",{\"1\":{\"130\":1,\"146\":2}}],[\"super\",{\"1\":{\"241\":1,\"259\":1}}],[\"suppresswarnings\",{\"1\":{\"186\":1}}],[\"successfully\",{\"1\":{\"163\":1}}],[\"success\",{\"1\":{\"153\":3}}],[\"sum作为后缀\",{\"1\":{\"134\":1}}],[\"sum\",{\"1\":{\"124\":1,\"134\":1,\"135\":1,\"141\":1,\"146\":6,\"150\":2,\"153\":2,\"154\":1,\"156\":2,\"164\":1,\"169\":2,\"171\":4,\"172\":1}}],[\"summary在通过promql进行查询时有更好的性能表现\",{\"1\":{\"135\":1}}],[\"summary是在sdk侧已经计算好了分位数\",{\"1\":{\"135\":1}}],[\"summary和histogram类似\",{\"1\":{\"135\":1}}],[\"summary\",{\"0\":{\"135\":1},\"1\":{\"124\":2,\"131\":1,\"135\":2,\"153\":1,\"164\":1}}],[\"sublist\",{\"1\":{\"174\":1}}],[\"subtraction\",{\"1\":{\"141\":1}}],[\"subject\",{\"1\":{\"105\":1,\"109\":1,\"110\":3,\"112\":5,\"113\":5}}],[\"substitution\",{\"1\":{\"70\":1}}],[\"socket\",{\"1\":{\"236\":1}}],[\"socketchannel介绍\",{\"0\":{\"232\":1}}],[\"socketchannel\",{\"1\":{\"225\":1,\"226\":1,\"229\":1,\"232\":19,\"233\":8,\"236\":8,\"237\":16}}],[\"soft\",{\"1\":{\"183\":4}}],[\"sofa=\",{\"1\":{\"103\":1}}],[\"sofa\",{\"1\":{\"96\":2,\"97\":17,\"99\":2,\"100\":7,\"103\":5}}],[\"sortarray\",{\"1\":{\"217\":1}}],[\"sort\",{\"1\":{\"174\":1}}],[\"so\",{\"1\":{\"171\":1}}],[\"sourcechannel\",{\"1\":{\"226\":1}}],[\"source\",{\"1\":{\"162\":1,\"163\":2}}],[\"somthing\",{\"1\":{\"110\":2,\"112\":1,\"113\":1}}],[\"sinkchannel\",{\"1\":{\"226\":1}}],[\"sington\",{\"1\":{\"80\":1}}],[\"singleton=memory\",{\"1\":{\"75\":1}}],[\"single\",{\"1\":{\"70\":1}}],[\"sieve\",{\"1\":{\"217\":7}}],[\"sighup信号或者请求alertmanager\",{\"1\":{\"161\":1}}],[\"size++\",{\"1\":{\"190\":1}}],[\"size\",{\"1\":{\"106\":1,\"174\":5,\"175\":5,\"176\":5,\"181\":2,\"182\":3,\"183\":1,\"184\":7,\"185\":3,\"186\":3,\"188\":4,\"190\":1,\"191\":5,\"192\":5,\"199\":1,\"207\":1,\"215\":4,\"217\":14,\"236\":2}}],[\"simplefactory\",{\"1\":{\"97\":3}}],[\"simplesofafactory\",{\"1\":{\"96\":1,\"97\":1}}],[\"simple\",{\"1\":{\"95\":1}}],[\"sequenceinputstream\",{\"1\":{\"223\":1}}],[\"separate\",{\"1\":{\"183\":1}}],[\"search=\",{\"1\":{\"164\":1}}],[\"search=node+exporter+mac\",{\"1\":{\"127\":1}}],[\"sent\",{\"1\":{\"163\":2}}],[\"sending\",{\"1\":{\"163\":2}}],[\"send\",{\"1\":{\"163\":1}}],[\"selectedkeys\",{\"1\":{\"229\":1,\"234\":3,\"236\":1}}],[\"selectionkey\",{\"1\":{\"229\":7,\"234\":3,\"236\":10}}],[\"selector介绍\",{\"0\":{\"234\":1}}],[\"selector\",{\"0\":{\"229\":1},\"1\":{\"225\":1,\"229\":13,\"232\":1,\"233\":1,\"234\":21,\"236\":21,\"238\":5}}],[\"selectors查询\",{\"1\":{\"138\":1}}],[\"selectors\",{\"0\":{\"137\":1,\"138\":1}}],[\"select\",{\"1\":{\"146\":2,\"229\":1,\"234\":3,\"236\":2,\"238\":1}}],[\"serializable\",{\"1\":{\"179\":1,\"180\":1,\"188\":1}}],[\"series的形式存储在prometheus的level\",{\"1\":{\"131\":1}}],[\"series中每个点被称为一个样子\",{\"1\":{\"130\":1}}],[\"series\",{\"0\":{\"130\":1},\"1\":{\"130\":1}}],[\"servlet\",{\"1\":{\"154\":4}}],[\"serverconnect\",{\"1\":{\"236\":1}}],[\"serversocketchannel介绍\",{\"0\":{\"233\":1}}],[\"serversocketchannel的网络编程\",{\"1\":{\"230\":1}}],[\"serversocketchannel\",{\"1\":{\"225\":1,\"226\":1,\"229\":1,\"233\":19,\"236\":7}}],[\"server中配置告警规则\",{\"1\":{\"157\":1}}],[\"server中配置alertmanager的地址\",{\"1\":{\"157\":1}}],[\"server中的告警规则\",{\"1\":{\"157\":1}}],[\"server进行计算的\",{\"1\":{\"135\":1}}],[\"server\",{\"1\":{\"127\":1,\"153\":10,\"154\":2,\"158\":1,\"232\":1}}],[\"server是最核心的组件\",{\"1\":{\"119\":1}}],[\"seconds指标\",{\"1\":{\"135\":1}}],[\"seconds\",{\"1\":{\"124\":9,\"134\":13,\"135\":9,\"141\":1,\"150\":13,\"153\":10,\"154\":19,\"156\":1,\"237\":1}}],[\"second\",{\"1\":{\"124\":1,\"228\":1}}],[\"severity\",{\"1\":{\"162\":2,\"163\":4,\"164\":1}}],[\"sever\",{\"1\":{\"122\":1}}],[\"setname\",{\"1\":{\"257\":1}}],[\"setnextapproval\",{\"1\":{\"92\":3}}],[\"setage\",{\"1\":{\"257\":2}}],[\"setattribute\",{\"1\":{\"154\":1}}],[\"set<selectionkey>\",{\"1\":{\"234\":1}}],[\"set<string>\",{\"1\":{\"175\":1,\"205\":1}}],[\"set=new\",{\"1\":{\"205\":1}}],[\"set和map接口\",{\"1\":{\"177\":1}}],[\"setexample\",{\"1\":{\"175\":1}}],[\"set接口\",{\"0\":{\"175\":1}}],[\"set\",{\"1\":{\"173\":3,\"174\":2,\"175\":17,\"205\":6,\"215\":11,\"217\":5}}],[\"setcallback\",{\"1\":{\"113\":1}}],[\"setsuperclass\",{\"1\":{\"113\":1}}],[\"segregation\",{\"1\":{\"70\":1}}],[\"sb\",{\"1\":{\"87\":3,\"217\":5}}],[\"str3\",{\"1\":{\"251\":3}}],[\"str2\",{\"1\":{\"251\":3}}],[\"str1\",{\"1\":{\"251\":4}}],[\"str\",{\"1\":{\"217\":3}}],[\"streams\",{\"1\":{\"221\":3}}],[\"stream\",{\"1\":{\"215\":1}}],[\"string是线程安全的\",{\"1\":{\"243\":1}}],[\"string是不可变\",{\"1\":{\"243\":1}}],[\"string和stringbuffer\",{\"0\":{\"243\":1}}],[\"stringwriter\",{\"1\":{\"223\":1}}],[\"string中读取数据\",{\"1\":{\"223\":1}}],[\"stringreader\",{\"1\":{\"223\":1}}],[\"stringbuffer是线程安全的\",{\"1\":{\"243\":1}}],[\"stringbuffer和stringbuilder是可变的\",{\"1\":{\"243\":1}}],[\"stringbuffer和stringbuilder是可变\",{\"1\":{\"243\":1}}],[\"stringbuffer和stringbuilder是用于处理字符串的类\",{\"1\":{\"243\":1}}],[\"stringbuffer\",{\"1\":{\"223\":1}}],[\"stringbufferinputstream\",{\"1\":{\"223\":2}}],[\"stringbuilder的性能比stringbuffer性能更好\",{\"1\":{\"243\":1}}],[\"stringbuilder的区别是什么\",{\"0\":{\"243\":1}}],[\"stringbuilder是非线程安全的\",{\"1\":{\"243\":1}}],[\"stringbuilder\",{\"1\":{\"87\":2,\"217\":2}}],[\"string>\",{\"1\":{\"166\":5,\"198\":1}}],[\"stringdata\",{\"1\":{\"87\":4}}],[\"string\",{\"1\":{\"82\":1,\"87\":24,\"92\":1,\"97\":5,\"100\":1,\"103\":3,\"106\":3,\"110\":1,\"112\":1,\"113\":1,\"153\":2,\"154\":3,\"166\":9,\"174\":5,\"175\":3,\"176\":3,\"205\":2,\"215\":1,\"217\":1,\"223\":1,\"227\":2,\"228\":1,\"232\":1,\"233\":1,\"236\":2,\"237\":4,\"240\":5,\"241\":5,\"243\":1,\"251\":4,\"252\":3,\"254\":1,\"257\":10,\"258\":3,\"260\":3}}],[\"stdvar\",{\"1\":{\"146\":1}}],[\"stddev\",{\"1\":{\"146\":1}}],[\"still\",{\"1\":{\"124\":1}}],[\"starsliao\",{\"1\":{\"167\":1}}],[\"startsat\",{\"1\":{\"166\":2}}],[\"starttime\",{\"1\":{\"154\":6}}],[\"starter\",{\"0\":{\"153\":1},\"1\":{\"152\":1,\"153\":3}}],[\"status\",{\"1\":{\"154\":2,\"166\":4}}],[\"status=\",{\"1\":{\"153\":3,\"154\":15}}],[\"staticproxy\",{\"1\":{\"109\":1,\"110\":7}}],[\"static\",{\"1\":{\"74\":2,\"75\":2,\"76\":3,\"78\":2,\"79\":2,\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":2,\"112\":2,\"113\":2,\"124\":2,\"125\":2,\"155\":1,\"164\":1,\"166\":1,\"174\":1,\"175\":1,\"176\":1,\"183\":2,\"198\":1,\"205\":1,\"215\":1,\"217\":5,\"227\":1,\"228\":1,\"236\":8,\"237\":2,\"240\":2,\"241\":4,\"254\":2,\"257\":5,\"258\":1,\"260\":6}}],[\"standardcharsets\",{\"1\":{\"236\":2}}],[\"standard\",{\"1\":{\"146\":2}}],[\"staff\",{\"1\":{\"92\":7}}],[\"sys\",{\"1\":{\"124\":3}}],[\"system\",{\"1\":{\"82\":3,\"87\":3,\"92\":6,\"97\":1,\"103\":1,\"106\":1,\"110\":3,\"112\":2,\"113\":2,\"154\":2,\"174\":10,\"175\":7,\"176\":9,\"182\":1,\"184\":1,\"205\":1,\"215\":3,\"217\":11,\"223\":1,\"227\":1,\"228\":8,\"236\":5,\"237\":2,\"240\":5,\"241\":5,\"246\":2,\"251\":3,\"254\":3,\"257\":3,\"258\":2,\"260\":9}}],[\"synchronized\",{\"1\":{\"75\":1,\"79\":1}}],[\"src\",{\"1\":{\"80\":1}}],[\"srp\",{\"1\":{\"70\":1,\"97\":1}}],[\"s\",{\"1\":{\"70\":1,\"87\":3,\"138\":1,\"176\":2,\"182\":4,\"205\":2,\"257\":2}}],[\"svg\",{\"1\":{\"28\":1}}],[\"legs\",{\"1\":{\"241\":2}}],[\"len\",{\"1\":{\"237\":2}}],[\"length属性\",{\"1\":{\"214\":1}}],[\"length\",{\"1\":{\"87\":2,\"181\":1,\"182\":1,\"183\":6,\"186\":1,\"198\":1,\"199\":3,\"200\":1,\"215\":1,\"217\":4,\"252\":2,\"253\":2}}],[\"level\",{\"1\":{\"171\":4}}],[\"le\",{\"1\":{\"150\":2,\"156\":1}}],[\"left修改器进行查询\",{\"1\":{\"145\":1}}],[\"left\",{\"1\":{\"145\":2,\"171\":1}}],[\"less\",{\"1\":{\"142\":2}}],[\"le=\",{\"1\":{\"134\":12,\"150\":10,\"154\":12}}],[\"lotail\",{\"1\":{\"199\":6}}],[\"lohead\",{\"1\":{\"199\":3}}],[\"load\",{\"1\":{\"197\":2}}],[\"loadfactor\",{\"1\":{\"197\":8,\"199\":1}}],[\"longbuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"long\",{\"1\":{\"154\":4,\"163\":3,\"213\":1,\"214\":5,\"215\":3,\"225\":1,\"236\":1,\"251\":1}}],[\"localhost\",{\"1\":{\"123\":1,\"124\":2,\"125\":4,\"126\":1,\"146\":1,\"150\":10,\"154\":1,\"155\":1,\"165\":1}}],[\"logger\",{\"1\":{\"166\":1}}],[\"logy\",{\"1\":{\"33\":2}}],[\"logo\",{\"1\":{\"28\":2}}],[\"last\",{\"1\":{\"188\":2,\"190\":10,\"191\":1,\"192\":1}}],[\"lastret\",{\"1\":{\"186\":11}}],[\"lastindexof\",{\"1\":{\"174\":1}}],[\"large\",{\"1\":{\"183\":1}}],[\"largest\",{\"1\":{\"146\":1}}],[\"latest\",{\"1\":{\"151\":1,\"166\":1}}],[\"lang\",{\"1\":{\"112\":2}}],[\"lable\",{\"1\":{\"137\":1}}],[\"labelvalues\",{\"1\":{\"154\":2}}],[\"labelnames\",{\"1\":{\"154\":2}}],[\"label\",{\"1\":{\"137\":5}}],[\"labels\",{\"1\":{\"137\":4,\"141\":1,\"163\":1,\"164\":2,\"166\":2,\"169\":1,\"171\":1,\"172\":1}}],[\"lab\",{\"1\":{\"80\":1}}],[\"labs\",{\"1\":{\"80\":1}}],[\"lazyinstancesafe\",{\"1\":{\"79\":5}}],[\"lazyinstancenosafe\",{\"1\":{\"78\":5}}],[\"lazyinstance\",{\"1\":{\"75\":6}}],[\"lsp\",{\"1\":{\"70\":1}}],[\"l\",{\"1\":{\"70\":1,\"228\":3}}],[\"limit\",{\"1\":{\"228\":1}}],[\"linenumberinputstream\",{\"1\":{\"223\":1}}],[\"linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据\",{\"1\":{\"149\":1}}],[\"linear函数对指标的数据变化趋势进行预测\",{\"1\":{\"133\":1}}],[\"linear\",{\"1\":{\"133\":1,\"149\":2}}],[\"linklast\",{\"1\":{\"190\":4}}],[\"linkedhashmap\",{\"1\":{\"176\":1}}],[\"linkedlist类主要由linkedlist和它的内部类node构成\",{\"1\":{\"188\":1}}],[\"linkedlist的底层数据结构是使用一个双向的链表结构实现的\",{\"1\":{\"188\":1}}],[\"linkedlist的类结构图如下\",{\"1\":{\"188\":1}}],[\"linkedlist的类结构图\",{\"0\":{\"188\":1}}],[\"linkedlist除了继承abstractsequentiallist之外\",{\"1\":{\"188\":1}}],[\"linkedlist是java集合中比较常见的线性表的数据结构\",{\"1\":{\"188\":1}}],[\"linkedlist源码解析\",{\"0\":{\"187\":1}}],[\"linkedlist\",{\"1\":{\"173\":2,\"188\":4,\"189\":3,\"190\":1,\"191\":1,\"192\":1,\"193\":6}}],[\"link\",{\"1\":{\"28\":1}}],[\"lifecycle\",{\"1\":{\"126\":2}}],[\"libraries\",{\"1\":{\"119\":1}}],[\"library\",{\"1\":{\"113\":1}}],[\"lisi\",{\"1\":{\"240\":2}}],[\"list<e>\",{\"1\":{\"180\":1}}],[\"list<string>\",{\"1\":{\"174\":1}}],[\"list<observer>\",{\"1\":{\"106\":1}}],[\"listexample\",{\"1\":{\"174\":1}}],[\"list>\",{\"1\":{\"146\":1}}],[\"list\",{\"0\":{\"174\":1},\"1\":{\"106\":5,\"173\":2,\"174\":18,\"179\":1}}],[\"liskov\",{\"1\":{\"70\":1}}],[\"light\",{\"1\":{\"28\":1}}],[\"tcp\",{\"1\":{\"226\":1,\"232\":3,\"233\":2}}],[\"t\",{\"1\":{\"149\":1,\"217\":2}}],[\"timeunit\",{\"1\":{\"237\":2}}],[\"timeout对于prometheus的告警消息是不生效的\",{\"1\":{\"163\":1}}],[\"timeout\",{\"1\":{\"162\":1,\"163\":2,\"236\":2}}],[\"timeseries格式如下\",{\"1\":{\"146\":1}}],[\"timestamp\",{\"1\":{\"130\":3}}],[\"time\",{\"1\":{\"130\":1}}],[\"title\",{\"1\":{\"28\":1}}],[\"task2\",{\"1\":{\"258\":1}}],[\"task1\",{\"1\":{\"258\":1}}],[\"taskname+\",{\"1\":{\"258\":1}}],[\"taskname=\",{\"1\":{\"258\":2}}],[\"taskname\",{\"1\":{\"258\":3}}],[\"task\",{\"1\":{\"258\":6}}],[\"tab\",{\"1\":{\"198\":5,\"199\":3,\"200\":5}}],[\"tablesizefor\",{\"1\":{\"197\":3}}],[\"table=\",{\"1\":{\"103\":1}}],[\"table\",{\"1\":{\"102\":1,\"103\":9,\"124\":1,\"198\":5,\"199\":12,\"200\":4}}],[\"tar\",{\"1\":{\"123\":2,\"127\":3}}],[\"targets\",{\"1\":{\"124\":2,\"125\":2,\"155\":1,\"164\":1}}],[\"target\",{\"1\":{\"113\":6,\"162\":1,\"163\":2}}],[\"type\",{\"1\":{\"97\":3,\"124\":6,\"130\":1,\"131\":1,\"135\":1,\"153\":2,\"154\":2}}],[\"txt\",{\"1\":{\"87\":1,\"227\":1}}],[\"test2\",{\"1\":{\"257\":1}}],[\"test<\",{\"1\":{\"153\":1}}],[\"testcglibproxy\",{\"1\":{\"113\":2}}],[\"testjdkproxy\",{\"1\":{\"112\":2}}],[\"teststatic\",{\"1\":{\"110\":2}}],[\"test\",{\"1\":{\"87\":1,\"164\":2,\"227\":1,\"257\":4}}],[\"text\",{\"1\":{\"87\":2}}],[\"tex\",{\"0\":{\"33\":1}}],[\"too\",{\"1\":{\"183\":1}}],[\"toarray\",{\"1\":{\"181\":1}}],[\"together\",{\"1\":{\"163\":1}}],[\"topk\",{\"1\":{\"146\":2}}],[\"to\",{\"1\":{\"144\":3,\"145\":2,\"163\":8,\"166\":4,\"171\":1,\"236\":1,\"260\":1}}],[\"total的后缀\",{\"1\":{\"171\":1}}],[\"total和http\",{\"1\":{\"154\":1}}],[\"total这个指标有4个标签\",{\"1\":{\"146\":1}}],[\"total指标的不同标签维度的所有指标\",{\"1\":{\"137\":1}}],[\"total都会累积1\",{\"1\":{\"132\":1}}],[\"total表示prometheus服务的http请求的数量\",{\"1\":{\"132\":1}}],[\"total结尾\",{\"1\":{\"132\":1}}],[\"total\",{\"1\":{\"124\":4,\"130\":11,\"131\":3,\"132\":1,\"137\":7,\"138\":1,\"139\":4,\"141\":3,\"146\":5,\"148\":5,\"154\":5,\"156\":1,\"164\":1,\"171\":4,\"172\":1}}],[\"tobytearray\",{\"1\":{\"87\":2,\"215\":1}}],[\"tostring\",{\"1\":{\"87\":1,\"106\":1,\"166\":1,\"215\":1,\"217\":1}}],[\"toc\",{\"1\":{\"45\":1}}],[\"th\",{\"1\":{\"237\":5}}],[\"threshold\",{\"1\":{\"197\":2,\"198\":2,\"199\":3}}],[\"throw\",{\"1\":{\"181\":1,\"183\":1,\"186\":5,\"191\":1,\"192\":1,\"197\":2}}],[\"throwable有两个重要的子类\",{\"1\":{\"254\":1}}],[\"throwable是所有异常类的根类\",{\"1\":{\"254\":1}}],[\"throwable\",{\"1\":{\"112\":1,\"113\":1,\"254\":1,\"259\":1}}],[\"throws\",{\"1\":{\"112\":1,\"113\":1,\"154\":4,\"236\":3,\"237\":1,\"259\":1}}],[\"than\",{\"1\":{\"142\":2}}],[\"thanos\",{\"1\":{\"118\":1}}],[\"that\",{\"1\":{\"124\":1,\"163\":1,\"166\":1}}],[\"then\",{\"1\":{\"171\":1}}],[\"the\",{\"1\":{\"124\":3,\"135\":1,\"146\":4,\"163\":2,\"166\":5,\"171\":1,\"217\":2,\"260\":1}}],[\"there\",{\"1\":{\"28\":2}}],[\"this\",{\"1\":{\"82\":1,\"87\":3,\"92\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":2,\"181\":3,\"182\":1,\"184\":1,\"186\":3,\"189\":1,\"197\":2,\"198\":1,\"199\":1,\"241\":2,\"252\":2,\"257\":3}}],[\"transient\",{\"1\":{\"180\":1}}],[\"truncated\",{\"1\":{\"166\":1}}],[\"truncatedalerts\",{\"1\":{\"166\":2}}],[\"true\",{\"1\":{\"1\":1,\"2\":1,\"154\":1,\"174\":2,\"175\":2,\"176\":2,\"182\":1,\"184\":1,\"190\":2,\"209\":1,\"215\":1,\"217\":3,\"234\":1,\"236\":2,\"237\":1,\"251\":5,\"252\":2}}],[\"try语句没有被执行到\",{\"1\":{\"260\":1}}],[\"try块用于包裹可能发生异常的代码片段\",{\"1\":{\"254\":1}}],[\"try块\",{\"1\":{\"254\":1}}],[\"try\",{\"1\":{\"87\":6,\"186\":1,\"227\":1,\"236\":2,\"237\":3,\"254\":1,\"259\":1,\"260\":3}}],[\"treeifybin\",{\"1\":{\"198\":2}}],[\"treeify\",{\"1\":{\"198\":2}}],[\"treenode<k\",{\"1\":{\"198\":1,\"199\":1,\"200\":1}}],[\"treenode\",{\"1\":{\"196\":1,\"198\":1,\"199\":1,\"200\":1}}],[\"treemap\",{\"1\":{\"173\":1,\"176\":1}}],[\"treeset\",{\"1\":{\"173\":1}}],[\"tree\",{\"1\":{\"80\":1}}],[\"卡片\",{\"0\":{\"28\":1}}],[\"脚注\",{\"0\":{\"24\":1}}],[\"的默认行为是使用对象的内存地址计算哈希码\",{\"1\":{\"253\":1}}],[\"的多次调用应始终返回相同的结果\",{\"1\":{\"252\":1}}],[\"的区别\",{\"0\":{\"250\":1}}],[\"的类\",{\"1\":{\"243\":2}}],[\"的轮询机制下\",{\"1\":{\"238\":1}}],[\"的情况下\",{\"1\":{\"238\":1}}],[\"的方式能够更高效地处理多个连接的读写事件\",{\"1\":{\"238\":1}}],[\"的方法调用是基于运行时类型而不是编译时类型\",{\"1\":{\"246\":1}}],[\"的方法\",{\"1\":{\"73\":1,\"100\":1,\"223\":3}}],[\"的简单的非阻塞客户端程序\",{\"1\":{\"237\":1}}],[\"的简单的非阻塞服务器端程序\",{\"1\":{\"236\":1}}],[\"的客户端程序\",{\"1\":{\"237\":1}}],[\"的服务器端程序\",{\"1\":{\"236\":1}}],[\"的网络编程场景\",{\"1\":{\"234\":1}}],[\"的事件\",{\"1\":{\"234\":1}}],[\"的优势在于可以使用较少的线程来处理多个通道的\",{\"1\":{\"229\":1}}],[\"的工作原理如下\",{\"1\":{\"229\":1}}],[\"的常用操作\",{\"1\":{\"228\":1}}],[\"的常用操作包括\",{\"1\":{\"228\":1}}],[\"的容量是在创建时预先确定的\",{\"1\":{\"228\":1}}],[\"的容量达到了一个较大的值\",{\"1\":{\"196\":1}}],[\"的特点和功能包括\",{\"1\":{\"226\":1}}],[\"的主要作用包括\",{\"1\":{\"234\":1}}],[\"的主要属性和方法包括\",{\"1\":{\"228\":1}}],[\"的主要特点和组成部分包括\",{\"1\":{\"225\":1}}],[\"的主要类\",{\"1\":{\"188\":1}}],[\"的实例对象\",{\"1\":{\"241\":1}}],[\"的实例\",{\"1\":{\"223\":1}}],[\"的功能是查看最后一个字节\",{\"1\":{\"223\":1}}],[\"的子类都是装饰流\",{\"1\":{\"223\":2}}],[\"的数称之为素数\",{\"1\":{\"217\":1}}],[\"的数据读写以缓冲区为中心\",{\"1\":{\"225\":1}}],[\"的数据域\",{\"1\":{\"192\":1}}],[\"的数据到\",{\"1\":{\"192\":1}}],[\"的数据结构\",{\"1\":{\"173\":1}}],[\"的基本用法\",{\"1\":{\"215\":1}}],[\"的位数\",{\"1\":{\"215\":1}}],[\"的第\",{\"1\":{\"214\":2}}],[\"的查找\",{\"1\":{\"204\":1}}],[\"的性能取决于哈希函数的质量和哈希表的大小\",{\"1\":{\"204\":1}}],[\"的键\",{\"1\":{\"204\":1,\"209\":1,\"210\":1}}],[\"的底层数据结构是基于\",{\"1\":{\"204\":1}}],[\"的底层采用数组实现\",{\"1\":{\"180\":1}}],[\"的哈希值\",{\"1\":{\"199\":1}}],[\"的当前\",{\"1\":{\"199\":1}}],[\"的幂\",{\"1\":{\"197\":1}}],[\"的引用变量\",{\"1\":{\"246\":1}}],[\"的引用\",{\"1\":{\"196\":1}}],[\"的的底层数据结构为数组+链表\",{\"1\":{\"196\":1}}],[\"的内存占用较高\",{\"1\":{\"193\":1}}],[\"的后向引用置为\",{\"1\":{\"192\":1}}],[\"的后向节点\",{\"1\":{\"192\":5}}],[\"的后向节点指向\",{\"1\":{\"190\":1,\"192\":1}}],[\"的前向引用置为\",{\"1\":{\"192\":1}}],[\"的前向节点指向\",{\"1\":{\"192\":1}}],[\"的前向节点\",{\"1\":{\"192\":6}}],[\"的过程中\",{\"1\":{\"186\":1}}],[\"的值则被忽略\",{\"1\":{\"207\":1}}],[\"的值在\",{\"1\":{\"200\":1}}],[\"的值\",{\"1\":{\"186\":2,\"204\":1}}],[\"的迭代器通过内部类\",{\"1\":{\"186\":1}}],[\"的迭代器\",{\"1\":{\"186\":1}}],[\"的元素删除操作是通过调用\",{\"1\":{\"210\":1}}],[\"的元素被存储为\",{\"1\":{\"209\":1,\"210\":1}}],[\"的元素添加操作是通过调用\",{\"1\":{\"208\":1}}],[\"的元素将会以键的形式存储在\",{\"1\":{\"207\":1}}],[\"的元素作为\",{\"1\":{\"204\":1}}],[\"的元素\",{\"1\":{\"185\":3}}],[\"的元素总数减少一个\",{\"1\":{\"184\":1}}],[\"的构造函数\",{\"1\":{\"181\":1}}],[\"的大小和是否为空\",{\"1\":{\"176\":1}}],[\"的大小\",{\"1\":{\"176\":1}}],[\"的大小可以根据需要进行动态调整\",{\"1\":{\"174\":1}}],[\"的映射关系\",{\"1\":{\"176\":1}}],[\"的形式存储数据\",{\"1\":{\"173\":1}}],[\"的请求量\",{\"1\":{\"172\":1}}],[\"的指标情况\",{\"1\":{\"137\":2}}],[\"的所有的数据\",{\"1\":{\"137\":1}}],[\"的所有方法\",{\"1\":{\"109\":1}}],[\"的包含时间和值的流式数据\",{\"1\":{\"130\":1}}],[\"的项目\",{\"1\":{\"117\":1}}],[\"的代码如下\",{\"1\":{\"110\":1}}],[\"的抽象方法getname\",{\"1\":{\"97\":2}}],[\"的静态对象和\",{\"1\":{\"73\":1}}],[\"的\",{\"1\":{\"23\":1,\"43\":1,\"161\":1,\"174\":1,\"190\":1,\"191\":1,\"192\":1,\"199\":1,\"208\":3,\"209\":2,\"210\":3,\"228\":1,\"229\":1,\"232\":2,\"234\":3,\"236\":2}}],[\"i+\",{\"1\":{\"217\":1}}],[\"i++\",{\"1\":{\"87\":2,\"106\":1,\"184\":2,\"185\":2,\"191\":1,\"215\":1,\"217\":9,\"237\":1,\"252\":1,\"253\":1}}],[\"illegalstateexception\",{\"1\":{\"186\":1}}],[\"illegal\",{\"1\":{\"181\":1,\"197\":2}}],[\"illegalargumentexception\",{\"1\":{\"181\":1,\"197\":2}}],[\"irate\",{\"1\":{\"148\":1}}],[\"irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率\",{\"1\":{\"148\":1}}],[\"irate同样用于计算区间向量的计算率\",{\"1\":{\"148\":1}}],[\"ir⋯\",{\"1\":{\"33\":1}}],[\"ignoring\",{\"1\":{\"144\":1,\"145\":2}}],[\"iin\",{\"1\":{\"87\":3}}],[\"immutable\",{\"1\":{\"243\":1}}],[\"img\",{\"1\":{\"121\":1,\"204\":1,\"223\":1}}],[\"import\",{\"1\":{\"106\":2,\"154\":6,\"174\":2,\"175\":2,\"176\":2,\"215\":1,\"217\":2,\"227\":3,\"228\":2,\"236\":9,\"237\":5}}],[\"implements\",{\"1\":{\"82\":2,\"87\":3,\"100\":2,\"103\":1,\"106\":2,\"110\":2,\"112\":1,\"113\":1,\"154\":1,\"180\":1,\"186\":1,\"241\":2}}],[\"image\",{\"1\":{\"65\":1,\"73\":1,\"86\":1,\"99\":1,\"105\":1,\"115\":1,\"123\":2,\"125\":1,\"127\":2,\"130\":1,\"137\":2,\"138\":1,\"156\":2,\"157\":1,\"164\":2,\"165\":1,\"172\":1,\"222\":1}}],[\"iusb\",{\"1\":{\"82\":9}}],[\"io来说\",{\"1\":{\"225\":1}}],[\"io库提供了多个基本的io流类\",{\"1\":{\"221\":1}}],[\"io流对象\",{\"0\":{\"223\":1}}],[\"io流基本类\",{\"0\":{\"221\":1}}],[\"io流主要包括字节流和字符流两种类型\",{\"1\":{\"220\":1}}],[\"io学习总结\",{\"0\":{\"219\":1}}],[\"io读写等\",{\"1\":{\"125\":1}}],[\"ioexception\",{\"1\":{\"87\":6,\"154\":1,\"236\":6,\"237\":5}}],[\"io\",{\"1\":{\"80\":1,\"92\":2,\"106\":5,\"123\":1,\"151\":1,\"154\":3,\"162\":1,\"166\":1,\"167\":1,\"180\":1,\"220\":2,\"223\":4,\"227\":1,\"236\":2,\"237\":2,\"260\":1}}],[\"ifurniturefactory\",{\"1\":{\"102\":1,\"103\":5}}],[\"ifactory的具体实现类americasofafactory\",{\"1\":{\"100\":1}}],[\"ifactory的具体实现类chinesesofafactory\",{\"1\":{\"100\":1}}],[\"ifactory\",{\"1\":{\"99\":1,\"100\":4}}],[\"if\",{\"1\":{\"75\":2,\"78\":1,\"79\":1,\"87\":4,\"92\":3,\"97\":2,\"124\":1,\"163\":1,\"181\":4,\"182\":1,\"183\":4,\"184\":4,\"185\":3,\"186\":4,\"190\":1,\"191\":2,\"192\":3,\"197\":3,\"198\":7,\"199\":13,\"200\":5,\"217\":4,\"234\":4,\"236\":8,\"237\":2,\"252\":4,\"253\":1}}],[\"inheritance\",{\"1\":{\"242\":1}}],[\"inhibiting\",{\"1\":{\"163\":1}}],[\"inhibit\",{\"1\":{\"162\":2,\"163\":3}}],[\"inetsocketaddress\",{\"1\":{\"232\":1,\"233\":1,\"236\":2,\"237\":3}}],[\"inlining\",{\"1\":{\"183\":1}}],[\"index++\",{\"1\":{\"217\":1}}],[\"indexoutofboundsexception\",{\"1\":{\"186\":1,\"191\":2,\"192\":2}}],[\"indexof\",{\"1\":{\"174\":1,\"185\":4}}],[\"index的值和elementdata的长度相等\",{\"1\":{\"182\":1}}],[\"index\",{\"0\":{\"191\":1,\"192\":1},\"1\":{\"182\":8,\"184\":2,\"185\":4,\"188\":2,\"191\":22,\"192\":15,\"215\":3,\"217\":3}}],[\"input\",{\"1\":{\"220\":1}}],[\"inputstreamreader\",{\"1\":{\"223\":2}}],[\"inputstream\",{\"1\":{\"87\":1,\"221\":1,\"223\":1}}],[\"inprogress\",{\"1\":{\"169\":2}}],[\"initialcapacity\",{\"1\":{\"181\":6,\"197\":8}}],[\"initial\",{\"1\":{\"163\":2,\"197\":2,\"199\":1}}],[\"initially\",{\"1\":{\"163\":1}}],[\"ini文件下\",{\"1\":{\"127\":1}}],[\"instrumentation\",{\"1\":{\"154\":2,\"171\":1}}],[\"instant\",{\"0\":{\"137\":1},\"1\":{\"150\":1}}],[\"instanceof\",{\"1\":{\"198\":1,\"199\":1,\"200\":1,\"252\":1}}],[\"instances\",{\"1\":{\"171\":1}}],[\"instance的标签值相等\",{\"1\":{\"163\":1}}],[\"instance=\",{\"1\":{\"146\":1,\"150\":10}}],[\"instance为被采集的实例\",{\"1\":{\"146\":1}}],[\"instance\",{\"1\":{\"73\":1,\"75\":5,\"76\":2,\"78\":4,\"79\":4,\"146\":2,\"162\":1,\"163\":2,\"171\":13,\"172\":2}}],[\"incoming\",{\"1\":{\"163\":1}}],[\"inc\",{\"1\":{\"154\":1}}],[\"include=prometheus\",{\"1\":{\"153\":1}}],[\"increase是promql中的一个函数\",{\"1\":{\"132\":1}}],[\"increase\",{\"1\":{\"132\":1,\"148\":2,\"156\":2,\"164\":1}}],[\"infinity\",{\"1\":{\"150\":1}}],[\"information\",{\"1\":{\"124\":1,\"237\":5}}],[\"info\",{\"1\":{\"124\":3,\"166\":1,\"237\":2}}],[\"inflaterinputstream\",{\"1\":{\"87\":2}}],[\"invoke\",{\"1\":{\"112\":6,\"113\":1}}],[\"invocationhandler\",{\"1\":{\"112\":1}}],[\"invocationhandler接口来实现动态代理\",{\"1\":{\"112\":1}}],[\"inversion\",{\"1\":{\"70\":1}}],[\"in\",{\"1\":{\"87\":3,\"124\":1,\"146\":2,\"183\":1,\"217\":2}}],[\"intbuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"integer\",{\"1\":{\"183\":1,\"199\":1,\"245\":1}}],[\"integer>\",{\"1\":{\"176\":3}}],[\"interruptedexception\",{\"1\":{\"237\":1}}],[\"intersection\",{\"1\":{\"143\":1}}],[\"interval是全局配置告警规则任务的计算\",{\"1\":{\"124\":1}}],[\"interval\",{\"1\":{\"124\":3,\"162\":2,\"163\":4,\"169\":3,\"172\":1}}],[\"interceptorregistry\",{\"1\":{\"154\":1}}],[\"intercept\",{\"1\":{\"113\":1}}],[\"interface的继承接口\",{\"1\":{\"173\":1}}],[\"interface\",{\"1\":{\"70\":1,\"82\":2,\"87\":1,\"100\":1,\"103\":1,\"106\":2,\"110\":1,\"173\":1,\"241\":2,\"242\":1}}],[\"int\",{\"0\":{\"191\":1,\"192\":1},\"1\":{\"82\":10,\"87\":3,\"92\":8,\"106\":1,\"166\":1,\"174\":1,\"175\":1,\"176\":4,\"181\":1,\"182\":4,\"183\":12,\"184\":5,\"185\":5,\"186\":4,\"188\":3,\"191\":10,\"192\":6,\"197\":1,\"198\":3,\"199\":4,\"200\":3,\"207\":1,\"214\":1,\"215\":7,\"217\":27,\"223\":2,\"225\":1,\"227\":1,\"232\":1,\"233\":1,\"234\":1,\"236\":3,\"237\":2,\"241\":1,\"245\":1,\"251\":3,\"252\":2,\"253\":3,\"254\":4,\"257\":6,\"260\":8}}],[\"inner\",{\"1\":{\"76\":2}}],[\"innerclzsingleton\",{\"1\":{\"76\":5}}],[\"i\",{\"1\":{\"70\":1,\"87\":6,\"106\":3,\"184\":11,\"185\":8,\"186\":5,\"191\":5,\"198\":5,\"199\":1,\"200\":2,\"215\":4,\"217\":42,\"225\":8,\"226\":2,\"229\":3,\"232\":3,\"233\":3,\"234\":7,\"236\":1,\"237\":7,\"238\":3,\"245\":2,\"252\":3,\"253\":3}}],[\"isconnectable\",{\"1\":{\"236\":2}}],[\"isvalid\",{\"1\":{\"236\":1}}],[\"iswritable\",{\"1\":{\"234\":1,\"236\":1}}],[\"isreadable\",{\"1\":{\"234\":1,\"236\":1}}],[\"isacceptable\",{\"1\":{\"234\":1,\"236\":1}}],[\"isnan\",{\"1\":{\"197\":1}}],[\"iselementindex\",{\"1\":{\"191\":2,\"192\":2}}],[\"isempty\",{\"1\":{\"174\":1,\"175\":1,\"176\":1,\"215\":1}}],[\"isp\",{\"1\":{\"70\":1}}],[\"is\",{\"1\":{\"28\":2,\"174\":2,\"175\":2,\"176\":2,\"183\":1,\"241\":3,\"260\":1}}],[\"idea提示\",{\"1\":{\"260\":1}}],[\"idea会提示错误\",{\"1\":{\"257\":1}}],[\"identify\",{\"1\":{\"166\":1}}],[\"identifying\",{\"1\":{\"166\":1}}],[\"identifies\",{\"1\":{\"166\":1}}],[\"id=0\",{\"1\":{\"218\":1}}],[\"id\",{\"1\":{\"23\":1}}],[\"iter\",{\"1\":{\"236\":4}}],[\"iterate\",{\"1\":{\"217\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"234\":1,\"236\":1}}],[\"iterator<e>\",{\"1\":{\"186\":2}}],[\"iterator\",{\"1\":{\"186\":1,\"234\":1,\"236\":2}}],[\"item\",{\"1\":{\"188\":2,\"191\":2,\"192\":3}}],[\"itr\",{\"1\":{\"186\":4}}],[\"itypec\",{\"1\":{\"82\":2}}],[\"it\",{\"1\":{\"16\":2,\"163\":1}}],[\"我们调用了divide方法并将结果存储在result变量中\",{\"1\":{\"254\":1}}],[\"我们调用的是get\",{\"1\":{\"200\":1}}],[\"我们使用try\",{\"1\":{\"254\":1}}],[\"我们使用父类\",{\"1\":{\"246\":1}}],[\"我们需要使用相同的属性来计算hashcode\",{\"1\":{\"253\":1}}],[\"我们需要有一些专注力\",{\"1\":{\"64\":1}}],[\"我们对对象内容的比较\",{\"1\":{\"252\":1}}],[\"我们将字符串数据写入到缓冲区\",{\"1\":{\"227\":1}}],[\"我们完全可以自己建立一个linenumberoutputstream\",{\"1\":{\"223\":1}}],[\"我们看看这些字节流中不太对称的几个类吧\",{\"1\":{\"223\":1}}],[\"我们并不关心值的内容\",{\"1\":{\"208\":1}}],[\"我们都会选择使用histogram类型的指标去做分位数的统计\",{\"1\":{\"135\":1}}],[\"我们还可以通过histogram\",{\"1\":{\"134\":1}}],[\"我们可以实现代码的解耦和类之间的松耦合\",{\"1\":{\"241\":1}}],[\"我们可以从这个类中得到一定的技巧\",{\"1\":{\"223\":1}}],[\"我们可以根据指标的名称可以反推出指标的表达式\",{\"1\":{\"171\":1}}],[\"我们可以将一组相关的规则设置定义在一个group下\",{\"1\":{\"164\":1}}],[\"我们可以计算所有handler\",{\"1\":{\"146\":1}}],[\"我们可以使用offset关键字\",{\"1\":{\"139\":1}}],[\"我们可以使用求平均值来量化指标\",{\"1\":{\"134\":1}}],[\"我们可以直接输入指标名查询所有的这个指标名的时间序列\",{\"1\":{\"137\":1}}],[\"我们可以提前预测在未来什么时间节点上需要对资源进行扩容\",{\"1\":{\"121\":1}}],[\"我们可以看出代理模式有三个关键角色\",{\"1\":{\"109\":1}}],[\"我们可以看出适配器模式中包含三个关键角色\",{\"1\":{\"81\":1}}],[\"我们可以得出以下的一些结论\",{\"1\":{\"93\":1}}],[\"我们经常有一些审批流程\",{\"1\":{\"92\":1}}],[\"我们来思考一下\",{\"1\":{\"88\":1}}],[\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解\",{\"1\":{\"81\":1}}],[\"我们主要讲解最常用到的适配器模式\",{\"1\":{\"81\":1}}],[\"我们支持\",{\"1\":{\"57\":1,\"61\":1}}],[\"我觉得需要刻意练习\",{\"1\":{\"64\":1}}],[\"我在右对齐\",{\"1\":{\"22\":1}}],[\"我是居中的\",{\"1\":{\"22\":1}}],[\"hugelength\",{\"1\":{\"183\":2}}],[\"hugryinstance\",{\"1\":{\"74\":7}}],[\"hitail\",{\"1\":{\"199\":6}}],[\"hihead\",{\"1\":{\"199\":3}}],[\"highqps\",{\"1\":{\"164\":2}}],[\"histogram类型的http\",{\"1\":{\"154\":1}}],[\"histogram类型的指标可以使用histogram\",{\"1\":{\"150\":1}}],[\"histogram和summary的区别在于\",{\"1\":{\"135\":1}}],[\"histogram的指标\",{\"1\":{\"134\":1}}],[\"histogram直方图可以解决上面的问题\",{\"1\":{\"134\":1}}],[\"histogram直方图是用来统计和分析样本的分布情况\",{\"1\":{\"134\":1}}],[\"histogram直方图\",{\"0\":{\"134\":1}}],[\"histogram\",{\"1\":{\"131\":1,\"150\":3,\"154\":6,\"156\":1}}],[\"hello接口相关的指标\",{\"1\":{\"153\":1}}],[\"hello\",{\"1\":{\"153\":8,\"154\":19,\"227\":1,\"232\":1,\"233\":1,\"236\":2,\"240\":3}}],[\"help\",{\"1\":{\"124\":6,\"130\":1,\"131\":1,\"135\":1,\"153\":2,\"154\":4}}],[\"h\",{\"1\":{\"138\":1,\"198\":3,\"228\":1,\"253\":6}}],[\"have\",{\"1\":{\"166\":1}}],[\"hasremaining\",{\"1\":{\"227\":1,\"228\":3,\"232\":1,\"233\":1,\"236\":2,\"237\":1}}],[\"hasnext\",{\"1\":{\"186\":3,\"234\":1,\"236\":1}}],[\"has\",{\"1\":{\"163\":2}}],[\"hashcode\",{\"1\":{\"198\":1,\"204\":1,\"253\":3}}],[\"hashmap不是线程安全的\",{\"1\":{\"201\":1}}],[\"hashmap的底层数据结构\",{\"0\":{\"196\":1}}],[\"hashmap的类结构图如下\",{\"1\":{\"195\":1}}],[\"hashmap的类结构图\",{\"0\":{\"195\":1}}],[\"hashmap实现了serializable接口\",{\"1\":{\"195\":1}}],[\"hashmap实现了cloneable接口\",{\"1\":{\"195\":1}}],[\"hashmap继承了abstractmap类并实现类map接口\",{\"1\":{\"195\":1}}],[\"hashmap原理解析\",{\"0\":{\"194\":1}}],[\"hashmap<>\",{\"1\":{\"176\":1,\"198\":1,\"207\":3}}],[\"hashmapexample\",{\"1\":{\"176\":1}}],[\"hashmap\",{\"1\":{\"173\":1,\"176\":15,\"195\":1,\"196\":3,\"197\":5,\"198\":1,\"199\":3,\"200\":1,\"201\":3,\"204\":5,\"207\":3,\"208\":5,\"209\":5,\"210\":5,\"211\":1,\"253\":1}}],[\"hashset使用hashmap作为底层存储数据的结构\",{\"1\":{\"204\":1}}],[\"hashset实现了serializable接口\",{\"1\":{\"203\":1}}],[\"hashset实现了cloneable接口\",{\"1\":{\"203\":1}}],[\"hashset继承了abstractset类并实现类set接口\",{\"1\":{\"203\":1}}],[\"hashset存储的元素不会重复\",{\"1\":{\"203\":1}}],[\"hashset原理解析\",{\"0\":{\"202\":1}}],[\"hashset<>\",{\"1\":{\"175\":1,\"205\":1}}],[\"hashset\",{\"1\":{\"173\":1,\"175\":1,\"203\":1,\"204\":7,\"207\":6,\"208\":3,\"209\":5,\"210\":3,\"211\":3}}],[\"hash\",{\"1\":{\"124\":4,\"198\":13,\"199\":2,\"200\":13,\"253\":2}}],[\"handlewrite\",{\"1\":{\"236\":3}}],[\"handleaccept\",{\"1\":{\"236\":3}}],[\"handle\",{\"1\":{\"92\":7}}],[\"handleread\",{\"1\":{\"236\":3}}],[\"handlerinterceptoradapter\",{\"1\":{\"154\":2}}],[\"handler=~\",{\"1\":{\"137\":2}}],[\"handler=\",{\"1\":{\"130\":6,\"131\":1,\"134\":12,\"137\":1,\"138\":1,\"141\":4,\"146\":1,\"148\":5,\"150\":12,\"164\":1,\"172\":1}}],[\"handler\",{\"1\":{\"112\":3,\"130\":1,\"137\":2,\"141\":2,\"146\":3,\"150\":2,\"154\":4,\"172\":2}}],[\"handlerc\",{\"1\":{\"91\":1}}],[\"handlerb\",{\"1\":{\"91\":1}}],[\"http\",{\"1\":{\"124\":1,\"125\":1,\"126\":1,\"130\":12,\"131\":4,\"132\":3,\"134\":13,\"137\":8,\"138\":1,\"139\":4,\"141\":4,\"145\":12,\"146\":6,\"148\":5,\"150\":13,\"153\":11,\"154\":23,\"156\":2,\"162\":1,\"163\":1,\"164\":3,\"165\":1,\"169\":2,\"172\":2}}],[\"httpservletresponse\",{\"1\":{\"154\":4}}],[\"httpservletrequest\",{\"1\":{\"154\":4}}],[\"httpserver\",{\"1\":{\"154\":3}}],[\"httpserver是用于导出指标的服务\",{\"1\":{\"154\":1}}],[\"httpserver<\",{\"1\":{\"154\":1}}],[\"https\",{\"1\":{\"28\":2,\"80\":1,\"125\":1,\"127\":2,\"151\":1,\"162\":1,\"166\":1,\"167\":4,\"218\":1}}],[\"how\",{\"1\":{\"163\":3,\"166\":1}}],[\"hook\",{\"1\":{\"162\":2,\"163\":2}}],[\"hope\",{\"1\":{\"28\":4,\"36\":1,\"43\":1}}],[\"home\",{\"1\":{\"1\":1,\"2\":1}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"上以监听读事件\",{\"1\":{\"236\":1}}],[\"上注册的事件\",{\"1\":{\"236\":1}}],[\"上是否有对应的\",{\"1\":{\"234\":1}}],[\"上\",{\"1\":{\"229\":1,\"234\":4,\"236\":1}}],[\"上界等于最后一个写入元素的索引加一\",{\"1\":{\"228\":1}}],[\"上界等于缓冲区的容量\",{\"1\":{\"228\":1}}],[\"上界表示缓冲区中已经存储的元素数量\",{\"1\":{\"228\":1}}],[\"上界\",{\"1\":{\"228\":1}}],[\"上一个元素的索引\",{\"1\":{\"186\":1}}],[\"上一篇\",{\"1\":{\"7\":1}}],[\"上面的内容可能不会被面试官问到\",{\"1\":{\"177\":1}}],[\"上面的例子演示了如何创建\",{\"1\":{\"175\":1,\"176\":1}}],[\"上面的表达式rate\",{\"1\":{\"171\":1}}],[\"上面的表达式等价于\",{\"1\":{\"148\":1}}],[\"上面的语句等同于\",{\"1\":{\"137\":1}}],[\"上面的配置是采集prometheus自身的监控指标\",{\"1\":{\"124\":1}}],[\"上面的测试输出结果\",{\"1\":{\"100\":1}}],[\"上图是装饰器的uml图\",{\"1\":{\"86\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"危险容器\",{\"1\":{\"19\":1}}],[\"提高代码的安全性\",{\"1\":{\"257\":1}}],[\"提高散列存储结构的性能\",{\"1\":{\"253\":1}}],[\"提高系统的吞吐量和响应性能\",{\"1\":{\"229\":1}}],[\"提高\",{\"1\":{\"225\":1}}],[\"提高了\",{\"1\":{\"234\":1}}],[\"提高了系统的并发处理能力\",{\"1\":{\"234\":1}}],[\"提高了系统的资源利用率和响应速度\",{\"1\":{\"229\":1}}],[\"提高了系统的灵活性和可维护性\",{\"1\":{\"93\":1}}],[\"提高了数据传输的效率\",{\"1\":{\"226\":1}}],[\"提高了程序的性能和响应能力\",{\"1\":{\"225\":1}}],[\"提升代码的可扩展性\",{\"1\":{\"93\":1}}],[\"提升代码的复用性\",{\"1\":{\"72\":1}}],[\"提供一些通用方法的实现\",{\"1\":{\"241\":1}}],[\"提供一个静态工厂方法用于创建不同的产品对象\",{\"1\":{\"96\":1}}],[\"提供一个全局的访问点\",{\"1\":{\"66\":1}}],[\"提供的一种多路复用的机制\",{\"1\":{\"225\":1}}],[\"提供了一套完整的开发工具\",{\"1\":{\"255\":1}}],[\"提供了一种通用的规范\",{\"1\":{\"241\":1}}],[\"提供了访问基本类型数据的方法\",{\"1\":{\"245\":1}}],[\"提供了灵活而高效的\",{\"1\":{\"232\":1,\"233\":1}}],[\"提供了对文件的更强大和灵活的支持\",{\"1\":{\"225\":1}}],[\"提供了更高效的数据传输能力\",{\"1\":{\"225\":1}}],[\"提供了字符缓冲功能\",{\"1\":{\"223\":1}}],[\"提供了写入基本数据类型\",{\"1\":{\"223\":1}}],[\"提供了写入数据的高效能力\",{\"1\":{\"223\":1}}],[\"提供了\",{\"1\":{\"223\":1}}],[\"提供了读取基本数据类型\",{\"1\":{\"223\":1}}],[\"提供了读取数据的高效能力\",{\"1\":{\"223\":1}}],[\"提供了基本的类操作方法\",{\"1\":{\"223\":1}}],[\"提供了相关操作方法\",{\"1\":{\"221\":1}}],[\"提供了高效的事件多路复用能力\",{\"1\":{\"234\":1}}],[\"提供了高效的键值对存储和查找能力\",{\"1\":{\"201\":1}}],[\"提供了高效的查找操作\",{\"1\":{\"175\":1}}],[\"提供了多种方法来操作链表\",{\"1\":{\"193\":1}}],[\"提供了根据键快速查找对应值的方法\",{\"1\":{\"176\":1}}],[\"提供了非常多的面板和插件\",{\"1\":{\"127\":1}}],[\"提供了单节点和分布式的数据存储方案\",{\"1\":{\"118\":1}}],[\"提供了数据查询的promql\",{\"1\":{\"118\":1}}],[\"提供了数据采集\",{\"1\":{\"117\":1}}],[\"提供更大的灵活性\",{\"1\":{\"113\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"18\":1}}],[\"提供整个责任链的可扩展性\",{\"1\":{\"93\":1}}],[\"提供统一的方法来访问内部子系统\",{\"1\":{\"67\":1}}],[\"提示\",{\"1\":{\"44\":1}}],[\"提示容器\",{\"1\":{\"19\":1}}],[\"=~\",{\"1\":{\"137\":2}}],[\"=>\",{\"1\":{\"130\":3}}],[\"=factory\",{\"1\":{\"100\":1}}],[\"==比较结果为\",{\"1\":{\"251\":1}}],[\"==\",{\"0\":{\"250\":1,\"251\":1},\"1\":{\"75\":2,\"78\":1,\"79\":1,\"142\":1,\"180\":1,\"181\":2,\"182\":1,\"184\":2,\"185\":2,\"190\":1,\"192\":2,\"198\":7,\"199\":7,\"200\":6,\"208\":1,\"210\":1,\"217\":2,\"234\":1,\"236\":3,\"237\":1,\"250\":1,\"251\":7,\"252\":4,\"253\":1}}],[\"=\",{\"1\":{\"19\":1,\"33\":1,\"74\":1,\"75\":1,\"76\":1,\"78\":1,\"79\":1,\"82\":3,\"85\":2,\"87\":36,\"92\":4,\"97\":5,\"103\":1,\"106\":3,\"110\":2,\"112\":4,\"113\":5,\"137\":4,\"142\":1,\"153\":2,\"154\":8,\"169\":1,\"174\":4,\"175\":3,\"176\":8,\"181\":9,\"182\":5,\"183\":8,\"184\":6,\"185\":2,\"186\":11,\"190\":4,\"191\":6,\"192\":14,\"197\":5,\"198\":14,\"199\":37,\"200\":15,\"207\":2,\"215\":5,\"217\":32,\"227\":7,\"228\":1,\"232\":4,\"233\":5,\"234\":5,\"236\":21,\"237\":8,\"241\":4,\"245\":2,\"246\":2,\"251\":5,\"252\":7,\"253\":5,\"254\":1,\"257\":5,\"258\":2,\"260\":4}}],[\"a=3\",{\"1\":{\"260\":1}}],[\"a=2\",{\"1\":{\"260\":2}}],[\"a=1\",{\"1\":{\"260\":2}}],[\"accept\",{\"1\":{\"229\":1,\"233\":2,\"236\":3}}],[\"actuator<\",{\"1\":{\"153\":1}}],[\"actuator的依赖包中\",{\"1\":{\"153\":1}}],[\"actuator\",{\"0\":{\"153\":1},\"1\":{\"152\":1,\"153\":1}}],[\"attachment\",{\"1\":{\"236\":2}}],[\"attrs\",{\"0\":{\"23\":1}}],[\"at\",{\"1\":{\"215\":3}}],[\"assigned\",{\"1\":{\"260\":1}}],[\"assert\",{\"1\":{\"183\":2}}],[\"as\",{\"1\":{\"171\":1}}],[\"age\",{\"1\":{\"257\":8}}],[\"aggregate\",{\"1\":{\"171\":1}}],[\"again\",{\"1\":{\"163\":1}}],[\"anotherstring\",{\"1\":{\"252\":3}}],[\"anotherbitset\",{\"1\":{\"215\":4}}],[\"anobject\",{\"1\":{\"252\":4}}],[\"animal2\",{\"1\":{\"246\":3}}],[\"animal1\",{\"1\":{\"246\":3}}],[\"animaldemo\",{\"1\":{\"241\":1}}],[\"animal\",{\"1\":{\"240\":7,\"241\":7,\"246\":8}}],[\"annotations的内容在告警产生时会一同作为参数发送到alertmanager\",{\"1\":{\"164\":1}}],[\"annotations\",{\"1\":{\"164\":2,\"166\":2}}],[\"an\",{\"1\":{\"163\":3}}],[\"and\",{\"1\":{\"124\":1,\"143\":1,\"144\":1,\"171\":1,\"215\":1}}],[\"avi等\",{\"1\":{\"221\":1}}],[\"average\",{\"1\":{\"146\":1}}],[\"avg\",{\"1\":{\"146\":1}}],[\"avail\",{\"1\":{\"133\":3}}],[\"alicescore\",{\"1\":{\"176\":2}}],[\"alice\",{\"1\":{\"175\":3,\"176\":6}}],[\"already\",{\"1\":{\"163\":2}}],[\"allows\",{\"1\":{\"163\":1}}],[\"allocate\",{\"1\":{\"227\":1,\"228\":1,\"232\":1,\"233\":1,\"237\":1}}],[\"allocatedirect\",{\"1\":{\"236\":1}}],[\"allocated\",{\"1\":{\"124\":2}}],[\"alloc\",{\"1\":{\"124\":6}}],[\"all\",{\"1\":{\"146\":1}}],[\"alert\",{\"1\":{\"163\":2,\"164\":2,\"166\":3,\"167\":2}}],[\"alerts\",{\"1\":{\"163\":5,\"164\":1,\"165\":1,\"166\":5}}],[\"alertname\",{\"1\":{\"162\":2,\"163\":3}}],[\"alerting\",{\"1\":{\"124\":2,\"164\":1,\"166\":1}}],[\"alertmanager收到告警消息后\",{\"1\":{\"166\":1}}],[\"alertmanager查看告警消息\",{\"0\":{\"165\":1}}],[\"alertmanager持续多长时间未接收到告警后标记告警状态为resolved\",{\"1\":{\"163\":1}}],[\"alertmanager会启动它的告警恢复逻辑\",{\"1\":{\"163\":1}}],[\"alertmanager安装\",{\"0\":{\"162\":1}}],[\"alertmanager则不会发送消息到下游\",{\"1\":{\"161\":1}}],[\"alertmanager处理来自客户端的告警消息\",{\"1\":{\"158\":1}}],[\"alertmanager介绍\",{\"0\":{\"158\":1}}],[\"alertmanager作为告警收敛的组件\",{\"1\":{\"157\":1}}],[\"alertmanager的主要功能包括告警消息的分组\",{\"1\":{\"157\":1}}],[\"alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",{\"1\":{\"124\":1}}],[\"alertmanagers是配置alertmanagers的地址的\",{\"1\":{\"124\":1}}],[\"alertmanagers\",{\"1\":{\"124\":1,\"164\":1}}],[\"alertmanager提供了对告警消息的管理\",{\"1\":{\"120\":1}}],[\"alertmanager是用来管理告警消息的\",{\"1\":{\"119\":1}}],[\"alertmanager\",{\"1\":{\"115\":1,\"124\":2,\"161\":2,\"162\":1,\"166\":1}}],[\"abc\",{\"1\":{\"251\":3}}],[\"about\",{\"1\":{\"124\":1,\"163\":1}}],[\"abstractlist<e>\",{\"1\":{\"180\":1}}],[\"abstractlist\",{\"1\":{\"179\":1}}],[\"abstract\",{\"1\":{\"92\":2,\"97\":2,\"101\":1,\"103\":2,\"241\":4,\"246\":2,\"258\":2}}],[\"aftercompletion\",{\"1\":{\"154\":1}}],[\"after\",{\"1\":{\"110\":2,\"112\":2,\"174\":2,\"176\":2,\"217\":1}}],[\"aop\",{\"1\":{\"108\":1,\"154\":1}}],[\"addall\",{\"1\":{\"174\":1,\"182\":2,\"189\":1,\"207\":1}}],[\"added\",{\"1\":{\"163\":1}}],[\"addinterceptor\",{\"1\":{\"154\":1}}],[\"addinterceptors\",{\"1\":{\"154\":1}}],[\"addition\",{\"1\":{\"141\":1}}],[\"add\",{\"0\":{\"190\":1},\"1\":{\"106\":1,\"174\":5,\"175\":4,\"182\":5,\"188\":2,\"190\":4,\"205\":5,\"208\":4}}],[\"adapter\",{\"1\":{\"82\":2}}],[\"adaptee\",{\"1\":{\"81\":1}}],[\"arithmeticexception\",{\"1\":{\"254\":2,\"260\":6}}],[\"article\",{\"1\":{\"167\":1}}],[\"artifactid>\",{\"1\":{\"113\":1,\"153\":3,\"154\":3}}],[\"arraycopy\",{\"1\":{\"182\":1,\"184\":1}}],[\"array\",{\"1\":{\"181\":1,\"183\":5,\"217\":3,\"237\":1}}],[\"arrays=null\",{\"1\":{\"257\":1}}],[\"arrays=new\",{\"1\":{\"257\":1}}],[\"arrayssupport\",{\"1\":{\"183\":1}}],[\"arrays\",{\"1\":{\"181\":1,\"183\":1,\"217\":1}}],[\"arraylist有三种构造函数\",{\"1\":{\"181\":1}}],[\"arraylist会在构造函数执行的时候初始化\",{\"1\":{\"181\":1}}],[\"arraylist的初始化\",{\"0\":{\"181\":1}}],[\"arraylist的容量就是这个数组缓冲区的长度\",{\"1\":{\"180\":1}}],[\"arraylist的底层使用数组实现的源码如下\",{\"1\":{\"180\":1}}],[\"arraylist的类结构图\",{\"0\":{\"179\":1}}],[\"arraylist底层是如何实现的\",{\"0\":{\"180\":1}}],[\"arraylist底层基于数组实现\",{\"1\":{\"179\":1}}],[\"arraylist实现了serializable接口\",{\"1\":{\"179\":1}}],[\"arraylist实现了cloneable接口\",{\"1\":{\"179\":1}}],[\"arraylist实现了randomaccess接口\",{\"1\":{\"179\":1}}],[\"arraylist继承了abstractlist类并实现类list接口\",{\"1\":{\"179\":1}}],[\"arraylist源码解析\",{\"0\":{\"178\":1}}],[\"arraylist<e>\",{\"1\":{\"180\":1}}],[\"arraylist<alert>\",{\"1\":{\"166\":1}}],[\"arraylist<>\",{\"1\":{\"106\":1,\"174\":1}}],[\"arraylist\",{\"1\":{\"106\":1,\"173\":1,\"174\":1,\"179\":1,\"180\":11,\"181\":4,\"184\":2,\"185\":3,\"186\":13}}],[\"arrive\",{\"1\":{\"163\":1}}],[\"are\",{\"1\":{\"146\":1,\"163\":2}}],[\"architecture\",{\"1\":{\"120\":1}}],[\"args\",{\"1\":{\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":3,\"113\":3,\"174\":1,\"175\":1,\"176\":1,\"205\":1,\"215\":1,\"227\":1,\"228\":1,\"236\":1,\"237\":1,\"240\":2,\"241\":2,\"254\":1,\"257\":1,\"258\":1,\"260\":3}}],[\"amd64\",{\"1\":{\"123\":2,\"127\":2}}],[\"america\",{\"1\":{\"97\":1}}],[\"americasofafactory\",{\"1\":{\"100\":1}}],[\"americasofa\",{\"1\":{\"97\":2,\"100\":1}}],[\"americasofa类实现了抽象产品类\",{\"1\":{\"97\":1}}],[\"amount<1000\",{\"1\":{\"92\":1}}],[\"amount\",{\"1\":{\"92\":12}}],[\"apple\",{\"1\":{\"174\":8}}],[\"append\",{\"1\":{\"87\":1,\"217\":3}}],[\"apistatinterceptor\",{\"1\":{\"154\":2}}],[\"api\",{\"1\":{\"137\":4,\"141\":1,\"225\":1}}],[\"aproval\",{\"1\":{\"92\":7}}],[\"a\",{\"1\":{\"19\":1,\"124\":1,\"130\":2,\"135\":1,\"163\":5,\"181\":4,\"183\":1,\"217\":2,\"251\":2,\"260\":8}}],[\"circle=new\",{\"1\":{\"241\":1}}],[\"circle\",{\"1\":{\"241\":6}}],[\"c\",{\"1\":{\"181\":3,\"182\":2,\"189\":2,\"207\":4}}],[\"c661e8050434\",{\"1\":{\"167\":1}}],[\"csdn\",{\"1\":{\"167\":1}}],[\"critical\",{\"1\":{\"162\":1,\"163\":2}}],[\"createhttpserver\",{\"1\":{\"154\":1}}],[\"create\",{\"1\":{\"113\":1}}],[\"createsofa\",{\"1\":{\"97\":1,\"100\":4}}],[\"createcoffee\",{\"1\":{\"97\":1}}],[\"caught\",{\"1\":{\"260\":4}}],[\"caused\",{\"1\":{\"166\":1}}],[\"cat\",{\"1\":{\"246\":6}}],[\"catch语句中使用\",{\"1\":{\"259\":1}}],[\"catch语句对可能发生异常的代码块进行了包裹\",{\"1\":{\"254\":1}}],[\"catch块可以捕获多个异常类型\",{\"1\":{\"254\":1}}],[\"catch块用于捕获并处理指定类型的异常\",{\"1\":{\"254\":1}}],[\"catch块\",{\"1\":{\"254\":1}}],[\"catch\",{\"1\":{\"87\":7,\"186\":1,\"227\":1,\"236\":2,\"237\":3,\"254\":4,\"259\":1,\"260\":2}}],[\"cardinality\",{\"1\":{\"215\":1,\"217\":1}}],[\"capacity\",{\"1\":{\"180\":1,\"181\":1,\"183\":2,\"197\":4,\"199\":3,\"228\":1}}],[\"calculate\",{\"1\":{\"146\":5}}],[\"cursor\",{\"1\":{\"186\":10}}],[\"currenttimemillis\",{\"1\":{\"154\":2}}],[\"currently\",{\"1\":{\"124\":1}}],[\"curl\",{\"1\":{\"126\":1,\"127\":1}}],[\"cycles\",{\"1\":{\"124\":1,\"135\":1}}],[\"cd\",{\"1\":{\"123\":1}}],[\"cglib无法从代理对象中调用自身的方法\",{\"1\":{\"113\":1}}],[\"cglib无法代理final方法和final类\",{\"1\":{\"113\":1}}],[\"cglib能够代理普通类和接口类\",{\"1\":{\"113\":1}}],[\"cglib动态代理需要引入额外的库\",{\"1\":{\"113\":1}}],[\"cglib动态代理的缺点\",{\"1\":{\"113\":1}}],[\"cglib动态代理的优点\",{\"1\":{\"113\":1}}],[\"cglib动态代理可以代理没有实现任何接口的类\",{\"1\":{\"113\":1}}],[\"cglib动态代理通常能够提供更好的性能\",{\"1\":{\"113\":1}}],[\"cglib可以代理非接口类型的类\",{\"1\":{\"113\":1}}],[\"cglib\",{\"1\":{\"113\":1}}],[\"cglibproxyfactory\",{\"1\":{\"113\":3}}],[\"cglib代码模式需要实现methodinterceptor\",{\"1\":{\"113\":1}}],[\"cglib代码\",{\"0\":{\"113\":1}}],[\"cn\",{\"1\":{\"97\":2}}],[\"checkelementindex\",{\"1\":{\"191\":3,\"192\":3}}],[\"checked异常需要在代码中进行处理或声明\",{\"1\":{\"254\":1}}],[\"checked异常和unchecked异常\",{\"1\":{\"254\":1}}],[\"checked\",{\"1\":{\"183\":1,\"254\":1}}],[\"checkforcomodification\",{\"1\":{\"186\":7}}],[\"checkindex\",{\"1\":{\"185\":1}}],[\"channel2\",{\"1\":{\"234\":1}}],[\"channel1\",{\"1\":{\"234\":1}}],[\"channels\",{\"1\":{\"227\":1,\"236\":4,\"237\":1}}],[\"channel\",{\"0\":{\"226\":1},\"1\":{\"225\":1,\"226\":6,\"227\":5,\"234\":10,\"236\":5}}],[\"charset\",{\"1\":{\"236\":1}}],[\"charbuffer\",{\"1\":{\"225\":1,\"228\":1}}],[\"chararraywriter\",{\"1\":{\"223\":1}}],[\"chararrayreader\",{\"1\":{\"223\":1}}],[\"character\",{\"1\":{\"221\":1,\"245\":1}}],[\"charat\",{\"1\":{\"217\":1}}],[\"char\",{\"1\":{\"217\":2,\"225\":1,\"227\":1,\"228\":5,\"236\":1,\"245\":1,\"251\":1,\"252\":2,\"253\":1}}],[\"charlie\",{\"1\":{\"175\":3,\"176\":5}}],[\"chain\",{\"1\":{\"92\":2}}],[\"chu\",{\"1\":{\"167\":1}}],[\"china\",{\"1\":{\"97\":2,\"100\":1,\"103\":3}}],[\"chinesetable\",{\"1\":{\"102\":1,\"103\":3}}],[\"chinesesofafactory\",{\"1\":{\"99\":1,\"100\":2}}],[\"chinesesofa\",{\"1\":{\"97\":2,\"100\":1,\"103\":1}}],[\"chinesesofa类实现了抽象产品类\",{\"1\":{\"97\":1}}],[\"chinese\",{\"1\":{\"96\":1,\"99\":1}}],[\"cfo审批通过\",{\"1\":{\"92\":2}}],[\"cfo\",{\"1\":{\"92\":5}}],[\"cfo继承了aproval\",{\"1\":{\"92\":1}}],[\"cfo三个角色\",{\"1\":{\"92\":1}}],[\"ctorinstance\",{\"1\":{\"75\":1}}],[\"clear\",{\"1\":{\"174\":1,\"175\":1,\"176\":1,\"215\":2,\"217\":1,\"227\":2,\"228\":4,\"232\":1,\"233\":1,\"236\":2,\"237\":3}}],[\"clientconnect\",{\"1\":{\"237\":1}}],[\"clienta不关闭不断发送数据给服务端\",{\"1\":{\"235\":1}}],[\"client的数据\",{\"1\":{\"157\":1}}],[\"client\",{\"1\":{\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":1,\"119\":1,\"233\":1,\"236\":3,\"237\":8}}],[\"class\",{\"1\":{\"74\":1,\"75\":2,\"76\":2,\"78\":1,\"79\":1,\"82\":3,\"87\":4,\"92\":5,\"97\":5,\"100\":3,\"103\":4,\"106\":3,\"110\":3,\"112\":2,\"113\":2,\"153\":1,\"154\":2,\"166\":2,\"174\":1,\"175\":1,\"176\":1,\"180\":1,\"181\":2,\"186\":1,\"215\":1,\"217\":1,\"227\":1,\"228\":1,\"236\":1,\"237\":1,\"240\":5,\"241\":5,\"246\":3,\"254\":1,\"257\":5,\"258\":2,\"260\":3}}],[\"cloneable\",{\"1\":{\"179\":1,\"180\":1,\"188\":1}}],[\"close\",{\"1\":{\"87\":9,\"227\":2,\"232\":2,\"233\":2,\"236\":3,\"237\":1}}],[\"closed\",{\"1\":{\"70\":1}}],[\"cloud\",{\"0\":{\"0\":1}}],[\"copyof\",{\"1\":{\"181\":1,\"183\":1}}],[\"core\",{\"1\":{\"154\":2}}],[\"core包是指标的关键包\",{\"1\":{\"154\":1}}],[\"core<\",{\"1\":{\"154\":1}}],[\"count作为后缀\",{\"1\":{\"134\":1}}],[\"counter类型的http\",{\"1\":{\"154\":1}}],[\"counter类型的指标和计数器一样\",{\"1\":{\"132\":1}}],[\"counter\",{\"0\":{\"132\":1},\"1\":{\"124\":1,\"130\":2,\"131\":3,\"154\":10,\"217\":1}}],[\"count\",{\"1\":{\"124\":1,\"134\":1,\"135\":1,\"141\":1,\"146\":4,\"153\":2,\"154\":26,\"156\":2}}],[\"cold\",{\"1\":{\"183\":1}}],[\"collect\",{\"1\":{\"163\":1}}],[\"collection<\",{\"1\":{\"181\":1,\"182\":2,\"189\":1,\"207\":1}}],[\"collection的手写实现两个维度来讲解常见的集合类的具体实现\",{\"1\":{\"177\":1}}],[\"collection的实现还是经常被问到\",{\"1\":{\"177\":1}}],[\"collection概述\",{\"0\":{\"173\":1}}],[\"collection\",{\"1\":{\"124\":1,\"135\":1,\"173\":5,\"174\":1,\"175\":2}}],[\"color\",{\"1\":{\"28\":1,\"241\":6}}],[\"code的的请求总数\",{\"1\":{\"146\":1}}],[\"code=\",{\"1\":{\"130\":6,\"131\":1,\"145\":10,\"146\":1,\"148\":5}}],[\"code\",{\"1\":{\"87\":1,\"113\":1,\"130\":1,\"145\":9,\"146\":2,\"172\":2,\"183\":1}}],[\"concurrent\",{\"1\":{\"237\":1}}],[\"concurrenthashset\",{\"1\":{\"211\":1}}],[\"concurrentmodificationexception\",{\"1\":{\"186\":3}}],[\"concrete\",{\"1\":{\"105\":2}}],[\"continue\",{\"1\":{\"234\":1,\"236\":1}}],[\"containchars\",{\"1\":{\"217\":1}}],[\"containskey\",{\"1\":{\"176\":3,\"209\":4}}],[\"containsbob\",{\"1\":{\"175\":2}}],[\"contains\",{\"1\":{\"174\":3,\"175\":3,\"176\":2,\"185\":3,\"209\":5}}],[\"containsapple\",{\"1\":{\"174\":2}}],[\"controller\",{\"1\":{\"153\":1}}],[\"content\",{\"1\":{\"87\":7}}],[\"configureblocking\",{\"1\":{\"232\":2,\"233\":2,\"236\":2,\"237\":1}}],[\"configuration\",{\"1\":{\"124\":1,\"154\":1,\"166\":1}}],[\"configs是配置采集任务的\",{\"1\":{\"124\":1}}],[\"configs\",{\"1\":{\"124\":3,\"125\":3,\"155\":2,\"162\":1,\"163\":1,\"164\":1}}],[\"config\",{\"1\":{\"124\":1,\"162\":1,\"166\":1}}],[\"consul\",{\"1\":{\"118\":1,\"124\":1}}],[\"const\",{\"1\":{\"19\":1}}],[\"connect\",{\"1\":{\"82\":6,\"229\":1,\"232\":2,\"237\":2}}],[\"commonannotations\",{\"1\":{\"166\":2}}],[\"commonlabels\",{\"1\":{\"166\":2}}],[\"composition\",{\"1\":{\"242\":1}}],[\"componentimpl提供基本的实现方法\",{\"1\":{\"86\":1}}],[\"componentdecoratora\",{\"1\":{\"86\":1}}],[\"componentdecoratorb和componentdecoratora分别对componentimpl进行了增强\",{\"1\":{\"86\":1}}],[\"componentdecoratorb\",{\"1\":{\"86\":1}}],[\"compact\",{\"1\":{\"228\":4,\"236\":1}}],[\"computeprime\",{\"1\":{\"217\":1}}],[\"complement\",{\"1\":{\"143\":1}}],[\"compress\",{\"1\":{\"87\":2}}],[\"compressionfilereaderwriter\",{\"1\":{\"87\":3}}],[\"compressionfilereaderwriter是一个装饰器\",{\"1\":{\"87\":1}}],[\"com\",{\"1\":{\"28\":2,\"80\":1,\"87\":3,\"106\":3,\"125\":1,\"127\":2,\"167\":2,\"218\":1}}],[\"与阻塞\",{\"1\":{\"238\":1}}],[\"与客户端进行通信\",{\"1\":{\"233\":1}}],[\"与实现无关\",{\"1\":{\"214\":1}}],[\"与数组相比\",{\"1\":{\"193\":1}}],[\"与java动态代理不同\",{\"1\":{\"113\":1}}],[\"与\",{\"1\":{\"19\":1}}],[\"信息容器\",{\"1\":{\"19\":1}}],[\"virtual\",{\"1\":{\"255\":2}}],[\"victoriametrics\",{\"1\":{\"118\":1}}],[\"victoriametrics系列\",{\"1\":{\"115\":1}}],[\"v2\",{\"1\":{\"252\":2}}],[\"vs\",{\"1\":{\"221\":1}}],[\"v>\",{\"1\":{\"198\":3,\"199\":7,\"200\":6}}],[\"v\",{\"1\":{\"148\":1,\"149\":1,\"196\":1,\"200\":2}}],[\"v1\",{\"1\":{\"137\":4,\"141\":1,\"252\":2}}],[\"vector\",{\"0\":{\"137\":1,\"138\":1,\"144\":1},\"1\":{\"138\":1,\"144\":2,\"146\":2,\"148\":1,\"149\":1,\"150\":1}}],[\"version\",{\"1\":{\"166\":2}}],[\"version=\",{\"1\":{\"124\":1}}],[\"version>\",{\"1\":{\"113\":1,\"153\":1,\"154\":3}}],[\"version>3\",{\"1\":{\"113\":1}}],[\"val\",{\"1\":{\"253\":2}}],[\"values\",{\"1\":{\"146\":2}}],[\"value1\",{\"1\":{\"137\":1}}],[\"value2\",{\"1\":{\"137\":1}}],[\"value\",{\"1\":{\"130\":3,\"137\":5,\"146\":3,\"173\":1,\"176\":1,\"183\":1,\"198\":5,\"199\":1,\"200\":2,\"204\":1,\"215\":3,\"252\":4,\"253\":3,\"260\":1}}],[\"value键值对\",{\"1\":{\"117\":1}}],[\"variance\",{\"1\":{\"146\":1}}],[\"variable\",{\"1\":{\"19\":1}}],[\"void\",{\"1\":{\"82\":5,\"87\":5,\"92\":6,\"97\":2,\"100\":1,\"103\":2,\"106\":7,\"110\":5,\"112\":2,\"113\":2,\"154\":3,\"174\":1,\"175\":1,\"176\":1,\"182\":2,\"184\":1,\"186\":2,\"190\":1,\"191\":1,\"192\":1,\"205\":1,\"215\":1,\"217\":3,\"227\":1,\"228\":1,\"236\":5,\"237\":2,\"240\":6,\"241\":7,\"246\":3,\"254\":1,\"257\":6,\"258\":6,\"259\":1,\"260\":3}}],[\"volatile\",{\"1\":{\"75\":1}}],[\"vue\",{\"0\":{\"38\":1}}],[\"vuepress\",{\"0\":{\"17\":1},\"1\":{\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"18\":1,\"44\":1}}],[\"mutable\",{\"1\":{\"243\":1}}],[\"multiplication\",{\"1\":{\"141\":1}}],[\"might\",{\"1\":{\"183\":1}}],[\"micrometer<\",{\"1\":{\"153\":1}}],[\"minlength\",{\"1\":{\"183\":4}}],[\"mingrowth\",{\"1\":{\"183\":7}}],[\"mincapacity\",{\"1\":{\"183\":3}}],[\"minutes\",{\"1\":{\"163\":1}}],[\"minimum\",{\"1\":{\"146\":1,\"183\":1}}],[\"min\",{\"1\":{\"146\":1}}],[\"mister\",{\"1\":{\"28\":2}}],[\"modcount\",{\"1\":{\"186\":6}}],[\"modcount++\",{\"1\":{\"182\":2,\"184\":1}}],[\"modelandview\",{\"1\":{\"154\":3}}],[\"modifiers\",{\"0\":{\"145\":1}}],[\"modulo\",{\"1\":{\"141\":1}}],[\"more\",{\"1\":{\"42\":1,\"163\":3}}],[\"m\",{\"1\":{\"138\":2,\"237\":5}}],[\"mymethod\",{\"1\":{\"260\":6}}],[\"myjob\",{\"1\":{\"171\":9}}],[\"my\",{\"1\":{\"124\":1}}],[\"mysql等\",{\"1\":{\"119\":1}}],[\"mcclient\",{\"1\":{\"82\":1}}],[\"meow\",{\"1\":{\"246\":2}}],[\"memstats\",{\"1\":{\"124\":9}}],[\"memory=allocate\",{\"1\":{\"75\":1}}],[\"metric\",{\"1\":{\"130\":1,\"137\":1,\"171\":2}}],[\"metrics|\",{\"1\":{\"137\":2}}],[\"metrics接口耗时\",{\"1\":{\"134\":1}}],[\"metrics接口来获取自身的数据\",{\"1\":{\"130\":1}}],[\"metrics接口暴露\",{\"1\":{\"130\":1}}],[\"metrics\",{\"1\":{\"124\":1,\"125\":1,\"130\":9,\"131\":1,\"134\":12,\"137\":6,\"138\":1,\"141\":5,\"146\":1,\"148\":5,\"150\":13,\"154\":11,\"164\":1,\"172\":2}}],[\"method=\",{\"1\":{\"145\":14,\"153\":3}}],[\"methodproxy\",{\"1\":{\"113\":2}}],[\"methodinterceptor\",{\"1\":{\"113\":1}}],[\"method\",{\"1\":{\"98\":1,\"112\":5,\"113\":3,\"145\":12,\"183\":1}}],[\"mermaid\",{\"0\":{\"32\":1}}],[\"ms\",{\"1\":{\"43\":1}}],[\"mr\",{\"1\":{\"28\":1,\"36\":1}}],[\"md\",{\"1\":{\"18\":1}}],[\"mark\",{\"1\":{\"228\":2}}],[\"markdown\",{\"0\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1},\"1\":{\"5\":1,\"13\":2,\"14\":3,\"15\":1,\"16\":3,\"17\":2,\"18\":1,\"19\":1,\"34\":1,\"43\":1,\"44\":2},\"2\":{\"41\":1}}],[\"map=new\",{\"1\":{\"198\":1}}],[\"map接口\",{\"0\":{\"176\":1}}],[\"map\",{\"1\":{\"173\":1,\"176\":10,\"198\":4,\"207\":3,\"208\":1,\"209\":1,\"210\":1}}],[\"map等\",{\"1\":{\"173\":1}}],[\"map<string\",{\"1\":{\"166\":5,\"176\":1,\"198\":1}}],[\"maximum\",{\"1\":{\"146\":1,\"197\":2,\"199\":2}}],[\"max\",{\"1\":{\"146\":1,\"153\":4,\"166\":1,\"183\":7,\"199\":1,\"207\":1}}],[\"mango\",{\"1\":{\"174\":4}}],[\"management\",{\"1\":{\"153\":1}}],[\"manager\",{\"1\":{\"92\":6}}],[\"manager继承了aproval\",{\"1\":{\"92\":1}}],[\"many的向量匹配\",{\"1\":{\"145\":1}}],[\"many\",{\"1\":{\"144\":1,\"166\":1}}],[\"math\",{\"1\":{\"183\":2,\"207\":1,\"217\":1,\"241\":1}}],[\"match\",{\"1\":{\"162\":2,\"163\":4}}],[\"matches\",{\"1\":{\"144\":2}}],[\"matching\",{\"0\":{\"144\":1},\"1\":{\"144\":1}}],[\"matter\",{\"1\":{\"1\":1,\"2\":1}}],[\"machine\",{\"1\":{\"255\":2}}],[\"mac的版本\",{\"1\":{\"123\":1}}],[\"mac连接typec\",{\"1\":{\"82\":1}}],[\"makesound\",{\"1\":{\"241\":5,\"246\":9}}],[\"makesofa\",{\"1\":{\"103\":3}}],[\"maketable\",{\"1\":{\"103\":3}}],[\"main\",{\"1\":{\"80\":2,\"82\":1,\"87\":1,\"92\":1,\"97\":1,\"100\":1,\"103\":1,\"106\":1,\"110\":1,\"112\":1,\"113\":1,\"174\":1,\"175\":1,\"176\":1,\"205\":1,\"215\":1,\"227\":1,\"228\":1,\"236\":1,\"237\":1,\"240\":2,\"241\":2,\"254\":1,\"257\":1,\"258\":1,\"260\":3}}],[\"主题实现类\",{\"1\":{\"109\":1,\"110\":1}}],[\"主题和观察者之间松耦合\",{\"1\":{\"107\":1}}],[\"主题包含了一个自定义徽章可以使用\",{\"1\":{\"44\":1}}],[\"主题扩展了更多\",{\"1\":{\"18\":1}}],[\"主题扩展\",{\"0\":{\"18\":1}}],[\"主要功能包括\",{\"1\":{\"236\":1}}],[\"主要功能与配置演示\",{\"0\":{\"4\":1}}],[\"主要包括通道channel\",{\"1\":{\"230\":1}}],[\"主要包括以下几类\",{\"1\":{\"221\":1}}],[\"主要可以向其他输出流\",{\"1\":{\"223\":1}}],[\"主要因为string\",{\"1\":{\"223\":1}}],[\"主要用在编译器的语法\",{\"1\":{\"223\":1}}],[\"主要完成从流中读取数据时\",{\"1\":{\"223\":1}}],[\"主要原因\",{\"1\":{\"88\":1}}],[\"主要从\",{\"1\":{\"13\":1}}],[\"请看下面的示例代码\",{\"1\":{\"260\":1}}],[\"请求状态码\",{\"1\":{\"154\":2}}],[\"请求路径\",{\"1\":{\"154\":2}}],[\"请求的最大耗时\",{\"1\":{\"153\":1}}],[\"请求的总耗时\",{\"1\":{\"153\":1}}],[\"请求的总次数\",{\"1\":{\"153\":1}}],[\"请求都是在100ms以内\",{\"1\":{\"134\":1}}],[\"请使用绝对链接\",{\"1\":{\"44\":1}}],[\"请阅读\",{\"1\":{\"17\":1}}],[\"请先阅读\",{\"1\":{\"14\":1}}],[\"语法\",{\"0\":{\"33\":1},\"1\":{\"18\":1}}],[\"语法进行了扩展\",{\"1\":{\"17\":1}}],[\"语法扩展\",{\"1\":{\"16\":1}}],[\"对异常进行合适的处理\",{\"1\":{\"254\":1}}],[\"对称性\",{\"1\":{\"252\":1}}],[\"对字符串进行操作时不需要创建新的对象\",{\"1\":{\"243\":1}}],[\"对性能会有一定的影响\",{\"1\":{\"243\":1}}],[\"对每一个新进来的连接都会创建一个socketchannel\",{\"1\":{\"225\":1}}],[\"对reader\",{\"1\":{\"223\":1}}],[\"对应的键值对\",{\"1\":{\"210\":1}}],[\"对应的java实体如下\",{\"1\":{\"166\":1}}],[\"对空数组进行初始化\",{\"1\":{\"183\":1}}],[\"对象中重写的\",{\"1\":{\"246\":1}}],[\"对象用于读写数据\",{\"1\":{\"237\":1}}],[\"对象进行数据的读取和写入\",{\"1\":{\"233\":1}}],[\"对象进行装饰\",{\"1\":{\"223\":1}}],[\"对象作为参数\",{\"1\":{\"198\":1}}],[\"对象计算哈希值\",{\"1\":{\"198\":1,\"200\":1}}],[\"对象包含了键\",{\"1\":{\"196\":1}}],[\"对象的相应方法进行操作\",{\"1\":{\"229\":1}}],[\"对象的\",{\"1\":{\"186\":1,\"232\":1,\"233\":1}}],[\"对象时\",{\"1\":{\"180\":1}}],[\"对象\",{\"1\":{\"174\":1,\"175\":2,\"176\":1,\"197\":2,\"207\":2,\"223\":1,\"229\":1,\"232\":1,\"233\":1,\"234\":1,\"236\":2,\"246\":2}}],[\"对象之间通过消息传递来进行通信和协作\",{\"1\":{\"244\":1}}],[\"对象之间关系也比较清晰\",{\"1\":{\"107\":1}}],[\"对象之间尽量少了解\",{\"1\":{\"70\":1}}],[\"对meric使用了rate操作将metric原来的名称去掉\",{\"1\":{\"171\":1}}],[\"对处理者来说是一个灾难\",{\"1\":{\"159\":1}}],[\"对照分析\",{\"1\":{\"121\":1}}],[\"对监控指标进行长期趋势分析\",{\"1\":{\"121\":1}}],[\"对final方法和final类的限制\",{\"1\":{\"113\":1}}],[\"对原有功能的做扩展或者增强\",{\"1\":{\"108\":1}}],[\"对一些基础类无法修改\",{\"1\":{\"88\":1}}],[\"对读取的字符进行先解压再解密\",{\"1\":{\"87\":1}}],[\"对读取的字符进行解压\",{\"1\":{\"87\":2}}],[\"对读取的字符进行解密\",{\"1\":{\"87\":2}}],[\"对它进行功能的增强\",{\"1\":{\"87\":2}}],[\"对写入的字符进行先加密再压缩\",{\"1\":{\"87\":1}}],[\"对写入的字符进行压缩\",{\"1\":{\"87\":1}}],[\"对写入的字符进行加密\",{\"1\":{\"87\":1}}],[\"对写入字符进行压缩\",{\"1\":{\"87\":1}}],[\"对写入文件的字符的加密\",{\"1\":{\"87\":1}}],[\"对于被final修饰的局部变量\",{\"1\":{\"257\":1}}],[\"对于实例变量\",{\"1\":{\"257\":1}}],[\"对于任何非null的引用值x和y\",{\"1\":{\"252\":2}}],[\"对于任何非null的引用值x\",{\"1\":{\"252\":3}}],[\"对于基本数据类型的变量\",{\"1\":{\"251\":1}}],[\"对于包装类\",{\"1\":{\"245\":1}}],[\"对于读取操作\",{\"1\":{\"228\":1}}],[\"对于写入操作\",{\"1\":{\"228\":1}}],[\"对于请求数量在5分钟的时间窗口内\",{\"1\":{\"148\":1}}],[\"对于分位数的计算而言\",{\"1\":{\"135\":1}}],[\"对于标签值无约束\",{\"1\":{\"130\":1}}],[\"对于需要代理的类数量较多或变化频繁的情况下\",{\"1\":{\"109\":1}}],[\"对于修改是封闭的\",{\"1\":{\"70\":1}}],[\"对于扩展是开放的\",{\"1\":{\"70\":1}}],[\"对于\",{\"1\":{\"44\":1}}],[\"对\",{\"1\":{\"17\":1}}],[\"为例\",{\"1\":{\"251\":1}}],[\"为什么会这样呢\",{\"1\":{\"258\":1}}],[\"为什么会有人把equals方法当做是比较两个内容的比较呢\",{\"1\":{\"252\":1}}],[\"为什么内部类引用的外部变量必须用final修饰\",{\"0\":{\"258\":1}}],[\"为什么java不支持多继承\",{\"0\":{\"242\":1}}],[\"为什么要使用观察者模式\",{\"0\":{\"107\":1}}],[\"为什么要使用责任链模式\",{\"0\":{\"93\":1}}],[\"为什么要使用装饰器模式\",{\"0\":{\"88\":1},\"1\":{\"88\":1}}],[\"为单位\",{\"1\":{\"221\":1}}],[\"为尾节点\",{\"1\":{\"192\":1}}],[\"为头节点\",{\"1\":{\"192\":1}}],[\"为\",{\"1\":{\"190\":1,\"192\":2}}],[\"为了保持一致性\",{\"1\":{\"253\":1}}],[\"为了保持数组的连续性\",{\"1\":{\"180\":1}}],[\"为了解决该问题\",{\"1\":{\"148\":1}}],[\"为了丰富文档写作\",{\"1\":{\"17\":1}}],[\"为目标对象生成代理对象\",{\"1\":{\"113\":1}}],[\"为每个\",{\"1\":{\"15\":1}}],[\"插件来实现\",{\"1\":{\"16\":1}}],[\"中读取数据\",{\"1\":{\"236\":1}}],[\"中非常重要的组件\",{\"1\":{\"234\":1}}],[\"中用于\",{\"1\":{\"232\":1,\"233\":1}}],[\"中写入数据\",{\"1\":{\"223\":1}}],[\"中找到对应的键值对并删除\",{\"1\":{\"210\":1}}],[\"中指定键\",{\"1\":{\"210\":1}}],[\"中包含指定的元素\",{\"1\":{\"209\":1}}],[\"中存在指定的键\",{\"1\":{\"209\":1}}],[\"中是否存在该键\",{\"1\":{\"209\":1}}],[\"中是否包含指定的键\",{\"1\":{\"209\":1}}],[\"中是否包含指定的元素\",{\"1\":{\"209\":1}}],[\"中是否包含某个键\",{\"1\":{\"176\":1}}],[\"中已经存在相同的键\",{\"1\":{\"208\":1}}],[\"中之前不存在相同的键\",{\"1\":{\"208\":1}}],[\"中元素的唯一性\",{\"1\":{\"204\":1}}],[\"中常用的哈希表实现\",{\"1\":{\"201\":1}}],[\"中\",{\"1\":{\"176\":1,\"192\":1,\"204\":2,\"207\":1,\"208\":2,\"225\":1,\"226\":1,\"246\":1}}],[\"中间件有着广泛的应用\",{\"1\":{\"109\":1}}],[\"中介者对象封装了一组对象之间的交互\",{\"1\":{\"68\":1}}],[\"中介者模式\",{\"1\":{\"68\":1}}],[\"中使用\",{\"1\":{\"19\":1}}],[\"中的对象\",{\"1\":{\"250\":1}}],[\"中的多态\",{\"1\":{\"246\":1}}],[\"中的一个关键组件\",{\"1\":{\"228\":1}}],[\"中的字节流是极其对称的\",{\"1\":{\"223\":1}}],[\"中的不同键上\",{\"1\":{\"204\":1}}],[\"中的键值对数量超过了负载因子乘以\",{\"1\":{\"198\":1}}],[\"中的键值对\",{\"1\":{\"176\":1}}],[\"中的键值对没有固定的顺序\",{\"1\":{\"176\":1}}],[\"中的键是唯一的\",{\"1\":{\"176\":1}}],[\"中的元素是唯一的\",{\"1\":{\"175\":1}}],[\"中的元素没有固定的顺序\",{\"1\":{\"175\":2}}],[\"中的元素按照插入的顺序进行存储\",{\"1\":{\"174\":1}}],[\"中的创建对象的方法\",{\"1\":{\"103\":1}}],[\"中的\",{\"1\":{\"17\":1}}],[\"中很重要的一个概念\",{\"1\":{\"15\":1}}],[\"中设置页面信息\",{\"1\":{\"43\":1}}],[\"中设置\",{\"1\":{\"1\":1,\"2\":1}}],[\"是终止java虚拟机jvm的\",{\"1\":{\"260\":1}}],[\"是不可以被更改的\",{\"1\":{\"258\":1}}],[\"是不能改变原有的基础功能\",{\"1\":{\"86\":1}}],[\"是在目标机器上运行java应用程序所需的最小环境\",{\"1\":{\"255\":1}}],[\"是java平台的核心部分\",{\"1\":{\"255\":1}}],[\"是java虚拟机\",{\"1\":{\"255\":1}}],[\"是java运行时环境\",{\"1\":{\"255\":1}}],[\"是java开发工具包\",{\"1\":{\"255\":1}}],[\"是java语言中的两个重要概念\",{\"1\":{\"240\":1}}],[\"是程序的稳定性和健壮性的一种保护机制\",{\"1\":{\"254\":1}}],[\"是因为在string\",{\"1\":{\"252\":1}}],[\"是比较对象的内容\",{\"1\":{\"252\":1}}],[\"是两种不同的编程范式\",{\"1\":{\"244\":1}}],[\"是两种基本的介质流\",{\"1\":{\"223\":3}}],[\"是其子类\",{\"1\":{\"241\":1}}],[\"是非阻塞模式下的特性\",{\"1\":{\"229\":1}}],[\"是非线程安全的\",{\"1\":{\"211\":1}}],[\"是连接数据源和目标的管道\",{\"1\":{\"226\":1}}],[\"是outputstream\",{\"1\":{\"223\":1}}],[\"是所有自定义具体装饰流的父类\",{\"1\":{\"223\":1}}],[\"是所有的输入字节流的父类\",{\"1\":{\"223\":1}}],[\"是向与其它线程共用的管道中写入数据\",{\"1\":{\"223\":2}}],[\"是从与其它线程共用的管道中读取数据\",{\"1\":{\"223\":2}}],[\"是三种基本的介质流\",{\"1\":{\"223\":1}}],[\"是线程安全的\",{\"1\":{\"204\":1}}],[\"是用于存储单列数据的容器\",{\"1\":{\"188\":1}}],[\"是用来开发应用指标的工具包\",{\"1\":{\"119\":1}}],[\"是否可读\",{\"1\":{\"223\":1}}],[\"是否包含该对象\",{\"1\":{\"209\":1}}],[\"是否包含指定的元素\",{\"1\":{\"185\":1}}],[\"是否小于\",{\"1\":{\"186\":1}}],[\"是否等于\",{\"1\":{\"186\":2}}],[\"是否被修改过\",{\"1\":{\"186\":6}}],[\"是通过双向链表实现的数据结构\",{\"1\":{\"193\":1}}],[\"是通过内部类\",{\"1\":{\"186\":1}}],[\"是通过基于数组的方式实现的动态数组\",{\"1\":{\"180\":1}}],[\"是元素的数量\",{\"1\":{\"180\":1}}],[\"是应用于指标的操作函数列表\",{\"1\":{\"171\":1}}],[\"是和预聚合前的名称保存一致\",{\"1\":{\"171\":1}}],[\"是单调递增的\",{\"1\":{\"132\":1}}],[\"是全局配置默认采集时间间隔\",{\"1\":{\"124\":1}}],[\"是一个装饰器为writer\",{\"1\":{\"223\":1}}],[\"是一个连接字节流和字符流的桥梁\",{\"1\":{\"223\":1}}],[\"是一个适用于插入和删除操作频繁的数据结构\",{\"1\":{\"193\":1}}],[\"是一个强大的高性能的代码生成库\",{\"1\":{\"113\":1}}],[\"是一种多路复用的机制\",{\"1\":{\"229\":1}}],[\"是一种无序\",{\"1\":{\"211\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"104\":1}}],[\"是一种创建型设计模式\",{\"1\":{\"98\":1,\"101\":1}}],[\"是会经常使用到的一个设计模式\",{\"1\":{\"90\":1}}],[\"是为了保持简单性\",{\"1\":{\"83\":1}}],[\"是作为适配的中间类\",{\"1\":{\"81\":1}}],[\"是\",{\"1\":{\"15\":1,\"173\":1,\"179\":1,\"195\":1,\"201\":1,\"203\":1,\"220\":1,\"223\":3,\"225\":1,\"228\":1,\"232\":1,\"233\":1,\"234\":1}}],[\"演示了try\",{\"1\":{\"254\":1}}],[\"演示如何使用\",{\"1\":{\"175\":1}}],[\"演示\",{\"1\":{\"14\":1}}],[\"和java类库\",{\"1\":{\"255\":1}}],[\"和hashcode的关系\",{\"0\":{\"253\":1}}],[\"和handler不为\",{\"1\":{\"137\":1}}],[\"和handler为\",{\"1\":{\"137\":1}}],[\"和它的两个子类\",{\"1\":{\"246\":1}}],[\"和行为\",{\"1\":{\"244\":1}}],[\"和面向对象\",{\"1\":{\"244\":1}}],[\"和静态方法\",{\"1\":{\"241\":1}}],[\"和静态代理类似\",{\"1\":{\"112\":1}}],[\"和抽象方法\",{\"1\":{\"241\":1}}],[\"和私有方法\",{\"1\":{\"241\":1}}],[\"和重写\",{\"1\":{\"240\":1}}],[\"和非阻塞\",{\"1\":{\"238\":1}}],[\"和阻塞\",{\"1\":{\"238\":1}}],[\"和高并发处理的网络服务器编程场景\",{\"1\":{\"233\":1}}],[\"和高并发处理的网络编程场景\",{\"1\":{\"232\":1}}],[\"和printstream\",{\"1\":{\"223\":1}}],[\"和system\",{\"1\":{\"223\":1}}],[\"和status\",{\"1\":{\"154\":2}}],[\"和所有filteroutputstream\",{\"1\":{\"223\":1}}],[\"和所有filterinputstream\",{\"1\":{\"223\":1}}],[\"和本地文件中写入数据\",{\"1\":{\"223\":1}}],[\"和本地文件中读取数据\",{\"1\":{\"223\":1}}],[\"和负载因子\",{\"1\":{\"197\":1,\"199\":1}}],[\"和后向节点\",{\"1\":{\"192\":1}}],[\"和alert\",{\"1\":{\"169\":1}}],[\"和many\",{\"1\":{\"144\":1}}],[\"和maketable\",{\"1\":{\"103\":1}}],[\"和值的总和\",{\"1\":{\"134\":1}}],[\"和直方图类似\",{\"1\":{\"131\":1}}],[\"和一个具体方法showname\",{\"1\":{\"97\":1}}],[\"和持有一个aproval对象\",{\"1\":{\"92\":1}}],[\"和双重检查模式一样\",{\"1\":{\"76\":1}}],[\"和\",{\"0\":{\"250\":1},\"1\":{\"14\":1,\"43\":1,\"173\":5,\"176\":1,\"186\":4,\"188\":2,\"198\":1,\"204\":1,\"225\":1,\"226\":1,\"228\":1,\"229\":1,\"238\":2,\"246\":4,\"250\":1,\"251\":2}}],[\"介绍\",{\"0\":{\"14\":1,\"57\":1,\"61\":1},\"1\":{\"14\":1,\"15\":1}}],[\"文章标题列表\",{\"1\":{\"45\":1}}],[\"文章加密\",{\"2\":{\"12\":1}}],[\"文件映射等功能\",{\"1\":{\"225\":1}}],[\"文件锁定\",{\"1\":{\"225\":1}}],[\"文件长度\",{\"1\":{\"223\":1}}],[\"文件操作\",{\"1\":{\"221\":1,\"225\":1}}],[\"文件系统里剩余的磁盘字节数\",{\"1\":{\"125\":1}}],[\"文件夹的图片\",{\"1\":{\"44\":1}}],[\"文件放置在一起\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"13\":1}}],[\"文件生成页面\",{\"1\":{\"13\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"44\":1}}],[\"文字\",{\"1\":{\"10\":2}}],[\"文字段落\",{\"1\":{\"10\":24}}],[\"2^7\",{\"1\":{\"251\":2}}],[\"23\",{\"1\":{\"241\":1}}],[\"2323\",{\"1\":{\"217\":1}}],[\"230\",{\"1\":{\"28\":1}}],[\"24\",{\"1\":{\"145\":3,\"149\":1}}],[\"296\",{\"1\":{\"135\":1}}],[\"2s\",{\"1\":{\"134\":1}}],[\"21\",{\"1\":{\"124\":1,\"145\":2}}],[\"25\",{\"1\":{\"124\":1,\"135\":1,\"154\":1}}],[\"253\",{\"1\":{\"28\":1}}],[\"20\",{\"1\":{\"134\":1,\"150\":1}}],[\"20ms的请求又多少个\",{\"1\":{\"134\":1}}],[\"200\",{\"1\":{\"130\":9,\"131\":1,\"146\":1,\"148\":5,\"153\":3}}],[\"2017年底发布了基于全新存储层的2\",{\"1\":{\"117\":1}}],[\"2016年5月继kubernetes之后成为第二个正式加入cncf\",{\"1\":{\"117\":1}}],[\"20230830224136440\",{\"1\":{\"115\":1}}],[\"20231204151718877\",{\"1\":{\"222\":1}}],[\"20231023210926364\",{\"1\":{\"172\":1}}],[\"20231021174948512\",{\"1\":{\"165\":1}}],[\"20231021174854220\",{\"1\":{\"164\":1}}],[\"20231021174512876\",{\"1\":{\"164\":1}}],[\"20231021170507878\",{\"1\":{\"157\":1}}],[\"20231021115611700\",{\"1\":{\"156\":1}}],[\"20231021115719027\",{\"1\":{\"156\":1}}],[\"20231014211256244\",{\"1\":{\"138\":1}}],[\"20231014210912914\",{\"1\":{\"137\":1}}],[\"20231014210829763\",{\"1\":{\"137\":1}}],[\"20231012215203283\",{\"1\":{\"130\":1}}],[\"20231010201727866\",{\"1\":{\"127\":1}}],[\"20231009220040376\",{\"1\":{\"127\":1}}],[\"20231008231356066\",{\"1\":{\"125\":1}}],[\"20231008084050835\",{\"1\":{\"123\":1}}],[\"20231008083006727\",{\"1\":{\"123\":1}}],[\"20231030213851667\",{\"1\":{\"73\":1}}],[\"20231107230028268\",{\"1\":{\"105\":1}}],[\"20231105210628018\",{\"1\":{\"99\":1}}],[\"20231102232111957\",{\"1\":{\"86\":1}}],[\"20231112200737983\",{\"1\":{\"65\":1}}],[\"2020\",{\"1\":{\"43\":1}}],[\"2和3可能会发生重排序\",{\"1\":{\"75\":1}}],[\"2\",{\"1\":{\"10\":14,\"26\":1,\"75\":1,\"82\":1,\"113\":1,\"123\":2,\"124\":1,\"134\":2,\"150\":1,\"154\":4,\"174\":1,\"197\":1,\"205\":2,\"214\":1,\"217\":9,\"223\":1,\"228\":1,\"237\":1,\"251\":2,\"257\":2,\"260\":3}}],[\"1460\",{\"1\":{\"214\":1}}],[\"16\",{\"1\":{\"198\":1,\"207\":1,\"215\":2}}],[\"1696984033\",{\"1\":{\"130\":2}}],[\"1696984153\",{\"1\":{\"130\":2}}],[\"1696984318\",{\"1\":{\"130\":2}}],[\"1m\",{\"1\":{\"150\":2,\"156\":2,\"164\":2,\"169\":1,\"172\":2}}],[\"175\",{\"1\":{\"145\":1}}],[\"171390910999984\",{\"1\":{\"134\":1}}],[\"1d\",{\"1\":{\"139\":1}}],[\"128\",{\"1\":{\"251\":1}}],[\"127\",{\"1\":{\"153\":3,\"154\":1,\"162\":1,\"163\":1,\"164\":3,\"237\":2}}],[\"1255515\",{\"1\":{\"135\":1}}],[\"120665690\",{\"1\":{\"167\":1}}],[\"120\",{\"1\":{\"134\":1,\"145\":4,\"150\":1}}],[\"1205\",{\"1\":{\"130\":3,\"131\":1}}],[\"1st\",{\"1\":{\"198\":2}}],[\"1s\",{\"1\":{\"134\":1}}],[\"1831\",{\"1\":{\"134\":7}}],[\"1830\",{\"1\":{\"134\":1}}],[\"1829\",{\"1\":{\"134\":1}}],[\"1828\",{\"1\":{\"134\":1}}],[\"1827\",{\"1\":{\"134\":1}}],[\"1h\",{\"1\":{\"133\":1,\"162\":1,\"163\":1}}],[\"11\",{\"1\":{\"153\":1}}],[\"1186\",{\"1\":{\"130\":2}}],[\"1194\",{\"1\":{\"130\":2}}],[\"1024\",{\"1\":{\"217\":1,\"227\":1,\"232\":1,\"233\":1,\"236\":1,\"237\":1}}],[\"10s\",{\"1\":{\"163\":1}}],[\"10ms\",{\"1\":{\"134\":1}}],[\"10ms的请求有多少个\",{\"1\":{\"134\":1}}],[\"10\",{\"1\":{\"127\":2,\"154\":1,\"183\":1,\"228\":2,\"245\":1,\"254\":1,\"260\":2}}],[\"10000\",{\"1\":{\"92\":1}}],[\"13\",{\"1\":{\"217\":1}}],[\"1363728e+07\",{\"1\":{\"124\":1}}],[\"138\",{\"1\":{\"28\":1}}],[\"15s\",{\"1\":{\"124\":2}}],[\"15\",{\"1\":{\"28\":1,\"134\":1,\"217\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"1\",{\"1\":{\"10\":12,\"19\":1,\"24\":1,\"26\":1,\"43\":2,\"75\":1,\"82\":1,\"87\":3,\"123\":2,\"124\":4,\"127\":2,\"134\":3,\"135\":1,\"146\":2,\"150\":2,\"153\":3,\"154\":4,\"162\":1,\"163\":1,\"164\":4,\"174\":1,\"180\":2,\"182\":2,\"183\":2,\"184\":2,\"185\":3,\"186\":3,\"191\":2,\"198\":10,\"199\":3,\"200\":2,\"204\":1,\"205\":3,\"207\":1,\"214\":2,\"215\":1,\"217\":7,\"223\":1,\"225\":1,\"227\":1,\"236\":1,\"237\":4,\"251\":3,\"257\":2,\"260\":2}}],[\"段落\",{\"1\":{\"10\":2}}],[\"页脚\",{\"1\":{\"7\":1,\"45\":1}}],[\"页面的导入路径如下\",{\"1\":{\"127\":1}}],[\"页面结构\",{\"0\":{\"45\":1}}],[\"页面内容\",{\"0\":{\"44\":1}}],[\"页面配置\",{\"0\":{\"42\":1},\"1\":{\"43\":1},\"2\":{\"47\":1}}],[\"页面引入配置\",{\"1\":{\"15\":1}}],[\"页面信息\",{\"0\":{\"43\":1},\"1\":{\"7\":1}}],[\"页面展示如下\",{\"1\":{\"123\":1}}],[\"页面展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"贡献者\",{\"1\":{\"7\":1,\"45\":1}}],[\"侧边栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"展示prometheus数据\",{\"1\":{\"127\":1}}],[\"展示\",{\"0\":{\"13\":1},\"1\":{\"5\":1,\"34\":1}}],[\"项目主页配置\",{\"1\":{\"1\":1,\"2\":1}}],[\"你需要阅读\",{\"1\":{\"15\":1}}],[\"你需要在页面\",{\"1\":{\"1\":1,\"2\":1}}],[\"你应该创建和编写\",{\"1\":{\"13\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"45\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"7\":1}}],[\"你可以将图片和\",{\"1\":{\"44\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"44\":1}}],[\"你可以在\",{\"1\":{\"43\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"1\":1,\"2\":1}}],[\"你可以标记\",{\"1\":{\"25\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"13\":1}}],[\"想要使用此布局\",{\"1\":{\"1\":1,\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
