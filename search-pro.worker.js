const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":558,\"nextId\":558,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#更新计划\",\"2\":\"v-8daa1a0e#更新计划-1\",\"3\":\"v-2e3eac9e\",\"4\":\"v-71b3ae87\",\"5\":\"v-71b3ae87#功能亮点\",\"6\":\"v-71b3ae87#bar\",\"7\":\"v-71b3ae87#foo\",\"8\":\"v-9cffac66\",\"9\":\"v-9cffac66#设计模式有哪些类型\",\"10\":\"v-9cffac66#创建型模式\",\"11\":\"v-9cffac66#结构型模式\",\"12\":\"v-9cffac66#行为型模式\",\"13\":\"v-9cffac66#面试过程中常问的设计模式\",\"14\":\"v-9cffac66#设计模式的几种原则\",\"15\":\"v-1110218a\",\"16\":\"v-1110218a#什么是单例模式\",\"17\":\"v-1110218a#单例模式的实现\",\"18\":\"v-1110218a#饿汉模式-线程安全-推荐\",\"19\":\"v-1110218a#双重检查-线程安全-推荐\",\"20\":\"v-1110218a#使用内部类模式-线程安全-推荐\",\"21\":\"v-1110218a#其他\",\"22\":\"v-1110218a#懒汉模式-线程不安全-不推荐\",\"23\":\"v-1110218a#懒汉模式-线程不安全-不推荐-1\",\"24\":\"v-1110218a#源码下载\",\"25\":\"v-3be12559\",\"26\":\"v-3be12559#代码实现\",\"27\":\"v-3be12559#使用适配器模式有什么收益\",\"28\":\"v-3be12559#源码下载\",\"29\":\"v-4b45c2fc\",\"30\":\"v-4b45c2fc#uml图\",\"31\":\"v-4b45c2fc#使用案例\",\"32\":\"v-4b45c2fc#为什么要使用装饰器模式\",\"33\":\"v-4b45c2fc#源码下载\",\"34\":\"v-7f97107a\",\"35\":\"v-7f97107a#责任链模式的uml图\",\"36\":\"v-7f97107a#案例实战\",\"37\":\"v-7f97107a#为什么要使用责任链模式\",\"38\":\"v-9b0dc620\",\"39\":\"v-9b0dc620#简单工厂\",\"40\":\"v-9b0dc620#uml图\",\"41\":\"v-9b0dc620#代码实现\",\"42\":\"v-9b0dc620#工厂方法模式\",\"43\":\"v-9b0dc620#uml图-1\",\"44\":\"v-9b0dc620#代码实现-1\",\"45\":\"v-9b0dc620#抽象工厂\",\"46\":\"v-9b0dc620#uml图-2\",\"47\":\"v-9b0dc620#代码实现-2\",\"48\":\"v-63d3fd84\",\"49\":\"v-63d3fd84#观察者模式uml图\",\"50\":\"v-63d3fd84#案例实战\",\"51\":\"v-63d3fd84#为什么要使用观察者模式\",\"52\":\"v-a950132e\",\"53\":\"v-a950132e#静态代理\",\"54\":\"v-a950132e#代码实现\",\"55\":\"v-a950132e#动态代理\",\"56\":\"v-a950132e#java-动态代理\",\"57\":\"v-a950132e#cglib代码\",\"58\":\"v-4b047fe4\",\"59\":\"v-fc645b62\",\"60\":\"v-fc645b62#什么是mysql的读写分离\",\"61\":\"v-fc645b62#实现-mysql-的读写分离的几种方式\",\"62\":\"v-f76e3d8c\",\"63\":\"v-f76e3d8c#mysql主从复制的过程\",\"64\":\"v-f76e3d8c#扩展阅读\",\"65\":\"v-f76e3d8c#主从复制的一致性是怎么保证的\",\"66\":\"v-f76e3d8c#什么是binlog\",\"67\":\"v-287c29f6\",\"68\":\"v-287c29f6#mysql主从复制的过程\",\"69\":\"v-287c29f6#mysql主从同步的延迟主要原因\",\"70\":\"v-287c29f6#解决办法\",\"71\":\"v-20734aa9\",\"72\":\"v-20734aa9#什么是存储过程\",\"73\":\"v-20734aa9#为什么不推荐使用存储过程\",\"74\":\"v-820b7be6\",\"75\":\"v-820b7be6#什么是数据库的范式\",\"76\":\"v-820b7be6#第一范式\",\"77\":\"v-820b7be6#第二范式\",\"78\":\"v-820b7be6#第三范式\",\"79\":\"v-820b7be6#反范式\",\"80\":\"v-7296f48a\",\"81\":\"v-7296f48a#命名规范\",\"82\":\"v-7296f48a#选择合适的数据类型\",\"83\":\"v-7296f48a#设置合适的字段长度\",\"84\":\"v-7296f48a#选择合适的精度\",\"85\":\"v-7296f48a#合理建立的约束\",\"86\":\"v-7296f48a#避免在表中存储重复或冗余的数据\",\"87\":\"v-7296f48a#合理的建立索引\",\"88\":\"v-7296f48a#遵循数据库设计范式的原则\",\"89\":\"v-7296f48a#禁止使用foreign-key\",\"90\":\"v-7296f48a#表字段不能超过100个-字段的总大小没有特殊原因不要超过8k\",\"91\":\"v-0b096db8\",\"92\":\"v-5b56c82f\",\"93\":\"v-5b56c82f#mysql综合练习题\",\"94\":\"v-5b56c82f#创建表\",\"95\":\"v-5b56c82f#插入数据\",\"96\":\"v-5b56c82f#查询学生表中的所有记录\",\"97\":\"v-5b56c82f#查询-student表中2-4条记录\",\"98\":\"v-5b56c82f#查询student学生的学号、姓名和院校信息\",\"99\":\"v-5b56c82f#查询计算机系和英语系的学生的信息的两种方法\",\"100\":\"v-5b56c82f#查询年龄为18-22岁的学生\",\"101\":\"v-5b56c82f#student表中查询每个院系有多少人\",\"102\":\"v-5b56c82f#从score-表中查询每个科目的最高分\",\"103\":\"v-5b56c82f#查询李四的考试科目-c-name-和考试成绩-grade\",\"104\":\"v-5b56c82f#用连接查询的方式查询所有学生的信息和考试成绩\",\"105\":\"v-5b56c82f#计算每个学生的总成绩\",\"106\":\"v-5b56c82f#计算每个考试科目的平均成绩\",\"107\":\"v-5b56c82f#查询计算机成绩低于95分的学生成绩\",\"108\":\"v-5b56c82f#查询同时参加计算机和英语考试的学生信息\",\"109\":\"v-5b56c82f#将计算机成绩按从高到低进行排序\",\"110\":\"v-5b56c82f#从student表和score-表中查询出学号然后合并查询结果\",\"111\":\"v-5b56c82f#查询姓张和姓王的同学的姓名、院系、考试科目和成绩。\",\"112\":\"v-5b56c82f#查询都是湖南的同学的姓名、年龄、院系、考试科目和成绩\",\"113\":\"v-78dbac94\",\"114\":\"v-78dbac94#mysql的存储引擎有哪些\",\"115\":\"v-78dbac94#innodb存储引擎介绍\",\"116\":\"v-78dbac94#myisam存储引擎介绍\",\"117\":\"v-7f5b750b\",\"118\":\"v-a6d93fec\",\"119\":\"v-3967b396\",\"120\":\"v-3967b396#什么是数据库索引\",\"121\":\"v-3967b396#innodb存储引擎支持哪些索引\",\"122\":\"v-3967b396#创建索引示例\",\"123\":\"v-4e6dd8ae\",\"124\":\"v-442c383b\",\"125\":\"v-19eba57c\",\"126\":\"v-19eba57c#根据查询条件设计索引\",\"127\":\"v-19eba57c#选择合适的索引列\",\"128\":\"v-19eba57c#使用联合索引\",\"129\":\"v-19eba57c#避免过度索引\",\"130\":\"v-19eba57c#定期优化和维护索引\",\"131\":\"v-19eba57c#考虑查询性能和写入性能的平衡\",\"132\":\"v-19eba57c#注意索引的数据类型和长度\",\"133\":\"v-19eba57c#尽量为order-by-和-group-by-后面的字段建立索引\",\"134\":\"v-19eba57c#主建索引尽量使用自增的\",\"135\":\"v-175ef5eb\",\"136\":\"v-175ef5eb#什么是b-树\",\"137\":\"v-175ef5eb#为什么使用b-树来实现索引\",\"138\":\"v-75411ad0\",\"139\":\"v-75411ad0#什么是哈希索引\",\"140\":\"v-75411ad0#具有什么特点\",\"141\":\"v-75411ad0#适用场景\",\"142\":\"v-e89b9ca2\",\"143\":\"v-e89b9ca2#什么是聚簇索引\",\"144\":\"v-e89b9ca2#什么是非聚簇索引\",\"145\":\"v-e89b9ca2#总结\",\"146\":\"v-1b7983a2\",\"147\":\"v-1b7983a2#什么是mysql的回表\",\"148\":\"v-1b7983a2#示例\",\"149\":\"v-1b7983a2#怎么避免\",\"150\":\"v-09abe2c2\",\"151\":\"v-09abe2c2#数据准备\",\"152\":\"v-09abe2c2#索引失效的几种情况\",\"153\":\"v-09abe2c2#_1-使用like操作符\",\"154\":\"v-09abe2c2#_2-联合索引不满足列的最左匹配原则\",\"155\":\"v-09abe2c2#_3-使用了select-from\",\"156\":\"v-09abe2c2#_4-查询条件中使用了函数或者运算\",\"157\":\"v-09abe2c2#_5-类型进行了隐式转换\",\"158\":\"v-09abe2c2#_6-order-by-在某些情况下会导致索引失效\",\"159\":\"v-09abe2c2#_7-使用了两列比较\",\"160\":\"v-09abe2c2#_8-使用or操作\",\"161\":\"v-09abe2c2#_9-mysql会根据数据量而决定走不走索引\",\"162\":\"v-09abe2c2#_10-还有一些可能导致索引失效的场景\",\"163\":\"v-526e1633\",\"164\":\"v-526e1633#数据准备\",\"165\":\"v-526e1633#联合索引使用示例\",\"166\":\"v-526e1633#索引生效情况\",\"167\":\"v-526e1633#索引失效的情况\",\"168\":\"v-526e1633#总结\",\"169\":\"v-b356d1ce\",\"170\":\"v-53d2a284\",\"171\":\"v-7daf0f93\",\"172\":\"v-608350e9\",\"173\":\"v-608350e9#什么是事务的两阶段提交\",\"174\":\"v-608350e9#什么是mysql的事务两阶段提交\",\"175\":\"v-608350e9#两阶段写日志有什么作用\",\"176\":\"v-541cf5da\",\"177\":\"v-7e340ee0\",\"178\":\"v-7e340ee0#prometheus教程介绍\",\"179\":\"v-69099ac7\",\"180\":\"v-69099ac7#什么是prometheus\",\"181\":\"v-69099ac7#prometheus提供的特性\",\"182\":\"v-69099ac7#组件\",\"183\":\"v-69099ac7#架构\",\"184\":\"v-69099ac7#prometheus适用的场景\",\"185\":\"v-300045a1\",\"186\":\"v-300045a1#安装prometheus\",\"187\":\"v-300045a1#prometheus配置文件讲解\",\"188\":\"v-300045a1#采集node-exporter的指标\",\"189\":\"v-300045a1#prometheus配置文件热更新\",\"190\":\"v-300045a1#grafana安装\",\"191\":\"v-300045a1#总结\",\"192\":\"v-0890d0c6\",\"193\":\"v-0890d0c6#什么是time-series\",\"194\":\"v-0890d0c6#指标的类型\",\"195\":\"v-0890d0c6#counter-累加器\",\"196\":\"v-0890d0c6#gauge仪表盘\",\"197\":\"v-0890d0c6#histogram直方图\",\"198\":\"v-0890d0c6#summary\",\"199\":\"v-40c62e56\",\"200\":\"v-40c62e56#瞬时向量查询-instant-vector-selectors\",\"201\":\"v-40c62e56#范围向量查询-range-vector-selectors\",\"202\":\"v-40c62e56#offset-时间位移操作\",\"203\":\"v-40c62e56#操作符\",\"204\":\"v-40c62e56#数学操作符\",\"205\":\"v-40c62e56#比较操作符\",\"206\":\"v-40c62e56#逻辑运算符\",\"207\":\"v-40c62e56#向量匹配符号-vector-matching\",\"208\":\"v-40c62e56#分组修改器-group-modifiers\",\"209\":\"v-40c62e56#聚合函数\",\"210\":\"v-40c62e56#其他常见的函数\",\"211\":\"v-40c62e56#计算counter的增长率\",\"212\":\"v-40c62e56#预测指标变化趋势\",\"213\":\"v-40c62e56#计算分位数\",\"214\":\"v-40c62e56#总结\",\"215\":\"v-a5f16108\",\"216\":\"v-a5f16108#方案一-使用spring-boot-starter-actuator\",\"217\":\"v-a5f16108#方案二-使用prometheus\",\"218\":\"v-a5f16108#配置prometheus采集\",\"219\":\"v-a5f16108#配置grafana视图\",\"220\":\"v-9930b448\",\"221\":\"v-9930b448#alertmanager介绍\",\"222\":\"v-9930b448#分组\",\"223\":\"v-9930b448#抑制\",\"224\":\"v-9930b448#静默\",\"225\":\"v-9930b448#alertmanager安装\",\"226\":\"v-9930b448#配置讲解\",\"227\":\"v-9930b448#在prometheus中配置告警规则\",\"228\":\"v-9930b448#alertmanager查看告警消息\",\"229\":\"v-9930b448#webhook\",\"230\":\"v-9930b448#参考文档\",\"231\":\"v-012ad836\",\"232\":\"v-012ad836#定义recoding-rules\",\"233\":\"v-012ad836#recording-rule的最佳实践\",\"234\":\"v-012ad836#命名规范\",\"235\":\"v-012ad836#实战\",\"236\":\"v-4271bd10\",\"237\":\"v-4271bd10#为什么会有可见性、原子性、有序性的问题\",\"238\":\"v-4271bd10#缓存导致的可见性问题\",\"239\":\"v-4271bd10#线程切换带来的原子问题\",\"240\":\"v-4271bd10#编译优化带来的有序性问题\",\"241\":\"v-4271bd10#总结\",\"242\":\"v-dfa7306e\",\"243\":\"v-dfa7306e#java内存模型\",\"244\":\"v-dfa7306e#编发编程的概念\",\"245\":\"v-dfa7306e#原子性\",\"246\":\"v-dfa7306e#可见性\",\"247\":\"v-dfa7306e#有序性\",\"248\":\"v-dfa7306e#volatile详解\",\"249\":\"v-dfa7306e#volatile关键字作用\",\"250\":\"v-dfa7306e#volatile能够保证可见性和防止指令重排\",\"251\":\"v-dfa7306e#volatile不能保证原子性\",\"252\":\"v-dfa7306e#volatile的使用场景\",\"253\":\"v-dfa7306e#状态标记\",\"254\":\"v-dfa7306e#防止指令重排\",\"255\":\"v-dfa7306e#happens-before-规则\",\"256\":\"v-dfa7306e#参考资料\",\"257\":\"v-ad9c5168\",\"258\":\"v-ad9c5168#java死锁示例\",\"259\":\"v-ad9c5168#死锁发生的条件\",\"260\":\"v-ad9c5168#如何避免死锁\",\"261\":\"v-ad9c5168#破坏占有且等待\",\"262\":\"v-ad9c5168#破坏循环等待条件\",\"263\":\"v-0c63cbe7\",\"264\":\"v-0c63cbe7#synchronized关键字的作用\",\"265\":\"v-0c63cbe7#使用示例\",\"266\":\"v-0c63cbe7#synchronized原理\",\"267\":\"v-0c63cbe7#synchronized优化\",\"268\":\"v-0c63cbe7#对象头\",\"269\":\"v-0c63cbe7#偏向锁\",\"270\":\"v-0c63cbe7#轻量级锁\",\"271\":\"v-0c63cbe7#重量级锁\",\"272\":\"v-0c63cbe7#synchronized的优化一览表\",\"273\":\"v-218427ee\",\"274\":\"v-218427ee#thread状态\",\"275\":\"v-218427ee#new-新建状态\",\"276\":\"v-218427ee#runnable\",\"277\":\"v-218427ee#blocked\",\"278\":\"v-218427ee#wait\",\"279\":\"v-218427ee#两个线程交替打印奇数和偶数\",\"280\":\"v-2ba52b9a\",\"281\":\"v-2ba52b9a#aqs简介\",\"282\":\"v-2ba52b9a#aqs核心思想\",\"283\":\"v-2ba52b9a#aqs-对资源的共享方式\",\"284\":\"v-2ba52b9a#aqs源码解析\",\"285\":\"v-2ba52b9a#类的继承关系\",\"286\":\"v-2ba52b9a#类的内部类\",\"287\":\"v-2ba52b9a#node类\",\"288\":\"v-2ba52b9a#conditionobject类\",\"289\":\"v-2ba52b9a#类的属性\",\"290\":\"v-2ba52b9a#类的构造函数\",\"291\":\"v-2ba52b9a#类的核心函数\",\"292\":\"v-2ba52b9a#acquire函数\",\"293\":\"v-2ba52b9a#release\",\"294\":\"v-2ba52b9a#手写一个aqs\",\"295\":\"v-2ba52b9a#参考资料\",\"296\":\"v-620122cd\",\"297\":\"v-620122cd#reentrantlock数据结构\",\"298\":\"v-620122cd#reentrantlock类继承关系\",\"299\":\"v-620122cd#类的属性\",\"300\":\"v-620122cd#类的构造函数\",\"301\":\"v-620122cd#类的内部类\",\"302\":\"v-620122cd#sync类\",\"303\":\"v-620122cd#nonfairsync类\",\"304\":\"v-620122cd#fairsyn类\",\"305\":\"v-620122cd#reentrantlock在dubbo中的使用\",\"306\":\"v-620122cd#reentrantlock使用示例\",\"307\":\"v-620122cd#reentrantlock的特点总结\",\"308\":\"v-1ed9a138\",\"309\":\"v-1ed9a138#countdownlatch简介\",\"310\":\"v-1ed9a138#countdownlatch使用示例\",\"311\":\"v-1ed9a138#countdownlatch源码解析\",\"312\":\"v-1ed9a138#countdownlatch数据结构\",\"313\":\"v-1ed9a138#类的继承关系\",\"314\":\"v-1ed9a138#类的属性\",\"315\":\"v-1ed9a138#类的构造函数\",\"316\":\"v-1ed9a138#类的内部类\",\"317\":\"v-1ed9a138#await函数\",\"318\":\"v-1ed9a138#countdown函数\",\"319\":\"v-1ed9a138#参考文档\",\"320\":\"v-6bf87dc7\",\"321\":\"v-6bf87dc7#cyclicbarrier简介\",\"322\":\"v-6bf87dc7#cyclicbarrier使用示例\",\"323\":\"v-6bf87dc7#cyclicbarrier源码解析\",\"324\":\"v-6bf87dc7#cyclicbarrier数据结构\",\"325\":\"v-6bf87dc7#类的继承关系\",\"326\":\"v-6bf87dc7#类的内部类\",\"327\":\"v-6bf87dc7#类的属性\",\"328\":\"v-6bf87dc7#类的构造函数\",\"329\":\"v-6bf87dc7#cyclicbarrier-int-runnable-型构造函数\",\"330\":\"v-6bf87dc7#cyclicbarrier-int-型构造函数\",\"331\":\"v-6bf87dc7#核心函数分析\",\"332\":\"v-6bf87dc7#dowait函数\",\"333\":\"v-6bf87dc7#nextgeneration函数\",\"334\":\"v-6bf87dc7#breakbarrier函数\",\"335\":\"v-6bf87dc7#参考\",\"336\":\"v-6ea84c4f\",\"337\":\"v-6ea84c4f#并发包的锁\",\"338\":\"v-6ea84c4f#reentrantlock\",\"339\":\"v-6ea84c4f#readwritelock\",\"340\":\"v-6ea84c4f#stampedlock\",\"341\":\"v-5c7e9d2b\",\"342\":\"v-5c7e9d2b#list\",\"343\":\"v-5c7e9d2b#map\",\"344\":\"v-5c7e9d2b#set\",\"345\":\"v-5c7e9d2b#queue\",\"346\":\"v-5c7e9d2b#总结\",\"347\":\"v-08dda278\",\"348\":\"v-08dda278#copyonwritearraylist介绍\",\"349\":\"v-08dda278#copyonwritearraylist使用示例\",\"350\":\"v-08dda278#copyonwritearraylist源码解析\",\"351\":\"v-08dda278#类的继承关系\",\"352\":\"v-08dda278#类的属性\",\"353\":\"v-08dda278#类的构造函数\",\"354\":\"v-08dda278#类的内部类\",\"355\":\"v-08dda278#核心函数分析\",\"356\":\"v-08dda278#copyof函数\",\"357\":\"v-08dda278#add函数\",\"358\":\"v-08dda278#addifabsent\",\"359\":\"v-08dda278#set函数\",\"360\":\"v-08dda278#remove函数\",\"361\":\"v-08dda278#总结\",\"362\":\"v-9d9dd8ee\",\"363\":\"v-9d9dd8ee#concurrenthashmap介绍\",\"364\":\"v-9d9dd8ee#java7-基于分段锁的concurrenthashmap\",\"365\":\"v-9d9dd8ee#java-8基于cas的concurrenthashmap\",\"366\":\"v-9d9dd8ee#concurrenthashmap使用示例\",\"367\":\"v-9d9dd8ee#concurrenthashmap源码解析\",\"368\":\"v-9d9dd8ee#类的继承关系\",\"369\":\"v-9d9dd8ee#类的内部类\",\"370\":\"v-9d9dd8ee#node类\",\"371\":\"v-9d9dd8ee#traverser类\",\"372\":\"v-9d9dd8ee#collectionview类\",\"373\":\"v-9d9dd8ee#segment类\",\"374\":\"v-9d9dd8ee#countercell\",\"375\":\"v-9d9dd8ee#类的属性\",\"376\":\"v-9d9dd8ee#类的构造函数\",\"377\":\"v-9d9dd8ee#核心函数分析\",\"378\":\"v-9d9dd8ee#putval函数\",\"379\":\"v-9d9dd8ee#get函数\",\"380\":\"v-9d9dd8ee#replacenode函数\",\"381\":\"v-9d9dd8ee#参考\",\"382\":\"v-301d6afa\",\"383\":\"v-301d6afa#什么是blockingqueue\",\"384\":\"v-301d6afa#blockingqueue接口定义\",\"385\":\"v-301d6afa#blockingqueue实现\",\"386\":\"v-301d6afa#arrayblockingqueue使用介绍\",\"387\":\"v-301d6afa#arrayblockingqueue源码实现\",\"388\":\"v-301d6afa#类的继承关系\",\"389\":\"v-301d6afa#类的属性\",\"390\":\"v-301d6afa#类的构造函数\",\"391\":\"v-301d6afa#核心函数分析\",\"392\":\"v-301d6afa#put函数\",\"393\":\"v-301d6afa#offer函数\",\"394\":\"v-301d6afa#take函数\",\"395\":\"v-301d6afa#poll函数\",\"396\":\"v-301d6afa#clear函数\",\"397\":\"v-301d6afa#参考\",\"398\":\"v-65337fdb\",\"399\":\"v-65337fdb#什么是threadlocal\",\"400\":\"v-65337fdb#threadlocal的使用示例\",\"401\":\"v-65337fdb#threadlocal原理分析\",\"402\":\"v-65337fdb#threadlocal的使用场景\",\"403\":\"v-65337fdb#threadlocal内存泄露\",\"404\":\"v-65337fdb#内存引用链路\",\"405\":\"v-65337fdb#java中的引用\",\"406\":\"v-65337fdb#泄露原因分析\",\"407\":\"v-65337fdb#inheritablethreadlocal-父子线程间的数据共享\",\"408\":\"v-65337fdb#参考\",\"409\":\"v-049841de\",\"410\":\"v-049841de#前言\",\"411\":\"v-049841de#threadpoolexecutor类图\",\"412\":\"v-049841de#threadpoolexecutor线程池的生命周期\",\"413\":\"v-049841de#threadpoolexecutor构造函数\",\"414\":\"v-049841de#corepoolsize\",\"415\":\"v-049841de#keepalivetime\",\"416\":\"v-049841de#workqueue\",\"417\":\"v-049841de#synchronousqueue\",\"418\":\"v-049841de#linkedblockingqueue\",\"419\":\"v-049841de#arrayblockingqueue\",\"420\":\"v-049841de#threadfactory\",\"421\":\"v-049841de#handler\",\"422\":\"v-049841de#线程池的工作流程\",\"423\":\"v-049841de#为什么线程池不允许使用executors去创建\",\"424\":\"v-049841de#推荐方式-1\",\"425\":\"v-049841de#推荐方式-2\",\"426\":\"v-049841de#threadpoolexecutor源码详解\",\"427\":\"v-049841de#几个关键属性\",\"428\":\"v-049841de#内部状态\",\"429\":\"v-049841de#任务的执行\",\"430\":\"v-049841de#execute-方法\",\"431\":\"v-049841de#addworker方法\",\"432\":\"v-049841de#worker类的runworker方法\",\"433\":\"v-049841de#gettask方法\",\"434\":\"v-049841de#任务的提交\",\"435\":\"v-049841de#submit方法\",\"436\":\"v-049841de#futuretask对象\",\"437\":\"v-049841de#run方法\",\"438\":\"v-049841de#任务的关闭\",\"439\":\"v-049841de#参考\",\"440\":\"v-fe3f8ca0\",\"441\":\"v-fe3f8ca0#什么是futuretask\",\"442\":\"v-fe3f8ca0#futuretask使用示例\",\"443\":\"v-fe3f8ca0#futuretask源码解析\",\"444\":\"v-fe3f8ca0#callable接口\",\"445\":\"v-fe3f8ca0#future接口\",\"446\":\"v-fe3f8ca0#futuretask\",\"447\":\"v-fe3f8ca0#核心属性\",\"448\":\"v-fe3f8ca0#run方法\",\"449\":\"v-fe3f8ca0#get方法\",\"450\":\"v-fe3f8ca0#awaitdone方法\",\"451\":\"v-fe3f8ca0#cancel方法\",\"452\":\"v-fe3f8ca0#finishcompletion方法\",\"453\":\"v-fe3f8ca0#参考\",\"454\":\"v-691e0ce0\",\"455\":\"v-691e0ce0#前言\",\"456\":\"v-691e0ce0#completablefuture介绍\",\"457\":\"v-691e0ce0#completablefuture使用示例\",\"458\":\"v-691e0ce0#completablefuture具有future的功能\",\"459\":\"v-691e0ce0#task异步完成后使用回调函数\",\"460\":\"v-691e0ce0#完成任意一个task就开始执行回调函数\",\"461\":\"v-691e0ce0#完成全部task就开始执行回调函数\",\"462\":\"v-691e0ce0#总结\",\"463\":\"v-ee339e7a\",\"464\":\"v-ee339e7a#简介\",\"465\":\"v-ee339e7a#核心模块\",\"466\":\"v-ee339e7a#forkjoinpool继承关系\",\"467\":\"v-ee339e7a#forkjointask继承关系\",\"468\":\"v-ee339e7a#使用示例\",\"469\":\"v-ee339e7a#参考\",\"470\":\"v-4d4f79fa\",\"471\":\"v-4d4f79fa#list-接口\",\"472\":\"v-4d4f79fa#set接口\",\"473\":\"v-4d4f79fa#map接口\",\"474\":\"v-4d4f79fa#总结\",\"475\":\"v-8631ab70\",\"476\":\"v-8631ab70#arraylist的类结构图\",\"477\":\"v-8631ab70#arraylist底层是如何实现的\",\"478\":\"v-8631ab70#arraylist的初始化\",\"479\":\"v-8631ab70#添加元素\",\"480\":\"v-8631ab70#扩容\",\"481\":\"v-8631ab70#删除元素\",\"482\":\"v-8631ab70#查找元素\",\"483\":\"v-8631ab70#迭代器源码解析\",\"484\":\"v-618535c6\",\"485\":\"v-618535c6#linkedlist的类结构图\",\"486\":\"v-618535c6#构造函数\",\"487\":\"v-618535c6#add-e-e-方法\",\"488\":\"v-618535c6#get-int-index-方法\",\"489\":\"v-618535c6#remove-int-index-方法\",\"490\":\"v-618535c6#总结\",\"491\":\"v-4e3cbe0a\",\"492\":\"v-4e3cbe0a#hashmap的类结构图\",\"493\":\"v-4e3cbe0a#hashmap的底层数据结构\",\"494\":\"v-4e3cbe0a#构造函数\",\"495\":\"v-4e3cbe0a#存储元素过程\",\"496\":\"v-4e3cbe0a#扩容\",\"497\":\"v-4e3cbe0a#获取元素\",\"498\":\"v-4e3cbe0a#总结\",\"499\":\"v-42225482\",\"500\":\"v-42225482#类结构图\",\"501\":\"v-42225482#底层数据结构\",\"502\":\"v-42225482#简单示例\",\"503\":\"v-42225482#源码解析\",\"504\":\"v-42225482#构造函数\",\"505\":\"v-42225482#添加元素\",\"506\":\"v-42225482#查找元素\",\"507\":\"v-42225482#删除元素\",\"508\":\"v-42225482#总结\",\"509\":\"v-4689cbba\",\"510\":\"v-4689cbba#类结构关系\",\"511\":\"v-4689cbba#bitset介绍\",\"512\":\"v-4689cbba#bitset的简单使用\",\"513\":\"v-4689cbba#使用场景\",\"514\":\"v-4689cbba#代码示例\",\"515\":\"v-4689cbba#参考\",\"516\":\"v-6ca18109\",\"517\":\"v-6ca18109#简介\",\"518\":\"v-6ca18109#io流基本类\",\"519\":\"v-6ca18109#java流类图结构\",\"520\":\"v-6ca18109#java-io流对象\",\"521\":\"v-518ce18e\",\"522\":\"v-518ce18e#简介\",\"523\":\"v-518ce18e#channel\",\"524\":\"v-518ce18e#filechannel\",\"525\":\"v-518ce18e#buffer\",\"526\":\"v-518ce18e#selector\",\"527\":\"v-518ce18e#总结\",\"528\":\"v-bb4bc3d6\",\"529\":\"v-bb4bc3d6#socketchannel介绍\",\"530\":\"v-bb4bc3d6#serversocketchannel介绍\",\"531\":\"v-bb4bc3d6#selector介绍\",\"532\":\"v-bb4bc3d6#案列介绍\",\"533\":\"v-bb4bc3d6#服务端代码\",\"534\":\"v-bb4bc3d6#客户端代码\",\"535\":\"v-bb4bc3d6#nio底层原理\",\"536\":\"v-879b283a\",\"537\":\"v-879b283a#重载与重写的区别\",\"538\":\"v-879b283a#抽象类和接口的区别\",\"539\":\"v-879b283a#为什么java不支持多继承\",\"540\":\"v-879b283a#string和stringbuffer、stringbuilder的区别是什么\",\"541\":\"v-879b283a#如何理解面向过程和面向对象\",\"542\":\"v-879b283a#java基本类型为什么需要包装类\",\"543\":\"v-879b283a#如何理解java中的多态\",\"544\":\"v-e4b894f2\",\"545\":\"v-e4b894f2#和-equals-的区别\",\"546\":\"v-e4b894f2#关系操作符号\",\"547\":\"v-e4b894f2#equals\",\"548\":\"v-e4b894f2#equals-和hashcode的关系\",\"549\":\"v-e4b894f2#java中的异常处理机制\",\"550\":\"v-e4b894f2#jdk、jre、jvm的区别和联系\",\"551\":\"v-9e8a134a\",\"552\":\"v-9e8a134a#final关键字的基本用法\",\"553\":\"v-9e8a134a#为什么内部类引用的外部变量必须用final修饰\",\"554\":\"v-9e8a134a#谈谈final、finally、finalize的区别\",\"555\":\"v-9e8a134a#finally语句到底是在return之前还是之后执行\",\"556\":\"v-10a19d78\",\"557\":\"v-10a19d78#谈谈final、finally、finalize的区别\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[1],\"4\":[1],\"5\":[1],\"6\":[1],\"7\":[1],\"8\":[1],\"9\":[2],\"10\":[1],\"11\":[1],\"12\":[1],\"13\":[1],\"14\":[1],\"15\":[1],\"16\":[1],\"17\":[1],\"18\":[4],\"19\":[4],\"20\":[4],\"21\":[1],\"22\":[4],\"23\":[4],\"24\":[1],\"25\":[1],\"26\":[1],\"27\":[1],\"28\":[1],\"29\":[1],\"30\":[1],\"31\":[1],\"32\":[2],\"33\":[1],\"34\":[1],\"35\":[1],\"36\":[1],\"37\":[1],\"38\":[1],\"39\":[1],\"40\":[1],\"41\":[1],\"42\":[1],\"43\":[1],\"44\":[1],\"45\":[1],\"46\":[1],\"47\":[1],\"48\":[1],\"49\":[1],\"50\":[1],\"51\":[1],\"52\":[1],\"53\":[1],\"54\":[1],\"55\":[1],\"56\":[2],\"57\":[1],\"58\":[1],\"59\":[2],\"60\":[1],\"61\":[3],\"62\":[1],\"63\":[1],\"64\":[1],\"65\":[2],\"66\":[2],\"67\":[1],\"68\":[1],\"69\":[1],\"70\":[1],\"71\":[2],\"72\":[1],\"73\":[1],\"74\":[2],\"75\":[2],\"76\":[1],\"77\":[1],\"78\":[1],\"79\":[1],\"80\":[2],\"81\":[1],\"82\":[1],\"83\":[1],\"84\":[1],\"85\":[1],\"86\":[1],\"87\":[1],\"88\":[1],\"89\":[2],\"90\":[2],\"91\":[1],\"92\":[1],\"93\":[1],\"94\":[1],\"95\":[1],\"96\":[1],\"97\":[3],\"98\":[2],\"99\":[1],\"100\":[2],\"101\":[1],\"102\":[2],\"103\":[6],\"104\":[1],\"105\":[1],\"106\":[1],\"107\":[1],\"108\":[1],\"109\":[1],\"110\":[2],\"111\":[4],\"112\":[4],\"113\":[2],\"114\":[2],\"115\":[1],\"116\":[1],\"117\":[3],\"118\":[1],\"119\":[1],\"120\":[1],\"121\":[1],\"122\":[1],\"123\":[1],\"124\":[2],\"125\":[2],\"126\":[1],\"127\":[1],\"128\":[1],\"129\":[1],\"130\":[1],\"131\":[1],\"132\":[1],\"133\":[5],\"134\":[1],\"135\":[2],\"136\":[1],\"137\":[1],\"138\":[2],\"139\":[1],\"140\":[1],\"141\":[1],\"142\":[2],\"143\":[1],\"144\":[1],\"145\":[1],\"146\":[2],\"147\":[1],\"148\":[1],\"149\":[1],\"150\":[2],\"151\":[1],\"152\":[1],\"153\":[2],\"154\":[2],\"155\":[4],\"156\":[2],\"157\":[2],\"158\":[4],\"159\":[2],\"160\":[2],\"161\":[2],\"162\":[2],\"163\":[2],\"164\":[1],\"165\":[1],\"166\":[2],\"167\":[1],\"168\":[1],\"169\":[2],\"170\":[2],\"171\":[2],\"172\":[2],\"173\":[1],\"174\":[1],\"175\":[2],\"176\":[2],\"177\":[1],\"178\":[1],\"179\":[1],\"180\":[1],\"181\":[1],\"182\":[1],\"183\":[1],\"184\":[1],\"185\":[1],\"186\":[1],\"187\":[1],\"188\":[2],\"189\":[1],\"190\":[1],\"191\":[1],\"192\":[1],\"193\":[2],\"194\":[1],\"195\":[2],\"196\":[1],\"197\":[1],\"198\":[1],\"199\":[1],\"200\":[5],\"201\":[5],\"202\":[2],\"203\":[1],\"204\":[1],\"205\":[1],\"206\":[1],\"207\":[3],\"208\":[3],\"209\":[1],\"210\":[1],\"211\":[1],\"212\":[1],\"213\":[1],\"214\":[1],\"215\":[1],\"216\":[5],\"217\":[2],\"218\":[1],\"219\":[1],\"220\":[1],\"221\":[1],\"222\":[1],\"223\":[1],\"224\":[1],\"225\":[1],\"226\":[1],\"227\":[1],\"228\":[1],\"229\":[1],\"230\":[1],\"231\":[3],\"232\":[2],\"233\":[2],\"234\":[1],\"235\":[1],\"236\":[3],\"237\":[3],\"238\":[1],\"239\":[1],\"240\":[1],\"241\":[1],\"242\":[1],\"243\":[1],\"244\":[1],\"245\":[1],\"246\":[1],\"247\":[1],\"248\":[1],\"249\":[1],\"250\":[1],\"251\":[1],\"252\":[1],\"253\":[1],\"254\":[1],\"255\":[3],\"256\":[1],\"257\":[1],\"258\":[1],\"259\":[1],\"260\":[1],\"261\":[1],\"262\":[1],\"263\":[2],\"264\":[1],\"265\":[1],\"266\":[1],\"267\":[1],\"268\":[1],\"269\":[1],\"270\":[1],\"271\":[1],\"272\":[1],\"273\":[2],\"274\":[1],\"275\":[3],\"276\":[1],\"277\":[1],\"278\":[1],\"279\":[1],\"280\":[1],\"281\":[1],\"282\":[1],\"283\":[2],\"284\":[1],\"285\":[1],\"286\":[1],\"287\":[1],\"288\":[1],\"289\":[1],\"290\":[1],\"291\":[1],\"292\":[1],\"293\":[1],\"294\":[1],\"295\":[1],\"296\":[1],\"297\":[1],\"298\":[1],\"299\":[1],\"300\":[1],\"301\":[1],\"302\":[1],\"303\":[1],\"304\":[1],\"305\":[1],\"306\":[1],\"307\":[1],\"308\":[1],\"309\":[1],\"310\":[1],\"311\":[1],\"312\":[1],\"313\":[1],\"314\":[1],\"315\":[1],\"316\":[1],\"317\":[1],\"318\":[1],\"319\":[1],\"320\":[1],\"321\":[1],\"322\":[1],\"323\":[1],\"324\":[1],\"325\":[1],\"326\":[1],\"327\":[1],\"328\":[1],\"329\":[4],\"330\":[3],\"331\":[1],\"332\":[1],\"333\":[1],\"334\":[1],\"335\":[1],\"336\":[1],\"337\":[1],\"338\":[1],\"339\":[1],\"340\":[1],\"341\":[1],\"342\":[1],\"343\":[1],\"344\":[1],\"345\":[1],\"346\":[1],\"347\":[1],\"348\":[1],\"349\":[1],\"350\":[1],\"351\":[1],\"352\":[1],\"353\":[1],\"354\":[1],\"355\":[1],\"356\":[1],\"357\":[1],\"358\":[1],\"359\":[1],\"360\":[1],\"361\":[1],\"362\":[1],\"363\":[1],\"364\":[2],\"365\":[2],\"366\":[1],\"367\":[1],\"368\":[1],\"369\":[1],\"370\":[1],\"371\":[1],\"372\":[1],\"373\":[1],\"374\":[1],\"375\":[1],\"376\":[1],\"377\":[1],\"378\":[1],\"379\":[1],\"380\":[1],\"381\":[1],\"382\":[1],\"383\":[1],\"384\":[1],\"385\":[1],\"386\":[1],\"387\":[1],\"388\":[1],\"389\":[1],\"390\":[1],\"391\":[1],\"392\":[1],\"393\":[1],\"394\":[1],\"395\":[1],\"396\":[1],\"397\":[1],\"398\":[1],\"399\":[1],\"400\":[1],\"401\":[1],\"402\":[1],\"403\":[1],\"404\":[1],\"405\":[1],\"406\":[1],\"407\":[2],\"408\":[1],\"409\":[2],\"410\":[1],\"411\":[1],\"412\":[1],\"413\":[1],\"414\":[1],\"415\":[1],\"416\":[1],\"417\":[1],\"418\":[1],\"419\":[1],\"420\":[1],\"421\":[1],\"422\":[1],\"423\":[2],\"424\":[2],\"425\":[2],\"426\":[1],\"427\":[1],\"428\":[1],\"429\":[1],\"430\":[2],\"431\":[1],\"432\":[1],\"433\":[1],\"434\":[1],\"435\":[1],\"436\":[1],\"437\":[1],\"438\":[1],\"439\":[1],\"440\":[1],\"441\":[1],\"442\":[1],\"443\":[1],\"444\":[1],\"445\":[1],\"446\":[1],\"447\":[1],\"448\":[1],\"449\":[1],\"450\":[1],\"451\":[1],\"452\":[1],\"453\":[1],\"454\":[1],\"455\":[1],\"456\":[1],\"457\":[1],\"458\":[1],\"459\":[1],\"460\":[1],\"461\":[1],\"462\":[1],\"463\":[2],\"464\":[1],\"465\":[1],\"466\":[1],\"467\":[1],\"468\":[1],\"469\":[1],\"470\":[2],\"471\":[2],\"472\":[1],\"473\":[1],\"474\":[1],\"475\":[1],\"476\":[1],\"477\":[2],\"478\":[1],\"479\":[1],\"480\":[1],\"481\":[1],\"482\":[1],\"483\":[1],\"484\":[1],\"485\":[1],\"486\":[1],\"487\":[4],\"488\":[4],\"489\":[4],\"490\":[1],\"491\":[1],\"492\":[1],\"493\":[1],\"494\":[1],\"495\":[1],\"496\":[1],\"497\":[1],\"498\":[1],\"499\":[1],\"500\":[1],\"501\":[1],\"502\":[1],\"503\":[1],\"504\":[1],\"505\":[1],\"506\":[1],\"507\":[1],\"508\":[1],\"509\":[1],\"510\":[1],\"511\":[1],\"512\":[1],\"513\":[1],\"514\":[1],\"515\":[1],\"516\":[2],\"517\":[1],\"518\":[1],\"519\":[1],\"520\":[2],\"521\":[2],\"522\":[1],\"523\":[1],\"524\":[1],\"525\":[1],\"526\":[1],\"527\":[1],\"528\":[2],\"529\":[1],\"530\":[1],\"531\":[1],\"532\":[1],\"533\":[1],\"534\":[1],\"535\":[1],\"536\":[1],\"537\":[1],\"538\":[1],\"539\":[1],\"540\":[2],\"541\":[1],\"542\":[1],\"543\":[1],\"544\":[1],\"545\":[5],\"546\":[3],\"547\":[2],\"548\":[3],\"549\":[1],\"550\":[3],\"551\":[1],\"552\":[1],\"553\":[1],\"554\":[3],\"555\":[2],\"556\":[1],\"557\":[3]},\"averageFieldLength\":[1.2974910394265236],\"storedFields\":{\"0\":{\"h\":\"个人生活文章\"},\"1\":{\"h\":\"更新计划\"},\"2\":{\"h\":\"更新计划\"},\"3\":{\"h\":\"幻灯片页\"},\"4\":{\"h\":\"指南\"},\"5\":{\"h\":\"功能亮点\"},\"6\":{\"h\":\"Bar\"},\"7\":{\"h\":\"Foo\"},\"8\":{\"h\":\"设计模式面试概述\"},\"9\":{\"h\":\"设计模式有哪些类型？\"},\"10\":{\"h\":\"创建型模式\"},\"11\":{\"h\":\"结构型模式\"},\"12\":{\"h\":\"行为型模式\"},\"13\":{\"h\":\"面试过程中常问的设计模式\"},\"14\":{\"h\":\"设计模式的几种原则\"},\"15\":{\"h\":\"单例模式\"},\"16\":{\"h\":\"什么是单例模式\"},\"17\":{\"h\":\"单例模式的实现\"},\"18\":{\"h\":\"饿汉模式（线程安全，推荐）\"},\"19\":{\"h\":\"双重检查（线程安全，推荐）\"},\"20\":{\"h\":\"使用内部类模式（线程安全，推荐）\"},\"21\":{\"h\":\"其他\"},\"22\":{\"h\":\"懒汉模式（线程不安全，不推荐）\"},\"23\":{\"h\":\"懒汉模式（线程不安全，不推荐）\"},\"24\":{\"h\":\"源码下载\"},\"25\":{\"h\":\"适配器模式\"},\"26\":{\"h\":\"代码实现\"},\"27\":{\"h\":\"使用适配器模式有什么收益\"},\"28\":{\"h\":\"源码下载\"},\"29\":{\"h\":\"装饰器模式\"},\"30\":{\"h\":\"UML图\"},\"31\":{\"h\":\"使用案例\"},\"32\":{\"h\":\"为什么要使用装饰器模式？\"},\"33\":{\"h\":\"源码下载\"},\"34\":{\"h\":\"责任链模式\"},\"35\":{\"h\":\"责任链模式的UML图\"},\"36\":{\"h\":\"案例实战\"},\"37\":{\"h\":\"为什么要使用责任链模式\"},\"38\":{\"h\":\"工厂模式\"},\"39\":{\"h\":\"简单工厂\"},\"40\":{\"h\":\"UML图\"},\"41\":{\"h\":\"代码实现\"},\"42\":{\"h\":\"工厂方法模式\"},\"43\":{\"h\":\"UML图\"},\"44\":{\"h\":\"代码实现\"},\"45\":{\"h\":\"抽象工厂\"},\"46\":{\"h\":\"UML图\"},\"47\":{\"h\":\"代码实现\"},\"48\":{\"h\":\"观察者模式\"},\"49\":{\"h\":\"观察者模式UML图\"},\"50\":{\"h\":\"案例实战\"},\"51\":{\"h\":\"为什么要使用观察者模式\"},\"52\":{\"h\":\"代理模式\"},\"53\":{\"h\":\"静态代理\"},\"54\":{\"h\":\"代码实现\"},\"55\":{\"h\":\"动态代理\"},\"56\":{\"h\":\"Java 动态代理\"},\"57\":{\"h\":\"CGLIB代码\"},\"58\":{\"h\":\"请介绍一下Mysql的架构\"},\"59\":{\"h\":\"什么是Mysql的读写分离；以及实现读写分离的几种方式\"},\"60\":{\"h\":\"什么是Mysql的读写分离\"},\"61\":{\"h\":\"实现 MySQL 的读写分离的几种方式\"},\"62\":{\"h\":\"MySQL主从复制的过程\"},\"63\":{\"h\":\"MySQL主从复制的过程\"},\"64\":{\"h\":\"扩展阅读\"},\"65\":{\"h\":\"主从复制的一致性是怎么保证的？\"},\"66\":{\"h\":\"什么是binlog？\"},\"67\":{\"h\":\"Mysql主从同步的延迟原因和解决办法\"},\"68\":{\"h\":\"MySQL主从复制的过程\"},\"69\":{\"h\":\"MySQL主从同步的延迟主要原因\"},\"70\":{\"h\":\"解决办法\"},\"71\":{\"h\":\"什么是存储过程，为什么不推荐使用存储过程\"},\"72\":{\"h\":\"什么是存储过程\"},\"73\":{\"h\":\"为什么不推荐使用存储过程\"},\"74\":{\"h\":\"什么是数据库的范式？\"},\"75\":{\"h\":\"什么是数据库的范式？\"},\"76\":{\"h\":\"第一范式\"},\"77\":{\"h\":\"第二范式\"},\"78\":{\"h\":\"第三范式\"},\"79\":{\"h\":\"反范式\"},\"80\":{\"h\":\"设计数据库表字段的时候应该遵循哪些规则？\"},\"81\":{\"h\":\"命名规范\"},\"82\":{\"h\":\"选择合适的数据类型\"},\"83\":{\"h\":\"设置合适的字段长度\"},\"84\":{\"h\":\"选择合适的精度\"},\"85\":{\"h\":\"合理建立的约束\"},\"86\":{\"h\":\"避免在表中存储重复或冗余的数据\"},\"87\":{\"h\":\"合理的建立索引\"},\"88\":{\"h\":\"遵循数据库设计范式的原则\"},\"89\":{\"h\":\"禁止使用foreign key\"},\"90\":{\"h\":\"表字段不能超过100个，字段的总大小没有特殊原因不要超过8K\"},\"91\":{\"h\":\"char和varchar的区别\"},\"92\":{\"h\":\"Mysql综合练习题\"},\"93\":{\"h\":\"Mysql综合练习题\"},\"94\":{\"h\":\"创建表\"},\"95\":{\"h\":\"插入数据\"},\"96\":{\"h\":\"查询学生表中的所有记录\"},\"97\":{\"h\":\"查询 student表中2-4条记录\"},\"98\":{\"h\":\"查询student学生的学号、姓名和院校信息\"},\"99\":{\"h\":\"查询计算机系和英语系的学生的信息的两种方法\"},\"100\":{\"h\":\"查询年龄为18-22岁的学生\"},\"101\":{\"h\":\"student表中查询每个院系有多少人\"},\"102\":{\"h\":\"从score 表中查询每个科目的最高分\"},\"103\":{\"h\":\"查询李四的考试科目（c_name)和考试成绩(grade).\"},\"104\":{\"h\":\"用连接查询的方式查询所有学生的信息和考试成绩\"},\"105\":{\"h\":\"计算每个学生的总成绩\"},\"106\":{\"h\":\"计算每个考试科目的平均成绩\"},\"107\":{\"h\":\"查询计算机成绩低于95分的学生成绩\"},\"108\":{\"h\":\"查询同时参加计算机和英语考试的学生信息\"},\"109\":{\"h\":\"将计算机成绩按从高到低进行排序\"},\"110\":{\"h\":\"从student表和score 表中查询出学号然后合并查询结果\"},\"111\":{\"h\":\"查询姓张和姓王的同学的姓名、院系、考试科目和成绩。\"},\"112\":{\"h\":\"查询都是湖南的同学的姓名、年龄、院系、考试科目和成绩\"},\"113\":{\"h\":\"mysql有哪些存储引擎?常见的两种存储引擎介绍\"},\"114\":{\"h\":\"Mysql的存储引擎有哪些？\"},\"115\":{\"h\":\"InnoDB存储引擎介绍\"},\"116\":{\"h\":\"MyISAM存储引擎介绍\"},\"117\":{\"h\":\"怎么优雅的选择 MySQL 存储引擎\"},\"118\":{\"h\":\"innodb和myisam引擎的区别\"},\"119\":{\"h\":\"Inndb存储引擎支持哪些索引\"},\"120\":{\"h\":\"什么是数据库索引\"},\"121\":{\"h\":\"innodb存储引擎支持哪些索引\"},\"122\":{\"h\":\"创建索引示例\"},\"123\":{\"h\":\"主键索引和唯一索引的区别\"},\"124\":{\"h\":\"唯一索引是怎么实现的？\"},\"125\":{\"h\":\"设计索引时应遵循什么规范？\"},\"126\":{\"h\":\"根据查询条件设计索引\"},\"127\":{\"h\":\"选择合适的索引列\"},\"128\":{\"h\":\"使用联合索引\"},\"129\":{\"h\":\"避免过度索引\"},\"130\":{\"h\":\"定期优化和维护索引\"},\"131\":{\"h\":\"考虑查询性能和写入性能的平衡\"},\"132\":{\"h\":\"注意索引的数据类型和长度\"},\"133\":{\"h\":\"尽量为ORDER BY 和 GROUP BY 后面的字段建立索引\"},\"134\":{\"h\":\"主建索引尽量使用自增的\"},\"135\":{\"h\":\"innodb为什么使用B+实现索引？\"},\"136\":{\"h\":\"什么是B+树\"},\"137\":{\"h\":\"为什么使用B+树来实现索引\"},\"138\":{\"h\":\"谈谈你对哈希索引的理解？\"},\"139\":{\"h\":\"什么是哈希索引\"},\"140\":{\"h\":\"具有什么特点\"},\"141\":{\"h\":\"适用场景\"},\"142\":{\"h\":\"什么是聚族索引？\"},\"143\":{\"h\":\"什么是聚簇索引\"},\"144\":{\"h\":\"什么是非聚簇索引\"},\"145\":{\"h\":\"总结\"},\"146\":{\"h\":\"什么是Mysql的回表？\"},\"147\":{\"h\":\"什么是Mysql的回表\"},\"148\":{\"h\":\"示例\"},\"149\":{\"h\":\"怎么避免\"},\"150\":{\"h\":\"什么情况下会导致索引失效？\"},\"151\":{\"h\":\"数据准备\"},\"152\":{\"h\":\"索引失效的几种情况\"},\"153\":{\"h\":\"1.使用like操作符\"},\"154\":{\"h\":\"2.联合索引不满足列的最左匹配原则\"},\"155\":{\"h\":\"3.**使用了select * from **\"},\"156\":{\"h\":\"4.查询条件中使用了函数或者运算\"},\"157\":{\"h\":\"5. 类型进行了隐式转换\"},\"158\":{\"h\":\"6.order by 在某些情况下会导致索引失效\"},\"159\":{\"h\":\"7.使用了两列比较\"},\"160\":{\"h\":\"8.使用or操作\"},\"161\":{\"h\":\"9.Mysql会根据数据量而决定走不走索引\"},\"162\":{\"h\":\"10.还有一些可能导致索引失效的场景\"},\"163\":{\"h\":\"谈谈你对索引最最左匹配原则的理解？\"},\"164\":{\"h\":\"数据准备\"},\"165\":{\"h\":\"联合索引使用示例\"},\"166\":{\"h\":\"索引生效情况：\"},\"167\":{\"h\":\"索引失效的情况\"},\"168\":{\"h\":\"总结\"},\"169\":{\"h\":\"为什么阿里巴巴不推荐使用外键？\"},\"170\":{\"h\":\"什么是Mysql事务？\"},\"171\":{\"h\":\"说说InnoDB存储引擎的事务提交过程？\"},\"172\":{\"h\":\"什么是事务的两阶段提交？\"},\"173\":{\"h\":\"什么是事务的两阶段提交\"},\"174\":{\"h\":\"什么是Mysql的事务两阶段提交\"},\"175\":{\"h\":\"两阶段写日志有什么作用？\"},\"176\":{\"h\":\"请你说说事务的特性？\"},\"177\":{\"h\":\"概览\"},\"178\":{\"h\":\"Prometheus教程介绍\"},\"179\":{\"h\":\"Prometheus概述\"},\"180\":{\"h\":\"什么是Prometheus\"},\"181\":{\"h\":\"Prometheus提供的特性\"},\"182\":{\"h\":\"组件\"},\"183\":{\"h\":\"架构\"},\"184\":{\"h\":\"prometheus适用的场景\"},\"185\":{\"h\":\"Prometheus环境搭建\"},\"186\":{\"h\":\"安装prometheus\"},\"187\":{\"h\":\"prometheus配置文件讲解\"},\"188\":{\"h\":\"采集Node Exporter的指标\"},\"189\":{\"h\":\"prometheus配置文件热更新\"},\"190\":{\"h\":\"grafana安装\"},\"191\":{\"h\":\"总结\"},\"192\":{\"h\":\"Prometheus的数据模型\"},\"193\":{\"h\":\"什么是time-series\"},\"194\":{\"h\":\"指标的类型\"},\"195\":{\"h\":\"Counter 累加器\"},\"196\":{\"h\":\"Gauge仪表盘\"},\"197\":{\"h\":\"Histogram直方图\"},\"198\":{\"h\":\"summary\"},\"199\":{\"h\":\"Promql快速入门\"},\"200\":{\"h\":\"瞬时向量查询（Instant vector selectors）\"},\"201\":{\"h\":\"范围向量查询（Range Vector Selectors）\"},\"202\":{\"h\":\"offset 时间位移操作\"},\"203\":{\"h\":\"操作符\"},\"204\":{\"h\":\"数学操作符\"},\"205\":{\"h\":\"比较操作符\"},\"206\":{\"h\":\"逻辑运算符\"},\"207\":{\"h\":\"向量匹配符号 Vector matching\"},\"208\":{\"h\":\"分组修改器 Group modifiers\"},\"209\":{\"h\":\"聚合函数\"},\"210\":{\"h\":\"其他常见的函数\"},\"211\":{\"h\":\"计算counter的增长率\"},\"212\":{\"h\":\"预测指标变化趋势\"},\"213\":{\"h\":\"计算分位数\"},\"214\":{\"h\":\"总结\"},\"215\":{\"h\":\"在SpringBoot项目中使用Prometheus监控\"},\"216\":{\"h\":\"方案一：使用spring-boot-starter-actuator\"},\"217\":{\"h\":\"方案二：使用Prometheus\"},\"218\":{\"h\":\"配置Prometheus采集\"},\"219\":{\"h\":\"配置grafana视图\"},\"220\":{\"h\":\"Prometheus告警与Alertmanager实战\"},\"221\":{\"h\":\"Alertmanager介绍\"},\"222\":{\"h\":\"分组\"},\"223\":{\"h\":\"抑制\"},\"224\":{\"h\":\"静默\"},\"225\":{\"h\":\"Alertmanager安装\"},\"226\":{\"h\":\"配置讲解\"},\"227\":{\"h\":\"在prometheus中配置告警规则\"},\"228\":{\"h\":\"Alertmanager查看告警消息\"},\"229\":{\"h\":\"webhook\"},\"230\":{\"h\":\"参考文档\"},\"231\":{\"h\":\"Prometheus预处理计算-Recording Rule\"},\"232\":{\"h\":\"定义Recoding rules\"},\"233\":{\"h\":\"recording rule的最佳实践\"},\"234\":{\"h\":\"命名规范\"},\"235\":{\"h\":\"实战\"},\"236\":{\"h\":\"理解可见性、原子性、有序性\"},\"237\":{\"h\":\"为什么会有可见性、原子性、有序性的问题\"},\"238\":{\"h\":\"缓存导致的可见性问题\"},\"239\":{\"h\":\"线程切换带来的原子问题\"},\"240\":{\"h\":\"编译优化带来的有序性问题\"},\"241\":{\"h\":\"总结\"},\"242\":{\"h\":\"Java内存模式以及volatile详解\"},\"243\":{\"h\":\"Java内存模型\"},\"244\":{\"h\":\"编发编程的概念\"},\"245\":{\"h\":\"原子性\"},\"246\":{\"h\":\"可见性\"},\"247\":{\"h\":\"有序性\"},\"248\":{\"h\":\"volatile详解\"},\"249\":{\"h\":\"volatile关键字作用\"},\"250\":{\"h\":\"volatile能够保证可见性和防止指令重排\"},\"251\":{\"h\":\"volatile不能保证原子性\"},\"252\":{\"h\":\"volatile的使用场景\"},\"253\":{\"h\":\"状态标记\"},\"254\":{\"h\":\"防止指令重排\"},\"255\":{\"h\":\"Happens-Before 规则\"},\"256\":{\"h\":\"参考资料\"},\"257\":{\"h\":\"Java死锁详解\"},\"258\":{\"h\":\"Java死锁示例\"},\"259\":{\"h\":\"死锁发生的条件\"},\"260\":{\"h\":\"如何避免死锁\"},\"261\":{\"h\":\"破坏占有且等待\"},\"262\":{\"h\":\"破坏循环等待条件\"},\"263\":{\"h\":\"Java synchronized关键字详解\"},\"264\":{\"h\":\"synchronized关键字的作用\"},\"265\":{\"h\":\"使用示例\"},\"266\":{\"h\":\"Synchronized原理\"},\"267\":{\"h\":\"synchronized优化\"},\"268\":{\"h\":\"对象头\"},\"269\":{\"h\":\"偏向锁\"},\"270\":{\"h\":\"轻量级锁\"},\"271\":{\"h\":\"重量级锁\"},\"272\":{\"h\":\"synchronized的优化一览表\"},\"273\":{\"h\":\"Thread状态、使用详解\"},\"274\":{\"h\":\"Thread状态\"},\"275\":{\"h\":\"New（新建状态）\"},\"276\":{\"h\":\"Runnable\"},\"277\":{\"h\":\"blocked\"},\"278\":{\"h\":\"wait\"},\"279\":{\"h\":\"两个线程交替打印奇数和偶数\"},\"280\":{\"h\":\"Java并发技术AQS详解\"},\"281\":{\"h\":\"AQS简介\"},\"282\":{\"h\":\"AQS核心思想\"},\"283\":{\"h\":\"AQS 对资源的共享方式\"},\"284\":{\"h\":\"AQS源码解析\"},\"285\":{\"h\":\"类的继承关系\"},\"286\":{\"h\":\"类的内部类\"},\"287\":{\"h\":\"Node类\"},\"288\":{\"h\":\"ConditionObject类\"},\"289\":{\"h\":\"类的属性\"},\"290\":{\"h\":\"类的构造函数\"},\"291\":{\"h\":\"类的核心函数\"},\"292\":{\"h\":\"acquire函数\"},\"293\":{\"h\":\"release\"},\"294\":{\"h\":\"手写一个AQS\"},\"295\":{\"h\":\"参考资料\"},\"296\":{\"h\":\"ReentrantLock源码解析\"},\"297\":{\"h\":\"ReentrantLock数据结构\"},\"298\":{\"h\":\"ReentrantLock类继承关系\"},\"299\":{\"h\":\"类的属性\"},\"300\":{\"h\":\"类的构造函数\"},\"301\":{\"h\":\"类的内部类\"},\"302\":{\"h\":\"Sync类\"},\"303\":{\"h\":\"NonfairSync类\"},\"304\":{\"h\":\"FairSyn类\"},\"305\":{\"h\":\"ReentrantLock在Dubbo中的使用\"},\"306\":{\"h\":\"ReentrantLock使用示例\"},\"307\":{\"h\":\"ReentrantLock的特点总结\"},\"308\":{\"h\":\"CountDownLatch源码解析\"},\"309\":{\"h\":\"CountDownLatch简介\"},\"310\":{\"h\":\"CountDownLatch使用示例\"},\"311\":{\"h\":\"CountDownLatch源码解析\"},\"312\":{\"h\":\"CountDownLatch数据结构\"},\"313\":{\"h\":\"类的继承关系\"},\"314\":{\"h\":\"类的属性\"},\"315\":{\"h\":\"类的构造函数\"},\"316\":{\"h\":\"类的内部类\"},\"317\":{\"h\":\"await函数\"},\"318\":{\"h\":\"countDown函数\"},\"319\":{\"h\":\"参考文档\"},\"320\":{\"h\":\"CyclicBarrier源码解析\"},\"321\":{\"h\":\"CyclicBarrier简介\"},\"322\":{\"h\":\"CyclicBarrier使用示例\"},\"323\":{\"h\":\"CyclicBarrier源码解析\"},\"324\":{\"h\":\"CyclicBarrier数据结构\"},\"325\":{\"h\":\"类的继承关系\"},\"326\":{\"h\":\"类的内部类\"},\"327\":{\"h\":\"类的属性\"},\"328\":{\"h\":\"类的构造函数\"},\"329\":{\"h\":\"CyclicBarrier(int, Runnable)型构造函数\"},\"330\":{\"h\":\"CyclicBarrier(int)型构造函数\"},\"331\":{\"h\":\"核心函数分析\"},\"332\":{\"h\":\"dowait函数\"},\"333\":{\"h\":\"nextGeneration函数\"},\"334\":{\"h\":\"breakBarrier函数\"},\"335\":{\"h\":\"参考\"},\"336\":{\"h\":\"并发包里的锁总结\"},\"337\":{\"h\":\"并发包的锁\"},\"338\":{\"h\":\"ReentrantLock\"},\"339\":{\"h\":\"ReadWriteLock\"},\"340\":{\"h\":\"StampedLock\"},\"341\":{\"h\":\"并发容器详解\"},\"342\":{\"h\":\"List\"},\"343\":{\"h\":\"Map\"},\"344\":{\"h\":\"Set\"},\"345\":{\"h\":\"Queue\"},\"346\":{\"h\":\"总结\"},\"347\":{\"h\":\"CopyOnWriteArrayList源码解析\"},\"348\":{\"h\":\"CopyOnWriteArrayList介绍\"},\"349\":{\"h\":\"CopyOnWriteArrayList使用示例\"},\"350\":{\"h\":\"CopyOnWriteArrayList源码解析\"},\"351\":{\"h\":\"类的继承关系\"},\"352\":{\"h\":\"类的属性\"},\"353\":{\"h\":\"类的构造函数\"},\"354\":{\"h\":\"类的内部类\"},\"355\":{\"h\":\"核心函数分析\"},\"356\":{\"h\":\"copyOf函数\"},\"357\":{\"h\":\"add函数\"},\"358\":{\"h\":\"addIfAbsent\"},\"359\":{\"h\":\"set函数\"},\"360\":{\"h\":\"remove函数\"},\"361\":{\"h\":\"总结\"},\"362\":{\"h\":\"ConcurrentHashMap源码解析\"},\"363\":{\"h\":\"ConcurrentHashMap介绍\"},\"364\":{\"h\":\"Java7 基于分段锁的ConcurrentHashMap\"},\"365\":{\"h\":\"Java 8基于CAS的ConcurrentHashMap\"},\"366\":{\"h\":\"ConcurrentHashMap使用示例\"},\"367\":{\"h\":\"ConcurrentHashMap源码解析\"},\"368\":{\"h\":\"类的继承关系\"},\"369\":{\"h\":\"类的内部类\"},\"370\":{\"h\":\"Node类\"},\"371\":{\"h\":\"Traverser类\"},\"372\":{\"h\":\"CollectionView类\"},\"373\":{\"h\":\"Segment类\"},\"374\":{\"h\":\"CounterCell\"},\"375\":{\"h\":\"类的属性\"},\"376\":{\"h\":\"类的构造函数\"},\"377\":{\"h\":\"核心函数分析\"},\"378\":{\"h\":\"putVal函数\"},\"379\":{\"h\":\"get函数\"},\"380\":{\"h\":\"replaceNode函数\"},\"381\":{\"h\":\"参考\"},\"382\":{\"h\":\"BlockingQueue详解\"},\"383\":{\"h\":\"什么是BlockingQueue\"},\"384\":{\"h\":\"BlockingQueue接口定义\"},\"385\":{\"h\":\"BlockingQueue实现\"},\"386\":{\"h\":\"ArrayBlockingQueue使用介绍\"},\"387\":{\"h\":\"ArrayBlockingQueue源码实现\"},\"388\":{\"h\":\"类的继承关系\"},\"389\":{\"h\":\"类的属性\"},\"390\":{\"h\":\"类的构造函数\"},\"391\":{\"h\":\"核心函数分析\"},\"392\":{\"h\":\"put函数\"},\"393\":{\"h\":\"offer函数\"},\"394\":{\"h\":\"take函数\"},\"395\":{\"h\":\"poll函数\"},\"396\":{\"h\":\"clear函数\"},\"397\":{\"h\":\"参考\"},\"398\":{\"h\":\"ThreadLocal详解\"},\"399\":{\"h\":\"什么是ThreadLocal\"},\"400\":{\"h\":\"ThreadLocal的使用示例\"},\"401\":{\"h\":\"ThreadLocal原理分析\"},\"402\":{\"h\":\"ThreadLocal的使用场景\"},\"403\":{\"h\":\"ThreadLocal内存泄露\"},\"404\":{\"h\":\"内存引用链路\"},\"405\":{\"h\":\"Java中的引用\"},\"406\":{\"h\":\"泄露原因分析\"},\"407\":{\"h\":\"InheritableThreadLocal 父子线程间的数据共享\"},\"408\":{\"h\":\"参考\"},\"409\":{\"h\":\"JAVA并发包的线程池:ThreadPoolExecutor详解\"},\"410\":{\"h\":\"前言\"},\"411\":{\"h\":\"ThreadPoolExecutor类图\"},\"412\":{\"h\":\"ThreadPoolExecutor线程池的生命周期\"},\"413\":{\"h\":\"ThreadPoolExecutor构造函数\"},\"414\":{\"h\":\"corePoolSize\"},\"415\":{\"h\":\"keepAliveTime\"},\"416\":{\"h\":\"workQueue\"},\"417\":{\"h\":\"SynchronousQueue\"},\"418\":{\"h\":\"LinkedBlockingQueue\"},\"419\":{\"h\":\"ArrayBlockingQueue\"},\"420\":{\"h\":\"threadFactory\"},\"421\":{\"h\":\"handler\"},\"422\":{\"h\":\"线程池的工作流程\"},\"423\":{\"h\":\"为什么线程池不允许使用Executors去创建?\"},\"424\":{\"h\":\"推荐方式 1\"},\"425\":{\"h\":\"推荐方式 2\"},\"426\":{\"h\":\"ThreadPoolExecutor源码详解\"},\"427\":{\"h\":\"几个关键属性\"},\"428\":{\"h\":\"内部状态\"},\"429\":{\"h\":\"任务的执行\"},\"430\":{\"h\":\"execute()方法\"},\"431\":{\"h\":\"addWorker方法\"},\"432\":{\"h\":\"Worker类的runworker方法\"},\"433\":{\"h\":\"getTask方法\"},\"434\":{\"h\":\"任务的提交\"},\"435\":{\"h\":\"submit方法\"},\"436\":{\"h\":\"FutureTask对象\"},\"437\":{\"h\":\"run方法\"},\"438\":{\"h\":\"任务的关闭\"},\"439\":{\"h\":\"参考\"},\"440\":{\"h\":\"FutureTask详解\"},\"441\":{\"h\":\"什么是FutureTask\"},\"442\":{\"h\":\"FutureTask使用示例\"},\"443\":{\"h\":\"FutureTask源码解析\"},\"444\":{\"h\":\"Callable接口\"},\"445\":{\"h\":\"Future接口\"},\"446\":{\"h\":\"FutureTask\"},\"447\":{\"h\":\"核心属性\"},\"448\":{\"h\":\"run方法\"},\"449\":{\"h\":\"get方法\"},\"450\":{\"h\":\"awaitDone方法\"},\"451\":{\"h\":\"cancel方法\"},\"452\":{\"h\":\"finishCompletion方法\"},\"453\":{\"h\":\"参考\"},\"454\":{\"h\":\"CompletableFuture使用详解\"},\"455\":{\"h\":\"前言\"},\"456\":{\"h\":\"CompletableFuture介绍\"},\"457\":{\"h\":\"CompletableFuture使用示例\"},\"458\":{\"h\":\"CompletableFuture具有Future的功能\"},\"459\":{\"h\":\"task异步完成后使用回调函数\"},\"460\":{\"h\":\"完成任意一个Task就开始执行回调函数\"},\"461\":{\"h\":\"完成全部Task就开始执行回调函数\"},\"462\":{\"h\":\"总结\"},\"463\":{\"h\":\"Fork/Join使用详解\"},\"464\":{\"h\":\"简介\"},\"465\":{\"h\":\"核心模块\"},\"466\":{\"h\":\"ForkJoinPool继承关系\"},\"467\":{\"h\":\"ForkJoinTask继承关系\"},\"468\":{\"h\":\"使用示例\"},\"469\":{\"h\":\"参考\"},\"470\":{\"h\":\"Java Collection概述\"},\"471\":{\"h\":\"List 接口\"},\"472\":{\"h\":\"Set接口\"},\"473\":{\"h\":\"Map接口\"},\"474\":{\"h\":\"总结\"},\"475\":{\"h\":\"ArrayList源码解析\"},\"476\":{\"h\":\"ArrayList的类结构图\"},\"477\":{\"h\":\"ArrayList底层是如何实现的？\"},\"478\":{\"h\":\"ArrayList的初始化\"},\"479\":{\"h\":\"添加元素\"},\"480\":{\"h\":\"扩容\"},\"481\":{\"h\":\"删除元素\"},\"482\":{\"h\":\"查找元素\"},\"483\":{\"h\":\"迭代器源码解析\"},\"484\":{\"h\":\"LinkedList源码解析\"},\"485\":{\"h\":\"LinkedList的类结构图\"},\"486\":{\"h\":\"构造函数\"},\"487\":{\"h\":\"add(E e)方法\"},\"488\":{\"h\":\"get(int index)方法\"},\"489\":{\"h\":\"remove(int index)方法\"},\"490\":{\"h\":\"总结\"},\"491\":{\"h\":\"HashMap原理解析\"},\"492\":{\"h\":\"HashMap的类结构图\"},\"493\":{\"h\":\"HashMap的底层数据结构\"},\"494\":{\"h\":\"构造函数\"},\"495\":{\"h\":\"存储元素过程\"},\"496\":{\"h\":\"扩容\"},\"497\":{\"h\":\"获取元素\"},\"498\":{\"h\":\"总结\"},\"499\":{\"h\":\"HashSet原理解析\"},\"500\":{\"h\":\"类结构图\"},\"501\":{\"h\":\"底层数据结构\"},\"502\":{\"h\":\"简单示例\"},\"503\":{\"h\":\"源码解析\"},\"504\":{\"h\":\"构造函数\"},\"505\":{\"h\":\"添加元素\"},\"506\":{\"h\":\"查找元素\"},\"507\":{\"h\":\"删除元素\"},\"508\":{\"h\":\"总结\"},\"509\":{\"h\":\"BitSet使用讲解\"},\"510\":{\"h\":\"类结构关系\"},\"511\":{\"h\":\"BitSet介绍\"},\"512\":{\"h\":\"BitSet的简单使用\"},\"513\":{\"h\":\"使用场景\"},\"514\":{\"h\":\"代码示例\"},\"515\":{\"h\":\"参考\"},\"516\":{\"h\":\"Java IO学习总结\"},\"517\":{\"h\":\"简介\"},\"518\":{\"h\":\"IO流基本类\"},\"519\":{\"h\":\"Java流类图结构\"},\"520\":{\"h\":\"Java IO流对象\"},\"521\":{\"h\":\"Java NIO学习总结\"},\"522\":{\"h\":\"简介\"},\"523\":{\"h\":\"Channel\"},\"524\":{\"h\":\"FileChannel\"},\"525\":{\"h\":\"Buffer\"},\"526\":{\"h\":\"Selector\"},\"527\":{\"h\":\"总结\"},\"528\":{\"h\":\"Java NIO案列实战\"},\"529\":{\"h\":\"SocketChannel介绍\"},\"530\":{\"h\":\"ServerSocketChannel介绍\"},\"531\":{\"h\":\"Selector介绍\"},\"532\":{\"h\":\"案列介绍\"},\"533\":{\"h\":\"服务端代码\"},\"534\":{\"h\":\"客户端代码\"},\"535\":{\"h\":\"NIO底层原理\"},\"536\":{\"h\":\"java基础高频面试题1\"},\"537\":{\"h\":\"重载与重写的区别\"},\"538\":{\"h\":\"抽象类和接口的区别\"},\"539\":{\"h\":\"为什么Java不支持多继承\"},\"540\":{\"h\":\"String和StringBuffer、StringBuilder的区别是什么\"},\"541\":{\"h\":\"如何理解面向过程和面向对象\"},\"542\":{\"h\":\"Java基本类型为什么需要包装类\"},\"543\":{\"h\":\"如何理解java中的多态\"},\"544\":{\"h\":\"java基础高频面试题2\"},\"545\":{\"h\":\"\\\"==\\\" 和 \\\"equals\\\" 的区别\"},\"546\":{\"h\":\"关系操作符号“==”\"},\"547\":{\"h\":\"\\\"equals\\\"\"},\"548\":{\"h\":\"\\\"equals\\\" 和hashcode的关系\"},\"549\":{\"h\":\"java中的异常处理机制\"},\"550\":{\"h\":\"JDK、JRE、JVM的区别和联系\"},\"551\":{\"h\":\"final关键字详解\"},\"552\":{\"h\":\"final关键字的基本用法\"},\"553\":{\"h\":\"为什么内部类引用的外部变量必须用final修饰\"},\"554\":{\"h\":\"谈谈final、finally、finalize的区别\"},\"555\":{\"h\":\"finally语句到底是在return之前还是之后执行？\"},\"556\":{\"h\":\"Java关键字详解\"},\"557\":{\"h\":\"谈谈final、finally、finalize的区别\"}},\"dirtCount\":0,\"index\":[[\"谈谈final\",{\"0\":{\"554\":1,\"557\":1}}],[\"谈谈你对索引最最左匹配原则的理解\",{\"0\":{\"163\":1}}],[\"谈谈你对哈希索引的理解\",{\"0\":{\"138\":1}}],[\"关系操作符号\",{\"0\":{\"546\":1}}],[\"的区别\",{\"0\":{\"545\":1}}],[\"的读写分离的几种方式\",{\"0\":{\"61\":1}}],[\"==\",{\"0\":{\"545\":1,\"546\":1}}],[\"如何理解java中的多态\",{\"0\":{\"543\":1}}],[\"如何理解面向过程和面向对象\",{\"0\":{\"541\":1}}],[\"如何避免死锁\",{\"0\":{\"260\":1}}],[\"抽象类和接口的区别\",{\"0\":{\"538\":1}}],[\"抽象工厂\",{\"0\":{\"45\":1}}],[\"重载与重写的区别\",{\"0\":{\"537\":1}}],[\"重量级锁\",{\"0\":{\"271\":1}}],[\"客户端代码\",{\"0\":{\"534\":1}}],[\"服务端代码\",{\"0\":{\"533\":1}}],[\"案列介绍\",{\"0\":{\"532\":1}}],[\"案例实战\",{\"0\":{\"36\":1,\"50\":1}}],[\"io流对象\",{\"0\":{\"520\":1}}],[\"io流基本类\",{\"0\":{\"518\":1}}],[\"io学习总结\",{\"0\":{\"516\":1}}],[\"index\",{\"0\":{\"488\":1,\"489\":1}}],[\"inheritablethreadlocal\",{\"0\":{\"407\":1}}],[\"int\",{\"0\":{\"329\":1,\"330\":1,\"488\":1,\"489\":1}}],[\"instant\",{\"0\":{\"200\":1}}],[\"inndb存储引擎支持哪些索引\",{\"0\":{\"119\":1}}],[\"innodb为什么使用b+实现索引\",{\"0\":{\"135\":1}}],[\"innodb存储引擎支持哪些索引\",{\"0\":{\"121\":1}}],[\"innodb存储引擎介绍\",{\"0\":{\"115\":1}}],[\"innodb和myisam引擎的区别\",{\"0\":{\"118\":1}}],[\"源码解析\",{\"0\":{\"503\":1}}],[\"源码下载\",{\"0\":{\"24\":1,\"28\":1,\"33\":1}}],[\"底层数据结构\",{\"0\":{\"501\":1}}],[\"获取元素\",{\"0\":{\"497\":1}}],[\"存储元素过程\",{\"0\":{\"495\":1}}],[\"存储引擎\",{\"0\":{\"117\":1}}],[\"equals\",{\"0\":{\"545\":1,\"547\":1,\"548\":1}}],[\"e\",{\"0\":{\"487\":2}}],[\"execute\",{\"0\":{\"430\":1}}],[\"exporter的指标\",{\"0\":{\"188\":1}}],[\"构造函数\",{\"0\":{\"486\":1,\"494\":1,\"504\":1}}],[\"迭代器源码解析\",{\"0\":{\"483\":1}}],[\"查找元素\",{\"0\":{\"482\":1,\"506\":1}}],[\"查询条件中使用了函数或者运算\",{\"0\":{\"156\":1}}],[\"查询都是湖南的同学的姓名\",{\"0\":{\"112\":1}}],[\"查询姓张和姓王的同学的姓名\",{\"0\":{\"111\":1}}],[\"查询同时参加计算机和英语考试的学生信息\",{\"0\":{\"108\":1}}],[\"查询计算机成绩低于95分的学生成绩\",{\"0\":{\"107\":1}}],[\"查询计算机系和英语系的学生的信息的两种方法\",{\"0\":{\"99\":1}}],[\"查询李四的考试科目\",{\"0\":{\"103\":1}}],[\"查询年龄为18\",{\"0\":{\"100\":1}}],[\"查询student学生的学号\",{\"0\":{\"98\":1}}],[\"查询\",{\"0\":{\"97\":1}}],[\"查询学生表中的所有记录\",{\"0\":{\"96\":1}}],[\"删除元素\",{\"0\":{\"481\":1,\"507\":1}}],[\"扩容\",{\"0\":{\"480\":1,\"496\":1}}],[\"扩展阅读\",{\"0\":{\"64\":1}}],[\"添加元素\",{\"0\":{\"479\":1,\"505\":1}}],[\"接口\",{\"0\":{\"471\":1}}],[\"简单示例\",{\"0\":{\"502\":1}}],[\"简单工厂\",{\"0\":{\"39\":1}}],[\"简介\",{\"0\":{\"464\":1,\"517\":1,\"522\":1}}],[\"jvm的区别和联系\",{\"0\":{\"550\":1}}],[\"jre\",{\"0\":{\"550\":1}}],[\"jdk\",{\"0\":{\"550\":1}}],[\"join使用详解\",{\"0\":{\"463\":1}}],[\"java关键字详解\",{\"0\":{\"556\":1}}],[\"java中的异常处理机制\",{\"0\":{\"549\":1}}],[\"java中的引用\",{\"0\":{\"405\":1}}],[\"java基础高频面试题2\",{\"0\":{\"544\":1}}],[\"java基础高频面试题1\",{\"0\":{\"536\":1}}],[\"java基本类型为什么需要包装类\",{\"0\":{\"542\":1}}],[\"java流类图结构\",{\"0\":{\"519\":1}}],[\"java并发包的线程池\",{\"0\":{\"409\":1}}],[\"java并发技术aqs详解\",{\"0\":{\"280\":1}}],[\"java7\",{\"0\":{\"364\":1}}],[\"java死锁示例\",{\"0\":{\"258\":1}}],[\"java死锁详解\",{\"0\":{\"257\":1}}],[\"java内存模型\",{\"0\":{\"243\":1}}],[\"java内存模式以及volatile详解\",{\"0\":{\"242\":1}}],[\"java\",{\"0\":{\"56\":1,\"263\":1,\"365\":1,\"470\":1,\"516\":1,\"520\":1,\"521\":1,\"528\":1}}],[\"完成全部task就开始执行回调函数\",{\"0\":{\"461\":1}}],[\"完成任意一个task就开始执行回调函数\",{\"0\":{\"460\":1}}],[\"核心模块\",{\"0\":{\"465\":1}}],[\"核心属性\",{\"0\":{\"447\":1}}],[\"核心函数分析\",{\"0\":{\"331\":1,\"355\":1,\"377\":1,\"391\":1}}],[\"任务的关闭\",{\"0\":{\"438\":1}}],[\"任务的提交\",{\"0\":{\"434\":1}}],[\"任务的执行\",{\"0\":{\"429\":1}}],[\"方法\",{\"0\":{\"430\":1,\"487\":1,\"488\":1,\"489\":1}}],[\"方案二\",{\"0\":{\"217\":1}}],[\"方案一\",{\"0\":{\"216\":1}}],[\"内部状态\",{\"0\":{\"428\":1}}],[\"内存引用链路\",{\"0\":{\"404\":1}}],[\"几个关键属性\",{\"0\":{\"427\":1}}],[\"linkedlist的类结构图\",{\"0\":{\"485\":1}}],[\"linkedlist源码解析\",{\"0\":{\"484\":1}}],[\"linkedblockingqueue\",{\"0\":{\"418\":1}}],[\"list\",{\"0\":{\"342\":1,\"471\":1}}],[\"keepalivetime\",{\"0\":{\"415\":1}}],[\"key\",{\"0\":{\"89\":1}}],[\"前言\",{\"0\":{\"410\":1,\"455\":1}}],[\"父子线程间的数据共享\",{\"0\":{\"407\":1}}],[\"泄露原因分析\",{\"0\":{\"406\":1}}],[\"poll函数\",{\"0\":{\"395\":1}}],[\"put函数\",{\"0\":{\"392\":1}}],[\"putval函数\",{\"0\":{\"378\":1}}],[\"promql快速入门\",{\"0\":{\"199\":1}}],[\"prometheus预处理计算\",{\"0\":{\"231\":1}}],[\"prometheus告警与alertmanager实战\",{\"0\":{\"220\":1}}],[\"prometheus的数据模型\",{\"0\":{\"192\":1}}],[\"prometheus配置文件热更新\",{\"0\":{\"189\":1}}],[\"prometheus配置文件讲解\",{\"0\":{\"187\":1}}],[\"prometheus环境搭建\",{\"0\":{\"185\":1}}],[\"prometheus适用的场景\",{\"0\":{\"184\":1}}],[\"prometheus提供的特性\",{\"0\":{\"181\":1}}],[\"prometheus概述\",{\"0\":{\"179\":1}}],[\"prometheus教程介绍\",{\"0\":{\"178\":1}}],[\"task异步完成后使用回调函数\",{\"0\":{\"459\":1}}],[\"take函数\",{\"0\":{\"394\":1}}],[\"threadfactory\",{\"0\":{\"420\":1}}],[\"threadpoolexecutor源码详解\",{\"0\":{\"426\":1}}],[\"threadpoolexecutor构造函数\",{\"0\":{\"413\":1}}],[\"threadpoolexecutor线程池的生命周期\",{\"0\":{\"412\":1}}],[\"threadpoolexecutor类图\",{\"0\":{\"411\":1}}],[\"threadpoolexecutor详解\",{\"0\":{\"409\":1}}],[\"threadlocal内存泄露\",{\"0\":{\"403\":1}}],[\"threadlocal的使用场景\",{\"0\":{\"402\":1}}],[\"threadlocal的使用示例\",{\"0\":{\"400\":1}}],[\"threadlocal原理分析\",{\"0\":{\"401\":1}}],[\"threadlocal详解\",{\"0\":{\"398\":1}}],[\"thread状态\",{\"0\":{\"273\":1,\"274\":1}}],[\"traverser类\",{\"0\":{\"371\":1}}],[\"基于分段锁的concurrenthashmap\",{\"0\":{\"364\":1}}],[\"queue\",{\"0\":{\"345\":1}}],[\"并发容器详解\",{\"0\":{\"341\":1}}],[\"并发包的锁\",{\"0\":{\"337\":1}}],[\"并发包里的锁总结\",{\"0\":{\"336\":1}}],[\"dowait函数\",{\"0\":{\"332\":1}}],[\"型构造函数\",{\"0\":{\"329\":1,\"330\":1}}],[\"手写一个aqs\",{\"0\":{\"294\":1}}],[\"类结构关系\",{\"0\":{\"510\":1}}],[\"类结构图\",{\"0\":{\"500\":1}}],[\"类的核心函数\",{\"0\":{\"291\":1}}],[\"类的构造函数\",{\"0\":{\"290\":1,\"300\":1,\"315\":1,\"328\":1,\"353\":1,\"376\":1,\"390\":1}}],[\"类的属性\",{\"0\":{\"289\":1,\"299\":1,\"314\":1,\"327\":1,\"352\":1,\"375\":1,\"389\":1}}],[\"类的内部类\",{\"0\":{\"286\":1,\"301\":1,\"316\":1,\"326\":1,\"354\":1,\"369\":1}}],[\"类的继承关系\",{\"0\":{\"285\":1,\"313\":1,\"325\":1,\"351\":1,\"368\":1,\"388\":1}}],[\"类型进行了隐式转换\",{\"0\":{\"157\":1}}],[\"对资源的共享方式\",{\"0\":{\"283\":1}}],[\"对象头\",{\"0\":{\"268\":1}}],[\"两个线程交替打印奇数和偶数\",{\"0\":{\"279\":1}}],[\"两阶段写日志有什么作用\",{\"0\":{\"175\":1}}],[\"worker类的runworker方法\",{\"0\":{\"432\":1}}],[\"workqueue\",{\"0\":{\"416\":1}}],[\"wait\",{\"0\":{\"278\":1}}],[\"webhook\",{\"0\":{\"229\":1}}],[\"新建状态\",{\"0\":{\"275\":1}}],[\"nio底层原理\",{\"0\":{\"535\":1}}],[\"nio案列实战\",{\"0\":{\"528\":1}}],[\"nio学习总结\",{\"0\":{\"521\":1}}],[\"nextgeneration函数\",{\"0\":{\"333\":1}}],[\"new\",{\"0\":{\"275\":1}}],[\"nonfairsync类\",{\"0\":{\"303\":1}}],[\"node类\",{\"0\":{\"287\":1,\"370\":1}}],[\"name\",{\"0\":{\"103\":1}}],[\"轻量级锁\",{\"0\":{\"270\":1}}],[\"偏向锁\",{\"0\":{\"269\":1}}],[\"破坏循环等待条件\",{\"0\":{\"262\":1}}],[\"破坏占有且等待\",{\"0\":{\"261\":1}}],[\"死锁发生的条件\",{\"0\":{\"259\":1}}],[\"参考\",{\"0\":{\"335\":1,\"381\":1,\"397\":1,\"408\":1,\"439\":1,\"453\":1,\"469\":1,\"515\":1}}],[\"参考资料\",{\"0\":{\"256\":1,\"295\":1}}],[\"参考文档\",{\"0\":{\"230\":1,\"319\":1}}],[\"规则\",{\"0\":{\"255\":1}}],[\"hashset原理解析\",{\"0\":{\"499\":1}}],[\"hashmap的底层数据结构\",{\"0\":{\"493\":1}}],[\"hashmap的类结构图\",{\"0\":{\"492\":1}}],[\"hashmap原理解析\",{\"0\":{\"491\":1}}],[\"handler\",{\"0\":{\"421\":1}}],[\"happens\",{\"0\":{\"255\":1}}],[\"histogram直方图\",{\"0\":{\"197\":1}}],[\"防止指令重排\",{\"0\":{\"254\":1}}],[\"状态标记\",{\"0\":{\"253\":1}}],[\"volatile的使用场景\",{\"0\":{\"252\":1}}],[\"volatile不能保证原子性\",{\"0\":{\"251\":1}}],[\"volatile能够保证可见性和防止指令重排\",{\"0\":{\"250\":1}}],[\"volatile关键字作用\",{\"0\":{\"249\":1}}],[\"volatile详解\",{\"0\":{\"248\":1}}],[\"vector\",{\"0\":{\"200\":1,\"201\":1,\"207\":1}}],[\"可见性\",{\"0\":{\"246\":1}}],[\"编发编程的概念\",{\"0\":{\"244\":1}}],[\"编译优化带来的有序性问题\",{\"0\":{\"240\":1}}],[\"缓存导致的可见性问题\",{\"0\":{\"238\":1}}],[\"有序性的问题\",{\"0\":{\"237\":1}}],[\"有序性\",{\"0\":{\"236\":1,\"247\":1}}],[\"原子性\",{\"0\":{\"236\":1,\"237\":1,\"245\":1}}],[\"理解可见性\",{\"0\":{\"236\":1}}],[\"实战\",{\"0\":{\"235\":1}}],[\"实现\",{\"0\":{\"61\":1}}],[\"定义recoding\",{\"0\":{\"232\":1}}],[\"定期优化和维护索引\",{\"0\":{\"130\":1}}],[\"remove\",{\"0\":{\"489\":1}}],[\"remove函数\",{\"0\":{\"360\":1}}],[\"replacenode函数\",{\"0\":{\"380\":1}}],[\"readwritelock\",{\"0\":{\"339\":1}}],[\"reentrantlock\",{\"0\":{\"338\":1}}],[\"reentrantlock的特点总结\",{\"0\":{\"307\":1}}],[\"reentrantlock使用示例\",{\"0\":{\"306\":1}}],[\"reentrantlock在dubbo中的使用\",{\"0\":{\"305\":1}}],[\"reentrantlock类继承关系\",{\"0\":{\"298\":1}}],[\"reentrantlock数据结构\",{\"0\":{\"297\":1}}],[\"reentrantlock源码解析\",{\"0\":{\"296\":1}}],[\"release\",{\"0\":{\"293\":1}}],[\"recording\",{\"0\":{\"231\":1,\"233\":1}}],[\"run方法\",{\"0\":{\"437\":1,\"448\":1}}],[\"runnable\",{\"0\":{\"276\":1,\"329\":1}}],[\"rule的最佳实践\",{\"0\":{\"233\":1}}],[\"rules\",{\"0\":{\"232\":1}}],[\"rule\",{\"0\":{\"231\":1}}],[\"range\",{\"0\":{\"201\":1}}],[\"静默\",{\"0\":{\"224\":1}}],[\"静态代理\",{\"0\":{\"53\":1}}],[\"抑制\",{\"0\":{\"223\":1}}],[\"分组\",{\"0\":{\"222\":1}}],[\"分组修改器\",{\"0\":{\"208\":1}}],[\"arraylist的初始化\",{\"0\":{\"478\":1}}],[\"arraylist的类结构图\",{\"0\":{\"476\":1}}],[\"arraylist底层是如何实现的\",{\"0\":{\"477\":1}}],[\"arraylist源码解析\",{\"0\":{\"475\":1}}],[\"arrayblockingqueue\",{\"0\":{\"419\":1}}],[\"arrayblockingqueue源码实现\",{\"0\":{\"387\":1}}],[\"arrayblockingqueue使用介绍\",{\"0\":{\"386\":1}}],[\"awaitdone方法\",{\"0\":{\"450\":1}}],[\"await函数\",{\"0\":{\"317\":1}}],[\"add\",{\"0\":{\"487\":1}}],[\"addworker方法\",{\"0\":{\"431\":1}}],[\"addifabsent\",{\"0\":{\"358\":1}}],[\"add函数\",{\"0\":{\"357\":1}}],[\"acquire函数\",{\"0\":{\"292\":1}}],[\"actuator\",{\"0\":{\"216\":1}}],[\"aqs源码解析\",{\"0\":{\"284\":1}}],[\"aqs\",{\"0\":{\"283\":1}}],[\"aqs核心思想\",{\"0\":{\"282\":1}}],[\"aqs简介\",{\"0\":{\"281\":1}}],[\"alertmanager查看告警消息\",{\"0\":{\"228\":1}}],[\"alertmanager安装\",{\"0\":{\"225\":1}}],[\"alertmanager介绍\",{\"0\":{\"221\":1}}],[\"配置讲解\",{\"0\":{\"226\":1}}],[\"配置grafana视图\",{\"0\":{\"219\":1}}],[\"配置prometheus采集\",{\"0\":{\"218\":1}}],[\"在prometheus中配置告警规则\",{\"0\":{\"227\":1}}],[\"在springboot项目中使用prometheus监控\",{\"0\":{\"215\":1}}],[\"在某些情况下会导致索引失效\",{\"0\":{\"158\":1}}],[\"预测指标变化趋势\",{\"0\":{\"212\":1}}],[\"计算分位数\",{\"0\":{\"213\":1}}],[\"计算counter的增长率\",{\"0\":{\"211\":1}}],[\"计算每个考试科目的平均成绩\",{\"0\":{\"106\":1}}],[\"计算每个学生的总成绩\",{\"0\":{\"105\":1}}],[\"聚合函数\",{\"0\":{\"209\":1}}],[\"map接口\",{\"0\":{\"473\":1}}],[\"map\",{\"0\":{\"343\":1}}],[\"matching\",{\"0\":{\"207\":1}}],[\"modifiers\",{\"0\":{\"208\":1}}],[\"myisam存储引擎介绍\",{\"0\":{\"116\":1}}],[\"mysql会根据数据量而决定走不走索引\",{\"0\":{\"161\":1}}],[\"mysql的存储引擎有哪些\",{\"0\":{\"114\":1}}],[\"mysql有哪些存储引擎\",{\"0\":{\"113\":1}}],[\"mysql综合练习题\",{\"0\":{\"92\":1,\"93\":1}}],[\"mysql主从同步的延迟主要原因\",{\"0\":{\"69\":1}}],[\"mysql主从同步的延迟原因和解决办法\",{\"0\":{\"67\":1}}],[\"mysql主从复制的过程\",{\"0\":{\"62\":1,\"63\":1,\"68\":1}}],[\"mysql\",{\"0\":{\"61\":1,\"117\":1}}],[\"向量匹配符号\",{\"0\":{\"207\":1}}],[\"逻辑运算符\",{\"0\":{\"206\":1}}],[\"比较操作符\",{\"0\":{\"205\":1}}],[\"数学操作符\",{\"0\":{\"204\":1}}],[\"数据准备\",{\"0\":{\"151\":1,\"164\":1}}],[\"操作符\",{\"0\":{\"203\":1}}],[\"时间位移操作\",{\"0\":{\"202\":1}}],[\"offer函数\",{\"0\":{\"393\":1}}],[\"offset\",{\"0\":{\"202\":1}}],[\"order\",{\"0\":{\"158\":1}}],[\"范围向量查询\",{\"0\":{\"201\":1}}],[\"瞬时向量查询\",{\"0\":{\"200\":1}}],[\"get\",{\"0\":{\"488\":1}}],[\"get方法\",{\"0\":{\"449\":1}}],[\"gettask方法\",{\"0\":{\"433\":1}}],[\"get函数\",{\"0\":{\"379\":1}}],[\"gauge仪表盘\",{\"0\":{\"196\":1}}],[\"grafana安装\",{\"0\":{\"190\":1}}],[\"grade\",{\"0\":{\"103\":1}}],[\"group\",{\"0\":{\"133\":1,\"208\":1}}],[\"累加器\",{\"0\":{\"195\":1}}],[\"指标的类型\",{\"0\":{\"194\":1}}],[\"指南\",{\"0\":{\"4\":1}}],[\"socketchannel介绍\",{\"0\":{\"529\":1}}],[\"submit方法\",{\"0\":{\"435\":1}}],[\"summary\",{\"0\":{\"198\":1}}],[\"synchronousqueue\",{\"0\":{\"417\":1}}],[\"synchronized的优化一览表\",{\"0\":{\"272\":1}}],[\"synchronized优化\",{\"0\":{\"267\":1}}],[\"synchronized原理\",{\"0\":{\"266\":1}}],[\"synchronized关键字的作用\",{\"0\":{\"264\":1}}],[\"synchronized关键字详解\",{\"0\":{\"263\":1}}],[\"sync类\",{\"0\":{\"302\":1}}],[\"stringbuilder的区别是什么\",{\"0\":{\"540\":1}}],[\"string和stringbuffer\",{\"0\":{\"540\":1}}],[\"stampedlock\",{\"0\":{\"340\":1}}],[\"starter\",{\"0\":{\"216\":1}}],[\"student表中查询每个院系有多少人\",{\"0\":{\"101\":1}}],[\"student表中2\",{\"0\":{\"97\":1}}],[\"serversocketchannel介绍\",{\"0\":{\"530\":1}}],[\"series\",{\"0\":{\"193\":1}}],[\"selector介绍\",{\"0\":{\"531\":1}}],[\"selector\",{\"0\":{\"526\":1}}],[\"selectors\",{\"0\":{\"200\":1,\"201\":1}}],[\"segment类\",{\"0\":{\"373\":1}}],[\"set接口\",{\"0\":{\"472\":1}}],[\"set函数\",{\"0\":{\"359\":1}}],[\"set\",{\"0\":{\"344\":1}}],[\"采集node\",{\"0\":{\"188\":1}}],[\"安装prometheus\",{\"0\":{\"186\":1}}],[\"架构\",{\"0\":{\"183\":1}}],[\"组件\",{\"0\":{\"182\":1}}],[\"概览\",{\"0\":{\"177\":1}}],[\"请你说说事务的特性\",{\"0\":{\"176\":1}}],[\"请介绍一下mysql的架构\",{\"0\":{\"58\":1}}],[\"说说innodb存储引擎的事务提交过程\",{\"0\":{\"171\":1}}],[\"索引失效的情况\",{\"0\":{\"167\":1}}],[\"索引失效的几种情况\",{\"0\":{\"152\":1}}],[\"索引生效情况\",{\"0\":{\"166\":1}}],[\"联合索引使用示例\",{\"0\":{\"165\":1}}],[\"联合索引不满足列的最左匹配原则\",{\"0\":{\"154\":1}}],[\"还有一些可能导致索引失效的场景\",{\"0\":{\"162\":1}}],[\"9\",{\"0\":{\"161\":1}}],[\"8基于cas的concurrenthashmap\",{\"0\":{\"365\":1}}],[\"8\",{\"0\":{\"160\":1}}],[\"7\",{\"0\":{\"159\":1}}],[\"6\",{\"0\":{\"158\":1}}],[\"5\",{\"0\":{\"157\":1}}],[\"4\",{\"0\":{\"156\":1}}],[\"4条记录\",{\"0\":{\"97\":1}}],[\"finalize的区别\",{\"0\":{\"554\":1,\"557\":1}}],[\"finally语句到底是在return之前还是之后执行\",{\"0\":{\"555\":1}}],[\"finally\",{\"0\":{\"554\":1,\"557\":1}}],[\"final关键字的基本用法\",{\"0\":{\"552\":1}}],[\"final关键字详解\",{\"0\":{\"551\":1}}],[\"finishcompletion方法\",{\"0\":{\"452\":1}}],[\"filechannel\",{\"0\":{\"524\":1}}],[\"forkjointask继承关系\",{\"0\":{\"467\":1}}],[\"forkjoinpool继承关系\",{\"0\":{\"466\":1}}],[\"fork\",{\"0\":{\"463\":1}}],[\"foo\",{\"0\":{\"7\":1}}],[\"future接口\",{\"0\":{\"445\":1}}],[\"futuretask\",{\"0\":{\"446\":1}}],[\"futuretask源码解析\",{\"0\":{\"443\":1}}],[\"futuretask使用示例\",{\"0\":{\"442\":1}}],[\"futuretask详解\",{\"0\":{\"440\":1}}],[\"futuretask对象\",{\"0\":{\"436\":1}}],[\"fairsyn类\",{\"0\":{\"304\":1}}],[\"from\",{\"0\":{\"155\":1}}],[\"3\",{\"0\":{\"155\":1}}],[\"2\",{\"0\":{\"154\":1,\"425\":1}}],[\"22岁的学生\",{\"0\":{\"100\":1}}],[\"10\",{\"0\":{\"162\":1}}],[\"1\",{\"0\":{\"153\":1,\"424\":1}}],[\"什么情况下会导致索引失效\",{\"0\":{\"150\":1}}],[\"什么是futuretask\",{\"0\":{\"441\":1}}],[\"什么是threadlocal\",{\"0\":{\"399\":1}}],[\"什么是time\",{\"0\":{\"193\":1}}],[\"什么是prometheus\",{\"0\":{\"180\":1}}],[\"什么是事务的两阶段提交\",{\"0\":{\"172\":1,\"173\":1}}],[\"什么是mysql事务\",{\"0\":{\"170\":1}}],[\"什么是mysql的事务两阶段提交\",{\"0\":{\"174\":1}}],[\"什么是mysql的回表\",{\"0\":{\"146\":1,\"147\":1}}],[\"什么是mysql的读写分离\",{\"0\":{\"59\":1,\"60\":1}}],[\"什么是非聚簇索引\",{\"0\":{\"144\":1}}],[\"什么是聚簇索引\",{\"0\":{\"143\":1}}],[\"什么是聚族索引\",{\"0\":{\"142\":1}}],[\"什么是哈希索引\",{\"0\":{\"139\":1}}],[\"什么是blockingqueue\",{\"0\":{\"383\":1}}],[\"什么是b+树\",{\"0\":{\"136\":1}}],[\"什么是binlog\",{\"0\":{\"66\":1}}],[\"什么是数据库索引\",{\"0\":{\"120\":1}}],[\"什么是数据库的范式\",{\"0\":{\"74\":1,\"75\":1}}],[\"什么是存储过程\",{\"0\":{\"71\":1,\"72\":1}}],[\"什么是单例模式\",{\"0\":{\"16\":1}}],[\"怎么避免\",{\"0\":{\"149\":1}}],[\"怎么优雅的选择\",{\"0\":{\"117\":1}}],[\"示例\",{\"0\":{\"148\":1}}],[\"总结\",{\"0\":{\"145\":1,\"168\":1,\"191\":1,\"214\":1,\"241\":1,\"346\":1,\"361\":1,\"462\":1,\"474\":1,\"490\":1,\"498\":1,\"508\":1,\"527\":1}}],[\"适用场景\",{\"0\":{\"141\":1}}],[\"适配器模式\",{\"0\":{\"25\":1}}],[\"具有什么特点\",{\"0\":{\"140\":1}}],[\"后面的字段建立索引\",{\"0\":{\"133\":1}}],[\"和hashcode的关系\",{\"0\":{\"548\":1}}],[\"和\",{\"0\":{\"133\":1,\"545\":1}}],[\"和考试成绩\",{\"0\":{\"103\":1}}],[\"buffer\",{\"0\":{\"525\":1}}],[\"bitset的简单使用\",{\"0\":{\"512\":1}}],[\"bitset介绍\",{\"0\":{\"511\":1}}],[\"bitset使用讲解\",{\"0\":{\"509\":1}}],[\"blockingqueue实现\",{\"0\":{\"385\":1}}],[\"blockingqueue接口定义\",{\"0\":{\"384\":1}}],[\"blockingqueue详解\",{\"0\":{\"382\":1}}],[\"blocked\",{\"0\":{\"277\":1}}],[\"breakbarrier函数\",{\"0\":{\"334\":1}}],[\"before\",{\"0\":{\"255\":1}}],[\"boot\",{\"0\":{\"216\":1}}],[\"by\",{\"0\":{\"133\":2,\"158\":1}}],[\"bar\",{\"0\":{\"6\":1}}],[\"尽量为order\",{\"0\":{\"133\":1}}],[\"注意索引的数据类型和长度\",{\"0\":{\"132\":1}}],[\"考虑查询性能和写入性能的平衡\",{\"0\":{\"131\":1}}],[\"考试科目和成绩\",{\"0\":{\"111\":1,\"112\":1}}],[\"避免过度索引\",{\"0\":{\"129\":1}}],[\"避免在表中存储重复或冗余的数据\",{\"0\":{\"86\":1}}],[\"根据查询条件设计索引\",{\"0\":{\"126\":1}}],[\"唯一索引是怎么实现的\",{\"0\":{\"124\":1}}],[\"主建索引尽量使用自增的\",{\"0\":{\"134\":1}}],[\"主键索引和唯一索引的区别\",{\"0\":{\"123\":1}}],[\"主从复制的一致性是怎么保证的\",{\"0\":{\"65\":1}}],[\"常见的两种存储引擎介绍\",{\"0\":{\"113\":1}}],[\"年龄\",{\"0\":{\"112\":1}}],[\"院系\",{\"0\":{\"111\":1,\"112\":1}}],[\"从student表和score\",{\"0\":{\"110\":1}}],[\"从score\",{\"0\":{\"102\":1}}],[\"将计算机成绩按从高到低进行排序\",{\"0\":{\"109\":1}}],[\"用连接查询的方式查询所有学生的信息和考试成绩\",{\"0\":{\"104\":1}}],[\"表中查询出学号然后合并查询结果\",{\"0\":{\"110\":1}}],[\"表中查询每个科目的最高分\",{\"0\":{\"102\":1}}],[\"表字段不能超过100个\",{\"0\":{\"90\":1}}],[\"姓名和院校信息\",{\"0\":{\"98\":1}}],[\"插入数据\",{\"0\":{\"95\":1}}],[\"创建索引示例\",{\"0\":{\"122\":1}}],[\"创建表\",{\"0\":{\"94\":1}}],[\"创建型模式\",{\"0\":{\"10\":1}}],[\"channel\",{\"0\":{\"523\":1}}],[\"char和varchar的区别\",{\"0\":{\"91\":1}}],[\"cancel方法\",{\"0\":{\"451\":1}}],[\"callable接口\",{\"0\":{\"444\":1}}],[\"clear函数\",{\"0\":{\"396\":1}}],[\"cyclicbarrier\",{\"0\":{\"329\":1,\"330\":1}}],[\"cyclicbarrier数据结构\",{\"0\":{\"324\":1}}],[\"cyclicbarrier使用示例\",{\"0\":{\"322\":1}}],[\"cyclicbarrier简介\",{\"0\":{\"321\":1}}],[\"cyclicbarrier源码解析\",{\"0\":{\"320\":1,\"323\":1}}],[\"collection概述\",{\"0\":{\"470\":1}}],[\"collectionview类\",{\"0\":{\"372\":1}}],[\"completablefuture具有future的功能\",{\"0\":{\"458\":1}}],[\"completablefuture使用示例\",{\"0\":{\"457\":1}}],[\"completablefuture使用详解\",{\"0\":{\"454\":1}}],[\"completablefuture介绍\",{\"0\":{\"456\":1}}],[\"corepoolsize\",{\"0\":{\"414\":1}}],[\"concurrenthashmap使用示例\",{\"0\":{\"366\":1}}],[\"concurrenthashmap介绍\",{\"0\":{\"363\":1}}],[\"concurrenthashmap源码解析\",{\"0\":{\"362\":1,\"367\":1}}],[\"conditionobject类\",{\"0\":{\"288\":1}}],[\"copyof函数\",{\"0\":{\"356\":1}}],[\"copyonwritearraylist使用示例\",{\"0\":{\"349\":1}}],[\"copyonwritearraylist介绍\",{\"0\":{\"348\":1}}],[\"copyonwritearraylist源码解析\",{\"0\":{\"347\":1,\"350\":1}}],[\"countdown函数\",{\"0\":{\"318\":1}}],[\"countdownlatch数据结构\",{\"0\":{\"312\":1}}],[\"countdownlatch使用示例\",{\"0\":{\"310\":1}}],[\"countdownlatch简介\",{\"0\":{\"309\":1}}],[\"countdownlatch源码解析\",{\"0\":{\"308\":1,\"311\":1}}],[\"countercell\",{\"0\":{\"374\":1}}],[\"counter\",{\"0\":{\"195\":1}}],[\"c\",{\"0\":{\"103\":1}}],[\"cglib代码\",{\"0\":{\"57\":1}}],[\"字段的总大小没有特殊原因不要超过8k\",{\"0\":{\"90\":1}}],[\"禁止使用foreign\",{\"0\":{\"89\":1}}],[\"遵循数据库设计范式的原则\",{\"0\":{\"88\":1}}],[\"合理的建立索引\",{\"0\":{\"87\":1}}],[\"合理建立的约束\",{\"0\":{\"85\":1}}],[\"选择合适的索引列\",{\"0\":{\"127\":1}}],[\"选择合适的精度\",{\"0\":{\"84\":1}}],[\"选择合适的数据类型\",{\"0\":{\"82\":1}}],[\"设置合适的字段长度\",{\"0\":{\"83\":1}}],[\"设计索引时应遵循什么规范\",{\"0\":{\"125\":1}}],[\"设计数据库表字段的时候应该遵循哪些规则\",{\"0\":{\"80\":1}}],[\"设计模式的几种原则\",{\"0\":{\"14\":1}}],[\"设计模式有哪些类型\",{\"0\":{\"9\":1}}],[\"设计模式面试概述\",{\"0\":{\"8\":1}}],[\"命名规范\",{\"0\":{\"81\":1,\"234\":1}}],[\"反范式\",{\"0\":{\"79\":1}}],[\"第三范式\",{\"0\":{\"78\":1}}],[\"第二范式\",{\"0\":{\"77\":1}}],[\"第一范式\",{\"0\":{\"76\":1}}],[\"为什么内部类引用的外部变量必须用final修饰\",{\"0\":{\"553\":1}}],[\"为什么java不支持多继承\",{\"0\":{\"539\":1}}],[\"为什么线程池不允许使用executors去创建\",{\"0\":{\"423\":1}}],[\"为什么会有可见性\",{\"0\":{\"237\":1}}],[\"为什么阿里巴巴不推荐使用外键\",{\"0\":{\"169\":1}}],[\"为什么使用b+树来实现索引\",{\"0\":{\"137\":1}}],[\"为什么不推荐使用存储过程\",{\"0\":{\"71\":1,\"73\":1}}],[\"为什么要使用观察者模式\",{\"0\":{\"51\":1}}],[\"为什么要使用责任链模式\",{\"0\":{\"37\":1}}],[\"为什么要使用装饰器模式\",{\"0\":{\"32\":1}}],[\"解决办法\",{\"0\":{\"70\":1}}],[\"以及实现读写分离的几种方式\",{\"0\":{\"59\":1}}],[\"动态代理\",{\"0\":{\"55\":1,\"56\":1}}],[\"代码示例\",{\"0\":{\"514\":1}}],[\"代码实现\",{\"0\":{\"26\":1,\"41\":1,\"44\":1,\"47\":1,\"54\":1}}],[\"代理模式\",{\"0\":{\"52\":1}}],[\"观察者模式uml图\",{\"0\":{\"49\":1}}],[\"观察者模式\",{\"0\":{\"48\":1}}],[\"工厂方法模式\",{\"0\":{\"42\":1}}],[\"工厂模式\",{\"0\":{\"38\":1}}],[\"责任链模式的uml图\",{\"0\":{\"35\":1}}],[\"责任链模式\",{\"0\":{\"34\":1}}],[\"uml图\",{\"0\":{\"30\":1,\"40\":1,\"43\":1,\"46\":1}}],[\"装饰器模式\",{\"0\":{\"29\":1}}],[\"使用场景\",{\"0\":{\"513\":1}}],[\"使用详解\",{\"0\":{\"273\":1}}],[\"使用示例\",{\"0\":{\"265\":1,\"468\":1}}],[\"使用prometheus\",{\"0\":{\"217\":1}}],[\"使用spring\",{\"0\":{\"216\":1}}],[\"使用or操作\",{\"0\":{\"160\":1}}],[\"使用了两列比较\",{\"0\":{\"159\":1}}],[\"使用了select\",{\"0\":{\"155\":1}}],[\"使用like操作符\",{\"0\":{\"153\":1}}],[\"使用联合索引\",{\"0\":{\"128\":1}}],[\"使用案例\",{\"0\":{\"31\":1}}],[\"使用适配器模式有什么收益\",{\"0\":{\"27\":1}}],[\"使用内部类模式\",{\"0\":{\"20\":1}}],[\"不推荐\",{\"0\":{\"22\":1,\"23\":1}}],[\"线程池的工作流程\",{\"0\":{\"422\":1}}],[\"线程切换带来的原子问题\",{\"0\":{\"239\":1}}],[\"线程不安全\",{\"0\":{\"22\":1,\"23\":1}}],[\"线程安全\",{\"0\":{\"18\":1,\"19\":1,\"20\":1}}],[\"懒汉模式\",{\"0\":{\"22\":1,\"23\":1}}],[\"其他常见的函数\",{\"0\":{\"210\":1}}],[\"其他\",{\"0\":{\"21\":1}}],[\"双重检查\",{\"0\":{\"19\":1}}],[\"推荐方式\",{\"0\":{\"424\":1,\"425\":1}}],[\"推荐\",{\"0\":{\"18\":1,\"19\":1,\"20\":1}}],[\"饿汉模式\",{\"0\":{\"18\":1}}],[\"单例模式的实现\",{\"0\":{\"17\":1}}],[\"单例模式\",{\"0\":{\"15\":1}}],[\"面试过程中常问的设计模式\",{\"0\":{\"13\":1}}],[\"行为型模式\",{\"0\":{\"12\":1}}],[\"结构型模式\",{\"0\":{\"11\":1}}],[\"功能亮点\",{\"0\":{\"5\":1}}],[\"幻灯片页\",{\"0\":{\"3\":1}}],[\"更新计划\",{\"0\":{\"1\":1,\"2\":1}}],[\"个人生活文章\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
