const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":168,\"nextId\":168,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#更新计划\",\"2\":\"v-8daa1a0e#更新计划-1\",\"3\":\"v-2e3eac9e\",\"4\":\"v-1473bf53\",\"5\":\"v-1473bf53#目录\",\"6\":\"v-1473bf53@0\",\"7\":\"v-4e65ec78\",\"8\":\"v-4e65ec78@0\",\"9\":\"v-4e65ec78@1\",\"10\":\"v-c151bf32\",\"11\":\"v-c151bf32@0\",\"12\":\"v-c151bf32@1\",\"13\":\"v-438ffe52\",\"14\":\"v-438ffe52#markdown-介绍\",\"15\":\"v-438ffe52#markdown-配置\",\"16\":\"v-438ffe52#markdown-扩展\",\"17\":\"v-438ffe52#vuepress-扩展\",\"18\":\"v-438ffe52#主题扩展\",\"19\":\"v-438ffe52#自定义容器\",\"20\":\"v-438ffe52#代码块\",\"21\":\"v-438ffe52#上下角标\",\"22\":\"v-438ffe52#自定义对齐\",\"23\":\"v-438ffe52#attrs\",\"24\":\"v-438ffe52#脚注\",\"25\":\"v-438ffe52#标记\",\"26\":\"v-438ffe52#任务列表\",\"27\":\"v-438ffe52#图片增强\",\"28\":\"v-438ffe52#卡片\",\"29\":\"v-438ffe52#图表\",\"30\":\"v-438ffe52#echarts\",\"31\":\"v-438ffe52#流程图\",\"32\":\"v-438ffe52#mermaid\",\"33\":\"v-438ffe52#tex-语法\",\"34\":\"v-438ffe52#导入文件\",\"35\":\"v-438ffe52#代码演示\",\"36\":\"v-438ffe52#样式化\",\"37\":\"v-438ffe52#交互演示\",\"38\":\"v-438ffe52#vue-交互演示\",\"39\":\"v-438ffe52#幻灯片\",\"40\":\"v-438ffe52@0\",\"41\":\"v-438ffe52@1\",\"42\":\"v-6e19edb7\",\"43\":\"v-6e19edb7#页面信息\",\"44\":\"v-6e19edb7#页面内容\",\"45\":\"v-6e19edb7#页面结构\",\"46\":\"v-6e19edb7@0\",\"47\":\"v-6e19edb7@1\",\"48\":\"v-fffb8e28\",\"49\":\"v-fffb8e28#功能亮点\",\"50\":\"v-fffb8e28#bar\",\"51\":\"v-fffb8e28#foo\",\"52\":\"v-71b3ae87\",\"53\":\"v-71b3ae87#功能亮点\",\"54\":\"v-71b3ae87#bar\",\"55\":\"v-71b3ae87#foo\",\"56\":\"v-5d5c2d30\",\"57\":\"v-5d5c2d30#介绍\",\"58\":\"v-5d5c2d30#详情\",\"59\":\"v-177e1f06\",\"60\":\"v-5d5821d6\",\"61\":\"v-5d5821d6#介绍\",\"62\":\"v-5d5821d6#详情\",\"63\":\"v-0b6fc5f8\",\"64\":\"v-9cffac66\",\"65\":\"v-9cffac66#设计模式有哪些类型\",\"66\":\"v-1110218a\",\"67\":\"v-1110218a#什么是单例模式\",\"68\":\"v-1110218a#单例模式的实现\",\"69\":\"v-1110218a#饿汉模式-线程安全-推荐\",\"70\":\"v-1110218a#双重检查-线程安全-推荐\",\"71\":\"v-1110218a#使用内部类模式-线程安全-推荐\",\"72\":\"v-1110218a#其他\",\"73\":\"v-1110218a#懒汉模式-线程不安全-不推荐\",\"74\":\"v-1110218a#懒汉模式-线程不安全-不推荐-1\",\"75\":\"v-1110218a#源码下载\",\"76\":\"v-3be12559\",\"77\":\"v-3be12559#代码实现\",\"78\":\"v-3be12559#使用适配器模式有什么收益\",\"79\":\"v-3be12559#源码下载\",\"80\":\"v-4b45c2fc\",\"81\":\"v-4b45c2fc#uml图\",\"82\":\"v-4b45c2fc#使用案例\",\"83\":\"v-4b45c2fc#为什么要使用装饰器模式\",\"84\":\"v-4b45c2fc#源码下载\",\"85\":\"v-7f97107a\",\"86\":\"v-7f97107a#责任链模式的uml图\",\"87\":\"v-7f97107a#案例实战\",\"88\":\"v-7f97107a#为什么要使用责任链模式\",\"89\":\"v-9b0dc620\",\"90\":\"v-9b0dc620#简单工厂\",\"91\":\"v-9b0dc620#uml图\",\"92\":\"v-9b0dc620#代码实现\",\"93\":\"v-9b0dc620#工厂方法模式\",\"94\":\"v-9b0dc620#uml图-1\",\"95\":\"v-9b0dc620#代码实现-1\",\"96\":\"v-9b0dc620#抽象工厂\",\"97\":\"v-9b0dc620#uml图-2\",\"98\":\"v-9b0dc620#代码实现-2\",\"99\":\"v-63d3fd84\",\"100\":\"v-63d3fd84#观察者模式uml图\",\"101\":\"v-63d3fd84#案例实战\",\"102\":\"v-63d3fd84#为什么要使用观察者模式\",\"103\":\"v-a950132e\",\"104\":\"v-a950132e#静态代理\",\"105\":\"v-a950132e#代码实现\",\"106\":\"v-a950132e#动态代理\",\"107\":\"v-a950132e#java-动态代理\",\"108\":\"v-a950132e#cglib代码\",\"109\":\"v-7e340ee0\",\"110\":\"v-7e340ee0#打造亿级流量的监控系统\",\"111\":\"v-69099ac7\",\"112\":\"v-69099ac7#什么是prometheus\",\"113\":\"v-69099ac7#prometheus提供的特性\",\"114\":\"v-69099ac7#组件\",\"115\":\"v-69099ac7#架构\",\"116\":\"v-69099ac7#prometheus适用的场景\",\"117\":\"v-300045a1\",\"118\":\"v-300045a1#安装prometheus\",\"119\":\"v-300045a1#prometheus配置文件讲解\",\"120\":\"v-300045a1#采集node-exporter的指标\",\"121\":\"v-300045a1#prometheus配置文件热更新\",\"122\":\"v-300045a1#grafana安装\",\"123\":\"v-300045a1#总结\",\"124\":\"v-0890d0c6\",\"125\":\"v-0890d0c6#什么是time-series\",\"126\":\"v-0890d0c6#指标的类型\",\"127\":\"v-0890d0c6#counter-累加器\",\"128\":\"v-0890d0c6#gauge仪表盘\",\"129\":\"v-0890d0c6#histogram直方图\",\"130\":\"v-0890d0c6#summary\",\"131\":\"v-40c62e56\",\"132\":\"v-40c62e56#瞬时向量查询-instant-vector-selectors\",\"133\":\"v-40c62e56#范围向量查询-range-vector-selectors\",\"134\":\"v-40c62e56#offset-时间位移操作\",\"135\":\"v-40c62e56#操作符\",\"136\":\"v-40c62e56#数学操作符\",\"137\":\"v-40c62e56#比较操作符\",\"138\":\"v-40c62e56#逻辑运算符\",\"139\":\"v-40c62e56#向量匹配符号-vector-matching\",\"140\":\"v-40c62e56#分组修改器-group-modifiers\",\"141\":\"v-40c62e56#聚合函数\",\"142\":\"v-40c62e56#其他常见的函数\",\"143\":\"v-40c62e56#计算counter的增长率\",\"144\":\"v-40c62e56#预测指标变化趋势\",\"145\":\"v-40c62e56#计算分位数\",\"146\":\"v-40c62e56#总结\",\"147\":\"v-a5f16108\",\"148\":\"v-a5f16108#方案一-使用spring-boot-starter-actuator\",\"149\":\"v-a5f16108#方案二-使用prometheus\",\"150\":\"v-a5f16108#配置prometheus采集\",\"151\":\"v-a5f16108#配置grafana视图\",\"152\":\"v-9930b448\",\"153\":\"v-9930b448#alertmanager介绍\",\"154\":\"v-9930b448#分组\",\"155\":\"v-9930b448#抑制\",\"156\":\"v-9930b448#静默\",\"157\":\"v-9930b448#alertmanager安装\",\"158\":\"v-9930b448#配置讲解\",\"159\":\"v-9930b448#在prometheus中配置告警规则\",\"160\":\"v-9930b448#alertmanager查看告警消息\",\"161\":\"v-9930b448#webhook\",\"162\":\"v-9930b448#参考文档\",\"163\":\"v-012ad836\",\"164\":\"v-012ad836#定义recoding-rules\",\"165\":\"v-012ad836#recording-rule的最佳实践\",\"166\":\"v-012ad836#命名规范\",\"167\":\"v-012ad836#实战\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[6],\"1\":[1,12],\"2\":[1,12],\"3\":[1],\"4\":[1],\"5\":[1,5],\"6\":[null,null,1],\"7\":[1,18],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[1,7],\"11\":[null,null,1],\"12\":[null,null,1],\"13\":[2,11],\"14\":[2,8],\"15\":[2,13],\"16\":[2,11],\"17\":[2,10],\"18\":[1,10],\"19\":[1,19],\"20\":[1,1],\"21\":[1,3],\"22\":[1,3],\"23\":[1,5],\"24\":[1,3],\"25\":[1,3],\"26\":[1,5],\"27\":[1,2],\"28\":[1,23],\"29\":[1,1],\"30\":[1,1],\"31\":[1,1],\"32\":[1,1],\"33\":[2,10],\"34\":[1,6],\"35\":[1,1],\"36\":[1,5],\"37\":[1,1],\"38\":[2,1],\"39\":[1,3],\"40\":[null,null,1],\"41\":[null,null,1],\"42\":[1,3],\"43\":[1,20],\"44\":[1,17],\"45\":[1,16],\"46\":[null,null,1],\"47\":[null,null,2],\"48\":[1],\"49\":[1],\"50\":[1,2],\"51\":[1,2],\"52\":[1],\"53\":[1],\"54\":[1,2],\"55\":[1,2],\"56\":[2],\"57\":[1,4],\"58\":[1,2],\"59\":[1,2],\"60\":[2],\"61\":[1,4],\"62\":[1,2],\"63\":[1,2],\"64\":[1,35],\"65\":[2,8],\"66\":[1],\"67\":[1,22],\"68\":[1,12],\"69\":[4,29],\"70\":[4,59],\"71\":[4,28],\"72\":[1,4],\"73\":[4,17],\"74\":[4,20],\"75\":[1,15],\"76\":[1,34],\"77\":[1,49],\"78\":[1,31],\"79\":[1],\"80\":[1,17],\"81\":[1,32],\"82\":[1,155],\"83\":[2,24],\"84\":[1],\"85\":[1,8],\"86\":[1,13],\"87\":[1,88],\"88\":[1,41],\"89\":[1],\"90\":[1,10],\"91\":[1,14],\"92\":[1,65],\"93\":[1,10],\"94\":[1,19],\"95\":[1,49],\"96\":[1,15],\"97\":[1,18],\"98\":[1,64],\"99\":[1,8],\"100\":[1,29],\"101\":[1,71],\"102\":[1,33],\"103\":[1,18],\"104\":[1,27],\"105\":[1,43],\"106\":[1,4],\"107\":[2,91],\"108\":[1,108],\"109\":[1],\"110\":[1,14],\"111\":[1],\"112\":[1,22],\"113\":[1,29],\"114\":[1,23],\"115\":[1,30],\"116\":[1,41],\"117\":[1,12],\"118\":[1,37],\"119\":[1,125],\"120\":[2,52],\"121\":[1,17],\"122\":[1,65],\"123\":[1,10],\"124\":[1],\"125\":[2,79],\"126\":[1,41],\"127\":[2,23],\"128\":[1,25],\"129\":[1,66],\"130\":[1,47],\"131\":[1,15],\"132\":[5,55],\"133\":[5,37],\"134\":[2,18],\"135\":[1],\"136\":[1,53],\"137\":[1,20],\"138\":[1,16],\"139\":[3,21],\"140\":[3,46],\"141\":[1,88],\"142\":[1],\"143\":[1,46],\"144\":[1,23],\"145\":[1,51],\"146\":[1,13],\"147\":[1,7],\"148\":[5,106],\"149\":[2,172],\"150\":[1,15],\"151\":[1,22],\"152\":[1,37],\"153\":[1,10],\"154\":[1,16],\"155\":[1,7],\"156\":[1,15],\"157\":[1,66],\"158\":[1,145],\"159\":[1,78],\"160\":[1,8],\"161\":[1,84],\"162\":[1,27],\"163\":[3,9],\"164\":[2,56],\"165\":[2,5],\"166\":[1,69],\"167\":[1,46]},\"averageFieldLength\":[1.3697099096555616,25.37256572226298,0.49126766091051804],\"storedFields\":{\"0\":{\"h\":\"方志朋,Java,Spring,Spring Boot,Spring Cloud,Java后端技术\"},\"1\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"2\":{\"h\":\"更新计划\",\"t\":[\"这是项目主页的案例。你可以在这里放置你的主体内容。\",\"想要使用此布局，你需要在页面 front matter 中设置 home: true。\",\"配置项的相关说明详见 项目主页配置。\"]},\"3\":{\"h\":\"幻灯片页\"},\"4\":{\"h\":\"主要功能与配置演示\"},\"5\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"6\":{\"c\":[\"使用指南\"]},\"7\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"禁用\"]},\"10\":{\"h\":\"密码加密的文章\",\"t\":[\"实际的文章内容。\",\"段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。\",\"段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。\"]},\"11\":{\"c\":[\"使用指南\"]},\"12\":{\"c\":[\"文章加密\"]},\"13\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你应该创建和编写 Markdown 文件，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"14\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"15\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"相关信息\",\"Frontmatter 是 VuePress 中很重要的一个概念，如果你不了解它，你需要阅读 Frontmatter 介绍。\"]},\"16\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"17\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"18\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"19\":{\"h\":\"自定义容器\",\"t\":[\"安全的在 Markdown 中使用 {{ variable }}。\",\"自定义标题\",\"信息容器，包含 代码 与 链接。\",\"const a = 1; \",\"自定义标题\",\"提示容器\",\"自定义标题\",\"警告容器\",\"自定义标题\",\"危险容器\",\"自定义标题\",\"详情容器\",\"查看详情\"]},\"20\":{\"h\":\"代码块\",\"t\":[\"查看详情\"]},\"21\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"22\":{\"h\":\"自定义对齐\",\"t\":[\"我是居中的\",\"我在右对齐\",\"查看详情\"]},\"23\":{\"h\":\"Attrs\",\"t\":[\"一个拥有 ID 的 单词。\",\"查看详情\"]},\"24\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"25\":{\"h\":\"标记\",\"t\":[\"你可以标记 重要的内容 。\",\"查看详情\"]},\"26\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"27\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小\",\"查看详情\"]},\"28\":{\"h\":\"卡片\",\"t\":[\"title: Mr.Hope desc: Where there is light, there is hope logo: https://mister-hope.com/logo.svg link: https://mister-hope.com color: rgba(253, 230, 138, 0.15) \",\"查看详情\"]},\"29\":{\"h\":\"图表\",\"t\":[\"查看详情\"]},\"30\":{\"h\":\"Echarts\",\"t\":[\"查看详情\"]},\"31\":{\"h\":\"流程图\",\"t\":[\"查看详情\"]},\"32\":{\"h\":\"Mermaid\",\"t\":[\"查看详情\"]},\"33\":{\"h\":\"Tex 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"34\":{\"h\":\"导入文件\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\",\"查看详情\"]},\"35\":{\"h\":\"代码演示\",\"t\":[\"查看详情\"]},\"36\":{\"h\":\"样式化\",\"t\":[\"向 Mr.Hope 捐赠一杯咖啡。 \",\"查看详情\"]},\"37\":{\"h\":\"交互演示\",\"t\":[\"查看详情\"]},\"38\":{\"h\":\"Vue 交互演示\",\"t\":[\"查看详情\"]},\"39\":{\"h\":\"幻灯片\",\"t\":[\"查看详情\",\"这是脚注内容 ↩︎\"]},\"40\":{\"c\":[\"使用指南\"]},\"41\":{\"c\":[\"Markdown\"]},\"42\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"43\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"44\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用:\",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},\"45\":{\"h\":\"页面结构\",\"t\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]},\"46\":{\"c\":[\"使用指南\"]},\"47\":{\"c\":[\"页面配置\",\"使用指南\"]},\"48\":{\"h\":\"指南\"},\"49\":{\"h\":\"功能亮点\"},\"50\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"51\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"52\":{\"h\":\"指南\"},\"53\":{\"h\":\"功能亮点\"},\"54\":{\"h\":\"Bar\",\"t\":[\"baz\",\"...\"]},\"55\":{\"h\":\"Foo\",\"t\":[\"ray\",\"...\"]},\"56\":{\"h\":\"Bar 功能\"},\"57\":{\"h\":\"介绍\",\"t\":[\"我们支持 bar 功能，...\"]},\"58\":{\"h\":\"详情\",\"t\":[\"baz\",\"...\"]},\"59\":{\"h\":\"Baz\",\"t\":[\"功能详情...\"]},\"60\":{\"h\":\"Foo 功能\"},\"61\":{\"h\":\"介绍\",\"t\":[\"我们支持 foo 功能，...\"]},\"62\":{\"h\":\"详情\",\"t\":[\"ray\",\"...\"]},\"63\":{\"h\":\"Ray\",\"t\":[\"功能详情...\"]},\"64\":{\"h\":\"设计模式面试概述\",\"t\":[\"设计模式是软件开发的一种指导思想，它是为了解决具体的编码问题或者是解决某一类问题而产生的。这些年无论是生产环境遇到的事故，还是自己自己做的一些开源项目中，越来越体会到系统是运营出来的，代码质量是设计出来的。无论是在前期的需求分析、方案设计、代码编写，都需要良好的程序设计，这些都离不开设计模式的思想。所以设计模式是程序员的一项基本功。\",\"那么如何学习好设计模式呢，我觉得需要刻意练习，说的简单一点就是多写、多练、多应用。\",\"这些年技术层出不穷，新的框架、新的工具、新的软件开发模式，都会让程序员在技术的海洋里迷失。无论面对什么的环境，我们需要有一些专注力，刻意的去练习、要深挖技术背后的原因，要做到知其然并知其所以然。不能东一榔头西一棒槌，这样只会原地踏步走。\",\"那本系列教程将会讲述23种经典的设计模式，有两个目标：\",\"优先讲解面试过程中常见遇到的几种设计模式；剩下的设计模式会在写完Java面试系列文章之后做为补充。\",\"尽量以通俗易懂的语言和代码案例去讲述。\"]},\"65\":{\"h\":\"设计模式有哪些类型？\",\"t\":[\"结构型设计模式一共包括七种：适配器模式、桥接模式、组合模式、装饰模式、门面模式、享元模式和代理模式。\"]},\"66\":{\"h\":\"单例模式\"},\"67\":{\"h\":\"什么是单例模式\",\"t\":[\"单例模式在允许在全局中只存在一个实例，并提供一个方法，让其他的对象可以访问这个实例。单例模式可以解决一个全局的使用的实例，防止它频繁的被创建或者被销毁，从而提高整个系统的性能。单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的。\",\"在什么样的场景会使用到单列模式呢？\",\"需要表示全局唯一的对象，比如id生成器，比如工具类，或者访问资源配置文件的reader。这些对象一般只提供具体的方法、不提供全局的共享变量。在系统中只需要初始化一个实例，就能够提供给其他对象在各个地方使用。\",\"使用单例模式有什么好处呢？\",\"可以节约系统的资源，防止对象的频繁创建\",\"提升代码的复用性\",\"统一全局的访问点控制，方便统一管理和修改\"]},\"68\":{\"h\":\"单例模式的实现\",\"t\":[\"如下图的UML图，单例模式声明了一个名为 instance 的静态对象和 get­Instance() 的方法，静态对象用来存储对象自身的属性和方法，静态方法用来返回其所属类的一个相同实例。这里我们以单例模式经典的懒汉式初始化方式为例，其代码实现如下：\",\"image-20231030213851667\"]},\"69\":{\"h\":\"饿汉模式（线程安全，推荐）\",\"t\":[\"单例模式不需要对外提供构造方法，只允许通过getInstance()方法获取实例，在下面的案例中，会在程序的类的加载过程中，自动创建hugryInstance的静态实例，然后getInstance()去提供获取对象的服务。这种模式是在类加载的时候就完成了对象的实例化，类加载是加锁的，所以它是线程安全的。这种模式称为饿汉模式。\",\"饿汉模式类似于Spring框架初始化Bean实例，都是在程序启动之初创建。虽然可能会造成一定资源开销和浪费，但是由于简单、安全，所以还是比较推荐的。\",\"public class HugryInstance { private static HugryInstance hugryInstance = new HugryInstance(); private HugryInstance() { } public static HugryInstance getInstance() { return hugryInstance; } } \"]},\"70\":{\"h\":\"双重检查（线程安全，推荐）\",\"t\":[\"这种双重检查模式经常在面试中被考察，近几年由于八股文泛滥，可能问的少一些。\",\"public class LazyInstance { private static volatile LazyInstance instance; private LazyInstance() { } public static LazyInstance getInstance() { if (instance == null) { synchronized (LazyInstance.class) { if (instance == null) { instance = new LazyInstance(); } } } return instance; } } \",\"双重检查模式，它属于懒汉模式，只有第一次调用getSingleton()方法才会初始化实例instance。\",\"同时它是线程安全的，使用同步代码块来保证线程的安全。\",\"使用双重检查来判断实例是否初始化，减少同步创建实例的开销。\",\"那为什么要使用volatile关键字来修饰静态的instance对象呢？\",\"在java中创建一个对象，需要如下几步，伪代码如下：\",\"memory=allocate(); //1：分配内存空间 ctorInstance(); //2:初始化对象 singleton=memory; //3:设置singleton指向刚分配的内存空间 \",\"当线程1在执行上面伪代码时，2和3可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以JVM是允许的。如果此时伪代码发生重排序，步骤变为1->3->2，线程1执行到第3步时，线程2调用getsingleton方法，在判断singleton==null时不为null，则返回singleton。但此时singleton并还没初始化完毕，线程2访问的将是个还没初始化完毕的对象。这时程序会出错！\",\"当声明对象的引用为volatile后，伪代码的2、3的重排序在多线程中将被禁止!\"]},\"71\":{\"h\":\"使用内部类模式（线程安全，推荐）\",\"t\":[\"public class InnerClzSingleton { private InnerClzSingleton(){ } public static InnerClzSingleton getSingleton(){ return Inner.instance; } private static class Inner { private static final InnerClzSingleton instance = new InnerClzSingleton(); } } \",\"使用内部类的模式，有以下的优点在：\",\"延迟初始化，属于懒汉模式，需要第一次调用getSingleton()方法，才会初始化内部类。\",\"线程安全，Jvm在执行类的初始化的时候，会进行加锁初始化，在多线程的情况下，也不会频繁创建对象。\",\"所以它属于线程安全的懒汉模式，和双重检查模式一样，但是代码比双重检查模式简洁。\"]},\"72\":{\"h\":\"其他\",\"t\":[\"单例模式除了上面的写法，还有其他的写法，但是不太推荐。\"]},\"73\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是最简单的懒汉模式的单列模式，这种情况下在多线程下是不安全的，可能会同时存在多个实例的创建。\",\"public class LazyInstanceNoSafe { private static LazyInstanceNoSafe instance; private LazyInstanceNoSafe() { } public static LazyInstanceNoSafe getInstance() { if (instance == null) { instance = new LazyInstanceNoSafe(); } return instance; } } \"]},\"74\":{\"h\":\"懒汉模式（线程不安全，不推荐）\",\"t\":[\"下面是懒汉模式的线程安全的，但是在方法上加了锁，在访问的时候需要锁占用，会导致一定的资源开销和性能下降。此种模式是不推荐的。\",\"public class LazyInstanceSafe { private static LazyInstanceSafe instance; private LazyInstanceSafe() { } public static synchronized LazyInstanceSafe getInstance() { if (instance == null) { instance = new LazyInstanceSafe(); } return instance; } } \"]},\"75\":{\"h\":\"源码下载\",\"t\":[\"https://github.com/forezp/Java-Labs/tree/main/design-pattern-lab/src/main/java/io/github/forezp/java/design/sington\"]},\"76\":{\"h\":\"适配器模式\",\"t\":[\"今天这一讲，我们主要讲解最常用到的适配器模式。\",\"在程序中，经常需要新的项目中需要对老代码进行适配才能用。适配器模式就是将旧代码和新程序的中间的转换角色。举个现实例子，比如我们的MAC电脑需要连接USB接口的键盘，但是MAC电脑只有typec接口，这时我们需要一个拓展坞，需要把typec接口转换成USB接口，给键盘使用，如图所示：\",\"适配器模式的定义是：将类的接口转换为客户期望的另一个接口，适配器可以让不兼容的两个类一起协同工作。\",\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解，它的UML图如下所示：\",\"从 UML 图中，我们可以看出适配器模式中包含三个关键角色：\",\"目标类Target， 适配器类即将要进行适配的抽象类或接口，比如TypeC接口；\",\"适配器类Adapter，是作为适配的中间类，它必须持有或者实现目标类和适配类的接口，比如拓展坞类实现了目标接口TypeC接口，持有适配者的类Keyboard；\",\"需要被适配器转换的对象 Adaptee, 比如图中的键盘（实现了USB接口）。\"]},\"77\":{\"h\":\"代码实现\",\"t\":[\"需要被适配的接口USB接口：\",\"public interface IUsb { void connect(int x, int y); } \",\"需要被适配的接口的实现类，比如案例中Keyboard：\",\"public class Keyboard implements IUsb{ @Override public void connect(int x, int y) { System.out.println(\\\"keyborad 连上了usb接口\\\"); } } \",\"目标接口ITypeC：\",\"public interface ITypeC { void connect(int x, int y,int z); } \",\"ExpansionDockAdapter（拓展坞适配器）实现了ITypeC的目标接口接口，ExpansionDockAdapter并持有需要被适配的IUsb接口，适配器只有同时实现或者持有目标接口和被适配的对象，才能进行适配工作：\",\"public class ExpansionDockAdapter implements ITypeC{ private IUsb iUsb; public ExpansionDockAdapter(IUsb iUsb) { this.iUsb = iUsb; } @Override public void connect(int x, int y, int z) { System.out.println(\\\"拓展坞将Typec接口转换成USB接口\\\"); iUsb.connect(x,y); } } \",\"最后，可以调用客户端对它们调用：\",\"public class McClient { public static void main(String[] args) { Keyboard keyboard = new Keyboard(); ExpansionDockAdapter adapter = new ExpansionDockAdapter(keyboard); System.out.println(\\\"mac连接typec\\\"); adapter.connect(1, 2, 3); } } \"]},\"78\":{\"h\":\"使用适配器模式有什么收益\",\"t\":[\"可能有很多人比较疑惑，如果在目标类中，新写一个方法就可以将需要适配的类进行转换。那么为什么还需要使用适配器模式呢？\",\"首先 ，是为了保持简单性，正如mac电脑一样，它只提供TypeC接口。由拓展坞去做USB或者是HDMI接口的转换。保证了MAC电脑对外接口的简单性。\",\"单一职责，不同的角色做不同的事，没有必要将多个事情给一个角色做完，这样代码会非常的臃肿，难以维护。\",\"可复用，将适配器这个角色进行高度抽象化，可以做到移植可复用\",\"使用适配器模式有以下的优点：\",\"将目标类和适配的类解耦，引入一个适配器类兼容现有目标类，拓展新的适配者类功能，很好的避免了现有类和适配者类的耦合。\",\"单一职责，目标类和适配者类各司其职，互不干扰。\",\"满足里氏替换原则。 目标类和适配者类是通过适配器进行交互的，适配器类只要不影响目标类的接口功能，适配者类无论出现什么新功能，都很方便替换。\"]},\"79\":{\"h\":\"源码下载\"},\"80\":{\"h\":\"装饰器模式\",\"t\":[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能，相当于对原有的类进行类一个包装，它又称为包装器模式。\",\"在Java的IO源码中，使用到了包装器模式，比如在以下的代码中，BufferedReader和FileReader都是使用到包装器模式，各种Reader一层套一层，进行数据的转换或者功能的增强。\",\" fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); \"]},\"81\":{\"h\":\"UML图\",\"t\":[\"image-20231102232111957\",\"上图是装饰器的UML图，在图中一共有三个角色：\",\"组件Component，它是目标接口，定义目标的方法\",\"组件实现类ComponentImpl，它实现了目标接口\",\"装饰器ComponentDecoratorB和ComponentDecoratorA \",\"ComponentDecoratorB，它实现了目标接口，并持有组件实现类ComponentImpl\",\"ComponentDecoratorA，它实现了目标接口，并持有装饰器ComponentDecoratorB\",\"ComponentImpl提供基本的实现方法，在不改变了ComponentImpl的情况下，ComponentDecoratorB和ComponentDecoratorA分别对ComponentImpl进行了增强。\",\"什么时候使用装饰器模式\",\"一般来讲，装饰模式不改变原有类的结构，是不能改变原有的基础功能，只能在原有的基础功能之上做进一步增强。一般情况下，装饰器模式经常使用到以下场景：\",\"一个组件可以有很多个装饰器，不同的装饰器有不同的功能，可以按照需要使用不同装饰器组合。在扩展性上，装饰器非常的灵活。\",\"原有的类不支持继承，比如使用类final关键字的类。\"]},\"82\":{\"h\":\"使用案例\",\"t\":[\"在案例模仿JavaIO的文件流的写入和读取功能，在文件流的基础之上使用装饰器模式，做下面的增强功能：\",\"加密装饰器：对写入文件的字符的加密，对读取的字符进行解密\",\"压缩解压装饰器：对写入字符进行压缩，对读取的字符进行解压\",\"可以通过顺序组合包装的方式来附加扩张功能，比如可以先使用加密装饰器，后使用压缩解压装饰器；也可以把他们的顺序对调。\",\"首先，定义一个目标接口ReaderWriter，它有读取和写入的功能：\",\"public interface ReaderWriter { String read(); void write(String content); } \",\"ReaderWriter的基本实现类是FileReaderWriter，它可以把字符写入到文件中，也可以读取文件的字符。\",\"public class FileReaderWriter implements ReaderWriter { private String filePath; public FileReaderWriter(String filePath) { this.filePath = filePath; } @Override public String read() { StringBuilder sb = new StringBuilder(); File file = new File(filePath); BufferedReader bufferedReader = null; FileReader fileReader = null; try { fileReader = new FileReader(file); bufferedReader = new BufferedReader(fileReader); String s; while ((s = bufferedReader.readLine()) != null) { sb.append(s); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileReader != null) { fileReader.close(); } if (bufferedReader != null) { bufferedReader.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } @Override public void write(String content) { File file = new File(filePath); FileWriter fileWriter = null; BufferedWriter bufferedWriter = null; try { fileWriter = new FileWriter(file); bufferedWriter = new BufferedWriter(fileWriter); bufferedWriter.write(content); bufferedWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileWriter != null) { fileWriter.close(); } if (bufferedWriter != null) { bufferedWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } } \",\"EncryptionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行加密\",\"在读取文件的字符之后 ，对读取的字符进行解密\",\"public class EncryptionFileReaderWriter implements ReaderWriter{ private ReaderWriter readerWriter; public EncryptionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decode(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(encode(content)); } private String encode(String data) { byte[] result = data.getBytes(); for (int i = 0; i < result.length; i++) { result[i] += (byte) 1; } return Base64.getEncoder().encodeToString(result); } private String decode(String data) { byte[] result = Base64.getDecoder().decode(data); for (int i = 0; i < result.length; i++) { result[i] -= (byte) 1; } return new String(result); } } \",\"CompressionFileReaderWriter是一个装饰器，它实现了ReaderWriter接口，并持有ReaderWriter的实现类FileReaderWriter，对它进行功能的增强：\",\"在写入文件之前，对写入的字符进行压缩\",\"在读取文件的字符之后 ，对读取的字符进行解压\",\"public class CompressionFileReaderWriter implements ReaderWriter { private ReaderWriter readerWriter; public CompressionFileReaderWriter(ReaderWriter readerWriter) { this.readerWriter = readerWriter; } @Override public String read() { return decompress(readerWriter.read()); } @Override public void write(String content) { readerWriter.write(compress(content)); } private String compress(String stringData) { byte[] data = stringData.getBytes(); try { ByteArrayOutputStream bout = new ByteArrayOutputStream(512); DeflaterOutputStream dos = new DeflaterOutputStream(bout, new Deflater()); dos.write(data); dos.close(); bout.close(); return Base64.getEncoder().encodeToString(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } private String decompress(String stringData) { byte[] data = Base64.getDecoder().decode(stringData); try { InputStream in = new ByteArrayInputStream(data); InflaterInputStream iin = new InflaterInputStream(in); ByteArrayOutputStream bout = new ByteArrayOutputStream(512); int b; while ((b = iin.read()) != -1) { bout.write(b); } in.close(); iin.close(); bout.close(); return new String(bout.toByteArray()); } catch (IOException e) { e.printStackTrace(); return null; } } } \",\"写一个客户端测试类：\",\"定义一个写入的字符串text\",\"定义文件的写入或者读取的路径\",\"然后使用装饰器模式，嵌套了两个装饰器（加减密装饰器和压缩解缩的装饰器），对写入的字符进行先加密再压缩；对读取的字符进行先解压再解密。\",\"具体实现如下：\",\"public class Client { public static void main(String[] args) { String text = \\\"fangzhipeng.com\\\"; String filePath=\\\"/Users/forezp/Downloads//test.txt\\\"; System.out.println(\\\"原始内容：\\\"+text); ReaderWriter rw = new CompressionFileReaderWriter(new EncryptionFileReaderWriter(new FileReaderWriter(filePath))); rw.write(text); FileReaderWriter fileReaderWriter=new FileReaderWriter(filePath); // System.out.println(\\\"加密后、压缩后的内容为：\\\"+fileReaderWriter.read()); System.out.println(\\\"解密后、解缩后的内容为：\\\"+rw.read()); } } \",\"执行测试类，控制台打出的结果如下：\",\"原始内容：fangzhipeng.com 加密后、压缩后的内容为：Zkt5TVQ5eU1zOXNKTUZrT1Q6ZU17dDlHQkVFSENnOT4= 解密后、解缩后的内容为：fangzhipeng.com\",\"Process finished with exit code 0\"]},\"83\":{\"h\":\"为什么要使用装饰器模式？\",\"t\":[\"在讲解完具体案例后，我们来思考一下，为什么要使用装饰器模式，主要原因：\",\"能够快速的扩展现有类的功能，并能自由组合包装各种装饰器，达到不同的效果，也就是能够根据需求，快速的装载和卸载装饰器\",\"希望继承原有类的功能，但又不方便继承。\",\"使用装饰器模式有以下的优点：\",\"代码的可扩展性和可复用性非常的强，对一些基础类无法修改，需要扩展功能的时候，采用装饰器模式能够快速的扩展功能，同时有不会影响原有的公民\",\"满足单一职责的原则。基本功能实现类和不同的装饰器只实现自己的独一的功能，后面加一些功能，可以增加新的装饰器。\",\"可以快速装载和卸载增强功能\",\"可以快速组合，通过包装不同的装饰器组合来满足自己的业务需求\"]},\"84\":{\"h\":\"源码下载\"},\"85\":{\"h\":\"责任链模式\",\"t\":[\"责任链模式在软件开发中，是会经常使用到的一个设计模式，比如对某一次请求进行不同的规则的校验，这些规则的执行有先后顺序，组成了链式的执行顺序。\",\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理。这些在流水线的处理类对象构成了一个单项链表结构。\"]},\"86\":{\"h\":\"责任链模式的UML图\",\"t\":[\"从该UML中中，责任链模式有两个角色：\",\"处理类Handler，可以是一个接口，也可以是一个抽象类。它有一个核心的处理方法，比如handle_request();\",\"处理类的实现类HandlerA、HandlerB、HandlerC，这几个Handler构成了一个链式的处理顺序。\"]},\"87\":{\"h\":\"案例实战\",\"t\":[\"在工作中，我们经常有一些审批流程，现在使用责任链模式去模拟一个向公司借款的流程。在流程中有三个角色，分别是员工、经历、CFO三个角色，根据借款金额的不同，需要不同的审批角色。\",\"当借款金额小于1000元，只需要财务审批\",\"当借款金额大于1000元小于5000元，需要经理审批\",\"当借款金额大于5000元小于10000元，需要CFO审批\",\"当借款金额大于10000元，审批拒绝。\",\"首先创建一个审批抽象类Aproval，有一个核心的抽象处理方法handle(int amount)和持有一个Aproval对象。\",\"public abstract class Aproval { private Aproval nextApproval; public abstract void handle(int amount); public Aproval getNextApproval() { return nextApproval; } public void setNextApproval(Aproval nextApproval) { this.nextApproval = nextApproval; } } \",\"Staff（财务）继承了Aproval，并实现了handle(int amount)方法，里面有具体的处理逻辑，它只能审批1000元以下的借款。\",\"public class Staff extends Aproval { @Override public void handle(int amount) { if(amount<1000){ System.out.println(\\\"审批通过\\\"); }else { System.out.println(\\\"财物权限不够，需要经理审批\\\"); getNextApproval().handle(amount); } } } \",\"Manager继承了Aproval，并实现了handle(int amount)方法，它能审批5000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class Manager extends Aproval { @Override public void handle(int amount) { if (amount < 5000) { System.out.println(\\\"经理审批通过\\\"); } else { System.out.println(\\\"经理权限不够，需要总裁审批\\\"); getNextApproval().handle(amount); } } } \",\"CFO继承了Aproval，并实现了handle(int amount)方法，它能审批10000元以下的借款。\",\"package io.github.forezp.java.design.chain; public class CFO extends Aproval { @Override public void handle(int amount) { if (amount < 10000) { System.out.println(\\\"cfo审批通过\\\"); } else { System.out.println(\\\"金额太大，审批不通过\\\"); } } } \",\"写一个测试类，将三个审批角色组成一个责任链模式的审批流，并向审批流的第一角色handle(9000)：\",\"public class Client { public static void main(String[] args) { Staff staff = new Staff(); Manager manager = new Manager(); CFO cfo = new CFO(); staff.setNextApproval(manager); manager.setNextApproval(cfo); staff.handle(9000); } } \",\"运行代码处理结果如下：\",\"财物权限不够，需要经理审批 经理权限不够，需要总裁审批 cfo审批通过\"]},\"88\":{\"h\":\"为什么要使用责任链模式\",\"t\":[\"从上面的使用场景，我们可以得出以下的一些结论，使用责任链的原因有：\",\"使用责任链模式可以将一个大而复杂的判断逻辑，分成多个小的逻辑单元，每个逻辑单元组成了链中的一环。每个逻辑单元的功能都是解藕的。\",\"可以动态的扩展责任链中的逻辑单元，当需要扩展新的功能，可以写一个Handler即可\",\"也可以根据需求快速的删除一些逻辑单元，并且可以根据需要快速的组合逻辑单元\",\"从上面的分析原因我们可以得出，使用责任链有以下的优点：\",\"降低逻辑单元之间的耦合度，不同的逻辑单元的处理逻辑不耦合，提高了系统的灵活性和可维护性。\",\"提升代码的可扩展性，可以快速的装载和卸载逻辑单元，提供整个责任链的可扩展性。可以根据不同的需求，制定不同的处理流程，而且不需要修改现有的代码\",\"符合开闭原则：责任链模式将处理逻辑放在链式的逻辑单元中处理，新增一个逻辑功能，并不需要改变原有的逻辑功能\",\"可以灵活的控制责任链中逻辑单元的处理顺序\",\"总之，责任链模式可以提供一种灵活、可扩展和可维护的链式处理的机制，使系统能够更好地应对变化和复杂性。但需要防止责任链模式有过多的处理逻辑单元，如果处理链路过长，系统出错，很难去排查，也有可能影响系统的性能。所以我们在实际的使用过程中，需要权衡一下利弊，根据实际的情况做设计和优化。\"]},\"89\":{\"h\":\"工厂模式\"},\"90\":{\"h\":\"简单工厂\",\"t\":[\"简单工厂模式（Simple Factory Pattern）也称为静态工厂方法模式，属于创建型设计模式的一种。简单工厂模式提供一个简单的工厂类，根据传入参数的不同，返回不同类的实例对象。\"]},\"91\":{\"h\":\"UML图\",\"t\":[\"简单工厂包含如下角色：\",\"工厂类（SimpleSofaFactory）:负责创建实例对象的类，提供一个静态工厂方法用于创建不同的产品对象。工厂类根据客户端传入的参数来创建相应的产品对象。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"92\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象产品类（Sofa），它有一个抽象方法getName()和一个具体方法showName()\",\"public abstract class Sofa { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" sofa\\\"); } } \",\"ChineseSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class ChineseSofa extends Sofa { @Override String getName() { return \\\"china\\\"; } } \",\"AmericaSofa类实现了抽象产品类（Sofa）的抽象方法getName()。\",\"public class AmericaSofa extends Sofa{ @Override String getName() { return \\\"america\\\"; } } \",\"工厂类（SimpleSofaFactory）根据客户端传入的参数来创建相应的产品对象Sofa。\",\"public class SimpleFactory { public Sofa createCoffee(String type) { Sofa sofa = null; if(\\\"us\\\".equals(type)) { sofa = new AmericaSofa(); } else if(\\\"cn\\\".equals(type)) { sofa = new ChineseSofa(); } return sofa; } } \",\"写一个客户端，测试类：\",\"public class Client { public static void main(String[] args) { SimpleFactory factory = new SimpleFactory(); Sofa sofa = factory.createSofa(\\\"cn\\\"); sofa.showName(); } } \",\"运行结果如下：\",\"china sofa\",\"简单工厂模式是一种常见的设计模式，它具有如下的优点：\",\"工厂类包含了必要的逻辑判断，可以根据客户端的需求，动态地实例化具体的产品类。\",\"系统扩展性好，如果需要增加新的产品类，只需要修改工厂类的逻辑判断即可。\",\"那它的缺点是：\",\"工厂类包含了所有产品对象的创建逻辑，导致工厂类的代码会随着产品类型的增多而变得越来越复杂。\",\"违反了单一职责原则（SRP），工厂类负责了两个职责：创建和业务逻辑判断。\"]},\"93\":{\"h\":\"工厂方法模式\",\"t\":[\"工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个创建对象的接口，但由子类来决定要实例化哪个类，就是将实例化工作交给子类完成。工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题。\"]},\"94\":{\"h\":\"UML图\",\"t\":[\"image-20231105210628018\",\"工厂方法模式包含以下角色：\",\"抽象工厂（IFactory）：定义了一个工厂方法makeSofa()，用于创建产品对象的接口。\",\"具体工厂（ChineseSofaFactory）：实现抽象工厂类中定义的工厂方法makeSofa，返回一个具体的产品对象Sofa。\",\"抽象产品类（Sofa）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（Chinese Sofa）：实现了抽象产品类的属性和方法。\"]},\"95\":{\"h\":\"代码实现\",\"t\":[\"定义一个接口IFactory，它有一个createSofa()的方法：\",\"public interface IFactory { Sofa createSofa(); } \",\"IFactory的具体实现类ChineseSofaFactory：\",\"public class ChineseSofaFactory implements IFactory { @Override public Sofa createSofa() { return new ChineseSofa(); } } \",\"IFactory的具体实现类AmericaSofaFactory：\",\"public class AmericaSofaFactory implements IFactory{ @Override public Sofa createSofa() { return new AmericaSofa(); } } \",\"写一个客户端用于测试：\",\"public class Client { public static void main(String[] args) { IFactory factory=new ChineseSofaFactory(); Sofa sofa =factory.createSofa(); sofa.showName(); } } \",\"上面的测试输出结果：\",\"china sofa\",\"使用工厂方法模式的好处是：\",\"客户端通过抽象工厂来创建产品对象，可以方便地创建出不同的产品对象，而不需要了解具体的实现类。\",\"不同的产品由不同的工厂创建，符合单一职责原则，相对于简单工厂，具体工厂类的代码更加简洁。\",\"具备良好的扩展性，增加新的产品和新的工厂非常容易，无需修改已有代码。\",\"使用工厂方法模式的缺点是：\",\"大量的类：每个具体产品都需要一个具体工厂类来创建，会导致类的数量增加，增加了系统的复杂度。\"]},\"96\":{\"h\":\"抽象工厂\",\"t\":[\"工厂方法模式中考虑的是一类产品的生产，比如sofa的生产，但现实生活中，有很多同类型的产品生产，比如家具厂除了生产沙发，还生产桌子、椅子。\",\"抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个创建一系列相关对象的接口，而无需指定具体实现类。\"]},\"97\":{\"h\":\"UML图\",\"t\":[\"抽象工厂的UML图如下：\",\"抽象工厂模式包含以下角色：\",\"抽象工厂（IFurnitureFactory）：定义了一系列可以创建不同产品对象的方法，每个方法对应一个具体产品类的创建方法。\",\"具体工厂（FurnitureFactory ）：实现了抽象工厂接口，负责创建一族相关的具体产品对象。\",\"抽象产品类（Table）：由工厂类创建的对象的抽象类或接口，定义了产品类的属性和方法。\",\"具体产品类（ChineseTable）：实现了抽象产品类的属性和方法。\"]},\"98\":{\"h\":\"代码实现\",\"t\":[\"抽象产品类（Table），代码如下：\",\"public abstract class Table { abstract String getName(); public void showName(){ System.out.println(getName()+\\\" table\\\"); } } \",\"具体产品类（ChineseTable），代码如下：\",\"public class ChineseTable extends Table{ @Override String getName() { return \\\"china\\\"; } } \",\"抽象工厂（IFurnitureFactory），定义了makeSofa()和makeTable()方法，代码如下：\",\"public interface IFurnitureFactory { Sofa makeSofa(); Table makeTable(); } \",\"具体工厂（FurnitureFactory ）实现了抽象工厂（IFurnitureFactory）中的创建对象的方法：\",\"public class FurnitureFactory implements IFurnitureFactory { @Override public Sofa makeSofa() { return new ChineseSofa(); } @Override public Table makeTable() { return new ChineseTable(); } } \",\"写一个测试类，该类使用抽象工厂模式创建不同的产品对象，代码如下：\",\"public class Client { public static void main(String[] args) { IFurnitureFactory factory = new FurnitureFactory(); Sofa sofa= factory.makeSofa(); Table table= factory.makeTable(); sofa.showName(); table.showName(); } } \",\"运行上面的代码，输出如下：\",\"china sofa china table\",\"抽象工厂模式提供了一种创建一族相关对象的方法，能够实现不同产品族的兼容性和高度可扩展性，它具有以下的优点：\",\"可以创建一系列相关的产品对象，保证了这些对象之间的兼容性。\",\"客户端代码与具体产品的创建实现了解耦\",\"符合开闭原则，新增一族产品时，只需要增加相应的具体产品类和工厂类即可。\",\"同时它具有以下的缺点：\",\"新增产品族、比较困难，需要修改抽象工厂的接口和具体工厂类。\",\"增加系统的复杂性\"]},\"99\":{\"h\":\"观察者模式\",\"t\":[\"观察者模式（Observer Pattern）是一种行为型设计模式，用于对象之间的一对多的依赖关系，当对象发生改变时，所有依赖于它的对象都会收到通知。\"]},\"100\":{\"h\":\"观察者模式UML图\",\"t\":[\"UML图如下：\",\"image-20231107230028268\",\"从UML图上可以得出，在观察者模式中，有以下的角色：\",\"发布者Publisher：或者被称为被观察者，它维护了一个观察者的列表，并可以动态添加观察者或者删除观察者。\",\"观察者Observer：定义了一个接收发布者消息的方法，当发布者发布消息，观察者会执行该方法。\",\"具体主题（Concrete Subject）：具体主题是主题的具体实现，它维护了一个状态，并在状态改变时通知观察者。\",\"具体观察者（Concrete Observer）：具体观察者是观察者的具体实现，它实现了观察者的更新接口，并定义了观察者接收到通知后的具体行为。\",\"观察者模式在软件开发中有非常多的应用，在GUI中应用的比较多，在消息队列的场景有广泛的应用。\"]},\"101\":{\"h\":\"案例实战\",\"t\":[\"写一个观察者接口Observer，它有一个接收通知对象的方法 notify (Object obj);\",\"package io.github.forezp.java.design.obeserver2; public interface Observer { void notify (Object obj); } \",\"Observer接口的实现类ObserverImpl的代码如下：\",\"package io.github.forezp.java.design.obeserver2; public class ObserverImpl implements Observer { private String name; public ObserverImpl(String name) { this.name = name; } @Override public void notify(Object obj) { System.out.println(name+\\\":\\\"+obj.toString()); } } \",\"消息发布者Publisher接口，可以向它注册观察者对象，也可以用它来向观察者发送消息：\",\"package io.github.forezp.java.design.obeserver2; public interface Publisher { void register(Observer observer); void notify(Object o); } \",\"Publisher接口的实现类PublisherImpl，代码如下：\",\"package io.github.forezp.java.design.obeserver2; import java.util.ArrayList; import java.util.List; public class PublisherImpl implements Publisher { private List<Observer> list = new ArrayList<>(); @Override public void register(Observer observer) { list.add(observer); } @Override public void notify(Object o) { for (int i = 0; i < list.size(); i++) { list.get(i).notify(o); } } } \",\"写一个客户端测试类：\",\"package io.github.forezp.java.design.obeserver2; public class Client { public static void main(String[] args) { Publisher publisher=new PublisherImpl(); publisher.register(new ObserverImpl(\\\"observer1\\\")); publisher.register(new ObserverImpl(\\\"observer2\\\")); publisher.notify(\\\"fangzhipeng.com\\\"); } } \",\"运行结果如下：\",\"observer1:fangzhipeng.com observer2:fangzhipeng.com\"]},\"102\":{\"h\":\"为什么要使用观察者模式\",\"t\":[\"观察者模式的核心思想是将观察者对象注册到发布者对象中，发布者对象可以对所有的观察者发送消息，观察者收到消息后可以做出响应。\",\"使用观察者模式有以下的收益：\",\"主题和观察者之间松耦合，使得发布者和观察者互不影响。对象之间关系也比较清晰。可以利用发布者向所有的观察者发送消息。\",\"可扩展性很强，可以动态地添加和删除观察者，灵活性非常高。如果不使用观察者模式来捕获一个被观察对象的属性变化，那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑，这样不仅增加了代码的耦合性，也让代码扩展变得非常困难。\",\"观察者模式符合开闭原则，增加新的观察者，不需要修改已有的代码。\",\"同时，观察者模式也有一些缺点，比如发布者维护的观察者对象是无顺序的，并且发布者发布消息也是无顺序的，如果需要把证消息发送的顺序，需要做更多的工作。此外，过多的观察者会影响性能，需要做性能测试。\",\"综上所述，观察者模式是一种实用并且简单的设计模式，它能够提高系统的可扩展性和灵活性。但是在使用它的时候需要注意它带来的一些缺点，要做一些优化工作。\"]},\"103\":{\"h\":\"代理模式\",\"t\":[\"代理模式和装饰器模式类似，都是在不改变同一个接口功能的前提下，对原有功能的做扩展或者增强。代理模式并没有做类似于装饰器模式多层嵌套，而是采用灵活的单一结构。在Java语言中并支持动态代理，在很多RPC框架、Spring AOP、Spring事务等领域有着广泛的应用。\",\"代理模式是一种结构性模式，，它允许将对象的访问控制和代码运行位置转移到代理对象中。类似于中介，代理对象可以控制客户端对真实对象的访问。代理模式常用于对已有功能的增强，比如访问控制、远程调用。\"]},\"104\":{\"h\":\"静态代理\",\"t\":[\"代理模式分为静态代理和动态代码，一般静态代理使用的比较少，而动态代理在各种框架、中间件有着广泛的应用。\",\"静态代理需要手动创建一个代理类，实现被代理对象的接口，并将实际对象的方法调用转发给它。静态代理的优点是简单易懂，但缺点是需要手动创建代理类，对于需要代理的类数量较多或变化频繁的情况下，代码会变得臃肿难以维护。\",\"从上面的 UML 图中，我们可以看出代理模式有三个关键角色：\",\"抽象主题接口类（Subject）：它定义了一些方法。\",\"主题实现类（RealSubject）：实现了抽象接口类（的所有方法\",\"代理类（StaticProxy）：实现了抽象主题类的方法，并隐藏在代理后面可能其他类的实现。\"]},\"105\":{\"h\":\"代码实现\",\"t\":[\"定义一个抽象主题类：\",\"public interface Subject { void operation(); } \",\"主题实现类（RealSubject）的代码如下：\",\"public class RealSubject implements Subject{ @Override public void operation() { System.out.println(\\\"do somthing\\\"); } } \",\"代理类（StaticProxy）实现了抽象主题类，并持有主题实现类的对象，并在主题实现类的对象的operation()方法之前和之后做了功能的增强，具体代码如下：\",\"public class StaticProxy implements Subject{ private RealSubject realSubject; public StaticProxy(RealSubject realSubject) { this.realSubject = realSubject; } @Override public void operation() { System.out.println(\\\"before operation...\\\"); realSubject.operation(); System.out.println(\\\"after operation...\\\"); } } \",\"写一个客户端实现类，代码如下：\",\"public class Client { public static void main(String[] args) { testStatic(); } public static void testStatic() { StaticProxy staticProxy = new StaticProxy(new RealSubject()); staticProxy.operation(); } } \",\"运行代码，输出如下：\",\"before operation... do somthing after operation...\"]},\"106\":{\"h\":\"动态代理\",\"t\":[\"动态代理可以使用 Java 动态代理机制和CGLIB动态代理。\"]},\"107\":{\"h\":\"Java 动态代理\",\"t\":[\"Java 动态代理是在运行时自动生成代理类并将方法调用转发到实际对象。 Java 动态代理的优点是避免了手动创建代理类的麻烦，但缺点是对于一些无法实现接口的类，无法使用动态代理。\",\"Java 动态代理是使用Java的反射机制来实现动态代理。Java提供了java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。\",\"具体使用Java 动态代理的步骤是先实现InvocationHandler接口。和静态代理类似：在这个接口中，需要对真实的代理对象的功能需要做一下加强，它是实现动态代理的关键，代码如下：\",\"public class ProxyHandler implements InvocationHandler { private Object object; public ProxyHandler(Object object){ this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\\\"Before invoke \\\" + method.getName()); method.invoke(object, args); System.out.println(\\\"After invoke \\\" + method.getName()); return null; } } \",\"实现代理如下：\",\"public class Client { /** * jdk动态代理 */ public static void testJdkProxy() { Subject realSubject = new RealSubject(); ProxyHandler handler = new ProxyHandler(realSubject); Subject subject = (Subject) Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); subject.operation(); } public static void main(String[] args) { testJdkProxy(); } } \",\"运行代码输出：\",\"Before invoke operation do somthing After invoke operation\",\"Java动态代理是基于反射生产的一个代理类，这个代理类本身已经继承了jdk包中的Proxy对象，而Java是不允许多继承的，所以只能实现接口的方式进行代理。\",\"它的优点如下：\",\"Java动态代理不需要任何依赖\",\"灵活性：动态代理可以在运行时动态生成代理类，\",\"可拓展性：可以通过动态代理实现一些横切关注点，比如日志记录、性能监控等，而无需修改原有的代码。\",\"缺点：\",\"性能开销：由于动态代理是在运行时动态生成代理类，相比直接调用实现类的方法，会带来一定的性能开销\",\"功能限制：动态代理只能对接口进行代理，在某些情况下，无法代理实现类的方法。\"]},\"108\":{\"h\":\"CGLIB代码\",\"t\":[\"在pom文件中引入cglib包，代码如下：\",\" <dependency> <groupId>cglib</groupId> <artifactId>cglib</artifactId> version>3.2.5</version> </dependency> \",\"CGlib代码模式需要实现MethodInterceptor，并在intercept方法中实现真实对象的功能增强，代码如下：\",\"public class CglibProxyFactory implements MethodInterceptor { private Object target;//维护一个目标对象 public CglibProxyFactory(Object target) { this.target = target; } //为目标对象生成代理对象 public Object getProxyInstance() { //工具类 Enhancer en = new Enhancer(); //设置父类 en.setSuperclass(target.getClass()); //设置回调函数 en.setCallback(this); //创建子类对象代理 return en.create(); } @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\\\"开始cglib拦截\\\"); // 执行目标对象的方法 Object returnValue = method.invoke(target, args); System.out.println(\\\"结束cglib拦截\\\"); return returnValue; } } \",\"写一个测试类：\",\"public class Client { public static void main(String[] args) { testCglibProxy(); } /** * 测试cglib */ public static void testCglibProxy() { Subject subject = new RealSubject(); Subject proxy = (Subject) new CglibProxyFactory(subject).getProxyInstance(); proxy.operation(); } } \",\"执行结果如下：\",\"开始cglib拦截 do somthing 结束cglib拦截\",\"CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，用于在运行时扩展Java类和实现动态代理。与Java动态代理不同，CGLIB可以代理非接口类型的类。\",\"CGLIB动态代理的优点:\",\"性能高：相比Java动态代理，CGLIB动态代理通常能够提供更好的性能，因为它是通过生成子类来代理目标类，而不是通过实现接口。\",\"功能强大：CGLIB能够代理普通类和接口类，更灵活地满足额外需求，例如代理私有方法、拦截静态方法等。\",\"无需依赖接口：CGLIB动态代理可以代理没有实现任何接口的类，这使得它可以代理更多类型的类，提供更大的灵活性。\",\"CGLIB动态代理的缺点:\",\"需要额外依赖：CGLIB动态代理需要引入额外的库，增加项目的依赖，相比Java动态代理而言更为复杂。\",\"对final方法和final类的限制：CGLIB无法代理final方法和final类。\",\"不支持自身方法调用：CGLIB无法从代理对象中调用自身的方法，这可能会引起无限循环或抛出异常。\"]},\"109\":{\"h\":\"prometheus简明教程\"},\"110\":{\"h\":\"打造亿级流量的监控系统\",\"t\":[\"本篇文章为系列教程，旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统。所用到开源组件如下：\",\"Prometheus\",\"Grafana\",\"VictoriaMetrics系列\",\"Node-exporter\",\"Alertmanager\",\"Kafka\",\"Flink\",\"最终的技术架构如下：\",\"image-20230830224136440\"]},\"111\":{\"h\":\"Prometheus概述\"},\"112\":{\"h\":\"什么是Prometheus\",\"t\":[\"Prometheus是一个开源的监控系统，提供了数据采集、告警计算、告警管理等一系列工具包，周边生态非常的丰富。\",\"Prometheus受启发于Google的Brogmon监控系统（类似于Kubernetes是从Google的Brog系统演变而来），从2012年开始由前Google工程师以开源软件的形式进行研发，并且于2015年对外发布早期版本。2016年5月继Kubernetes之后成为第二个正式加入CNCF(云原生计算基金会)的项目，同年6月正式发布1.0版本。2017年底发布了基于全新存储层的2.0版本，能更好地与容器平台、云平台配合。\",\"Prometheus通过时序数据来收集和存储指标。一个时序数据包含了一个时间戳、值和一个或者是多个key-value键值对。\"]},\"113\":{\"h\":\"Prometheus提供的特性\",\"t\":[\"作为新一代的监控系统，Prometheus和传统的监控系统相比，有着非常大的创新。Prometheus让监控从传统的黑盒子监控提升到了白盒监控；不仅可以监控系统的一些状态，也可以深入到进程内部关键点的监控（白盒监控）。\",\"Prometheus提供一些关键的特性：\",\"多维的数据结构，这个数据结构包括一个指标名和一系列的键值对（指标）。\",\"提供了数据查询的Promql，Promql非常的强大和灵活。\",\"提供了单节点和分布式的数据存储方案。也可以使用第三方时序数据去存储，比如influxdb、thanos、victoriaMetrics\",\"时序数据使用http协议采集，通常是pull模式，也可以使用push模式（通过中间层push_gateway）\",\"采集目标可以使用服务发现的方式（比如k8s系统、consul），也可以通过静态的配置去发现采集目标。\",\"可以和开源组件grafana无缝对接。\"]},\"114\":{\"h\":\"组件\",\"t\":[\"Prometheus生态包含了一系列组件，除了Prometheus很多组件是可选的：\",\"Prometheus server是最核心的组件，用来抓取和存储时序数据的。\",\"Client-libraries（sdks）是用来开发应用指标的工具包\",\"Push_gateway是用来短暂存储push类型指标的\",\"exporters是用来暴露或者导出被监控对象的指标的，比如虚拟机、nginx、mysql等\",\"alertmanager是用来管理告警消息的，比如对消息的去重、静默、恢复等管理\",\"还有一系列其他的组件\",\"大多数Prometheus组件都是使用go语言写的，非常容易的打包和部署。\"]},\"115\":{\"h\":\"架构\",\"t\":[\"下图是Prometheus和它周边生态组件的架构图，这些组件构成了一个完整的监控系统：\",\"Prometheus architecture\",\"Prometheus通过pull的方式去周期性（通常15-30s）采集监控对象的指标，健康对象包含： \",\"直接采集的jobs和exporters\",\"也可以是短生命周期的任务推送到pushgateway的指标\",\"监控对象的发现 \",\"可以是k8s的集群的服务发现\",\"也可以是consul\",\"或者静态的配置文件\",\"prometheus发现到监控目标后，会周期性的去采集指标，并将指标存储在主机的磁盘中\",\"通过了内置的告警规则计算，并将告警消息发送给alertmanager\",\"alertmanager提供了对告警消息的管理、去重、静默、分发，可以配置多种分发方式： \",\"比如email\",\"webhook\",\"prometheus提供了http接口的方式让外部第三方访问数据，比如可以将指标数据展示在grafana上。\"]},\"116\":{\"h\":\"prometheus适用的场景\",\"t\":[\"prometheus可以很好地记录任何纯粹的数字时间序列。它既适合以机器为中心的监视，也适合高度动态的面向服务的体系结构的监视。\",\"在微服务的世界里，它对多维数据收集和查询的支持是一个特别的优势。\",\"Prometheus是为可靠性而设计的。每个Prometheus都是单节点设计的，使用多个节点去采集相通的监控对象可以做到高可用。通过Prometheus建立完善的监控体系，从而达到以下目的：\",\"长期趋势分析：通过对监控样本数据的持续收集和统计，对监控指标进行长期趋势分析。例如，通过对磁盘空间增长率的判断，我们可以提前预测在未来什么时间节点上需要对资源进行扩容。\",\"对照分析：两个版本的系统运行资源使用情况的差异如何？在不同容量情况下系统的并发和负载变化如何？通过监控能够方便的对系统进行跟踪和比较。\",\"告警：当系统出现或者即将出现故障时，监控系统需要迅速反应并通知管理员，从而能够对问题进行快速的处理或者提前预防问题的发生，避免出现对业务的影响。\",\"故障分析与定位：当问题发生后，需要对问题进行调查和处理。通过对不同监控监控以及历史数据的分析，能够找到并解决根源问题。\",\"数据可视化：通过可视化仪表盘能够直接获取系统的运行状态、资源使用情况、以及服务运行状态等直观的信息\",\"img\",\"那prometheus不适合什么？\",\"由于prometheus是使用周期性的采集数据，它并不能保证数据的及时性和绝对正确性，如果是想做与money相关的业务，使用prometheus明显是不合适的。\"]},\"117\":{\"h\":\"Prometheus环境搭建\",\"t\":[\"本文是Prometheus环境的搭建和安装，包括prometheus-sever、node-exporter、grafna的安装。安装成功后，配置prometheus采集node-exporter的指标，然后在grafana展示node-exporter采集的指标。\"]},\"118\":{\"h\":\"安装prometheus\",\"t\":[\"去prometheus官网下载prometheus，下载地址为https://prometheus.io/download/ ，目前提供了Linux\\\\windows\\\\mac的版本，笔者这里下载mac版本的。\",\"image-20231008083006727\",\"下载完成后，执行解压：\",\"tar -zxvf prometheus-2.47.1.darwin-amd64.tar.gz cd prometheus-2.47.1.darwin-amd64 \",\"执行启动命令：\",\"./prometheus \",\"笔者是mac电脑，运行时会被系统拒绝运行，需要打开系统偏好设置-安全与隐私，允许prometheus运行。\",\"其他操作系统应该没有这个问题。\",\"启动成功后，访问http://localhost:9090 ，就可以访问prometheus页面了，这个页面提供了对prometheus数据的查询和告警信息的查询，页面展示如下：\",\"image-20231008084050835\"]},\"119\":{\"h\":\"prometheus配置文件讲解\",\"t\":[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus.yml，这个配置文件是prometheus启动的时候会读取的配置。具体如下：\",\"# my global config global: scrape_interval: 15s evaluation_interval: 15s # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 rule_files: # - \\\"first_rules.yml\\\" # - \\\"second_rules.yml\\\" scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] \",\"具体的配置介绍如下：\",\"global.scrape_interval 是全局配置默认采集时间间隔（周期性采集监控目标）\",\"global.evaluation_interval是全局配置告警规则任务的计算\",\"alerting.alertmanagers是配置alertmanagers的地址的，alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",\"rule_files是配置告警规则文件的路径，可以使用通配符\",\"scrape_configs是配置采集任务的，支持多种类型的采集，比如从k8s、consul、也可以配置静态采集任务。上面的配置是采集prometheus自身的监控指标。可以访问prometheus自身的监控指标的暴露端点：http://localhost:9090/metrics，可以得到prometheus的监控指标，内容如下：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 4.5782e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 7.745e-05 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000123743 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000251038 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.002707693 go_gc_duration_seconds_sum 0.009608685 go_gc_duration_seconds_count 35 # HELP go_goroutines Number of goroutines that currently exist. # TYPE go_goroutines gauge go_goroutines 32 # HELP go_info Information about the Go environment. # TYPE go_info gauge go_info{version=\\\"go1.21.1\\\"} 1 # HELP go_memstats_alloc_bytes Number of bytes allocated and still in use. # TYPE go_memstats_alloc_bytes gauge go_memstats_alloc_bytes 2.1363728e+07 # HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed. # TYPE go_memstats_alloc_bytes_total counter go_memstats_alloc_bytes_total 3.82033736e+08 # HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table. # TYPE go_memstats_buck_hash_sys_bytes gauge go_memstats_buck_hash_sys_bytes 1.489234e+06 ... \"]},\"120\":{\"h\":\"采集Node Exporter的指标\",\"t\":[\"Node Exporter是Prometheus生态的一员，它为主机暴露了硬件和内核相关的指标，比如主机的cpu、内存、磁盘、io读写等。目前支持linux系统、windows系统和mac系统，下载地址为：\",\"https://github.com/prometheus/node_exporter/releases \",\"下载完成后，启动node_exporter，node_exporter的端口为9100，访问http://localhost:9100/metrics，就可以查看node_exporter暴露的端口指标。\",\"在prometheus的配置文prometheus.yml中，增加采集Node Exporter的任务，配置信息如下：\",\"scrape_configs: - job_name: \\\"prometheus\\\" static_configs: - targets: [\\\"localhost:9090\\\"] - job_name: \\\"node_exporter\\\" static_configs: - targets: [\\\"localhost:9100\\\"] \",\"重新启动prometheus的程序，prometheus 就可以采集Node_Exporter的指标了。\",\"访问prometheus的网页，http://localhost:9090/graph，在查询框里输入node_filesystem_free_bytes（文件系统里剩余的磁盘字节数），就可以看到各个目录的磁盘剩余字节数了。\",\"image-20231008231356066\"]},\"121\":{\"h\":\"prometheus配置文件热更新\",\"t\":[\"在prometheus启动的时候加上启动参数--web.enable-lifecycle，具体命令如下：\",\"prometheus --web.enable-lifecycle \",\"在更改完配置以后，就可以进行配置的热更新，通过拉prometheus的配置热更新接口，接口如戏：\",\"curl -XPOST http://localhost:9090/-/reload \"]},\"122\":{\"h\":\"grafana安装\",\"t\":[\"Grafana是一个开源的、流行的、炫酷的展示数据的可视化仪表盘，它支持多种类型的数据库，提供了非常多的面板和插件，可以让开发者轻松的实现监控大盘。\",\"grafana可以完美的和prometheus结合，展示prometheus数据。\",\"进入grafana官网下载安装包，笔者是mac，所以下载的是mac版本的，下载命令如下：\",\"curl -O https://dl.grafana.com/enterprise/release/grafana-enterprise-10.1.4.darwin-amd64.tar.gz tar -zxvf grafana-enterprise-10.1.4.darwin-amd64.tar.gz \",\"下载并解压成功后，进入到grafana的安装目录，启动grafana，启动命令如下：\",\"./bin/grafana-server \",\"grafana有很多配置项在conf目录下default.ini文件下，此篇文章不讲解这部分内容。\",\"启动成功后，进入grafana的页面，地址为localhost:3030 ，grafana的默认登陆用户名admin、密码为admin\",\"登陆成功后，需要为grafana配置prometheus的数据源，配置界面的路径和配置如下：\",\"配置完成后保存。\",\"然后去grafana官方网站的dashboard社区找一个node exporter的面板，搜索地址：https://grafana.com/grafana/dashboards/?pg=community&plcmt=topnav&search=node+exporter+mac\",\"搜索成功后，在本地部署的grafana页面导入node exporter的dashboard，页面的导入路径如下：\",\"image-20231010201727866\",\"导入成功后，就可以看到本机的资源dashboard（由node exporter采集的指标生产）\",\"image-20231009220040376\"]},\"123\":{\"h\":\"总结\",\"t\":[\"prometheus作为一个采集组件，采集了node-exporter的指标\",\"同时prometheus作为一个时序数据库，存储了node-expoter的指标时序\",\"grafana作为数据展示前端，读取prometheus的指标时序，并展示在监控大盘上。\"]},\"124\":{\"h\":\"Prometheus的数据模型\"},\"125\":{\"h\":\"什么是time-series\",\"t\":[\"Prometheus通过时间序列来存储所有的数据的。时间序列是指标（有相同指标名和标签构成的）的包含时间和值的流式数据。采用的数据模型是单值模型，且只支持浮点数指标。举个例子：\",\"在前面的文章介绍过如下Prometheus自身的监控，通过/metrics接口暴露，Prometheus可以通过调用/metrics接口来获取自身的数据。指标定义如下：\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \",\"指标是单值模型，即一个指标代表一种含义，如下表示prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 指标在不同时间下的值。\",\"指标名称(name)\",\"code\",\"handler\",\"Timestamp\",\"Value\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984318.82\",\"1205\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984153.822\",\"1194\",\"prometheus_http_requests_total\",\"200\",\"/metrics\",\"1696984033.817\",\"1186\",\"指标在不同时间有不同的值，被称为time-series（时间序列），time-series中每个点被称为一个样子（sample)，sample由三部分组成：\",\"指标：指标是由指标名和标签组成，它们共同组成描述当前指标的特征 \",\"指标名和标签名的命名需要满足[a-zA-Z_:][a-zA-Z0-9_:]*\",\"对于标签值无约束，但是需要对值的控制字符进行转义\",\"时间戳(timestamp)：时间戳精度为毫秒\",\"值(value)： float64类型的值。\",\"<--------------- metric -------------------------------------><-timestamp -><-value-> prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984318.82 => 1205 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984153.822 => 1194 prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}@1696984033.817 => 1186 \",\"在grafana上查询指标：prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}；\",\"image-20231012215203283\"]},\"126\":{\"h\":\"指标的类型\",\"t\":[\"Prometheus定义来四种类型的指标：\",\"Counter（累加器），初始值为0，只增不减，或者重启的进程的时候重置为0\",\"Gauge（仪表盘），状态值，可增可减。\",\"Histogram（直方图），用于求分位数，比如p99\",\"Summary（摘要），和直方图类似\",\"但是对于Prometheus的底层数据来说，这些类型的指标在存储的时候，并没有差别，都是以time-series的形式存储在Prometheus的level-db中。而在样本数据采集的时候，在注释中包含了指标的类型，其实在存储的时候是并没有存储的。\",\"# HELP prometheus_http_requests_total Counter of HTTP requests. # TYPE prometheus_http_requests_total counter prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"} 1205 \"]},\"127\":{\"h\":\"Counter 累加器\",\"t\":[\"Counter类型的指标和计数器一样，初始值为零，是单调递增的，除非进程重启重置。一般Counter类型的指标建议以_total结尾。例如prometheus_http_requests_total表示prometheus服务的http请求的数量，prometheus每发生一个请求，prometheus_http_requests_total都会累积1。\",\"使用counter类型的指标，可以很容易一段时间的增量数据，比如求最近5分钟prometheus发生了多少次请求：\",\"increase(prometheus_http_requests_total[5m]) \",\"increase是promql中的一个函数，函数的内容，在下一篇文章将会讲解。\"]},\"128\":{\"h\":\"Gauge仪表盘\",\"t\":[\"Gauge类型的指标主要反映的是当前的状态，它是可增可减的，比如node exporter采集的指标中：node_filesystem_avail_bytes，表示的是当前系统文件系统中磁盘可用的字节数，可用通过prometheus的内置函数计算最近5分钟node_filesystem_avail_bytes的差值。\",\"delta(node_filesystem_avail_bytes{}[5m]) \",\"还可以使用predict_linear函数对指标的数据变化趋势进行预测。例如，预测系统磁盘在6个小时之后的剩余情况：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[1h], 6* 3600) \"]},\"129\":{\"h\":\"Histogram直方图\",\"t\":[\"Histogram直方图是用来统计和分析样本的分布情况。\",\"在很多场景下，我们可以使用求平均值来量化指标。比如我们求某个请求耗时的平均值，但是在大多数情况下，请求都是在100ms以内，而个别情况可能导致请求耗时超过了5s，导致请求耗时的平均值远大于100ms，这个平均值是不能反应的请求的真实状态。\",\"Histogram直方图可以解决上面的问题，例如0-10ms的请求有多少个，10ms-20ms的请求又多少个。例如prometheus的服务的/metrics接口耗时，使用了prometheus_http_request_duration_seconds_bucket指标去统计。\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.1\\\"} 1827 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.2\\\"} 1828 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"0.4\\\"} 1829 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"1\\\"} 1830 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"3\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"8\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"20\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"60\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"120\\\"} 1831 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",le=\\\"+Inf\\\"} 1831 \",\"在上面的示例中，使用le标签表示小于的意思。\",\"le=\\\"0.1\\\" 表示小于0.1s，有1827个请求\",\"le=\\\"0.2\\\"表示小于0.2s，有1828个请求\",\"通过这种直方图可以很方便的统计请求耗时分布的真实状态。另外，会统计当前指标的记录总数(以_count作为后缀)和值的总和（以_sum作为后缀），例如：\",\"prometheus_http_request_duration_seconds_sum{handler=\\\"/metrics\\\"} 15.171390910999984 prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"} 1831 \",\"Histogram的指标，我们还可以通过histogram_quantile()函数计算出其值的分位数。\"]},\"130\":{\"h\":\"summary\",\"t\":[\"summary和Histogram类似，只不过summary是已经在客户端已经计算好的数据，例如go_gc_duration_seconds指标：\",\"# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles. # TYPE go_gc_duration_seconds summary go_gc_duration_seconds{quantile=\\\"0\\\"} 6.3884e-05 go_gc_duration_seconds{quantile=\\\"0.25\\\"} 0.00013637 go_gc_duration_seconds{quantile=\\\"0.5\\\"} 0.000194843 go_gc_duration_seconds{quantile=\\\"0.75\\\"} 0.000421166 go_gc_duration_seconds{quantile=\\\"1\\\"} 0.009242327 go_gc_duration_seconds_sum 0.1255515 go_gc_duration_seconds_count 296 \",\"Histogram和summary的区别在于，summary是在sdk侧已经计算好了分位数，而Histogram是通过histogram_quantile函数在prometheus-server进行计算的。对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多服务端的的资源。\",\"通常情况下，我们都会选择使用Histogram类型的指标去做分位数的统计，而不是使用summary。\"]},\"131\":{\"h\":\"Promql快速入门\",\"t\":[\"prometheus的时间序列是通过指标名和一组标签来唯一定义。指标的名称是监控样本的标识，而标签组是监控样本的多个维度特征的反应，所以可以通过标签进行对指标的筛选、过滤、聚合、转换等计算，计算的结果会产生一条新的时间序列。\",\"promql是Prometheus提供的数据查询语言，可以对时间序列提供丰富的查询。promql被广泛应用于指标视图的配置、告警语句的配置，它是一个基础能力，类似于mysql的sql查询语句。\"]},\"132\":{\"h\":\"瞬时向量查询（Instant vector selectors）\",\"t\":[\"我们可以直接输入指标名查询所有的这个指标名的时间序列，比如：\",\"prometheus_http_requests_total \",\"上面的语句等同于：\",\"prometheus_http_requests_total \",\"可以在grafana上查询，获取了prometheus_http_requests_total指标的不同标签维度的所有指标，一共有53个。\",\"image-20231014210829763\",\"可以筛选出handler=“/metrics\\\"接口的数据，在grafana执行：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"} \",\"image-20231014210912914\",\"另外也可以筛选出handler!=“/metrics\\\"的所有的数据，查询语句为：\",\"prometheus_http_requests_total{handler!=\\\"/metrics\\\"} \",\"也可以使用多个标签值进行进行查询，比如查询handler为\\\"/metrics“和handler为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler=~\\\"/metrics|/api/v1/labels\\\"} \",\"同理，也查询handler不为\\\"/metrics“和handler不为\\\"/api/v1/labels\\\"的指标情况：\",\"prometheus_http_requests_total{handler!~\\\"/metrics|/api/v1/labels\\\"} \",\"也可以使用.*通配符进行模糊匹配查询：\",\"prometheus_http_requests_total{handler=~\\\"/metric.*\\\"} \",\"小结：\",\"使用标签筛选数据的使用，可以使用完全匹配：\",\"label = value\",\"lable =~ value | value2\",\"也可以进行模糊匹配：\",\"label =~ value.*\",\"取反操作\",\"label != value\",\"Label !~ value1 |value2\",\"Label !~ value.*\"]},\"133\":{\"h\":\"范围向量查询（Range Vector Selectors）\",\"t\":[\"通过Instant vector selectors查询，返回值只会包含该时间序列的最新值的一个样本，它是一个瞬时向量结果。如果我们想查询一个时间区间的样本，可以使用范围矢量查询。范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围，时间范围通过时间范围选择器[]进行定义。例如，通过以下表达式可以选择最近5分钟内的所有样本数据：\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}[5m] \",\"image-20231014211256244\",\"时间范围除了支持分钟（m)外，还还支持\",\"秒（s)\",\"分钟（m）\",\"小时（h）\",\"天（d）\",\"周（w）\",\"年（y）\"]},\"134\":{\"h\":\"offset 时间位移操作\",\"t\":[\"瞬时向量查询和范围向量查询的表达式中，都是以当前时间为基准的，比如：\",\"prometheus_http_requests_total{}，查询当前时间的最新值\",\"prometheus_http_requests_total{}[5m]，查询的是当前时间的过去五分钟的数据。\",\"如果想查询五分钟前的数据，获取昨天的当前时间同一时刻的五分钟的数据，怎么查询呢，我们可以使用offset关键字：\",\"prometheus_http_requests_total{} offset 5m，查询五分钟前的最新值\",\"prometheus_http_requests_total{}[5m] offset 1d，查询的是昨天的当前时间同一时刻的五分钟的数据\"]},\"135\":{\"h\":\"操作符\"},\"136\":{\"h\":\"数学操作符\",\"t\":[\"Promql支持常见的逻辑和数学操作符，这些操作符使用于瞬时向量的查询，常见的逻辑运算符如下\",\"+ (addition) 加\",\"- (subtraction) 减\",\"* (multiplication) 乘\",\"/ (division) 除\",\"% (modulo) 取模\",\"^ (power/exponentiation) 幂运算\",\"在作用于两个瞬时向量之间，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。如果匹配到了，会将计算结果输出到新的向量上，向量里面的标签是左侧和右侧共同匹配的标签，指标名将会被删除。\",\"例如下面的查询语句不会输出任何结果，因为两个handler标签值不一样。\",\"prometheus_http_requests_total{handler=\\\"/metrics\\\"}+prometheus_http_requests_total{handler=\\\"/api/v1/labels\\\"} \",\"再比如下面的查询语句的可以输出结果，因为左侧的表达式有一个handler=\\\"/metrics\\\"，右侧的表达式也有一个handler=\\\"/metrics\\\"标签，完全匹配，所以能够输出：\",\"sum(prometheus_http_requests_total{handler=\\\"/metrics\\\"})by(handler)+sum(prometheus_http_request_duration_seconds_count{handler=\\\"/metrics\\\"})by(handler) \"]},\"137\":{\"h\":\"比较操作符\",\"t\":[\"promql还支持常见的比较运算符，比如：\",\"== (equal)\",\"!= (not-equal)\",\"> (greater-than)\",\"< (less-than)\",\">= (greater-or-equal)\",\"<= (less-or-equal)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"138\":{\"h\":\"逻辑运算符\",\"t\":[\"逻辑运算符作用于两个瞬时向量之间，支持的逻辑运算符如下：\",\"and (intersection) 求交集\",\"or (union) 求并集\",\"unless (complement)\",\"当比较运算符左右与两个瞬时向量之间，同操作运算符一样，左侧的标签条目和右侧的标签条目必须要相同，否则将匹配不到，不会输出结果。\"]},\"139\":{\"h\":\"向量匹配符号 Vector matching\",\"t\":[\"在上面讲解的操作符，比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算。在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算，promql提供了两个向量匹配符号\",\"on （匹配）\",\"Ignoring （忽略）\",\"使用上面的Vector matching，可以应用于One-to-one vector matches（一对一）和Many-to-one and one-to-many vector matches（一对多或者多对一）\"]},\"140\":{\"h\":\"分组修改器 Group modifiers\",\"t\":[\"分组修改器可以实现many-to-one/one-to-many的向量匹配，通常使用以下的关键字：\",\"group_left\",\"group_right\",\"分组修改器可以一边的标签组赋值给另一边的查询结构。\",\"举例子讲解\",\"比如有以下的时间序列的样本：\",\"method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"500\\\"} 24 method_code:http_errors:rate5m{method=\\\"get\\\", code=\\\"404\\\"} 30 method_code:http_errors:rate5m{method=\\\"put\\\", code=\\\"501\\\"} 3 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"500\\\"} 6 method_code:http_errors:rate5m{method=\\\"post\\\", code=\\\"404\\\"} 21 method:http_requests:rate5m{method=\\\"get\\\"} 600 method:http_requests:rate5m{method=\\\"del\\\"} 34 method:http_requests:rate5m{method=\\\"post\\\"} 120 \",\"使用以下的查询：\",\"method_code:http_errors:rate5m{code=\\\"500\\\"} / ignoring(code) method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\"} 0.04 // 24 / 600 {method=\\\"post\\\"} 0.05 // 6 / 120 \",\"如果不用ignoring修改器，将得不到任何结果。\",\"使用group_left修改器进行查询：\",\"method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m \",\"得到的结果是：\",\"{method=\\\"get\\\", code=\\\"500\\\"} 0.04 // 24 / 600 {method=\\\"get\\\", code=\\\"404\\\"} 0.05 // 30 / 600 {method=\\\"post\\\", code=\\\"500\\\"} 0.05 // 6 / 120 {method=\\\"post\\\", code=\\\"404\\\"} 0.175 // 21 / 120 \"]},\"141\":{\"h\":\"聚合函数\",\"t\":[\"Prometheus提供非常的多的聚合函数，可以用来聚合耽搁瞬时向量，聚合完后的结果会生成根据聚合标签生成一个新的序列：\",\"sum (calculate sum over dimensions)\",\"min (select minimum over dimensions)\",\"max (select maximum over dimensions)\",\"avg (calculate the average over dimensions)\",\"group (all values in the resulting vector are 1)\",\"stddev (calculate population standard deviation over dimensions)\",\"stdvar (calculate population standard variance over dimensions)\",\"count (count number of elements in the vector)\",\"count_values (count number of elements with the same value)\",\"bottomk (smallest k elements by sample value)\",\"topk (largest k elements by sample value)\",\"quantile (calculate φ-quantile (0 ≤ φ ≤ 1) over dimensions)\",\"基本查询格式是：\",\"<aggr-op> [without|by (<label list>)] ([parameter,] <vector expression>) \",\"比如prometheus_http_requests_total这个指标有4个标签，分别是code、handler、instance、job（其中job为采集任务、instance为被采集的实例，这两个标签对于同一个实例来说基本不变）， timeseries格式如下：\",\"prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\",job=\\\"prometheus\\\"} \",\"我们可以计算所有handler、code的的请求总数：\",\"sum by (handler, code) (prometheus_http_requests_total) \",\"它同等于：\",\"sum without (instance, job) (prometheus_http_requests_total) \",\"如果想计算所有的请求的总数：\",\"sum(prometheus_http_requests_total) \",\"获取请求次数最多的5个请求，可以用topk函数：\",\"topk(5,sum by (handler, code) (prometheus_http_requests_total)) \"]},\"142\":{\"h\":\"其他常见的函数\"},\"143\":{\"h\":\"计算counter的增长率\",\"t\":[\"可以使用increase函数计算增量数据，比如计算最近5分钟的请求次数：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"这里使用prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]获取最近五分钟的样本，用increase函数算出五分钟的增量。\",\"那么每秒的增量率，可以将上面的结果除以300，可以使用以下的表达式进行计算：\",\"increase(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m])/(60*5) \",\"除了使用increase函数计算增量外，可以使用rate函数计算速率，上面的表达式等价于：\",\"rate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \",\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率，容易陷入“长尾问题”当中，其无法反应在时间窗口内样本数据的突发变化。 例如，对于请求数量在5分钟的时间窗口内，可能在某一时刻访问量突增，但是通过计算在时间窗口内的平均增长率却无法反应出该问题。\",\"为了解决该问题，PromQL提供了另外一个灵敏度更高的函数irate(v range-vector)。irate同样用于计算区间向量的计算率，但是其反应出的是瞬时增长率。irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。\",\"irate(prometheus_http_requests_total{code=\\\"200\\\",handler=\\\"/metrics\\\"}[5m]) \"]},\"144\":{\"h\":\"预测指标变化趋势\",\"t\":[\"predict_linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据，函数的格式如下：\",\"predict_linear(v range-vector, t scalar) \",\"例如，基于5小时的样本数据，来预测主机可用磁盘空间的是否在24个小时候被占满，可以使用如下表达式：\",\"predict_linear(node_filesystem_free{job=\\\"node\\\"}[5h], 24 * 3600) < 0 \"]},\"145\":{\"h\":\"计算分位数\",\"t\":[\"Histogram类型的指标可以使用histogram_quantile函数进行计算，函数格式为：\",\"histogram_quantile(φ scalar, b instant-vector) \",\"例如有以下的指标prometheus_http_request_duration_seconds_bucket\",\"prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090\\\", job=\\\"prometheus\\\", le=\\\"0.1\\\"} 3767 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.2\\\"} 3769 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"0.4\\\"} 3773 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"1\\\"} 3775 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"3\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"8\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"20\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"60\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"120\\\"} 3776 prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\",instance=\\\"localhost:9090, job=\\\"prometheus\\\", le=\\\"Infinity\\\"} 3776 \",\"计算handler=\\\"/metrics\\\"接口的p90耗时：\",\"histogram_quantile(0.9, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \",\"计算p99耗时的表达式如下：\",\"histogram_quantile(0.99, sum by (handler,le) (rate(prometheus_http_request_duration_seconds_bucket{handler=\\\"/metrics\\\"}[1m]))) \"]},\"146\":{\"h\":\"总结\",\"t\":[\"本文快速的讲解了promql的查询、操作符、函数，并通过案例进行了实战。详细内容可以查看官方网站：https://prometheus.io/docs/prometheus/latest/querying/basics/\"]},\"147\":{\"h\":\"在SpringBoot项目中使用Prometheus监控\",\"t\":[\"本篇文章主要讲解如何在SpringBoot项目中使用Prometheus监控，实现方式有两种，一种是使用Springboot自带的spring-boot-starter-actuator；另一种是使用Prometheus的Java客户端\"]},\"148\":{\"h\":\"方案一：使用spring-boot-starter-actuator\",\"t\":[\"SpringBoot已经有来Micrometer的指标库，它默认集成在spring-boot-starter-actuator的依赖包中（要求SpringBoot>=2.0版本）。\",\"新建一个SpringBoot项目，在项目中引入以下的依赖：\",\" <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> <dependency> <groupId>io.micrometer</groupId> <artifactId>micrometer-registry-prometheus</artifactId> <version>1.11.4</version> </dependency> \",\"其中micrometer-registry-prometheus依赖是将Micrometer的指标转换成prometheus格式的指标。\",\"然后在springboot的配置文件application.properties中开启prometheus的暴露接口：\",\"management.endpoints.web.exposure.include=prometheus \",\"在SpringBoot项目创建一个测试接口：\",\"@Controller public class BasicController { // http://127.0.0.1:8080/hello?name=lisi @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后，在浏览器上请求http://127.0.0.1:8080/actuator/prometheus\",\"可以得到/hello接口相关的指标，当然actuator有很多内置的指标，在这里就不展开讲解了 。\",\"# HELP http_server_requests_seconds # TYPE http_server_requests_seconds summary http_server_requests_seconds_count{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 7.0 http_server_requests_seconds_sum{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.071374449 # HELP http_server_requests_seconds_max # TYPE http_server_requests_seconds_max gauge http_server_requests_seconds_max{exception=\\\"None\\\",method=\\\"GET\\\",outcome=\\\"SUCCESS\\\",status=\\\"200\\\",uri=\\\"/hello\\\",} 0.049234863 \",\"在这里有三个指标，分别为\",\"http_server_requests_seconds_count 请求的总次数\",\"http_server_requests_seconds_sum 请求的总耗时\",\"http_server_requests_seconds_max 请求的最大耗时\",\"这个内置指标对请求耗时统计不是做的很好，只能求到最大的耗时和平均耗时，如果要求分位耗时，其实是做不到。而使用Prometheus的Java客户端是可以做到分位耗时的。\"]},\"149\":{\"h\":\"方案二：使用Prometheus\",\"t\":[\"Prometheus官方提供了Java客户端，用于Java程序的指标暴露。在SpringBoot项目中的pom文件引入以下的依赖：\",\" <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-core</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-instrumentation-jvm</artifactId> <version>1.0.0</version> </dependency> <dependency> <groupId>io.prometheus</groupId> <artifactId>prometheus-metrics-exporter-httpserver</artifactId> <version>1.0.0</version> </dependency> \",\"其中prometheus-metrics-core包是指标的关键包；prometheus-metrics-instrumentation-jvm是用于暴露JVM相关的指标（可选）；prometheus-metrics-exporter-httpserver是用于导出指标的服务（可选）；\",\"同样的，在项目中有一个测试接口，如下：\",\" @RequestMapping(\\\"/hello\\\") @ResponseBody public String hello(@RequestParam(name = \\\"name\\\", defaultValue = \\\"unknown user\\\") String name) { return \\\"Hello \\\" + name; } \",\"然后，需要创建两个指标，如下：\",\"Counter类型的http_count_total，用于统计请求的数量，包括两个标签uri（请求路径）和status（请求状态码）\",\"Histogram类型的http_count_seconds，用于统计请求的耗时，包括两个标签uri（请求路径）和status（请求状态码）\",\"然后创建一个HandlerInterceptorAdapter的拦截器，用于指标数据的统计：\",\"在preHandle方法中记录请求的开始时间startTime\",\"在afterCompletion方法中，统计请求的次数和请求耗时，\",\"完整的代码如下：\",\"package io.github.forezp.prometheuslab.aop; import io.prometheus.metrics.core.metrics.Counter; import io.prometheus.metrics.core.metrics.Histogram; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ApiStatInterceptor extends HandlerInterceptorAdapter { Counter counter = Counter.builder() .name(\\\"http_count_total\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); Histogram histogram = Histogram.builder() .name(\\\"http_count_seconds\\\") .help(\\\"example counter\\\") .labelNames(\\\"uri\\\",\\\"status\\\") .register(); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long startTime = System.currentTimeMillis(); request.setAttribute(\\\"startTime\\\", startTime); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { long startTime = (Long) request.getAttribute(\\\"startTime\\\"); long endTime = System.currentTimeMillis(); String uri=request.getRequestURI(); counter.labelValues(uri,\\\"ok\\\").inc(); histogram.labelValues(uri,\\\"ok\\\").observe(endTime-startTime); } } \",\"然后将ApiStatInterceptor注册到WebMvcConfigurer中：\",\"@Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new ApiStatInterceptor()); } } \",\"开启HTTPServer，并已bean的形式注册：\",\" @Bean public HTTPServer createHttpServer() throws IOException { HTTPServer server = HTTPServer.builder() .port(9400) .buildAndStart(); return server; } \",\"在浏览器上请求测试接口http://127.0.0.1:8080/hello?name=lisi\",\"然后在浏览器上访问http://localhost:9400/metrics，可以看到有两个指标http_count_total和http_count_seconds，指标数据如下：\",\"# HELP http_count_total example counter # TYPE http_count_total counter http_count_total{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2.0 # HELP http_count_seconds example counter # TYPE http_count_seconds histogram http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.005\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.01\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.025\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.05\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.1\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.25\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"0.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"1.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"2.5\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"5.0\\\"} 0 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"10.0\\\"} 1 http_count_seconds_bucket{status=\\\"ok\\\",uri=\\\"/hello\\\",le=\\\"+Inf\\\"} 2 http_count_seconds_count{status=\\\"ok\\\",uri=\\\"/hello\\\"} 2 http_count_seconds_sum{status=\\\"ok\\\",uri=\\\"/hello\\\"} 44.0 \"]},\"150\":{\"h\":\"配置Prometheus采集\",\"t\":[\"在Springboot的项目中增加springboot指标的采集，配置如下：\",\"scrape_configs: - job_name: \\\"springboot\\\" static_configs: - targets: [\\\"localhost:9400\\\"] \",\"配置完成后，重新启动prometheus或者热加载，重新加载一下配置。\"]},\"151\":{\"h\":\"配置grafana视图\",\"t\":[\"在grafana中为Springboot项目配置试图，比如配置每分钟的请求量，配置的表达式如下：\",\"sum(increase(http_count_total{}[1m]))by (uri) \",\"image-20231021115719027\",\"配置请求的p95耗时，配置的表达式如下：\",\"histogram_quantile(0.95,sum(increase(http_count_seconds_bucket{}[1m]))by(uri,le)) \",\"image-20231021115611700\"]},\"152\":{\"h\":\"Prometheus告警与Alertmanager实战\",\"t\":[\"Prometheus的告警分为两部分内容：\",\"Prometheus server中的告警规则、告警发送。\",\"告警消息的处理程序Alertmanager，Alertmanager的主要功能包括告警消息的分组、路由分发、抑制和静默等核心功能\",\"工作流程包括：\",\"配置和启动Alertmanager\",\"在Prometheus server中配置Alertmanager的地址，用于向Alertmanager发送告警消息\",\"在Prometheus server中配置告警规则\",\"一个简单版的Prometheus的架构图如下：\",\"image-20231021170507878\",\"Prometheus作为采集端，采集Node-exporter、sdk client的数据\",\"Prometheus作为存储端，起到了时序数据库的作用，存储采集到的数据\",\"同时Prometheus读取告警规则文件，在进程内部计算告警规则，如果有告警发生，则向Alertmanager发送告警消息\",\"Alertmanager作为告警收敛的组件，在它内部进行告警消息的管理，最终将消息发送给第三方组件，通常是webhook\",\"最后webhook发送给告警平台。\",\"在前面的文章已经讲解过Prometheus采集数据和查询数据，在本篇文章中将会讲述Prometheus告警与Alertmanager实战。\"]},\"153\":{\"h\":\"Alertmanager介绍\",\"t\":[\"Alertmanager处理来自客户端的告警消息，例如Prometheus server，包括消息的去重、分组、路由、抑制和静默等核心功能。先了解这些核心概念，然后通过配置文件的形式来具体讲解。\"]},\"154\":{\"h\":\"分组\",\"t\":[\"分组是将同一组多个的相同的告警消息合并成一个高级消息。这在系统出现大量故障的时候非常有用，如果系统发出成千上万条相同的告警消息，对处理者来说是一个灾难。\",\"比如，某个数据库出现网络故障，导致连接它的应用的几百个实例都出现异常，如果不进行分组合并，则会出现几百上千的告警消息，很可能淹没掉一些其他的告警消息，导致告警处理者漏处理一些告警消息，从而导致一些系统问题。\",\"分组是\",\"告警分组，告警时间间隔，以及告警的接受方式可以通过Alertmanager的配置文件进行配置\"]},\"155\":{\"h\":\"抑制\",\"t\":[\"抑制是当某一告警已经发出，可以停止重复发送由此告警引发的其它告警的机制。\",\"例如，当集群不可用访问出发了告警，通过Alertmanager的配置可以忽略与该集群有关的其它告警功能。这样可以避免接受一些与实际问题相关的告警。\"]},\"156\":{\"h\":\"静默\",\"t\":[\"静默提供了一个标签匹配的设置，如果告警消息符合匹配，Alertmanager则不会发送消息到下游。\",\"Alertmanager 通过配置文件去配置一些配置，然后通过命令行的方式的启动它。Alertmanager 可以在运行时重新加载其配置，通过向Alertmanager 进程发送 SIGHUP信号或者请求Alertmanager 的 /-/reload 接口（POST请求）。\"]},\"157\":{\"h\":\"Alertmanager安装\",\"t\":[\"下载地址：https://prometheus.io/download/\",\"启动alertmanager可以使用以下命令：\",\"./alertmanager --config.file=alertmanager.yml \",\"在启动之前，需要修改alertmanager的配置文件，默认的配置文件如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 30s group_interval: 5m repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:5001/' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"配置文件中包含了4个部分，分别是：\",\"全局配置（global）：用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容； 告警路由（route）：根据标签匹配，确定当前告警应该如何处理； 接收人（receivers）：接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用； 抑制规则（inhibit_rules）：合理设置抑制规则可以减少垃圾告警的产生\"]},\"158\":{\"h\":\"配置讲解\",\"t\":[\"每个部分包含的可配置的参数很多，参数的配置会在以后的文章中讲解，在此篇文章只讲解最基础的和几个重要的配置：\",\"gloabl配置\",\"resolve_timeout\",\"当告警消息没有endTs这个时间戳参数时，Alertmanager会启动它的告警恢复逻辑。当启动告警恢复逻辑时，Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）。这个对于prometheus的告警消息来说，它会含有endTs这个时间戳参数，所以这个resolve_timeout对于prometheus的告警消息是不生效的。\",\"route配置\",\"group_by 默认alertname\",\"The labels by which incoming alerts are grouped together.\",\"将告警消息按照某个标签分组，比如按照alertname\",\"group_wait（default: 30s）\",\"How long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.) 一组告警第一次发送之前等待的时间。用于等待抑制告警，或等待同一组告警采集更多初始告警后一起发送。（一般设置为0秒 ~ 几分钟\",\"group_interval（default: 5m）\",\"How long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.) 一组已发送初始通知的告警接收到新告警后，再次发送通知前等待的时间（一般设置为5分钟或更多）\",\"repeat_interval（default: 4h）\",\"How long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). 一条成功发送的告警，在再次发送通知之前等待的时间。 （通常设置为3小时或更长时间）。\",\"receivers配置\",\"Receiver可以集成邮箱、微信、邮箱等，本文使用webHook的方式，即Alertmanager通过http接口调用来发送告警消息。\",\"inhibit_rules 配置\",\"抑制允许根据另一组警报的存在来静音一组警报。这允许在系统或服务之间建立依赖关系，以便在中断期间仅发送一组互连警报中最相关的警报。\",\"当存在与另一组匹配器匹配的警报（源）时，禁止规则会静音与一组匹配器匹配的警报（目标）。目标警报和源警报在相等列表中的标签名称必须具有相同的标签值。\",\"inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"比如当发生severity=critical的告警时，会屏蔽掉severity=warning的告警，前提条件是两个告警的alertname、dev、instance的标签值相等。\",\"根据实际情况，最终我的配置修改成如下：\",\"global: resolve_timeout: 5m route: group_by: ['alertname'] group_wait: 10s group_interval: 30s repeat_interval: 1h receiver: 'web.hook' receivers: - name: 'web.hook' webhook_configs: - url: 'http://127.0.0.1:8080/webhook' inhibit_rules: - source_match: severity: 'critical' target_match: severity: 'warning' equal: ['alertname', 'dev', 'instance'] \",\"重新启动alertmanager，获取通过热加载的方式重新加载配置文件。\",\"在浏览器中访问localhost:9093，可以看到alertmanager的界面。\"]},\"159\":{\"h\":\"在prometheus中配置告警规则\",\"t\":[\"在prometheus的启动程序的同级目录下面，建一个first_rule.yml的文件，这个文件是告警规则计算的配置，内容如下：\",\"groups: - name: test rules: - alert: HighQps expr: sum(increase(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m])) > 1 for: 1m labels: severity: page env: test region: wuhan annotations: summary: HighQps description: '{{ $value }}' \",\"在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：\",\"alert：告警规则的名称。\",\"expr：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。\",\"for：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。\",\"labels：自定义标签，允许用户指定要附加到告警上的一组附加标签。\",\"annotations：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。\",\"在Prometheus的配置文件中，增加告警规则的配置：\",\"alerting: alertmanagers: - static_configs: - targets: - 127.0.0.1:909 rule_files: - ./first_rule.yml \",\"最好创建一个目录专门存储告警规则文件，然后用*.yml去配置所有的告警规则文件。\",\"访问Prometheus的规则文件界面（http://127.0.0.1:9090/rules），可以看到的规则状态如下：\",\"image-20231021174512876\",\"等待1分钟，访问Prometheus的告警页面界面（http://127.0.0.1:9090/alerts?search=），可以看到已经有一条告警消息已经发送给Alertmanager\",\"image-20231021174854220\"]},\"160\":{\"h\":\"Alertmanager查看告警消息\",\"t\":[\"访问alertmanager的界面（http://localhost:9093/#/alerts），显示告警消息已经收到：\",\"image-20231021174948512\"]},\"161\":{\"h\":\"webhook\",\"t\":[\"Alertmanager收到告警消息后，如果判断需要发送消息给下游的Webhook程序，将通过POST的http请求发送下游程序，发送的告警消息的JSON格式如下：\",\"https://prometheus.io/docs/alerting/latest/configuration/#webhook_config\",\"{ \\\"version\\\": \\\"4\\\", \\\"groupKey\\\": <string>, // key identifying the group of alerts (e.g. to deduplicate) \\\"truncatedAlerts\\\": <int>, // how many alerts have been truncated due to \\\"max_alerts\\\" \\\"status\\\": \\\"<resolved|firing>\\\", \\\"receiver\\\": <string>, \\\"groupLabels\\\": <object>, \\\"commonLabels\\\": <object>, \\\"commonAnnotations\\\": <object>, \\\"externalURL\\\": <string>, // backlink to the Alertmanager. \\\"alerts\\\": [ { \\\"status\\\": \\\"<resolved|firing>\\\", \\\"labels\\\": <object>, \\\"annotations\\\": <object>, \\\"startsAt\\\": \\\"<rfc3339>\\\", \\\"endsAt\\\": \\\"<rfc3339>\\\", \\\"generatorURL\\\": <string>, // identifies the entity that caused the alert \\\"fingerprint\\\": <string> // fingerprint to identify the alert }, ... ] } \",\"对应的Java实体如下：\",\" public class Webhook { public String receiver; public String status; public ArrayList<Alert> alerts; public Map<String,String> groupLabels; public Map<String,String> commonLabels; public Map<String,String> commonAnnotations; public String externalURL; public String version; public String groupKey; public int truncatedAlerts public static class Alert { public String status; public Map<String,String> labels; public Map<String,String> annotations; public Date startsAt; public Date endsAt; public String generatorURL; public String fingerprint; } } \",\"在Springboot项目中，写一个接口如下：\",\" @PostMapping(\\\"/webhook\\\") public String webhook(@RequestBody Webhook webhook) { logger.info(webhook.toString()); return \\\"ok\\\"; } \",\"这样webhook的程序收到告警消息后，就可以具体的执行告警逻辑，比如将告警消息发送给运维人员的邮箱。\"]},\"162\":{\"h\":\"参考文档\",\"t\":[\"https://blog.csdn.net/qq_37843943/article/details/120665690\",\"https://www.jianshu.com/p/c661e8050434\",\"https://blog.51cto.com/starsliao/5763175\",\"https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/alert/prometheus-alert-rule\"]},\"163\":{\"h\":\"Prometheus预处理计算-Recording Rule\",\"t\":[\"prometheus支持两种规则表达式，一种是告警告警规则表达式，另外一种是预计算规则recording rule。recording rule是预先计算成本较高的表达式，并将计算结果保存在一组新的时间序列上。预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多。\"]},\"164\":{\"h\":\"定义Recoding rules\",\"t\":[\"Prometheus会定时的根据拉取expr定时表达式的数据，并将数据的结果存储在新的时间序列中，新的序列名称为record中的值。如果expr表达式的计算结果包含标签，则会把标签添加到新的序列中，如果labels配置中含有额外的标签也会放到新的timeseries中。\",\"和alert rule类似，每个Recording rule的规则定义如下：\",\"groups: - name: example rules: - record: job:http_inprogress_requests:sum expr: sum(http_inprogress_requests) by (job) \",\"rule_group可以配置两个参数：\",\"name，group的名称，需要全局唯一\",\"interval, rule_group执行的时间间隔，如果没有配置，则默认是global.evaluation_interval\",\"Groups.rules选项是recording-rule的具体配置，可以有以下几个配置项：\",\"record ： expr执行后生成新的指标的名称，指标名称的定义可以参考下面一小节\",\"expr：具体预处理生成指标的表达式。\",\"labels：可以在新生成的指标上额外加一些标签。\",\"记录和告警规则存在于规则组中。组内的规则以固定的时间间隔按顺序运行，评估时间相同。记录规则的名称必须是有效的指标名称。警报规则的名称必须是有效的标签值。\",\"另外如果没有配置groups的interval配置，recording的计算规则和alert的计算规则，都可以通过以下配置，进行全局的计算频次的设置：\",\"global: [ evaluation_interval: <duration> | default = 1m ] \"]},\"165\":{\"h\":\"recording rule的最佳实践\",\"t\":[\"recording rule的命令规范很重要，一个好的命名规范可以一目了然的知道规则的含义，避免出现一些无意义的计算。\"]},\"166\":{\"h\":\"命名规范\",\"t\":[\"通过recording rule产生的新的指标，应该遵循通用的方式：level:metric:operations\",\"level 表示聚合的级别和规则标签的输出\",\"metric 是和预聚合前的名称保存一致\",\"Operations 是应用于指标的操作函数列表，最新的操作函数在前。\",\"当对counter类型使用rate或者是irate操作，去掉_total的后缀\",\"当对指标用作除法,并且是求百分数，可以使用_per_\",\"例如：\",\"- record: instance_path:requests:rate5m expr: rate(requests_total{job=\\\"myjob\\\"}[5m]) \",\"上面的表达式rate(requests_total{job=\\\"myjob\\\"}[5m])，有两个标签分别是instance和path，所以它的level可以命名为instance_path；对meric使用了rate操作将metric原来的名称去掉_total；最后使用是rate操作\",\"最终根据上面的表达式得到的指标的名称是instance_path:requests:rate5m；我们可以根据指标的名称可以反推出指标的表达式，这样真的一目了然。\",\"其他例子：\",\"- record: instance_path:request_failures:rate5m expr: rate(request_failures_total{job=\\\"myjob\\\"}[5m]) - record: instance_path:request_failures_per_requests:ratio_rate5m expr: |2 instance_path:request_failures:rate5m{job=\\\"myjob\\\"} / instance_path:requests:rate5m{job=\\\"myjob\\\"} # Aggregate up numerator and denominator, then divide to get path-level ratio. - record: path:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) # No labels left from instrumentation or distinguishing instances, # so we use 'job' as the level. - record: job:request_failures_per_requests:ratio_rate5m expr: |2 sum without (instance, path)(instance_path:request_failures:rate5m{job=\\\"myjob\\\"}) / sum without (instance, path)(instance_path:requests:rate5m{job=\\\"myjob\\\"}) \"]},\"167\":{\"h\":\"实战\",\"t\":[\"新建一个recoding_rule.yml的文件，在文件中写一个指标聚合的表达式，该表达式的计算时间间隔为1分钟，表达式的含义是计算每分钟handler=\\\"/metrics\\\"的请求量，另外在新生成的指标上添加一个新的标签region，具体表达式格式如下：\",\"groups: - name: recording_rule interval: 1m rules: - record: instance_handler_code:prometheus_http_requests:rate1m expr: sum(rate(prometheus_http_requests_total{handler=\\\"/metrics\\\"}[1m]) )by(instance,handler,code) labels: region: wuhan \",\"在Prometheus的yaml配置文件中，通过rule_files定义recoding rule规则文件的路径。\",\"rule_files: - ./first_rule.yml - ./recoding_rule.yml \",\"重新启动Prometheus，在Prometheus的页面上可以查看新指标的数据，如下：\",\"image-20231023210926364\"]}},\"dirtCount\":0,\"index\":[[\"表达式的含义是计算每分钟handler=\",{\"1\":{\"167\":1}}],[\"表示聚合的级别和规则标签的输出\",{\"1\":{\"166\":1}}],[\"表示小于0\",{\"1\":{\"129\":2}}],[\"表示的是当前系统文件系统中磁盘可用的字节数\",{\"1\":{\"128\":1}}],[\"该表达式的计算时间间隔为1分钟\",{\"1\":{\"167\":1}}],[\"该类使用抽象工厂模式创建不同的产品对象\",{\"1\":{\"98\":1}}],[\"应该遵循通用的方式\",{\"1\":{\"166\":1}}],[\"命名规范\",{\"0\":{\"166\":1}}],[\"避免出现一些无意义的计算\",{\"1\":{\"165\":1}}],[\"避免出现对业务的影响\",{\"1\":{\"116\":1}}],[\"警报规则的名称必须是有效的标签值\",{\"1\":{\"164\":1}}],[\"警告容器\",{\"1\":{\"19\":1}}],[\"记录规则的名称必须是有效的指标名称\",{\"1\":{\"164\":1}}],[\"记录和告警规则存在于规则组中\",{\"1\":{\"164\":1}}],[\"预先计算的结果通常它的查询速度要比每次执行原始表达式要快很多\",{\"1\":{\"163\":1}}],[\"预测指标变化趋势\",{\"0\":{\"144\":1}}],[\"预测系统磁盘在6个小时之后的剩余情况\",{\"1\":{\"128\":1}}],[\"qq\",{\"1\":{\"162\":1}}],[\"querying\",{\"1\":{\"146\":1}}],[\"quantile函数进行计算\",{\"1\":{\"145\":1}}],[\"quantile函数在prometheus\",{\"1\":{\"130\":1}}],[\"quantile\",{\"1\":{\"129\":1,\"141\":2,\"145\":3,\"151\":1}}],[\"quantile=\",{\"1\":{\"119\":5,\"130\":5}}],[\"参考文档\",{\"0\":{\"162\":1}}],[\"参数的配置会在以后的文章中讲解\",{\"1\":{\"158\":1}}],[\"发送的告警消息的json格式如下\",{\"1\":{\"161\":1}}],[\"发布者对象可以对所有的观察者发送消息\",{\"1\":{\"102\":1}}],[\"发布者publisher\",{\"1\":{\"100\":1}}],[\"显示告警消息已经收到\",{\"1\":{\"160\":1}}],[\"等待1分钟\",{\"1\":{\"159\":1}}],[\"允许用户指定要附加到告警上的一组附加标签\",{\"1\":{\"159\":1}}],[\"允许prometheus运行\",{\"1\":{\"118\":1}}],[\"评估时间相同\",{\"1\":{\"164\":1}}],[\"评估等待时间\",{\"1\":{\"159\":1}}],[\"评论\",{\"1\":{\"7\":1,\"45\":1}}],[\"$value\",{\"1\":{\"159\":1}}],[\"建一个first\",{\"1\":{\"159\":1}}],[\"前提条件是两个告警的alertname\",{\"1\":{\"158\":1}}],[\"禁止规则会静音与一组匹配器匹配的警报\",{\"1\":{\"158\":1}}],[\"禁用\",{\"2\":{\"9\":1}}],[\"禁用了如下功能\",{\"1\":{\"7\":1}}],[\"禁用展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"源\",{\"1\":{\"158\":1}}],[\"源码下载\",{\"0\":{\"75\":1,\"79\":1,\"84\":1}}],[\"即alertmanager通过http接口调用来发送告警消息\",{\"1\":{\"158\":1}}],[\"即一个指标代表一种含义\",{\"1\":{\"125\":1}}],[\"邮箱等\",{\"1\":{\"158\":1}}],[\"微信\",{\"1\":{\"158\":1}}],[\"再次发送通知前等待的时间\",{\"1\":{\"158\":1}}],[\"再比如下面的查询语句的可以输出结果\",{\"1\":{\"136\":1}}],[\"几分钟\",{\"1\":{\"158\":1}}],[\"或等待同一组告警采集更多初始告警后一起发送\",{\"1\":{\"158\":1}}],[\"或者重启的进程的时候重置为0\",{\"1\":{\"126\":1}}],[\"或者静态的配置文件\",{\"1\":{\"115\":1}}],[\"或者被称为被观察者\",{\"1\":{\"100\":1}}],[\"或者访问资源配置文件的reader\",{\"1\":{\"67\":1}}],[\"默认alertname\",{\"1\":{\"158\":1}}],[\"默认的配置文件如下\",{\"1\":{\"157\":1}}],[\"已解决\",{\"1\":{\"158\":1}}],[\"合理设置抑制规则可以减少垃圾告警的产生\",{\"1\":{\"157\":1}}],[\"接收人一般配合告警路由使用\",{\"1\":{\"157\":1}}],[\"接收人是一个抽象的概念\",{\"1\":{\"157\":1}}],[\"接收人\",{\"1\":{\"157\":1}}],[\"接口\",{\"1\":{\"156\":1}}],[\"接口的p90耗时\",{\"1\":{\"145\":1}}],[\"接口的数据\",{\"1\":{\"132\":1}}],[\"接口如戏\",{\"1\":{\"121\":1}}],[\"确定当前告警应该如何处理\",{\"1\":{\"157\":1}}],[\"全局配置\",{\"1\":{\"157\":1}}],[\"抑制允许根据另一组警报的存在来静音一组警报\",{\"1\":{\"158\":1}}],[\"抑制规则\",{\"1\":{\"157\":1}}],[\"抑制是当某一告警已经发出\",{\"1\":{\"155\":1}}],[\"抑制\",{\"0\":{\"155\":1}}],[\"抑制和静默等核心功能\",{\"1\":{\"152\":1,\"153\":1}}],[\"某个数据库出现网络故障\",{\"1\":{\"154\":1}}],[\"先了解这些核心概念\",{\"1\":{\"153\":1}}],[\"则默认是global\",{\"1\":{\"164\":1}}],[\"则会把标签添加到新的序列中\",{\"1\":{\"164\":1}}],[\"则会出现几百上千的告警消息\",{\"1\":{\"154\":1}}],[\"则向alertmanager发送告警消息\",{\"1\":{\"152\":1}}],[\"则返回singleton\",{\"1\":{\"70\":1}}],[\"存储采集到的数据\",{\"1\":{\"152\":1}}],[\"存储了node\",{\"1\":{\"123\":1}}],[\"起到了时序数据库的作用\",{\"1\":{\"152\":1}}],[\"路由\",{\"1\":{\"153\":1}}],[\"路由分发\",{\"1\":{\"152\":1}}],[\"路径导航\",{\"1\":{\"7\":1,\"45\":1}}],[\"开启httpserver\",{\"1\":{\"149\":1}}],[\"开始cglib拦截\",{\"1\":{\"108\":2}}],[\"完整的代码如下\",{\"1\":{\"149\":1}}],[\"完全匹配\",{\"1\":{\"136\":1}}],[\"统计请求的次数和请求耗时\",{\"1\":{\"149\":1}}],[\"统一全局的访问点控制\",{\"1\":{\"67\":1}}],[\"另一种是使用prometheus的java客户端\",{\"1\":{\"147\":1}}],[\"另外在新生成的指标上添加一个新的标签region\",{\"1\":{\"167\":1}}],[\"另外如果没有配置groups的interval配置\",{\"1\":{\"164\":1}}],[\"另外一种是预计算规则recording\",{\"1\":{\"163\":1}}],[\"另外也可以筛选出handler\",{\"1\":{\"132\":1}}],[\"另外\",{\"1\":{\"129\":1}}],[\"详细内容可以查看官方网站\",{\"1\":{\"146\":1}}],[\"详情\",{\"0\":{\"58\":1,\"62\":1}}],[\"详情容器\",{\"1\":{\"19\":1}}],[\"来预测主机可用磁盘空间的是否在24个小时候被占满\",{\"1\":{\"144\":1}}],[\"来解析\",{\"1\":{\"16\":1}}],[\"基于promql表达式告警触发条件\",{\"1\":{\"159\":1}}],[\"基于5小时的样本数据\",{\"1\":{\"144\":1}}],[\"基本查询格式是\",{\"1\":{\"141\":1}}],[\"基本功能实现类和不同的装饰器只实现自己的独一的功能\",{\"1\":{\"83\":1}}],[\"长尾问题\",{\"1\":{\"143\":2}}],[\"长期趋势分析\",{\"1\":{\"116\":1}}],[\"容易陷入\",{\"1\":{\"143\":1}}],[\"≤\",{\"1\":{\"141\":2}}],[\"φ\",{\"1\":{\"141\":2,\"145\":1}}],[\"得到的结果是\",{\"1\":{\"140\":2}}],[\"举例子讲解\",{\"1\":{\"140\":1}}],[\"举个例子\",{\"1\":{\"125\":1}}],[\"举个现实例子\",{\"1\":{\"76\":1}}],[\"忽略\",{\"1\":{\"139\":1}}],[\"匹配\",{\"1\":{\"139\":1}}],[\"求并集\",{\"1\":{\"138\":1}}],[\"求交集\",{\"1\":{\"138\":1}}],[\"逻辑运算符作用于两个瞬时向量之间\",{\"1\":{\"138\":1}}],[\"逻辑运算符\",{\"0\":{\"138\":1}}],[\"右侧的表达式也有一个handler=\",{\"1\":{\"136\":1}}],[\"否则将匹配不到\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"左侧的标签条目和右侧的标签条目必须要相同\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"幂运算\",{\"1\":{\"136\":1}}],[\"^\",{\"1\":{\"136\":1}}],[\"取模\",{\"1\":{\"136\":1}}],[\"取反操作\",{\"1\":{\"132\":1}}],[\"乘\",{\"1\":{\"136\":1}}],[\"减\",{\"1\":{\"136\":1}}],[\"减少同步创建实例的开销\",{\"1\":{\"70\":1}}],[\"常见的逻辑运算符如下\",{\"1\":{\"136\":1}}],[\"数学操作符\",{\"0\":{\"136\":1}}],[\"数据可视化\",{\"1\":{\"116\":1}}],[\"操作符\",{\"0\":{\"135\":1},\"1\":{\"146\":1}}],[\"怎么查询呢\",{\"1\":{\"134\":1}}],[\"获取通过热加载的方式重新加载配置文件\",{\"1\":{\"158\":1}}],[\"获取最近五分钟的样本\",{\"1\":{\"143\":1}}],[\"获取请求次数最多的5个请求\",{\"1\":{\"141\":1}}],[\"获取昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"134\":1}}],[\"获取了prometheus\",{\"1\":{\"132\":1}}],[\"天\",{\"1\":{\"133\":1}}],[\"小时\",{\"1\":{\"133\":1}}],[\"小结\",{\"1\":{\"132\":1}}],[\"秒\",{\"1\":{\"133\":1}}],[\"外\",{\"1\":{\"133\":1}}],[\"范围向量表达式和瞬时向量表达式之间的差异在于在区间向量表达式中我们需要定义时间选择的范围\",{\"1\":{\"133\":1}}],[\"范围向量查询\",{\"0\":{\"133\":1}}],[\"|2\",{\"1\":{\"166\":3}}],[\"|value2\",{\"1\":{\"132\":1}}],[\"|\",{\"1\":{\"132\":1,\"164\":1}}],[\"~3h\",{\"1\":{\"158\":1}}],[\"~5m\",{\"1\":{\"158\":1}}],[\"~0s\",{\"1\":{\"158\":1}}],[\"~\",{\"1\":{\"132\":3,\"158\":1}}],[\"查询的是昨天的当前时间同一时刻的五分钟的数据\",{\"1\":{\"134\":1}}],[\"查询的是当前时间的过去五分钟的数据\",{\"1\":{\"134\":1}}],[\"查询五分钟前的最新值\",{\"1\":{\"134\":1}}],[\"查询当前时间的最新值\",{\"1\":{\"134\":1}}],[\"查询语句为\",{\"1\":{\"132\":1}}],[\"查看详情\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1}}],[\"瞬时向量查询和范围向量查询的表达式中\",{\"1\":{\"134\":1}}],[\"瞬时向量查询\",{\"0\":{\"132\":1}}],[\"计算p99耗时的表达式如下\",{\"1\":{\"145\":1}}],[\"计算handler=\",{\"1\":{\"145\":1}}],[\"计算分位数\",{\"0\":{\"145\":1}}],[\"计算counter的增长率\",{\"0\":{\"143\":1}}],[\"计算的结果会产生一条新的时间序列\",{\"1\":{\"131\":1}}],[\"计划\",{\"1\":{\"26\":2}}],[\"转换等计算\",{\"1\":{\"131\":1}}],[\"聚合完后的结果会生成根据聚合标签生成一个新的序列\",{\"1\":{\"141\":1}}],[\"聚合函数\",{\"0\":{\"141\":1}}],[\"聚合\",{\"1\":{\"131\":1}}],[\"过滤\",{\"1\":{\"131\":1}}],[\"过多的观察者会影响性能\",{\"1\":{\"102\":1}}],[\"函数\",{\"1\":{\"146\":1}}],[\"函数格式为\",{\"1\":{\"145\":1}}],[\"函数的格式如下\",{\"1\":{\"144\":1}}],[\"函数的内容\",{\"1\":{\"127\":1}}],[\"函数计算出其值的分位数\",{\"1\":{\"129\":1}}],[\"600\",{\"1\":{\"140\":4}}],[\"60\",{\"1\":{\"129\":1,\"143\":1,\"145\":1}}],[\"6\",{\"1\":{\"128\":1,\"130\":1,\"140\":3}}],[\"除了使用increase函数计算增量外\",{\"1\":{\"143\":1}}],[\"除了prometheus很多组件是可选的\",{\"1\":{\"114\":1}}],[\"除\",{\"1\":{\"136\":1}}],[\"除非进程重启重置\",{\"1\":{\"127\":1}}],[\"摘要\",{\"1\":{\"126\":1}}],[\"直方图\",{\"1\":{\"126\":1}}],[\"直接采集的jobs和exporters\",{\"1\":{\"115\":1}}],[\"状态值\",{\"1\":{\"126\":1}}],[\"仪表盘\",{\"1\":{\"126\":1}}],[\"初始值为零\",{\"1\":{\"127\":1}}],[\"初始值为0\",{\"1\":{\"126\":1}}],[\"初始化对象\",{\"1\":{\"70\":1}}],[\"累加器\",{\"0\":{\"127\":1},\"1\":{\"126\":1}}],[\"值\",{\"1\":{\"125\":1}}],[\"值和一个或者是多个key\",{\"1\":{\"112\":1}}],[\"被称为time\",{\"1\":{\"125\":1}}],[\"8080\",{\"1\":{\"148\":3,\"149\":1,\"158\":1}}],[\"8\",{\"1\":{\"129\":1,\"145\":1}}],[\"817\",{\"1\":{\"125\":2}}],[\"822\",{\"1\":{\"125\":2}}],[\"82\",{\"1\":{\"125\":2}}],[\"82033736e+08\",{\"1\":{\"119\":1}}],[\"且只支持浮点数指标\",{\"1\":{\"125\":1}}],[\"时\",{\"1\":{\"158\":1}}],[\"时间位移操作\",{\"0\":{\"134\":1}}],[\"时间范围除了支持分钟\",{\"1\":{\"133\":1}}],[\"时间范围通过时间范围选择器\",{\"1\":{\"133\":1}}],[\"时间戳精度为毫秒\",{\"1\":{\"125\":1}}],[\"时间戳\",{\"1\":{\"125\":1}}],[\"时间序列\",{\"1\":{\"125\":1}}],[\"时间序列是指标\",{\"1\":{\"125\":1}}],[\"时序数据使用http协议采集\",{\"1\":{\"113\":1}}],[\"读取prometheus的指标时序\",{\"1\":{\"123\":1}}],[\"总结\",{\"0\":{\"123\":1,\"146\":1}}],[\"总之\",{\"1\":{\"88\":1}}],[\"搜索成功后\",{\"1\":{\"122\":1}}],[\"搜索地址\",{\"1\":{\"122\":1}}],[\"登陆成功后\",{\"1\":{\"122\":1}}],[\"密码为admin\",{\"1\":{\"122\":1}}],[\"密码加密的文章\",{\"0\":{\"10\":1}}],[\"地址为localhost\",{\"1\":{\"122\":1}}],[\"进程发送\",{\"1\":{\"156\":1}}],[\"进入grafana的页面\",{\"1\":{\"122\":1}}],[\"进入grafana官网下载安装包\",{\"1\":{\"122\":1}}],[\"进入到grafana的安装目录\",{\"1\":{\"122\":1}}],[\"进行全局的计算频次的设置\",{\"1\":{\"164\":1}}],[\"进行定义\",{\"1\":{\"133\":1}}],[\"进行数据的转换或者功能的增强\",{\"1\":{\"80\":1}}],[\"进行引用\",{\"1\":{\"44\":2}}],[\"炫酷的展示数据的可视化仪表盘\",{\"1\":{\"122\":1}}],[\"流行的\",{\"1\":{\"122\":1}}],[\"流程图\",{\"0\":{\"31\":1}}],[\"访问alertmanager的界面\",{\"1\":{\"160\":1}}],[\"访问prometheus的告警页面界面\",{\"1\":{\"159\":1}}],[\"访问prometheus的规则文件界面\",{\"1\":{\"159\":1}}],[\"访问prometheus的网页\",{\"1\":{\"120\":1}}],[\"访问http\",{\"1\":{\"118\":1,\"120\":1}}],[\"重新启动alertmanager\",{\"1\":{\"158\":1}}],[\"重新启动prometheus\",{\"1\":{\"167\":1}}],[\"重新启动prometheus或者热加载\",{\"1\":{\"150\":1}}],[\"重新启动prometheus的程序\",{\"1\":{\"120\":1}}],[\"重新加载一下配置\",{\"1\":{\"150\":1}}],[\"重要的内容\",{\"1\":{\"25\":1}}],[\"95\",{\"1\":{\"151\":1}}],[\"9400\",{\"1\":{\"149\":2,\"150\":1}}],[\"99\",{\"1\":{\"145\":1}}],[\"9\",{\"1\":{\"125\":1,\"145\":1}}],[\"9100\",{\"1\":{\"120\":2}}],[\"909\",{\"1\":{\"159\":1}}],[\"9093\",{\"1\":{\"119\":1,\"158\":1,\"160\":1}}],[\"9090\",{\"1\":{\"118\":1,\"119\":2,\"120\":2,\"121\":1,\"141\":1,\"145\":10,\"159\":2}}],[\"9000\",{\"1\":{\"87\":2}}],[\"启动alertmanager可以使用以下命令\",{\"1\":{\"157\":1}}],[\"启动命令如下\",{\"1\":{\"122\":1}}],[\"启动grafana\",{\"1\":{\"122\":1}}],[\"启动node\",{\"1\":{\"120\":1}}],[\"启动成功后\",{\"1\":{\"118\":1,\"122\":1}}],[\"磁盘\",{\"1\":{\"120\":1}}],[\"内存\",{\"1\":{\"120\":1}}],[\"内容如下\",{\"1\":{\"119\":1,\"159\":1}}],[\"内容\",{\"1\":{\"16\":1}}],[\"75\",{\"1\":{\"119\":1,\"130\":1}}],[\"745e\",{\"1\":{\"119\":1}}],[\"7\",{\"1\":{\"119\":1,\"148\":1}}],[\"4h\",{\"1\":{\"158\":1}}],[\"44\",{\"1\":{\"149\":1}}],[\"4<\",{\"1\":{\"148\":1}}],[\"404\",{\"1\":{\"140\":4}}],[\"489234e+06\",{\"1\":{\"119\":1}}],[\"4\",{\"1\":{\"119\":1,\"122\":2,\"129\":1,\"145\":1,\"161\":1}}],[\"47\",{\"1\":{\"118\":2}}],[\"支持的逻辑运算符如下\",{\"1\":{\"138\":1}}],[\"支持多种类型的采集\",{\"1\":{\"119\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"27\":1}}],[\"周\",{\"1\":{\"133\":1}}],[\"周期性采集监控目标\",{\"1\":{\"119\":1}}],[\"周边生态非常的丰富\",{\"1\":{\"112\":1}}],[\"笔者是mac\",{\"1\":{\"122\":1}}],[\"笔者是mac电脑\",{\"1\":{\"118\":1}}],[\"笔者这里下载mac版本的\",{\"1\":{\"118\":1}}],[\"安装prometheus\",{\"0\":{\"118\":1}}],[\"安装成功后\",{\"1\":{\"117\":1}}],[\"安全与隐私\",{\"1\":{\"118\":1}}],[\"安全\",{\"1\":{\"69\":1}}],[\"安全的在\",{\"1\":{\"19\":1}}],[\"包括消息的去重\",{\"1\":{\"153\":1}}],[\"包括两个标签uri\",{\"1\":{\"149\":2}}],[\"包括prometheus\",{\"1\":{\"117\":1}}],[\"包含\",{\"1\":{\"19\":1}}],[\"以及告警的接受方式可以通过alertmanager的配置文件进行配置\",{\"1\":{\"154\":1}}],[\"以及服务运行状态等直观的信息\",{\"1\":{\"116\":1}}],[\"以\",{\"1\":{\"129\":2}}],[\"以便在中断期间仅发送一组互连警报中最相关的警报\",{\"1\":{\"158\":1}}],[\"以便\",{\"1\":{\"13\":1}}],[\"资源使用情况\",{\"1\":{\"116\":1}}],[\"故障分析与定位\",{\"1\":{\"116\":1}}],[\"监控系统需要迅速反应并通知管理员\",{\"1\":{\"116\":1}}],[\"监控对象的发现\",{\"1\":{\"115\":1}}],[\"两个版本的系统运行资源使用情况的差异如何\",{\"1\":{\"116\":1}}],[\"例如有以下的指标prometheus\",{\"1\":{\"145\":1}}],[\"例如下面的查询语句不会输出任何结果\",{\"1\":{\"136\":1}}],[\"例如go\",{\"1\":{\"130\":1}}],[\"例如0\",{\"1\":{\"129\":1}}],[\"例如prometheus的服务的\",{\"1\":{\"129\":1}}],[\"例如prometheus\",{\"1\":{\"127\":1,\"153\":1}}],[\"例如\",{\"1\":{\"116\":1,\"128\":1,\"129\":1,\"133\":1,\"143\":1,\"144\":1,\"155\":1,\"166\":1}}],[\"例如代理私有方法\",{\"1\":{\"108\":1}}],[\"去掉\",{\"1\":{\"166\":1}}],[\"去prometheus官网下载prometheus\",{\"1\":{\"118\":1}}],[\"去重\",{\"1\":{\"115\":1}}],[\"去提供获取对象的服务\",{\"1\":{\"69\":1}}],[\"健康对象包含\",{\"1\":{\"115\":1}}],[\"架构\",{\"0\":{\"115\":1}}],[\"非常容易的打包和部署\",{\"1\":{\"114\":1}}],[\"大多数prometheus组件都是使用go语言写的\",{\"1\":{\"114\":1}}],[\"大量的类\",{\"1\":{\"95\":1}}],[\"恢复等管理\",{\"1\":{\"114\":1}}],[\"静默提供了一个标签匹配的设置\",{\"1\":{\"156\":1}}],[\"静默\",{\"0\":{\"156\":1},\"1\":{\"114\":1,\"115\":1}}],[\"静态代理的优点是简单易懂\",{\"1\":{\"104\":1}}],[\"静态代理需要手动创建一个代理类\",{\"1\":{\"104\":1}}],[\"静态代理\",{\"0\":{\"104\":1}}],[\"静态方法用来返回其所属类的一个相同实例\",{\"1\":{\"68\":1}}],[\"静态对象用来存储对象自身的属性和方法\",{\"1\":{\"68\":1}}],[\"用increase函数算出五分钟的增量\",{\"1\":{\"143\":1}}],[\"用来抓取和存储时序数据的\",{\"1\":{\"114\":1}}],[\"用于指定一组附加信息\",{\"1\":{\"159\":1}}],[\"用于指标数据的统计\",{\"1\":{\"149\":1}}],[\"用于表示只有当触发条件持续一段时间后才发送告警\",{\"1\":{\"159\":1}}],[\"用于计算是否有时间序列满足该条件\",{\"1\":{\"159\":1}}],[\"用于等待抑制告警\",{\"1\":{\"158\":1}}],[\"用于定义一些全局的公共参数\",{\"1\":{\"157\":1}}],[\"用于向alertmanager发送告警消息\",{\"1\":{\"152\":1}}],[\"用于统计请求的耗时\",{\"1\":{\"149\":1}}],[\"用于统计请求的数量\",{\"1\":{\"149\":1}}],[\"用于java程序的指标暴露\",{\"1\":{\"149\":1}}],[\"用于求分位数\",{\"1\":{\"126\":1}}],[\"用于在运行时扩展java类和实现动态代理\",{\"1\":{\"108\":1}}],[\"用于对象之间的一对多的依赖关系\",{\"1\":{\"99\":1}}],[\"用于创建产品对象的接口\",{\"1\":{\"94\":1}}],[\"采用的数据模型是单值模型\",{\"1\":{\"125\":1}}],[\"采用装饰器模式能够快速的扩展功能\",{\"1\":{\"83\":1}}],[\"采集了node\",{\"1\":{\"123\":1}}],[\"采集node\",{\"0\":{\"120\":1},\"1\":{\"152\":1}}],[\"采集监控对象的指标\",{\"1\":{\"115\":1}}],[\"采集目标可以使用服务发现的方式\",{\"1\":{\"113\":1}}],[\"通配符进行模糊匹配查询\",{\"1\":{\"132\":1}}],[\"通常设置为3小时或更长时间\",{\"1\":{\"158\":1}}],[\"通常是webhook\",{\"1\":{\"152\":1}}],[\"通常是pull模式\",{\"1\":{\"113\":1}}],[\"通常使用以下的关键字\",{\"1\":{\"140\":1}}],[\"通常情况下\",{\"1\":{\"130\":1}}],[\"通常15\",{\"1\":{\"115\":1}}],[\"通过rule\",{\"1\":{\"167\":1}}],[\"通过recording\",{\"1\":{\"166\":1}}],[\"通过向alertmanager\",{\"1\":{\"156\":1}}],[\"通过配置文件去配置一些配置\",{\"1\":{\"156\":1}}],[\"通过alertmanager的配置可以忽略与该集群有关的其它告警功能\",{\"1\":{\"155\":1}}],[\"通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态\",{\"1\":{\"143\":1}}],[\"通过instant\",{\"1\":{\"133\":1}}],[\"通过以下表达式可以选择最近5分钟内的所有样本数据\",{\"1\":{\"133\":1}}],[\"通过这种直方图可以很方便的统计请求耗时分布的真实状态\",{\"1\":{\"129\":1}}],[\"通过拉prometheus的配置热更新接口\",{\"1\":{\"121\":1}}],[\"通过可视化仪表盘能够直接获取系统的运行状态\",{\"1\":{\"116\":1}}],[\"通过监控能够方便的对系统进行跟踪和比较\",{\"1\":{\"116\":1}}],[\"通过对不同监控监控以及历史数据的分析\",{\"1\":{\"116\":1}}],[\"通过对磁盘空间增长率的判断\",{\"1\":{\"116\":1}}],[\"通过对监控样本数据的持续收集和统计\",{\"1\":{\"116\":1}}],[\"通过prometheus建立完善的监控体系\",{\"1\":{\"116\":1}}],[\"通过了内置的告警规则计算\",{\"1\":{\"115\":1}}],[\"通过中间层push\",{\"1\":{\"113\":1}}],[\"通过包装不同的装饰器组合来满足自己的业务需求\",{\"1\":{\"83\":1}}],[\"通过\",{\"1\":{\"15\":1,\"18\":1,\"125\":1}}],[\"指标数据如下\",{\"1\":{\"149\":1}}],[\"指标的名称是监控样本的标识\",{\"1\":{\"131\":1}}],[\"指标的类型\",{\"0\":{\"126\":1}}],[\"指标名将会被删除\",{\"1\":{\"136\":1}}],[\"指标名和标签名的命名需要满足\",{\"1\":{\"125\":1}}],[\"指标名称的定义可以参考下面一小节\",{\"1\":{\"164\":1}}],[\"指标名称\",{\"1\":{\"125\":1}}],[\"指标是由指标名和标签组成\",{\"1\":{\"125\":1}}],[\"指标是单值模型\",{\"1\":{\"125\":1}}],[\"指标在不同时间有不同的值\",{\"1\":{\"125\":1}}],[\"指标在不同时间下的值\",{\"1\":{\"125\":1}}],[\"指标定义如下\",{\"1\":{\"125\":1}}],[\"指标\",{\"1\":{\"113\":1,\"125\":1}}],[\"指南\",{\"0\":{\"48\":1,\"52\":1}}],[\"白盒监控\",{\"1\":{\"113\":1}}],[\"作为新一代的监控系统\",{\"1\":{\"113\":1}}],[\"作者设置为\",{\"1\":{\"43\":1}}],[\"云平台配合\",{\"1\":{\"112\":1}}],[\"云原生计算基金会\",{\"1\":{\"112\":1}}],[\"能更好地与容器平台\",{\"1\":{\"112\":1}}],[\"能够找到并解决根源问题\",{\"1\":{\"116\":1}}],[\"能够实现不同产品族的兼容性和高度可扩展性\",{\"1\":{\"98\":1}}],[\"能够快速的扩展现有类的功能\",{\"1\":{\"83\":1}}],[\"同样的\",{\"1\":{\"149\":1}}],[\"同操作运算符一样\",{\"1\":{\"137\":1,\"138\":1}}],[\"同理\",{\"1\":{\"132\":1}}],[\"同年6月正式发布1\",{\"1\":{\"112\":1}}],[\"同时prometheus读取告警规则文件\",{\"1\":{\"152\":1}}],[\"同时prometheus作为一个时序数据库\",{\"1\":{\"123\":1}}],[\"同时\",{\"1\":{\"102\":1}}],[\"同时它具有以下的缺点\",{\"1\":{\"98\":1}}],[\"同时它是线程安全的\",{\"1\":{\"70\":1}}],[\"同时有不会影响原有的公民\",{\"1\":{\"83\":1}}],[\"告警规则的名称\",{\"1\":{\"159\":1}}],[\"告警路由\",{\"1\":{\"157\":1}}],[\"告警时间间隔\",{\"1\":{\"154\":1}}],[\"告警分组\",{\"1\":{\"154\":1}}],[\"告警消息的处理程序alertmanager\",{\"1\":{\"152\":1}}],[\"告警发送\",{\"1\":{\"152\":1}}],[\"告警语句的配置\",{\"1\":{\"131\":1}}],[\"告警\",{\"1\":{\"116\":1}}],[\"告警管理等一系列工具包\",{\"1\":{\"112\":1}}],[\"告警计算\",{\"1\":{\"112\":1}}],[\"最新的操作函数在前\",{\"1\":{\"166\":1}}],[\"最好创建一个目录专门存储告警规则文件\",{\"1\":{\"159\":1}}],[\"最终根据上面的表达式得到的指标的名称是instance\",{\"1\":{\"166\":1}}],[\"最终我的配置修改成如下\",{\"1\":{\"158\":1}}],[\"最终将消息发送给第三方组件\",{\"1\":{\"152\":1}}],[\"最终的技术架构如下\",{\"1\":{\"110\":1}}],[\"最后使用是rate操作\",{\"1\":{\"166\":1}}],[\"最后webhook发送给告警平台\",{\"1\":{\"152\":1}}],[\"最后\",{\"1\":{\"77\":1}}],[\"key\",{\"1\":{\"161\":1}}],[\"keyborad\",{\"1\":{\"77\":1}}],[\"keyboard\",{\"1\":{\"77\":5}}],[\"k\",{\"1\":{\"141\":2}}],[\"kafka\",{\"1\":{\"110\":1}}],[\"旨在记录和向读者讲述如何利用prometheus系列技术栈打造亿级指标的监控系统\",{\"1\":{\"110\":1}}],[\"本篇文章主要讲解如何在springboot项目中使用prometheus监控\",{\"1\":{\"147\":1}}],[\"本篇文章为系列教程\",{\"1\":{\"110\":1}}],[\"本文使用webhook的方式\",{\"1\":{\"158\":1}}],[\"本文快速的讲解了promql的查询\",{\"1\":{\"146\":1}}],[\"本文是prometheus环境的搭建和安装\",{\"1\":{\"117\":1}}],[\"本页面就是一个示例\",{\"1\":{\"7\":1}}],[\"打造亿级流量的监控系统\",{\"0\":{\"110\":1}}],[\"拦截静态方法等\",{\"1\":{\"108\":1}}],[\"更灵活地满足额外需求\",{\"1\":{\"108\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"45\":1}}],[\"更新时间\",{\"1\":{\"7\":1}}],[\"更新计划\",{\"0\":{\"1\":1,\"2\":1}}],[\"测试cglib\",{\"1\":{\"108\":1}}],[\"测试类\",{\"1\":{\"92\":1}}],[\"结束cglib拦截\",{\"1\":{\"108\":2}}],[\"结构型设计模式一共包括七种\",{\"1\":{\"65\":1}}],[\"执行启动命令\",{\"1\":{\"118\":1}}],[\"执行解压\",{\"1\":{\"118\":1}}],[\"执行结果如下\",{\"1\":{\"108\":1}}],[\"执行目标对象的方法\",{\"1\":{\"108\":1}}],[\"执行测试类\",{\"1\":{\"82\":1}}],[\"创建子类对象代理\",{\"1\":{\"108\":1}}],[\"创建和业务逻辑判断\",{\"1\":{\"92\":1}}],[\"工作流程包括\",{\"1\":{\"152\":1}}],[\"工具类\",{\"1\":{\"108\":1}}],[\"工厂方法模式中考虑的是一类产品的生产\",{\"1\":{\"96\":1}}],[\"工厂方法模式包含以下角色\",{\"1\":{\"94\":1}}],[\"工厂方法模式可以有效地避免简单工厂模式中工厂类过于臃肿的问题\",{\"1\":{\"93\":1}}],[\"工厂方法模式\",{\"0\":{\"93\":1},\"1\":{\"93\":1}}],[\"工厂类负责了两个职责\",{\"1\":{\"92\":1}}],[\"工厂类包含了所有产品对象的创建逻辑\",{\"1\":{\"92\":1}}],[\"工厂类包含了必要的逻辑判断\",{\"1\":{\"92\":1}}],[\"工厂类根据客户端传入的参数来创建相应的产品对象\",{\"1\":{\"91\":1}}],[\"工厂类\",{\"1\":{\"91\":1,\"92\":1}}],[\"工厂模式\",{\"0\":{\"89\":1}}],[\"维护一个目标对象\",{\"1\":{\"108\":1}}],[\"性能高\",{\"1\":{\"108\":1}}],[\"性能开销\",{\"1\":{\"107\":1}}],[\"性能监控等\",{\"1\":{\"107\":1}}],[\"缺点\",{\"1\":{\"107\":1}}],[\"灵活性\",{\"1\":{\"107\":1}}],[\"灵活性非常高\",{\"1\":{\"102\":1}}],[\"动态代理只能对接口进行代理\",{\"1\":{\"107\":1}}],[\"动态代理可以在运行时动态生成代理类\",{\"1\":{\"107\":1}}],[\"动态代理可以使用\",{\"1\":{\"106\":1}}],[\"动态代理的步骤是先实现invocationhandler接口\",{\"1\":{\"107\":1}}],[\"动态代理的优点是避免了手动创建代理类的麻烦\",{\"1\":{\"107\":1}}],[\"动态代理是使用java的反射机制来实现动态代理\",{\"1\":{\"107\":1}}],[\"动态代理是在运行时自动生成代理类并将方法调用转发到实际对象\",{\"1\":{\"107\":1}}],[\"动态代理机制和cglib动态代理\",{\"1\":{\"106\":1}}],[\"动态代理\",{\"0\":{\"106\":1,\"107\":1}}],[\"动态地实例化具体的产品类\",{\"1\":{\"92\":1}}],[\"远程调用\",{\"1\":{\"103\":1}}],[\"类似于mysql的sql查询语句\",{\"1\":{\"131\":1}}],[\"类似于kubernetes是从google的brog系统演变而来\",{\"1\":{\"112\":1}}],[\"类似于中介\",{\"1\":{\"103\":1}}],[\"类加载是加锁的\",{\"1\":{\"69\":1}}],[\"代理类\",{\"1\":{\"104\":1,\"105\":1}}],[\"代理对象可以控制客户端对真实对象的访问\",{\"1\":{\"103\":1}}],[\"代理模式分为静态代理和动态代码\",{\"1\":{\"104\":1}}],[\"代理模式常用于对已有功能的增强\",{\"1\":{\"103\":1}}],[\"代理模式是一种结构性模式\",{\"1\":{\"103\":1}}],[\"代理模式并没有做类似于装饰器模式多层嵌套\",{\"1\":{\"103\":1}}],[\"代理模式和装饰器模式类似\",{\"1\":{\"103\":1}}],[\"代理模式\",{\"0\":{\"103\":1}}],[\"代码会变得臃肿难以维护\",{\"1\":{\"104\":1}}],[\"代码如下\",{\"1\":{\"98\":4,\"101\":1,\"105\":1,\"107\":1,\"108\":2}}],[\"代码的可扩展性和可复用性非常的强\",{\"1\":{\"83\":1}}],[\"代码实现\",{\"0\":{\"77\":1,\"92\":1,\"95\":1,\"98\":1,\"105\":1}}],[\"代码编写\",{\"1\":{\"64\":1}}],[\"代码质量是设计出来的\",{\"1\":{\"64\":1}}],[\"代码演示\",{\"0\":{\"35\":1}}],[\"代码块\",{\"0\":{\"20\":1}}],[\"代码\",{\"1\":{\"19\":1}}],[\"综上所述\",{\"1\":{\"102\":1}}],[\"消息发布者publisher接口\",{\"1\":{\"101\":1}}],[\"观察者收到消息后可以做出响应\",{\"1\":{\"102\":1}}],[\"观察者会执行该方法\",{\"1\":{\"100\":1}}],[\"观察者observer\",{\"1\":{\"100\":1}}],[\"观察者模式是一种实用并且简单的设计模式\",{\"1\":{\"102\":1}}],[\"观察者模式也有一些缺点\",{\"1\":{\"102\":1}}],[\"观察者模式符合开闭原则\",{\"1\":{\"102\":1}}],[\"观察者模式的核心思想是将观察者对象注册到发布者对象中\",{\"1\":{\"102\":1}}],[\"观察者模式在软件开发中有非常多的应用\",{\"1\":{\"100\":1}}],[\"观察者模式uml图\",{\"0\":{\"100\":1}}],[\"观察者模式\",{\"0\":{\"99\":1},\"1\":{\"99\":1}}],[\"所用到开源组件如下\",{\"1\":{\"110\":1}}],[\"所有依赖于它的对象都会收到通知\",{\"1\":{\"99\":1}}],[\"所以这个resolve\",{\"1\":{\"158\":1}}],[\"所以能够输出\",{\"1\":{\"136\":1}}],[\"所以可以通过标签进行对指标的筛选\",{\"1\":{\"131\":1}}],[\"所以下载的是mac版本的\",{\"1\":{\"122\":1}}],[\"所以只能实现接口的方式进行代理\",{\"1\":{\"107\":1}}],[\"所以我们在实际的使用过程中\",{\"1\":{\"88\":1}}],[\"所以它的level可以命名为instance\",{\"1\":{\"166\":1}}],[\"所以它属于线程安全的懒汉模式\",{\"1\":{\"71\":1}}],[\"所以它是线程安全的\",{\"1\":{\"69\":1}}],[\"所以jvm是允许的\",{\"1\":{\"70\":1}}],[\"所以还是比较推荐的\",{\"1\":{\"69\":1}}],[\"所以设计模式是程序员的一项基本功\",{\"1\":{\"64\":1}}],[\"比较操作符\",{\"0\":{\"137\":1}}],[\"比较困难\",{\"1\":{\"98\":1}}],[\"比如将告警消息发送给运维人员的邮箱\",{\"1\":{\"161\":1}}],[\"比如用于描述告警详细信息的文字等\",{\"1\":{\"159\":1}}],[\"比如当发生severity=critical的告警时\",{\"1\":{\"158\":1}}],[\"比如按照alertname\",{\"1\":{\"158\":1}}],[\"比如配置每分钟的请求量\",{\"1\":{\"151\":1}}],[\"比如计算最近5分钟的请求次数\",{\"1\":{\"143\":1}}],[\"比如prometheus\",{\"1\":{\"141\":1}}],[\"比如p99\",{\"1\":{\"126\":1}}],[\"比如有以下的时间序列的样本\",{\"1\":{\"140\":1}}],[\"比如左侧和右侧的向量标签组条目必须完全匹配才能进行计算\",{\"1\":{\"139\":1}}],[\"比如查询handler为\",{\"1\":{\"132\":1}}],[\"比如\",{\"1\":{\"132\":1,\"134\":1,\"137\":1,\"154\":1}}],[\"比如我们求某个请求耗时的平均值\",{\"1\":{\"129\":1}}],[\"比如我们的mac电脑需要连接usb接口的键盘\",{\"1\":{\"76\":1}}],[\"比如node\",{\"1\":{\"128\":1}}],[\"比如求最近5分钟prometheus发生了多少次请求\",{\"1\":{\"127\":1}}],[\"比如主机的cpu\",{\"1\":{\"120\":1}}],[\"比如从k8s\",{\"1\":{\"119\":1}}],[\"比如可以将指标数据展示在grafana上\",{\"1\":{\"115\":1}}],[\"比如可以先使用加密装饰器\",{\"1\":{\"82\":1}}],[\"比如email\",{\"1\":{\"115\":1}}],[\"比如对消息的去重\",{\"1\":{\"114\":1}}],[\"比如对某一次请求进行不同的规则的校验\",{\"1\":{\"85\":1}}],[\"比如虚拟机\",{\"1\":{\"114\":1}}],[\"比如k8s系统\",{\"1\":{\"113\":1}}],[\"比如influxdb\",{\"1\":{\"113\":1}}],[\"比如id生成器\",{\"1\":{\"67\":1}}],[\"比如日志记录\",{\"1\":{\"107\":1}}],[\"比如访问控制\",{\"1\":{\"103\":1}}],[\"比如发布者维护的观察者对象是无顺序的\",{\"1\":{\"102\":1}}],[\"比如家具厂除了生产沙发\",{\"1\":{\"96\":1}}],[\"比如sofa的生产\",{\"1\":{\"96\":1}}],[\"比如handle\",{\"1\":{\"86\":1}}],[\"比如使用类final关键字的类\",{\"1\":{\"81\":1}}],[\"比如在以下的代码中\",{\"1\":{\"80\":1}}],[\"比如案例中keyboard\",{\"1\":{\"77\":1}}],[\"比如图中的键盘\",{\"1\":{\"76\":1}}],[\"比如拓展坞类实现了目标接口typec接口\",{\"1\":{\"76\":1}}],[\"比如typec接口\",{\"1\":{\"76\":1}}],[\"比如工具类\",{\"1\":{\"67\":1}}],[\"客户端代码与具体产品的创建实现了解耦\",{\"1\":{\"98\":1}}],[\"客户端通过抽象工厂来创建产品对象\",{\"1\":{\"95\":1}}],[\"保证了这些对象之间的兼容性\",{\"1\":{\"98\":1}}],[\"保证了mac电脑对外接口的简单性\",{\"1\":{\"78\":1}}],[\"输出如下\",{\"1\":{\"98\":1,\"105\":1}}],[\"负责创建一族相关的具体产品对象\",{\"1\":{\"97\":1}}],[\"负责创建实例对象的类\",{\"1\":{\"91\":1}}],[\"椅子\",{\"1\":{\"96\":1}}],[\"增加告警规则的配置\",{\"1\":{\"159\":1}}],[\"增加采集node\",{\"1\":{\"120\":1}}],[\"增加项目的依赖\",{\"1\":{\"108\":1}}],[\"增加新的观察者\",{\"1\":{\"102\":1}}],[\"增加新的产品和新的工厂非常容易\",{\"1\":{\"95\":1}}],[\"增加系统的复杂性\",{\"1\":{\"98\":1}}],[\"增加了系统的复杂度\",{\"1\":{\"95\":1}}],[\"每个recording\",{\"1\":{\"164\":1}}],[\"每个部分包含的可配置的参数很多\",{\"1\":{\"158\":1}}],[\"每个prometheus都是单节点设计的\",{\"1\":{\"116\":1}}],[\"每个方法对应一个具体产品类的创建方法\",{\"1\":{\"97\":1}}],[\"每个具体产品都需要一个具体工厂类来创建\",{\"1\":{\"95\":1}}],[\"每个逻辑单元的功能都是解藕的\",{\"1\":{\"88\":1}}],[\"每个逻辑单元组成了链中的一环\",{\"1\":{\"88\":1}}],[\"无需依赖接口\",{\"1\":{\"108\":1}}],[\"无需修改已有代码\",{\"1\":{\"95\":1}}],[\"无法代理实现类的方法\",{\"1\":{\"107\":1}}],[\"无法使用动态代理\",{\"1\":{\"107\":1}}],[\"无论面对什么的环境\",{\"1\":{\"64\":1}}],[\"无论是在前期的需求分析\",{\"1\":{\"64\":1}}],[\"具备良好的扩展性\",{\"1\":{\"95\":1}}],[\"具体表达式格式如下\",{\"1\":{\"167\":1}}],[\"具体预处理生成指标的表达式\",{\"1\":{\"164\":1}}],[\"具体命令如下\",{\"1\":{\"121\":1}}],[\"具体的配置介绍如下\",{\"1\":{\"119\":1}}],[\"具体如下\",{\"1\":{\"119\":1}}],[\"具体使用java\",{\"1\":{\"107\":1}}],[\"具体代码如下\",{\"1\":{\"105\":1}}],[\"具体观察者是观察者的具体实现\",{\"1\":{\"100\":1}}],[\"具体观察者\",{\"1\":{\"100\":1}}],[\"具体主题是主题的具体实现\",{\"1\":{\"100\":1}}],[\"具体主题\",{\"1\":{\"100\":1}}],[\"具体工厂类的代码更加简洁\",{\"1\":{\"95\":1}}],[\"具体工厂\",{\"1\":{\"94\":1,\"97\":1,\"98\":1}}],[\"具体产品类\",{\"1\":{\"91\":1,\"94\":1,\"97\":1,\"98\":1}}],[\"具体实现如下\",{\"1\":{\"82\":1}}],[\"符合单一职责原则\",{\"1\":{\"95\":1}}],[\"符合开闭原则\",{\"1\":{\"88\":1,\"98\":1}}],[\"而使用prometheus的java客户端是可以做到分位耗时的\",{\"1\":{\"148\":1}}],[\"而标签组是监控样本的多个维度特征的反应\",{\"1\":{\"131\":1}}],[\"而histogram则会消耗更多服务端的的资源\",{\"1\":{\"130\":1}}],[\"而histogram是通过histogram\",{\"1\":{\"130\":1}}],[\"而个别情况可能导致请求耗时超过了5s\",{\"1\":{\"129\":1}}],[\"而在样本数据采集的时候\",{\"1\":{\"126\":1}}],[\"而不是使用summary\",{\"1\":{\"130\":1}}],[\"而不是通过实现接口\",{\"1\":{\"108\":1}}],[\"而不需要了解具体的实现类\",{\"1\":{\"95\":1}}],[\"而无需修改原有的代码\",{\"1\":{\"107\":1}}],[\"而无需指定具体实现类\",{\"1\":{\"96\":1}}],[\"而java是不允许多继承的\",{\"1\":{\"107\":1}}],[\"而动态代理在各种框架\",{\"1\":{\"104\":1}}],[\"而是采用灵活的单一结构\",{\"1\":{\"103\":1}}],[\"而且不需要修改现有的代码\",{\"1\":{\"88\":1}}],[\"抽象主题接口类\",{\"1\":{\"104\":1}}],[\"抽象工厂的uml图如下\",{\"1\":{\"97\":1}}],[\"抽象工厂模式提供了一种创建一族相关对象的方法\",{\"1\":{\"98\":1}}],[\"抽象工厂模式包含以下角色\",{\"1\":{\"97\":1}}],[\"抽象工厂模式\",{\"1\":{\"96\":1}}],[\"抽象工厂\",{\"0\":{\"96\":1},\"1\":{\"94\":1,\"97\":1,\"98\":1}}],[\"抽象产品类\",{\"1\":{\"91\":1,\"94\":1,\"97\":1,\"98\":1}}],[\"就可以具体的执行告警逻辑\",{\"1\":{\"161\":1}}],[\"就可以看到本机的资源dashboard\",{\"1\":{\"122\":1}}],[\"就可以看到各个目录的磁盘剩余字节数了\",{\"1\":{\"120\":1}}],[\"就可以进行配置的热更新\",{\"1\":{\"121\":1}}],[\"就可以采集node\",{\"1\":{\"120\":1}}],[\"就可以查看node\",{\"1\":{\"120\":1}}],[\"就可以访问prometheus页面了\",{\"1\":{\"118\":1}}],[\"就是将实例化工作交给子类完成\",{\"1\":{\"93\":1}}],[\"就能够提供给其他对象在各个地方使用\",{\"1\":{\"67\":1}}],[\"违反了单一职责原则\",{\"1\":{\"92\":1}}],[\"系统扩展性好\",{\"1\":{\"92\":1}}],[\"系统出错\",{\"1\":{\"88\":1}}],[\"运行时会被系统拒绝运行\",{\"1\":{\"118\":1}}],[\"运行代码输出\",{\"1\":{\"107\":1}}],[\"运行代码\",{\"1\":{\"105\":1}}],[\"运行代码处理结果如下\",{\"1\":{\"87\":1}}],[\"运行上面的代码\",{\"1\":{\"98\":1}}],[\"运行结果如下\",{\"1\":{\"92\":1,\"101\":1}}],[\"由node\",{\"1\":{\"122\":1}}],[\"由于prometheus是使用周期性的采集数据\",{\"1\":{\"116\":1}}],[\"由于动态代理是在运行时动态生成代理类\",{\"1\":{\"107\":1}}],[\"由工厂类创建的对象的抽象类或接口\",{\"1\":{\"91\":1,\"94\":1,\"97\":1}}],[\"由拓展坞去做usb或者是hdmi接口的转换\",{\"1\":{\"78\":1}}],[\"返回值只会包含该时间序列的最新值的一个样本\",{\"1\":{\"133\":1}}],[\"返回一个具体的产品对象sofa\",{\"1\":{\"94\":1}}],[\"返回不同类的实例对象\",{\"1\":{\"90\":1}}],[\"返回顶部按钮\",{\"1\":{\"7\":1,\"45\":1}}],[\"属于创建型设计模式的一种\",{\"1\":{\"90\":1}}],[\"属于懒汉模式\",{\"1\":{\"71\":1}}],[\"简单工厂包含如下角色\",{\"1\":{\"91\":1}}],[\"简单工厂模式是一种常见的设计模式\",{\"1\":{\"92\":1}}],[\"简单工厂模式提供一个简单的工厂类\",{\"1\":{\"90\":1}}],[\"简单工厂模式\",{\"1\":{\"90\":1}}],[\"简单工厂\",{\"0\":{\"90\":1}}],[\"根据实际情况\",{\"1\":{\"158\":1}}],[\"根据实际的情况做设计和优化\",{\"1\":{\"88\":1}}],[\"根据标签匹配\",{\"1\":{\"157\":1}}],[\"根据客户端传入的参数来创建相应的产品对象sofa\",{\"1\":{\"92\":1}}],[\"根据传入参数的不同\",{\"1\":{\"90\":1}}],[\"根据借款金额的不同\",{\"1\":{\"87\":1}}],[\"很可能淹没掉一些其他的告警消息\",{\"1\":{\"154\":1}}],[\"很难去排查\",{\"1\":{\"88\":1}}],[\"很好的避免了现有类和适配者类的耦合\",{\"1\":{\"78\":1}}],[\"使得发布者和观察者互不影响\",{\"1\":{\"102\":1}}],[\"使系统能够更好地应对变化和复杂性\",{\"1\":{\"88\":1}}],[\"使用prometheus\",{\"0\":{\"149\":1}}],[\"使用prometheus明显是不合适的\",{\"1\":{\"116\":1}}],[\"使用spring\",{\"0\":{\"148\":1}}],[\"使用group\",{\"1\":{\"140\":1}}],[\"使用以下的查询\",{\"1\":{\"140\":1}}],[\"使用上面的vector\",{\"1\":{\"139\":1}}],[\"使用标签筛选数据的使用\",{\"1\":{\"132\":1}}],[\"使用le标签表示小于的意思\",{\"1\":{\"129\":1}}],[\"使用了prometheus\",{\"1\":{\"129\":1}}],[\"使用counter类型的指标\",{\"1\":{\"127\":1}}],[\"使用多个节点去采集相通的监控对象可以做到高可用\",{\"1\":{\"116\":1}}],[\"使用观察者模式有以下的收益\",{\"1\":{\"102\":1}}],[\"使用工厂方法模式的缺点是\",{\"1\":{\"95\":1}}],[\"使用工厂方法模式的好处是\",{\"1\":{\"95\":1}}],[\"使用责任链有以下的优点\",{\"1\":{\"88\":1}}],[\"使用责任链模式可以将一个大而复杂的判断逻辑\",{\"1\":{\"88\":1}}],[\"使用责任链的原因有\",{\"1\":{\"88\":1}}],[\"使用装饰器模式有以下的优点\",{\"1\":{\"83\":1}}],[\"使用案例\",{\"0\":{\"82\":1}}],[\"使用到了包装器模式\",{\"1\":{\"80\":1}}],[\"使用适配器模式有以下的优点\",{\"1\":{\"78\":1}}],[\"使用适配器模式有什么收益\",{\"0\":{\"78\":1}}],[\"使用内部类的模式\",{\"1\":{\"71\":1}}],[\"使用内部类模式\",{\"0\":{\"71\":1}}],[\"使用双重检查来判断实例是否初始化\",{\"1\":{\"70\":1}}],[\"使用同步代码块来保证线程的安全\",{\"1\":{\"70\":1}}],[\"使用单例模式有什么好处呢\",{\"1\":{\"67\":1}}],[\"使用指南\",{\"1\":{\"43\":2},\"2\":{\"6\":1,\"8\":1,\"11\":1,\"40\":1,\"46\":1,\"47\":1}}],[\"制定不同的处理流程\",{\"1\":{\"88\":1}}],[\"降低逻辑单元之间的耦合度\",{\"1\":{\"88\":1}}],[\"金额太大\",{\"1\":{\"87\":1}}],[\"5763175\",{\"1\":{\"162\":1}}],[\"5782e\",{\"1\":{\"119\":1}}],[\"51cto\",{\"1\":{\"162\":1}}],[\"512\",{\"1\":{\"82\":2}}],[\"5h\",{\"1\":{\"144\":1}}],[\"501\",{\"1\":{\"140\":1}}],[\"5001\",{\"1\":{\"157\":1}}],[\"500\",{\"1\":{\"140\":5}}],[\"5000\",{\"1\":{\"87\":1}}],[\"5m\",{\"1\":{\"127\":1,\"128\":1,\"133\":1,\"134\":3,\"143\":5,\"157\":2,\"158\":2,\"166\":3}}],[\"5\",{\"1\":{\"119\":1,\"130\":1,\"141\":1,\"143\":1,\"149\":3}}],[\"5<\",{\"1\":{\"108\":1}}],[\"财物权限不够\",{\"1\":{\"87\":2}}],[\"财务\",{\"1\":{\"87\":1}}],[\"审批不通过\",{\"1\":{\"87\":1}}],[\"审批通过\",{\"1\":{\"87\":1}}],[\"审批拒绝\",{\"1\":{\"87\":1}}],[\"里面有具体的处理逻辑\",{\"1\":{\"87\":1}}],[\"继承了aproval\",{\"1\":{\"87\":1}}],[\"经理权限不够\",{\"1\":{\"87\":2}}],[\"经理审批通过\",{\"1\":{\"87\":1}}],[\"经历\",{\"1\":{\"87\":1}}],[\"经常需要新的项目中需要对老代码进行适配才能用\",{\"1\":{\"76\":1}}],[\"现在使用责任链模式去模拟一个向公司借款的流程\",{\"1\":{\"87\":1}}],[\"案例实战\",{\"0\":{\"87\":1,\"101\":1}}],[\"处理类的实现类handlera\",{\"1\":{\"86\":1}}],[\"处理类handler\",{\"1\":{\"86\":1}}],[\"责任链模式可以提供一种灵活\",{\"1\":{\"88\":1}}],[\"责任链模式将处理逻辑放在链式的逻辑单元中处理\",{\"1\":{\"88\":1}}],[\"责任链模式有两个角色\",{\"1\":{\"86\":1}}],[\"责任链模式的uml图\",{\"0\":{\"86\":1}}],[\"责任链模式的核心思想就是通过构建一个处理流水线来对一个请求对象进行多次有顺序的处理\",{\"1\":{\"85\":1}}],[\"责任链模式在软件开发中\",{\"1\":{\"85\":1}}],[\"责任链模式\",{\"0\":{\"85\":1}}],[\"后面加一些功能\",{\"1\":{\"83\":1}}],[\"后使用压缩解压装饰器\",{\"1\":{\"82\":1}}],[\"满足单一职责的原则\",{\"1\":{\"83\":1}}],[\"满足里氏替换原则\",{\"1\":{\"78\":1}}],[\"希望继承原有类的功能\",{\"1\":{\"83\":1}}],[\"快速的装载和卸载装饰器\",{\"1\":{\"83\":1}}],[\"达到不同的效果\",{\"1\":{\"83\":1}}],[\"控制台打出的结果如下\",{\"1\":{\"82\":1}}],[\"解缩后的内容为\",{\"1\":{\"82\":2}}],[\"解密后\",{\"1\":{\"82\":2}}],[\"压缩后的内容为\",{\"1\":{\"82\":2}}],[\"压缩解压装饰器\",{\"1\":{\"82\":1}}],[\"+sum\",{\"1\":{\"136\":1}}],[\"+prometheus\",{\"1\":{\"136\":1}}],[\"+inf\",{\"1\":{\"129\":1,\"149\":1}}],[\"+obj\",{\"1\":{\"101\":1}}],[\"+\",{\"1\":{\"92\":1,\"98\":1,\"107\":2,\"136\":1,\"148\":1,\"149\":1}}],[\"+rw\",{\"1\":{\"82\":1}}],[\"+filereaderwriter\",{\"1\":{\"82\":1}}],[\"+text\",{\"1\":{\"82\":1}}],[\"+=\",{\"1\":{\"82\":1}}],[\"原始内容\",{\"1\":{\"82\":2}}],[\"原有的类不支持继承\",{\"1\":{\"81\":1}}],[\"up\",{\"1\":{\"166\":1}}],[\"url\",{\"1\":{\"157\":1,\"158\":1}}],[\"uri\",{\"1\":{\"149\":4,\"151\":2}}],[\"uri=request\",{\"1\":{\"149\":1}}],[\"uri=\",{\"1\":{\"148\":3,\"149\":15}}],[\"unknown\",{\"1\":{\"148\":1,\"149\":1}}],[\"unless\",{\"1\":{\"138\":1}}],[\"union\",{\"1\":{\"138\":1}}],[\"util\",{\"1\":{\"101\":2}}],[\"usually\",{\"1\":{\"158\":3}}],[\"user\",{\"1\":{\"148\":1,\"149\":1}}],[\"users\",{\"1\":{\"82\":1}}],[\"used\",{\"1\":{\"119\":1}}],[\"use\",{\"1\":{\"119\":1,\"166\":1}}],[\"us\",{\"1\":{\"92\":1}}],[\"uml图如下\",{\"1\":{\"100\":1}}],[\"uml图\",{\"0\":{\"81\":1,\"91\":1,\"94\":1,\"97\":1}}],[\"uml\",{\"1\":{\"76\":1,\"104\":1}}],[\"加\",{\"1\":{\"136\":1}}],[\"加减密装饰器和压缩解缩的装饰器\",{\"1\":{\"82\":1}}],[\"加密后\",{\"1\":{\"82\":2}}],[\"加密装饰器\",{\"1\":{\"82\":1}}],[\"加密展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"嵌套了两个装饰器\",{\"1\":{\"82\":1}}],[\"然后用\",{\"1\":{\"159\":1}}],[\"然后通过命令行的方式的启动它\",{\"1\":{\"156\":1}}],[\"然后通过配置文件的形式来具体讲解\",{\"1\":{\"153\":1}}],[\"然后将apistatinterceptor注册到webmvcconfigurer中\",{\"1\":{\"149\":1}}],[\"然后创建一个handlerinterceptoradapter的拦截器\",{\"1\":{\"149\":1}}],[\"然后\",{\"1\":{\"148\":1,\"149\":1}}],[\"然后在浏览器上访问http\",{\"1\":{\"149\":1}}],[\"然后在springboot的配置文件application\",{\"1\":{\"148\":1}}],[\"然后在grafana展示node\",{\"1\":{\"117\":1}}],[\"然后去grafana官方网站的dashboard社区找一个node\",{\"1\":{\"122\":1}}],[\"然后使用装饰器模式\",{\"1\":{\"82\":1}}],[\"然后getinstance\",{\"1\":{\"69\":1}}],[\"写一个接口如下\",{\"1\":{\"161\":1}}],[\"写一个观察者接口observer\",{\"1\":{\"101\":1}}],[\"写一个客户端实现类\",{\"1\":{\"105\":1}}],[\"写一个客户端用于测试\",{\"1\":{\"95\":1}}],[\"写一个客户端\",{\"1\":{\"92\":1}}],[\"写一个客户端测试类\",{\"1\":{\"82\":1,\"101\":1}}],[\"写一个测试类\",{\"1\":{\"87\":1,\"98\":1,\"108\":1}}],[\"写作日期为\",{\"1\":{\"43\":1}}],[\"<duration>\",{\"1\":{\"164\":1}}],[\"<dependency>\",{\"1\":{\"108\":1,\"148\":3,\"149\":3}}],[\"<rfc3339>\",{\"1\":{\"161\":2}}],[\"<resolved|firing>\",{\"1\":{\"161\":2}}],[\"<object>\",{\"1\":{\"161\":5}}],[\"<int>\",{\"1\":{\"161\":1}}],[\"<string>\",{\"1\":{\"161\":5}}],[\"<scope>test<\",{\"1\":{\"148\":1}}],[\"<version>1\",{\"1\":{\"148\":1,\"149\":3}}],[\"<vector\",{\"1\":{\"141\":1}}],[\"<groupid>io\",{\"1\":{\"148\":1,\"149\":3}}],[\"<groupid>org\",{\"1\":{\"148\":2}}],[\"<groupid>cglib<\",{\"1\":{\"108\":1}}],[\"<label\",{\"1\":{\"141\":1}}],[\"<artifactid>prometheus\",{\"1\":{\"149\":3}}],[\"<artifactid>micrometer\",{\"1\":{\"148\":1}}],[\"<artifactid>spring\",{\"1\":{\"148\":2}}],[\"<artifactid>cglib<\",{\"1\":{\"108\":1}}],[\"<aggr\",{\"1\":{\"141\":1}}],[\"<=\",{\"1\":{\"137\":1}}],[\"<\",{\"1\":{\"82\":2,\"87\":2,\"101\":1,\"108\":1,\"125\":1,\"137\":1,\"144\":1,\"148\":3,\"149\":3}}],[\"due\",{\"1\":{\"161\":1}}],[\"duration\",{\"1\":{\"119\":10,\"129\":13,\"130\":11,\"136\":1,\"145\":13}}],[\"distinguishing\",{\"1\":{\"166\":1}}],[\"divide\",{\"1\":{\"166\":1}}],[\"division\",{\"1\":{\"136\":1}}],[\"dimensions\",{\"1\":{\"141\":7}}],[\"d\",{\"1\":{\"133\":1}}],[\"db中\",{\"1\":{\"126\":1}}],[\"dl\",{\"1\":{\"122\":1}}],[\"date\",{\"1\":{\"161\":2}}],[\"data\",{\"1\":{\"82\":8}}],[\"dashboards\",{\"1\":{\"122\":1}}],[\"darwin\",{\"1\":{\"118\":2,\"122\":2}}],[\"docs\",{\"1\":{\"146\":1,\"161\":1}}],[\"download\",{\"1\":{\"118\":1,\"157\":1}}],[\"downloads\",{\"1\":{\"82\":1}}],[\"do\",{\"1\":{\"105\":2,\"107\":1,\"108\":1}}],[\"dos\",{\"1\":{\"82\":3}}],[\"denominator\",{\"1\":{\"166\":1}}],[\"details\",{\"1\":{\"162\":1}}],[\"deduplicate\",{\"1\":{\"161\":1}}],[\"dev\",{\"1\":{\"157\":1,\"158\":3}}],[\"deviation\",{\"1\":{\"141\":1}}],[\"default\",{\"1\":{\"158\":3,\"164\":1}}],[\"defaultvalue\",{\"1\":{\"148\":1,\"149\":1}}],[\"deflater\",{\"1\":{\"82\":1}}],[\"deflateroutputstream\",{\"1\":{\"82\":2}}],[\"del\",{\"1\":{\"140\":1}}],[\"delta\",{\"1\":{\"128\":1}}],[\"dependency>\",{\"1\":{\"108\":1,\"148\":3,\"149\":3}}],[\"decompress\",{\"1\":{\"82\":2}}],[\"decode\",{\"1\":{\"82\":4}}],[\"design\",{\"1\":{\"75\":2,\"87\":2,\"101\":5}}],[\"description\",{\"1\":{\"159\":1}}],[\"desc\",{\"1\":{\"28\":1}}],[\"we\",{\"1\":{\"166\":1}}],[\"webmvcconfigurer\",{\"1\":{\"149\":1}}],[\"webconfig\",{\"1\":{\"149\":1}}],[\"web\",{\"1\":{\"121\":2,\"148\":1,\"149\":2,\"157\":2,\"158\":2}}],[\"webhook\",{\"0\":{\"161\":1},\"1\":{\"115\":1,\"157\":1,\"158\":2,\"161\":7}}],[\"www\",{\"1\":{\"162\":1}}],[\"wuhan\",{\"1\":{\"159\":1,\"167\":1}}],[\"warning\",{\"1\":{\"157\":1,\"158\":2}}],[\"wait\",{\"1\":{\"157\":1,\"158\":6}}],[\"w\",{\"1\":{\"133\":1}}],[\"windows系统和mac系统\",{\"1\":{\"120\":1}}],[\"windows\",{\"1\":{\"118\":1}}],[\"without\",{\"1\":{\"141\":1,\"166\":4}}],[\"without|by\",{\"1\":{\"141\":1}}],[\"with\",{\"1\":{\"82\":1,\"141\":1}}],[\"which\",{\"1\":{\"158\":2}}],[\"while\",{\"1\":{\"82\":2}}],[\"where\",{\"1\":{\"28\":1}}],[\"write\",{\"1\":{\"82\":10}}],[\"定义recoding\",{\"0\":{\"164\":1}}],[\"定义了makesofa\",{\"1\":{\"98\":1}}],[\"定义了一个接收发布者消息的方法\",{\"1\":{\"100\":1}}],[\"定义了一个工厂方法makesofa\",{\"1\":{\"94\":1}}],[\"定义了一系列可以创建不同产品对象的方法\",{\"1\":{\"97\":1}}],[\"定义了产品类的属性和方法\",{\"1\":{\"91\":1,\"94\":1,\"97\":1}}],[\"定义文件的写入或者读取的路径\",{\"1\":{\"82\":1}}],[\"定义一个抽象主题类\",{\"1\":{\"105\":1}}],[\"定义一个抽象产品类\",{\"1\":{\"92\":1}}],[\"定义一个接口ifactory\",{\"1\":{\"95\":1}}],[\"定义一个写入的字符串text\",{\"1\":{\"82\":1}}],[\"定义一个目标接口readerwriter\",{\"1\":{\"82\":1}}],[\"定义目标的方法\",{\"1\":{\"81\":1}}],[\"也查询handler不为\",{\"1\":{\"132\":1}}],[\"也适合高度动态的面向服务的体系结构的监视\",{\"1\":{\"116\":1}}],[\"也让代码扩展变得非常困难\",{\"1\":{\"102\":1}}],[\"也称为静态工厂方法模式\",{\"1\":{\"90\":1}}],[\"也有可能影响系统的性能\",{\"1\":{\"88\":1}}],[\"也就是能够根据需求\",{\"1\":{\"83\":1}}],[\"也可以进行模糊匹配\",{\"1\":{\"132\":1}}],[\"也可以配置静态采集任务\",{\"1\":{\"119\":1}}],[\"也可以是consul\",{\"1\":{\"115\":1}}],[\"也可以是短生命周期的任务推送到pushgateway的指标\",{\"1\":{\"115\":1}}],[\"也可以是一个抽象类\",{\"1\":{\"86\":1}}],[\"也可以通过静态的配置去发现采集目标\",{\"1\":{\"113\":1}}],[\"也可以使用\",{\"1\":{\"132\":1}}],[\"也可以使用多个标签值进行进行查询\",{\"1\":{\"132\":1}}],[\"也可以使用push模式\",{\"1\":{\"113\":1}}],[\"也可以使用第三方时序数据去存储\",{\"1\":{\"113\":1}}],[\"也可以深入到进程内部关键点的监控\",{\"1\":{\"113\":1}}],[\"也可以用它来向观察者发送消息\",{\"1\":{\"101\":1}}],[\"也可以根据需求快速的删除一些逻辑单元\",{\"1\":{\"88\":1}}],[\"也可以读取文件的字符\",{\"1\":{\"82\":1}}],[\"也可以把他们的顺序对调\",{\"1\":{\"82\":1}}],[\"也不会频繁创建对象\",{\"1\":{\"71\":1}}],[\"做下面的增强功能\",{\"1\":{\"82\":1}}],[\"一种是告警告警规则表达式\",{\"1\":{\"163\":1}}],[\"一种是使用springboot自带的spring\",{\"1\":{\"147\":1}}],[\"一条告警规则主要由以下几部分组成\",{\"1\":{\"159\":1}}],[\"一条成功发送的告警\",{\"1\":{\"158\":1}}],[\"一组已发送初始通知的告警接收到新告警后\",{\"1\":{\"158\":1}}],[\"一组告警第一次发送之前等待的时间\",{\"1\":{\"158\":1}}],[\"一对多或者多对一\",{\"1\":{\"139\":1}}],[\"一对一\",{\"1\":{\"139\":1}}],[\"一共有53个\",{\"1\":{\"132\":1}}],[\"一个好的命名规范可以一目了然的知道规则的含义\",{\"1\":{\"165\":1}}],[\"一个简单版的prometheus的架构图如下\",{\"1\":{\"152\":1}}],[\"一个时序数据包含了一个时间戳\",{\"1\":{\"112\":1}}],[\"一个组件可以有很多个装饰器\",{\"1\":{\"81\":1}}],[\"一个拥有\",{\"1\":{\"23\":1}}],[\"一般设置为5分钟或更多\",{\"1\":{\"158\":1}}],[\"一般设置为0秒\",{\"1\":{\"158\":1}}],[\"一般counter类型的指标建议以\",{\"1\":{\"127\":1}}],[\"一般静态代理使用的比较少\",{\"1\":{\"104\":1}}],[\"一般情况下\",{\"1\":{\"81\":1}}],[\"一般来讲\",{\"1\":{\"81\":1}}],[\"什么是time\",{\"0\":{\"125\":1}}],[\"什么是prometheus\",{\"0\":{\"112\":1}}],[\"什么是单例模式\",{\"0\":{\"67\":1}}],[\"什么时候使用装饰器模式\",{\"1\":{\"81\":1}}],[\"并已bean的形式注册\",{\"1\":{\"149\":1}}],[\"并通过案例进行了实战\",{\"1\":{\"146\":1}}],[\"并没有差别\",{\"1\":{\"126\":1}}],[\"并展示在监控大盘上\",{\"1\":{\"123\":1}}],[\"并将数据的结果存储在新的时间序列中\",{\"1\":{\"164\":1}}],[\"并将计算结果保存在一组新的时间序列上\",{\"1\":{\"163\":1}}],[\"并将告警消息发送给alertmanager\",{\"1\":{\"115\":1}}],[\"并将指标存储在主机的磁盘中\",{\"1\":{\"115\":1}}],[\"并将实际对象的方法调用转发给它\",{\"1\":{\"104\":1}}],[\"并在intercept方法中实现真实对象的功能增强\",{\"1\":{\"108\":1}}],[\"并在主题实现类的对象的operation\",{\"1\":{\"105\":1}}],[\"并在状态改变时通知观察者\",{\"1\":{\"100\":1}}],[\"并隐藏在代理后面可能其他类的实现\",{\"1\":{\"104\":1}}],[\"并且是求百分数\",{\"1\":{\"166\":1}}],[\"并且体现出更好的灵敏度\",{\"1\":{\"143\":1}}],[\"并且于2015年对外发布早期版本\",{\"1\":{\"112\":1}}],[\"并且发布者发布消息也是无顺序的\",{\"1\":{\"102\":1}}],[\"并且可以根据需要快速的组合逻辑单元\",{\"1\":{\"88\":1}}],[\"并定义了观察者接收到通知后的具体行为\",{\"1\":{\"100\":1}}],[\"并可以动态添加观察者或者删除观察者\",{\"1\":{\"100\":1}}],[\"并不需要改变原有的逻辑功能\",{\"1\":{\"88\":1}}],[\"并向审批流的第一角色handle\",{\"1\":{\"87\":1}}],[\"并实现了handle\",{\"1\":{\"87\":3}}],[\"并能自由组合包装各种装饰器\",{\"1\":{\"83\":1}}],[\"并持有主题实现类的对象\",{\"1\":{\"105\":1}}],[\"并持有readerwriter的实现类filereaderwriter\",{\"1\":{\"82\":2}}],[\"并持有装饰器componentdecoratorb\",{\"1\":{\"81\":1}}],[\"并持有组件实现类componentimpl\",{\"1\":{\"81\":1}}],[\"并提供一个方法\",{\"1\":{\"67\":1}}],[\"组内的规则以固定的时间间隔按顺序运行\",{\"1\":{\"164\":1}}],[\"组成了链式的执行顺序\",{\"1\":{\"85\":1}}],[\"组件\",{\"0\":{\"114\":1}}],[\"组件实现类componentimpl\",{\"1\":{\"81\":1}}],[\"组件component\",{\"1\":{\"81\":1}}],[\"组合模式\",{\"1\":{\"65\":1}}],[\"各种reader一层套一层\",{\"1\":{\"80\":1}}],[\"相比java动态代理而言更为复杂\",{\"1\":{\"108\":1}}],[\"相比java动态代理\",{\"1\":{\"108\":1}}],[\"相比直接调用实现类的方法\",{\"1\":{\"107\":1}}],[\"相对于简单工厂\",{\"1\":{\"95\":1}}],[\"相当于对原有的类进行类一个包装\",{\"1\":{\"80\":1}}],[\"相关信息\",{\"1\":{\"15\":1}}],[\"装饰器非常的灵活\",{\"1\":{\"81\":1}}],[\"装饰器componentdecoratorb和componentdecoratora\",{\"1\":{\"81\":1}}],[\"装饰器模式经常使用到以下场景\",{\"1\":{\"81\":1}}],[\"装饰器模式的核心思想就是在不改变原有的类的基础之上给类添加新的功能\",{\"1\":{\"80\":1}}],[\"装饰器模式\",{\"0\":{\"80\":1}}],[\"装饰模式不改变原有类的结构\",{\"1\":{\"81\":1}}],[\"装饰模式\",{\"1\":{\"65\":1}}],[\"适配者类无论出现什么新功能\",{\"1\":{\"78\":1}}],[\"适配器只有同时实现或者持有目标接口和被适配的对象\",{\"1\":{\"77\":1}}],[\"适配器类只要不影响目标类的接口功能\",{\"1\":{\"78\":1}}],[\"适配器类adapter\",{\"1\":{\"76\":1}}],[\"适配器类即将要进行适配的抽象类或接口\",{\"1\":{\"76\":1}}],[\"适配器可以让不兼容的两个类一起协同工作\",{\"1\":{\"76\":1}}],[\"适配器模式的定义是\",{\"1\":{\"76\":1}}],[\"适配器模式就是将旧代码和新程序的中间的转换角色\",{\"1\":{\"76\":1}}],[\"适配器模式\",{\"0\":{\"76\":1},\"1\":{\"65\":1}}],[\"互不干扰\",{\"1\":{\"78\":1}}],[\"拓展新的适配者类功能\",{\"1\":{\"78\":1}}],[\"拓展坞将typec接口转换成usb接口\",{\"1\":{\"77\":1}}],[\"拓展坞适配器\",{\"1\":{\"77\":1}}],[\"引入一个适配器类兼容现有目标类\",{\"1\":{\"78\":1}}],[\"将通过post的http请求发送下游程序\",{\"1\":{\"161\":1}}],[\"将告警消息按照某个标签分组\",{\"1\":{\"158\":1}}],[\"将得不到任何结果\",{\"1\":{\"140\":1}}],[\"将三个审批角色组成一个责任链模式的审批流\",{\"1\":{\"87\":1}}],[\"将目标类和适配的类解耦\",{\"1\":{\"78\":1}}],[\"将适配器这个角色进行高度抽象化\",{\"1\":{\"78\":1}}],[\"将类的接口转换为客户期望的另一个接口\",{\"1\":{\"76\":1}}],[\"难以维护\",{\"1\":{\"78\":1}}],[\"没有必要将多个事情给一个角色做完\",{\"1\":{\"78\":1}}],[\"正如mac电脑一样\",{\"1\":{\"78\":1}}],[\"首先创建一个审批抽象类aproval\",{\"1\":{\"87\":1}}],[\"首先\",{\"1\":{\"78\":1,\"82\":1}}],[\"新建一个recoding\",{\"1\":{\"167\":1}}],[\"新建一个springboot项目\",{\"1\":{\"148\":1}}],[\"新增产品族\",{\"1\":{\"98\":1}}],[\"新增一族产品时\",{\"1\":{\"98\":1}}],[\"新增一个逻辑功能\",{\"1\":{\"88\":1}}],[\"新写一个方法就可以将需要适配的类进行转换\",{\"1\":{\"78\":1}}],[\"新的序列名称为record中的值\",{\"1\":{\"164\":1}}],[\"新的软件开发模式\",{\"1\":{\"64\":1}}],[\"新的工具\",{\"1\":{\"64\":1}}],[\"新的框架\",{\"1\":{\"64\":1}}],[\"才能进行适配工作\",{\"1\":{\"77\":1}}],[\"才会初始化内部类\",{\"1\":{\"71\":1}}],[\"z0\",{\"1\":{\"125\":1}}],[\"za\",{\"1\":{\"125\":2}}],[\"zxvf\",{\"1\":{\"118\":1,\"122\":1}}],[\"zkt5tvq5eu1zoxnktuzrt1q6zu17ddlhqkvfsennot4=\",{\"1\":{\"82\":1}}],[\"z\",{\"1\":{\"77\":2,\"125\":1}}],[\"连上了usb接口\",{\"1\":{\"77\":1}}],[\"ok\",{\"1\":{\"149\":17,\"161\":1}}],[\"op>\",{\"1\":{\"141\":1}}],[\"operations\",{\"1\":{\"166\":2}}],[\"operation\",{\"1\":{\"105\":9,\"107\":3,\"108\":1}}],[\"over\",{\"1\":{\"141\":7}}],[\"override\",{\"1\":{\"77\":2,\"82\":6,\"87\":3,\"92\":2,\"95\":2,\"98\":3,\"101\":3,\"105\":2,\"107\":1,\"108\":1,\"149\":4}}],[\"one\",{\"1\":{\"139\":3,\"140\":2}}],[\"on\",{\"1\":{\"139\":1}}],[\"org\",{\"1\":{\"149\":2}}],[\"or\",{\"1\":{\"137\":2,\"138\":1,\"158\":3,\"166\":1}}],[\"offset\",{\"0\":{\"134\":1},\"1\":{\"134\":2}}],[\"of\",{\"1\":{\"119\":6,\"125\":1,\"126\":1,\"130\":2,\"141\":2,\"158\":2,\"161\":1}}],[\"o\",{\"1\":{\"101\":3,\"108\":1,\"122\":1}}],[\"observe\",{\"1\":{\"149\":1}}],[\"observer2\",{\"1\":{\"101\":2}}],[\"observer1\",{\"1\":{\"101\":2}}],[\"observerimpl\",{\"1\":{\"101\":4}}],[\"observer接口的实现类observerimpl的代码如下\",{\"1\":{\"101\":1}}],[\"observer\",{\"1\":{\"99\":1,\"100\":1,\"101\":7}}],[\"obeserver2\",{\"1\":{\"101\":5}}],[\"obj\",{\"1\":{\"101\":3}}],[\"object\",{\"1\":{\"101\":5,\"107\":10,\"108\":7,\"149\":3}}],[\"outcome=\",{\"1\":{\"148\":3}}],[\"out\",{\"1\":{\"77\":3,\"82\":3,\"87\":6,\"92\":1,\"98\":1,\"101\":1,\"105\":3,\"107\":2,\"108\":2}}],[\"yunlzheng\",{\"1\":{\"162\":1}}],[\"yml去配置所有的告警规则文件\",{\"1\":{\"159\":1}}],[\"yml的文件\",{\"1\":{\"159\":1,\"167\":1}}],[\"yml中\",{\"1\":{\"120\":1}}],[\"yml\",{\"1\":{\"119\":3,\"157\":1,\"159\":1,\"167\":2}}],[\"y\",{\"1\":{\"77\":5,\"133\":1}}],[\"xpost\",{\"1\":{\"121\":1}}],[\"x\",{\"1\":{\"77\":5}}],[\"实战\",{\"0\":{\"167\":1}}],[\"实现方式有两种\",{\"1\":{\"147\":1}}],[\"实现代理如下\",{\"1\":{\"107\":1}}],[\"实现被代理对象的接口\",{\"1\":{\"104\":1}}],[\"实现抽象工厂类中定义的工厂方法makesofa\",{\"1\":{\"94\":1}}],[\"实现了抽象主题类\",{\"1\":{\"105\":1}}],[\"实现了抽象主题类的方法\",{\"1\":{\"104\":1}}],[\"实现了抽象接口类\",{\"1\":{\"104\":1}}],[\"实现了抽象工厂\",{\"1\":{\"98\":1}}],[\"实现了抽象工厂接口\",{\"1\":{\"97\":1}}],[\"实现了抽象产品类的属性和方法\",{\"1\":{\"91\":1,\"94\":1,\"97\":1}}],[\"实现了itypec的目标接口接口\",{\"1\":{\"77\":1}}],[\"实现了usb接口\",{\"1\":{\"76\":1}}],[\"实际的文章内容\",{\"1\":{\"10\":1}}],[\"持有适配者的类keyboard\",{\"1\":{\"76\":1}}],[\"目前支持linux系统\",{\"1\":{\"120\":1}}],[\"目前提供了linux\",{\"1\":{\"118\":1}}],[\"目标警报和源警报在相等列表中的标签名称必须具有相同的标签值\",{\"1\":{\"158\":1}}],[\"目标\",{\"1\":{\"158\":1}}],[\"目标类和适配者类是通过适配器进行交互的\",{\"1\":{\"78\":1}}],[\"目标类和适配者类各司其职\",{\"1\":{\"78\":1}}],[\"目标类target\",{\"1\":{\"76\":1}}],[\"目标接口itypec\",{\"1\":{\"77\":1}}],[\"目录\",{\"0\":{\"5\":1}}],[\"从而导致一些系统问题\",{\"1\":{\"154\":1}}],[\"从而能够对问题进行快速的处理或者提前预防问题的发生\",{\"1\":{\"116\":1}}],[\"从而达到以下目的\",{\"1\":{\"116\":1}}],[\"从而提高整个系统的性能\",{\"1\":{\"67\":1}}],[\"从2012年开始由前google工程师以开源软件的形式进行研发\",{\"1\":{\"112\":1}}],[\"从uml图上可以得出\",{\"1\":{\"100\":1}}],[\"从上面的\",{\"1\":{\"104\":1}}],[\"从上面的分析原因我们可以得出\",{\"1\":{\"88\":1}}],[\"从上面的使用场景\",{\"1\":{\"88\":1}}],[\"从该uml中中\",{\"1\":{\"86\":1}}],[\"从\",{\"1\":{\"76\":1}}],[\"给键盘使用\",{\"1\":{\"76\":1}}],[\"今天这一讲\",{\"1\":{\"76\":1}}],[\"gitbook\",{\"1\":{\"162\":1}}],[\"github\",{\"1\":{\"75\":2,\"87\":2,\"101\":5,\"120\":1,\"149\":1}}],[\"g\",{\"1\":{\"161\":1}}],[\"gloabl配置\",{\"1\":{\"158\":1}}],[\"global\",{\"1\":{\"119\":4,\"157\":2,\"158\":1,\"164\":1}}],[\"gauge类型的指标主要反映的是当前的状态\",{\"1\":{\"128\":1}}],[\"gauge仪表盘\",{\"0\":{\"128\":1}}],[\"gauge\",{\"1\":{\"119\":4,\"126\":1,\"148\":1}}],[\"garbage\",{\"1\":{\"119\":1,\"130\":1}}],[\"gateway是用来短暂存储push类型指标的\",{\"1\":{\"114\":1}}],[\"gateway\",{\"1\":{\"113\":1}}],[\"gc\",{\"1\":{\"119\":9,\"130\":10}}],[\"go1\",{\"1\":{\"119\":1}}],[\"goroutines\",{\"1\":{\"119\":4}}],[\"go\",{\"1\":{\"119\":25,\"130\":9}}],[\"gz\",{\"1\":{\"118\":1,\"122\":2}}],[\"group执行的时间间隔\",{\"1\":{\"164\":1}}],[\"group的名称\",{\"1\":{\"164\":1}}],[\"group可以配置两个参数\",{\"1\":{\"164\":1}}],[\"grouplabels\",{\"1\":{\"161\":2}}],[\"groupkey\",{\"1\":{\"161\":2}}],[\"groups\",{\"1\":{\"159\":1,\"164\":2,\"167\":1}}],[\"grouped\",{\"1\":{\"158\":1}}],[\"group\",{\"0\":{\"140\":1},\"1\":{\"140\":3,\"141\":1,\"157\":3,\"158\":9,\"161\":1}}],[\"groupid>\",{\"1\":{\"108\":1,\"148\":3,\"149\":3}}],[\"greater\",{\"1\":{\"137\":2}}],[\"graph\",{\"1\":{\"120\":1}}],[\"grafna的安装\",{\"1\":{\"117\":1}}],[\"grafana作为数据展示前端\",{\"1\":{\"123\":1}}],[\"grafana的默认登陆用户名admin\",{\"1\":{\"122\":1}}],[\"grafana有很多配置项在conf目录下default\",{\"1\":{\"122\":1}}],[\"grafana可以完美的和prometheus结合\",{\"1\":{\"122\":1}}],[\"grafana是一个开源的\",{\"1\":{\"122\":1}}],[\"grafana安装\",{\"0\":{\"122\":1}}],[\"grafana\",{\"1\":{\"110\":1,\"122\":6}}],[\"generatorurl\",{\"1\":{\"161\":2}}],[\"generation\",{\"1\":{\"108\":1}}],[\"getrequesturi\",{\"1\":{\"149\":1}}],[\"getattribute\",{\"1\":{\"149\":1}}],[\"getproxyinstance\",{\"1\":{\"108\":2}}],[\"getinterfaces\",{\"1\":{\"107\":1}}],[\"getinstance\",{\"1\":{\"69\":1,\"70\":1,\"73\":1,\"74\":1}}],[\"getclassloader\",{\"1\":{\"107\":1}}],[\"getclass\",{\"1\":{\"107\":2,\"108\":1}}],[\"get\",{\"1\":{\"101\":1,\"140\":6,\"148\":3,\"166\":1}}],[\"getname\",{\"1\":{\"92\":4,\"98\":3,\"107\":2}}],[\"getnextapproval\",{\"1\":{\"87\":3}}],[\"getdecoder\",{\"1\":{\"82\":2}}],[\"getencoder\",{\"1\":{\"82\":2}}],[\"getbytes\",{\"1\":{\"82\":2}}],[\"getsingleton\",{\"1\":{\"71\":1}}],[\"get­instance\",{\"1\":{\"68\":1}}],[\"下载地址\",{\"1\":{\"157\":1}}],[\"下载地址为\",{\"1\":{\"120\":1}}],[\"下载地址为https\",{\"1\":{\"118\":1}}],[\"下载并解压成功后\",{\"1\":{\"122\":1}}],[\"下载命令如下\",{\"1\":{\"122\":1}}],[\"下载完成后\",{\"1\":{\"118\":1,\"120\":1}}],[\"下图是prometheus和它周边生态组件的架构图\",{\"1\":{\"115\":1}}],[\"下面是懒汉模式的线程安全的\",{\"1\":{\"74\":1}}],[\"下面是最简单的懒汉模式的单列模式\",{\"1\":{\"73\":1}}],[\"下一篇\",{\"1\":{\"7\":1}}],[\"懒汉模式\",{\"0\":{\"73\":1,\"74\":1}}],[\"其实是做不到\",{\"1\":{\"148\":1}}],[\"其实在存储的时候是并没有存储的\",{\"1\":{\"126\":1}}],[\"其中prometheus\",{\"1\":{\"149\":1}}],[\"其中micrometer\",{\"1\":{\"148\":1}}],[\"其中job为采集任务\",{\"1\":{\"141\":1}}],[\"其无法反应在时间窗口内样本数据的突发变化\",{\"1\":{\"143\":1}}],[\"其他例子\",{\"1\":{\"166\":1}}],[\"其他常见的函数\",{\"0\":{\"142\":1}}],[\"其他操作系统应该没有这个问题\",{\"1\":{\"118\":1}}],[\"其他\",{\"0\":{\"72\":1}}],[\"其代码实现如下\",{\"1\":{\"68\":1}}],[\"ji\",{\"1\":{\"162\":1}}],[\"jianshu\",{\"1\":{\"162\":1}}],[\"jvm是用于暴露jvm相关的指标\",{\"1\":{\"149\":1}}],[\"jvm<\",{\"1\":{\"149\":1}}],[\"jvm在执行类的初始化的时候\",{\"1\":{\"71\":1}}],[\"job=\",{\"1\":{\"128\":1,\"141\":1,\"144\":1,\"145\":10,\"166\":9}}],[\"job\",{\"1\":{\"119\":1,\"120\":2,\"141\":2,\"150\":1,\"164\":2,\"166\":2}}],[\"jdk动态代理\",{\"1\":{\"107\":1}}],[\"javax\",{\"1\":{\"149\":2}}],[\"java动态代理不需要任何依赖\",{\"1\":{\"107\":1}}],[\"java动态代理是基于反射生产的一个代理类\",{\"1\":{\"107\":1}}],[\"java提供了java\",{\"1\":{\"107\":1}}],[\"java后端技术\",{\"0\":{\"0\":1}}],[\"java\",{\"0\":{\"0\":1,\"107\":1},\"1\":{\"75\":3,\"87\":2,\"101\":7,\"106\":1,\"107\":3}}],[\"延迟初始化\",{\"1\":{\"71\":1}}],[\"有两个标签分别是instance和path\",{\"1\":{\"166\":1}}],[\"有两个目标\",{\"1\":{\"64\":1}}],[\"有1828个请求\",{\"1\":{\"129\":1}}],[\"有1827个请求\",{\"1\":{\"129\":1}}],[\"有相同指标名和标签构成的\",{\"1\":{\"125\":1}}],[\"有着非常大的创新\",{\"1\":{\"113\":1}}],[\"有以下的角色\",{\"1\":{\"100\":1}}],[\"有以下的优点在\",{\"1\":{\"71\":1}}],[\"有很多同类型的产品生产\",{\"1\":{\"96\":1}}],[\"有一个核心的抽象处理方法handle\",{\"1\":{\"87\":1}}],[\"伪代码的2\",{\"1\":{\"70\":1}}],[\"伪代码如下\",{\"1\":{\"70\":1}}],[\"当对指标用作除法\",{\"1\":{\"166\":1}}],[\"当对counter类型使用rate或者是irate操作\",{\"1\":{\"166\":1}}],[\"当对象发生改变时\",{\"1\":{\"99\":1}}],[\"当存在与另一组匹配器匹配的警报\",{\"1\":{\"158\":1}}],[\"当启动告警恢复逻辑时\",{\"1\":{\"158\":1}}],[\"当告警消息没有endts这个时间戳参数时\",{\"1\":{\"158\":1}}],[\"当集群不可用访问出发了告警\",{\"1\":{\"155\":1}}],[\"当然actuator有很多内置的指标\",{\"1\":{\"148\":1}}],[\"当中\",{\"1\":{\"143\":1}}],[\"当比较运算符左右与两个瞬时向量之间\",{\"1\":{\"137\":1,\"138\":1}}],[\"当问题发生后\",{\"1\":{\"116\":1}}],[\"当系统出现或者即将出现故障时\",{\"1\":{\"116\":1}}],[\"当发布者发布消息\",{\"1\":{\"100\":1}}],[\"当需要扩展新的功能\",{\"1\":{\"88\":1}}],[\"当借款金额大于10000元\",{\"1\":{\"87\":1}}],[\"当借款金额大于1000元小于5000元\",{\"1\":{\"87\":1}}],[\"当借款金额大于5000元小于10000元\",{\"1\":{\"87\":1}}],[\"当借款金额小于1000元\",{\"1\":{\"87\":1}}],[\"当声明对象的引用为volatile后\",{\"1\":{\"70\":1}}],[\"当线程1在执行上面伪代码时\",{\"1\":{\"70\":1}}],[\"但缺点是对于一些无法实现接口的类\",{\"1\":{\"107\":1}}],[\"但缺点是需要手动创建代理类\",{\"1\":{\"104\":1}}],[\"但现实生活中\",{\"1\":{\"96\":1}}],[\"但由子类来决定要实例化哪个类\",{\"1\":{\"93\":1}}],[\"但需要防止责任链模式有过多的处理逻辑单元\",{\"1\":{\"88\":1}}],[\"但又不方便继承\",{\"1\":{\"83\":1}}],[\"但此时singleton并还没初始化完毕\",{\"1\":{\"70\":1}}],[\"但是其反应出的是瞬时增长率\",{\"1\":{\"143\":1}}],[\"但是通过计算在时间窗口内的平均增长率却无法反应出该问题\",{\"1\":{\"143\":1}}],[\"但是对于prometheus的底层数据来说\",{\"1\":{\"126\":1}}],[\"但是需要对值的控制字符进行转义\",{\"1\":{\"125\":1}}],[\"但是在大多数情况下\",{\"1\":{\"129\":1}}],[\"但是在使用它的时候需要注意它带来的一些缺点\",{\"1\":{\"102\":1}}],[\"但是在方法上加了锁\",{\"1\":{\"74\":1}}],[\"但是mac电脑只有typec接口\",{\"1\":{\"76\":1}}],[\"但是不太推荐\",{\"1\":{\"72\":1}}],[\"但是代码比双重检查模式简洁\",{\"1\":{\"71\":1}}],[\"但是由于简单\",{\"1\":{\"69\":1}}],[\"但是你需要使用相对链接\",{\"1\":{\"44\":1}}],[\"线程不安全\",{\"0\":{\"73\":1,\"74\":1}}],[\"线程2访问的将是个还没初始化完毕的对象\",{\"1\":{\"70\":1}}],[\"线程2调用getsingleton方法\",{\"1\":{\"70\":1}}],[\"线程1执行到第3步时\",{\"1\":{\"70\":1}}],[\"线程安全\",{\"0\":{\"69\":1,\"70\":1,\"71\":1},\"1\":{\"71\":1}}],[\">=\",{\"1\":{\"137\":1}}],[\">\",{\"1\":{\"125\":1,\"137\":1,\"159\":1}}],[\"><\",{\"1\":{\"125\":2}}],[\">2\",{\"1\":{\"70\":1}}],[\">3\",{\"1\":{\"70\":1}}],[\"步骤变为1\",{\"1\":{\"70\":1}}],[\"因为左侧的表达式有一个handler=\",{\"1\":{\"136\":1}}],[\"因为两个handler标签值不一样\",{\"1\":{\"136\":1}}],[\"因为它是通过生成子类来代理目标类\",{\"1\":{\"108\":1}}],[\"因为重排序并不影响运行结果\",{\"1\":{\"70\":1}}],[\"因此可以借助于\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"13\":1}}],[\"设置回调函数\",{\"1\":{\"108\":1}}],[\"设置父类\",{\"1\":{\"108\":1}}],[\"设置singleton指向刚分配的内存空间\",{\"1\":{\"70\":1}}],[\"设计模式有哪些类型\",{\"0\":{\"65\":1}}],[\"设计模式是软件开发的一种指导思想\",{\"1\":{\"64\":1}}],[\"设计模式面试概述\",{\"0\":{\"64\":1}}],[\"37843943\",{\"1\":{\"162\":1}}],[\"3776\",{\"1\":{\"145\":6}}],[\"3775\",{\"1\":{\"145\":1}}],[\"3773\",{\"1\":{\"145\":1}}],[\"3769\",{\"1\":{\"145\":1}}],[\"3767\",{\"1\":{\"145\":1}}],[\"34\",{\"1\":{\"140\":1}}],[\"3884e\",{\"1\":{\"130\":1}}],[\"3600\",{\"1\":{\"128\":1,\"144\":1}}],[\"30\",{\"1\":{\"140\":2}}],[\"3030\",{\"1\":{\"122\":1}}],[\"30s\",{\"1\":{\"115\":1,\"157\":1,\"158\":2}}],[\"32\",{\"1\":{\"119\":1}}],[\"35\",{\"1\":{\"119\":1}}],[\"3的重排序在多线程中将被禁止\",{\"1\":{\"70\":1}}],[\"3\",{\"1\":{\"70\":1,\"77\":1,\"119\":1,\"129\":1,\"140\":1,\"145\":1}}],[\"分组是\",{\"1\":{\"154\":1}}],[\"分组是将同一组多个的相同的告警消息合并成一个高级消息\",{\"1\":{\"154\":1}}],[\"分组\",{\"0\":{\"154\":1},\"1\":{\"153\":1}}],[\"分组修改器可以一边的标签组赋值给另一边的查询结构\",{\"1\":{\"140\":1}}],[\"分组修改器可以实现many\",{\"1\":{\"140\":1}}],[\"分组修改器\",{\"0\":{\"140\":1}}],[\"分别为\",{\"1\":{\"148\":1}}],[\"分别是\",{\"1\":{\"157\":1}}],[\"分别是code\",{\"1\":{\"141\":1}}],[\"分别是员工\",{\"1\":{\"87\":1}}],[\"分钟\",{\"1\":{\"133\":1}}],[\"分发\",{\"1\":{\"115\":1}}],[\"分成多个小的逻辑单元\",{\"1\":{\"88\":1}}],[\"分配内存空间\",{\"1\":{\"70\":1}}],[\"分类为\",{\"1\":{\"43\":1}}],[\"需要全局唯一\",{\"1\":{\"164\":1}}],[\"需要修改alertmanager的配置文件\",{\"1\":{\"157\":1}}],[\"需要修改抽象工厂的接口和具体工厂类\",{\"1\":{\"98\":1}}],[\"需要创建两个指标\",{\"1\":{\"149\":1}}],[\"需要注意的是使用rate或者increase函数去计算样本的平均增长速率\",{\"1\":{\"143\":1}}],[\"需要为grafana配置prometheus的数据源\",{\"1\":{\"122\":1}}],[\"需要打开系统偏好设置\",{\"1\":{\"118\":1}}],[\"需要对问题进行调查和处理\",{\"1\":{\"116\":1}}],[\"需要对真实的代理对象的功能需要做一下加强\",{\"1\":{\"107\":1}}],[\"需要额外依赖\",{\"1\":{\"108\":1}}],[\"需要做性能测试\",{\"1\":{\"102\":1}}],[\"需要做更多的工作\",{\"1\":{\"102\":1}}],[\"需要权衡一下利弊\",{\"1\":{\"88\":1}}],[\"需要总裁审批\",{\"1\":{\"87\":2}}],[\"需要cfo审批\",{\"1\":{\"87\":1}}],[\"需要经理审批\",{\"1\":{\"87\":3}}],[\"需要不同的审批角色\",{\"1\":{\"87\":1}}],[\"需要扩展功能的时候\",{\"1\":{\"83\":1}}],[\"需要被适配的接口的实现类\",{\"1\":{\"77\":1}}],[\"需要被适配的接口usb接口\",{\"1\":{\"77\":1}}],[\"需要被适配器转换的对象\",{\"1\":{\"76\":1}}],[\"需要把typec接口转换成usb接口\",{\"1\":{\"76\":1}}],[\"需要第一次调用getsingleton\",{\"1\":{\"71\":1}}],[\"需要如下几步\",{\"1\":{\"70\":1}}],[\"需要表示全局唯一的对象\",{\"1\":{\"67\":1}}],[\"只能求到最大的耗时和平均耗时\",{\"1\":{\"148\":1}}],[\"只能在原有的基础功能之上做进一步增强\",{\"1\":{\"81\":1}}],[\"只不过summary是已经在客户端已经计算好的数据\",{\"1\":{\"130\":1}}],[\"只增不减\",{\"1\":{\"126\":1}}],[\"只需要增加相应的具体产品类和工厂类即可\",{\"1\":{\"98\":1}}],[\"只需要修改工厂类的逻辑判断即可\",{\"1\":{\"92\":1}}],[\"只需要财务审批\",{\"1\":{\"87\":1}}],[\"只有第一次调用getsingleton\",{\"1\":{\"70\":1}}],[\"只允许通过getinstance\",{\"1\":{\"69\":1}}],[\"它会含有endts这个时间戳参数\",{\"1\":{\"158\":1}}],[\"它可以是一个邮箱也可以是微信\",{\"1\":{\"157\":1}}],[\"它可以把字符写入到文件中\",{\"1\":{\"82\":1}}],[\"它默认集成在spring\",{\"1\":{\"148\":1}}],[\"它同等于\",{\"1\":{\"141\":1}}],[\"它们共同组成描述当前指标的特征\",{\"1\":{\"125\":1}}],[\"它支持多种类型的数据库\",{\"1\":{\"122\":1}}],[\"它为主机暴露了硬件和内核相关的指标\",{\"1\":{\"120\":1}}],[\"它并不能保证数据的及时性和绝对正确性\",{\"1\":{\"116\":1}}],[\"它对多维数据收集和查询的支持是一个特别的优势\",{\"1\":{\"116\":1}}],[\"它既适合以机器为中心的监视\",{\"1\":{\"116\":1}}],[\"它的优点如下\",{\"1\":{\"107\":1}}],[\"它的uml图如下所示\",{\"1\":{\"76\":1}}],[\"它定义了一些方法\",{\"1\":{\"104\":1}}],[\"它定义了一个创建对象的接口\",{\"1\":{\"93\":1}}],[\"它允许将对象的访问控制和代码运行位置转移到代理对象中\",{\"1\":{\"103\":1}}],[\"它能够提高系统的可扩展性和灵活性\",{\"1\":{\"102\":1}}],[\"它能审批10000元以下的借款\",{\"1\":{\"87\":1}}],[\"它能审批5000元以下的借款\",{\"1\":{\"87\":1}}],[\"它维护了一个状态\",{\"1\":{\"100\":1}}],[\"它维护了一个观察者的列表\",{\"1\":{\"100\":1}}],[\"它具有以下的优点\",{\"1\":{\"98\":1}}],[\"它具有如下的优点\",{\"1\":{\"92\":1}}],[\"它提供了一个创建一系列相关对象的接口\",{\"1\":{\"96\":1}}],[\"它只能审批1000元以下的借款\",{\"1\":{\"87\":1}}],[\"它只提供typec接口\",{\"1\":{\"78\":1}}],[\"它有一个接收通知对象的方法\",{\"1\":{\"101\":1}}],[\"它有一个createsofa\",{\"1\":{\"95\":1}}],[\"它有一个抽象方法getname\",{\"1\":{\"92\":1}}],[\"它有一个核心的处理方法\",{\"1\":{\"86\":1}}],[\"它有读取和写入的功能\",{\"1\":{\"82\":1}}],[\"它实现了观察者的更新接口\",{\"1\":{\"100\":1}}],[\"它实现了readerwriter接口\",{\"1\":{\"82\":2}}],[\"它实现了目标接口\",{\"1\":{\"81\":3}}],[\"它是一个瞬时向量结果\",{\"1\":{\"133\":1}}],[\"它是一个基础能力\",{\"1\":{\"131\":1}}],[\"它是可增可减的\",{\"1\":{\"128\":1}}],[\"它是实现动态代理的关键\",{\"1\":{\"107\":1}}],[\"它是目标接口\",{\"1\":{\"81\":1}}],[\"它是为了解决具体的编码问题或者是解决某一类问题而产生的\",{\"1\":{\"64\":1}}],[\"它又称为包装器模式\",{\"1\":{\"80\":1}}],[\"它必须持有或者实现目标类和适配类的接口\",{\"1\":{\"76\":1}}],[\"它属于懒汉模式\",{\"1\":{\"70\":1}}],[\"numerator\",{\"1\":{\"166\":1}}],[\"number\",{\"1\":{\"119\":4,\"141\":2}}],[\"null\",{\"1\":{\"70\":2,\"73\":1,\"74\":1,\"82\":11,\"92\":1,\"107\":1}}],[\"nginx\",{\"1\":{\"114\":1}}],[\"no\",{\"1\":{\"166\":1}}],[\"none\",{\"1\":{\"148\":3}}],[\"notification\",{\"1\":{\"158\":4}}],[\"notify\",{\"1\":{\"101\":7}}],[\"not\",{\"1\":{\"137\":1}}],[\"node\",{\"1\":{\"110\":1,\"117\":1,\"120\":4,\"128\":4,\"144\":2}}],[\"name=lisi\",{\"1\":{\"148\":2,\"149\":1}}],[\"name+\",{\"1\":{\"101\":1}}],[\"name\",{\"1\":{\"101\":4,\"119\":1,\"120\":2,\"125\":1,\"148\":4,\"149\":6,\"150\":1,\"157\":1,\"158\":1,\"159\":1,\"164\":2,\"167\":1}}],[\"net\",{\"1\":{\"162\":1}}],[\"nextapproval\",{\"1\":{\"87\":5}}],[\"newproxyinstance\",{\"1\":{\"107\":1}}],[\"new\",{\"1\":{\"69\":1,\"70\":1,\"71\":1,\"73\":1,\"74\":1,\"77\":2,\"80\":2,\"82\":18,\"87\":3,\"92\":3,\"95\":2,\"98\":3,\"101\":3,\"105\":2,\"107\":2,\"108\":3,\"149\":1,\"158\":1}}],[\"可选参数\",{\"1\":{\"159\":1}}],[\"可选\",{\"1\":{\"149\":2}}],[\"可用通过prometheus的内置函数计算最近5分钟node\",{\"1\":{\"128\":1}}],[\"可增可减\",{\"1\":{\"126\":1}}],[\"可拓展性\",{\"1\":{\"107\":1}}],[\"可扩展性很强\",{\"1\":{\"102\":1}}],[\"可扩展和可维护的链式处理的机制\",{\"1\":{\"88\":1}}],[\"可复用\",{\"1\":{\"78\":1}}],[\"可能在某一时刻访问量突增\",{\"1\":{\"143\":1}}],[\"可能有很多人比较疑惑\",{\"1\":{\"78\":1}}],[\"可能会同时存在多个实例的创建\",{\"1\":{\"73\":1}}],[\"可能问的少一些\",{\"1\":{\"70\":1}}],[\"可以有以下几个配置项\",{\"1\":{\"164\":1}}],[\"可以看到已经有一条告警消息已经发送给alertmanager\",{\"1\":{\"159\":1}}],[\"可以看到的规则状态如下\",{\"1\":{\"159\":1}}],[\"可以看到alertmanager的界面\",{\"1\":{\"158\":1}}],[\"可以看到有两个指标http\",{\"1\":{\"149\":1}}],[\"可以在新生成的指标上额外加一些标签\",{\"1\":{\"164\":1}}],[\"可以在运行时重新加载其配置\",{\"1\":{\"156\":1}}],[\"可以在grafana上查询\",{\"1\":{\"132\":1}}],[\"可以停止重复发送由此告警引发的其它告警的机制\",{\"1\":{\"155\":1}}],[\"可以得到\",{\"1\":{\"148\":1}}],[\"可以得到prometheus的监控指标\",{\"1\":{\"119\":1}}],[\"可以将上面的结果除以300\",{\"1\":{\"143\":1}}],[\"可以用topk函数\",{\"1\":{\"141\":1}}],[\"可以用来聚合耽搁瞬时向量\",{\"1\":{\"141\":1}}],[\"可以应用于one\",{\"1\":{\"139\":1}}],[\"可以使用\",{\"1\":{\"166\":1}}],[\"可以使用如下表达式\",{\"1\":{\"144\":1}}],[\"可以使用rate函数计算速率\",{\"1\":{\"143\":1}}],[\"可以使用以下的表达式进行计算\",{\"1\":{\"143\":1}}],[\"可以使用increase函数计算增量数据\",{\"1\":{\"143\":1}}],[\"可以使用范围矢量查询\",{\"1\":{\"133\":1}}],[\"可以使用完全匹配\",{\"1\":{\"132\":1}}],[\"可以使用通配符\",{\"1\":{\"119\":1}}],[\"可以筛选出handler=\",{\"1\":{\"132\":1}}],[\"可以对时间序列提供丰富的查询\",{\"1\":{\"131\":1}}],[\"可以很容易一段时间的增量数据\",{\"1\":{\"127\":1}}],[\"可以让开发者轻松的实现监控大盘\",{\"1\":{\"122\":1}}],[\"可以访问prometheus自身的监控指标的暴露端点\",{\"1\":{\"119\":1}}],[\"可以配置多种分发方式\",{\"1\":{\"115\":1}}],[\"可以是k8s的集群的服务发现\",{\"1\":{\"115\":1}}],[\"可以是一个接口\",{\"1\":{\"86\":1}}],[\"可以和开源组件grafana无缝对接\",{\"1\":{\"113\":1}}],[\"可以通过动态代理实现一些横切关注点\",{\"1\":{\"107\":1}}],[\"可以通过顺序组合包装的方式来附加扩张功能\",{\"1\":{\"82\":1}}],[\"可以动态地添加和删除观察者\",{\"1\":{\"102\":1}}],[\"可以动态的扩展责任链中的逻辑单元\",{\"1\":{\"88\":1}}],[\"可以利用发布者向所有的观察者发送消息\",{\"1\":{\"102\":1}}],[\"可以向它注册观察者对象\",{\"1\":{\"101\":1}}],[\"可以创建一系列相关的产品对象\",{\"1\":{\"98\":1}}],[\"可以方便地创建出不同的产品对象\",{\"1\":{\"95\":1}}],[\"可以灵活的控制责任链中逻辑单元的处理顺序\",{\"1\":{\"88\":1}}],[\"可以根据客户端的需求\",{\"1\":{\"92\":1}}],[\"可以根据不同的需求\",{\"1\":{\"88\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"13\":1}}],[\"可以写一个handler即可\",{\"1\":{\"88\":1}}],[\"可以快速的装载和卸载逻辑单元\",{\"1\":{\"88\":1}}],[\"可以快速组合\",{\"1\":{\"83\":1}}],[\"可以快速装载和卸载增强功能\",{\"1\":{\"83\":1}}],[\"可以增加新的装饰器\",{\"1\":{\"83\":1}}],[\"可以按照需要使用不同装饰器组合\",{\"1\":{\"81\":1}}],[\"可以做到移植可复用\",{\"1\":{\"78\":1}}],[\"可以调用客户端对它们调用\",{\"1\":{\"77\":1}}],[\"可以节约系统的资源\",{\"1\":{\"67\":1}}],[\"近几年由于八股文泛滥\",{\"1\":{\"70\":1}}],[\"双重检查模式\",{\"1\":{\"70\":1}}],[\"双重检查\",{\"0\":{\"70\":1}}],[\"虽然可能会造成一定资源开销和浪费\",{\"1\":{\"69\":1}}],[\"自动创建hugryinstance的静态实例\",{\"1\":{\"69\":1}}],[\"自定义标签\",{\"1\":{\"159\":1}}],[\"自定义标题\",{\"1\":{\"19\":5}}],[\"自定义它们\",{\"1\":{\"45\":1}}],[\"自定义对齐\",{\"0\":{\"22\":1}}],[\"自定义容器\",{\"0\":{\"19\":1}}],[\"会屏蔽掉severity=warning的告警\",{\"1\":{\"158\":1}}],[\"会将计算结果输出到新的向量上\",{\"1\":{\"136\":1}}],[\"会统计当前指标的记录总数\",{\"1\":{\"129\":1}}],[\"会周期性的去采集指标\",{\"1\":{\"115\":1}}],[\"会带来一定的性能开销\",{\"1\":{\"107\":1}}],[\"会导致类的数量增加\",{\"1\":{\"95\":1}}],[\"会导致一定的资源开销和性能下降\",{\"1\":{\"74\":1}}],[\"会进行加锁初始化\",{\"1\":{\"71\":1}}],[\"会在程序的类的加载过程中\",{\"1\":{\"69\":1}}],[\"会使用\",{\"1\":{\"16\":1}}],[\"推荐\",{\"0\":{\"69\":1,\"70\":1,\"71\":1}}],[\"饿汉模式类似于spring框架初始化bean实例\",{\"1\":{\"69\":1}}],[\"饿汉模式\",{\"0\":{\"69\":1}}],[\"如全局的smtp配置\",{\"1\":{\"157\":1}}],[\"如下\",{\"1\":{\"149\":2,\"167\":1}}],[\"如下表示prometheus\",{\"1\":{\"125\":1}}],[\"如下图的uml图\",{\"1\":{\"68\":1}}],[\"如图所示\",{\"1\":{\"76\":1}}],[\"如果没有配置\",{\"1\":{\"164\":1}}],[\"如果labels配置中含有额外的标签也会放到新的timeseries中\",{\"1\":{\"164\":1}}],[\"如果expr表达式的计算结果包含标签\",{\"1\":{\"164\":1}}],[\"如果判断需要发送消息给下游的webhook程序\",{\"1\":{\"161\":1}}],[\"如果告警消息符合匹配\",{\"1\":{\"156\":1}}],[\"如果系统发出成千上万条相同的告警消息\",{\"1\":{\"154\":1}}],[\"如果有告警发生\",{\"1\":{\"152\":1}}],[\"如果要求分位耗时\",{\"1\":{\"148\":1}}],[\"如果想计算所有的请求的总数\",{\"1\":{\"141\":1}}],[\"如果想查询五分钟前的数据\",{\"1\":{\"134\":1}}],[\"如果不进行分组合并\",{\"1\":{\"154\":1}}],[\"如果不用ignoring修改器\",{\"1\":{\"140\":1}}],[\"如果不使用观察者模式来捕获一个被观察对象的属性变化\",{\"1\":{\"102\":1}}],[\"如果匹配到了\",{\"1\":{\"136\":1}}],[\"如果我们想查询一个时间区间的样本\",{\"1\":{\"133\":1}}],[\"如果是想做与money相关的业务\",{\"1\":{\"116\":1}}],[\"如果需要把证消息发送的顺序\",{\"1\":{\"102\":1}}],[\"如果需要增加新的产品类\",{\"1\":{\"92\":1}}],[\"如果处理链路过长\",{\"1\":{\"88\":1}}],[\"如果在目标类中\",{\"1\":{\"78\":1}}],[\"如果此时伪代码发生重排序\",{\"1\":{\"70\":1}}],[\"如果你不了解它\",{\"1\":{\"15\":1}}],[\"如果你是一个新手\",{\"1\":{\"14\":1}}],[\"防止对象的频繁创建\",{\"1\":{\"67\":1}}],[\"防止它频繁的被创建或者被销毁\",{\"1\":{\"67\":1}}],[\"不会输出结果\",{\"1\":{\"136\":1,\"137\":1,\"138\":1}}],[\"不仅可以监控系统的一些状态\",{\"1\":{\"113\":1}}],[\"不支持自身方法调用\",{\"1\":{\"108\":1}}],[\"不需要修改已有的代码\",{\"1\":{\"102\":1}}],[\"不同的产品由不同的工厂创建\",{\"1\":{\"95\":1}}],[\"不同的逻辑单元的处理逻辑不耦合\",{\"1\":{\"88\":1}}],[\"不同的装饰器有不同的功能\",{\"1\":{\"81\":1}}],[\"不同的角色做不同的事\",{\"1\":{\"78\":1}}],[\"不推荐\",{\"0\":{\"73\":1,\"74\":1}}],[\"不提供全局的共享变量\",{\"1\":{\"67\":1}}],[\"不能东一榔头西一棒槌\",{\"1\":{\"64\":1}}],[\"在文件中写一个指标聚合的表达式\",{\"1\":{\"167\":1}}],[\"在文件流的基础之上使用装饰器模式\",{\"1\":{\"82\":1}}],[\"在等待期间新产生告警的状态为pending\",{\"1\":{\"159\":1}}],[\"在每一个group中我们可以定义多个告警规则\",{\"1\":{\"159\":1}}],[\"在告警规则文件中\",{\"1\":{\"159\":1}}],[\"在浏览器中访问localhost\",{\"1\":{\"158\":1}}],[\"在浏览器上请求http\",{\"1\":{\"148\":1}}],[\"在浏览器上请求测试接口http\",{\"1\":{\"148\":1,\"149\":1}}],[\"在再次发送通知之前等待的时间\",{\"1\":{\"158\":1}}],[\"在此篇文章只讲解最基础的和几个重要的配置\",{\"1\":{\"158\":1}}],[\"在启动之前\",{\"1\":{\"157\":1}}],[\"在本篇文章中将会讲述prometheus告警与alertmanager实战\",{\"1\":{\"152\":1}}],[\"在本地部署的grafana页面导入node\",{\"1\":{\"122\":1}}],[\"在前面的文章已经讲解过prometheus采集数据和查询数据\",{\"1\":{\"152\":1}}],[\"在前面的文章介绍过如下prometheus自身的监控\",{\"1\":{\"125\":1}}],[\"在它内部进行告警消息的管理\",{\"1\":{\"152\":1}}],[\"在进程内部计算告警规则\",{\"1\":{\"152\":1}}],[\"在springboot的项目中增加springboot指标的采集\",{\"1\":{\"150\":1}}],[\"在springboot项目中\",{\"1\":{\"161\":1}}],[\"在springboot项目中的pom文件引入以下的依赖\",{\"1\":{\"149\":1}}],[\"在springboot项目中使用prometheus监控\",{\"0\":{\"147\":1}}],[\"在springboot项目创建一个测试接口\",{\"1\":{\"148\":1}}],[\"在aftercompletion方法中\",{\"1\":{\"149\":1}}],[\"在项目中有一个测试接口\",{\"1\":{\"149\":1}}],[\"在项目中引入以下的依赖\",{\"1\":{\"148\":1}}],[\"在这里有三个指标\",{\"1\":{\"148\":1}}],[\"在这里就不展开讲解了\",{\"1\":{\"148\":1}}],[\"在这个接口中\",{\"1\":{\"107\":1}}],[\"在上面讲解的操作符\",{\"1\":{\"139\":1}}],[\"在上面的示例中\",{\"1\":{\"129\":1}}],[\"在作用于两个瞬时向量之间\",{\"1\":{\"136\":1}}],[\"在很多场景下\",{\"1\":{\"129\":1}}],[\"在很多rpc框架\",{\"1\":{\"103\":1}}],[\"在下一篇文章将会讲解\",{\"1\":{\"127\":1}}],[\"在下面的案例中\",{\"1\":{\"69\":1}}],[\"在注释中包含了指标的类型\",{\"1\":{\"126\":1}}],[\"在grafana中为springboot项目配置试图\",{\"1\":{\"151\":1}}],[\"在grafana执行\",{\"1\":{\"132\":1}}],[\"在grafana上查询指标\",{\"1\":{\"125\":1}}],[\"在gui中应用的比较多\",{\"1\":{\"100\":1}}],[\"在更改完配置以后\",{\"1\":{\"121\":1}}],[\"在查询框里输入node\",{\"1\":{\"120\":1}}],[\"在prehandle方法中记录请求的开始时间starttime\",{\"1\":{\"149\":1}}],[\"在promql中也可以使用向量匹配符去计算含有不同标签条组的向量之间的计算\",{\"1\":{\"139\":1}}],[\"在prometheus的页面上可以查看新指标的数据\",{\"1\":{\"167\":1}}],[\"在prometheus的yaml配置文件中\",{\"1\":{\"167\":1}}],[\"在prometheus的配置文件中\",{\"1\":{\"159\":1}}],[\"在prometheus的配置文prometheus\",{\"1\":{\"120\":1}}],[\"在prometheus的启动程序的同级目录下面\",{\"1\":{\"159\":1}}],[\"在prometheus中配置告警规则\",{\"0\":{\"159\":1}}],[\"在prometheus\",{\"1\":{\"152\":2}}],[\"在prometheus启动的时候加上启动参数\",{\"1\":{\"121\":1}}],[\"在prometheus启动文件同级的目录下面有一个配置文件prometheus\",{\"1\":{\"119\":1}}],[\"在pom文件中引入cglib包\",{\"1\":{\"108\":1}}],[\"在不同容量情况下系统的并发和负载变化如何\",{\"1\":{\"116\":1}}],[\"在不改变了componentimpl的情况下\",{\"1\":{\"81\":1}}],[\"在微服务的世界里\",{\"1\":{\"116\":1}}],[\"在某些情况下\",{\"1\":{\"107\":1}}],[\"在消息队列的场景有广泛的应用\",{\"1\":{\"100\":1}}],[\"在观察者模式中\",{\"1\":{\"100\":1}}],[\"在流程中有三个角色\",{\"1\":{\"87\":1}}],[\"在工作中\",{\"1\":{\"87\":1}}],[\"在讲解完具体案例后\",{\"1\":{\"83\":1}}],[\"在读取文件的字符之后\",{\"1\":{\"82\":2}}],[\"在写入文件之前\",{\"1\":{\"82\":2}}],[\"在案例模仿javaio的文件流的写入和读取功能\",{\"1\":{\"82\":1}}],[\"在扩展性上\",{\"1\":{\"81\":1}}],[\"在图中一共有三个角色\",{\"1\":{\"81\":1}}],[\"在java语言中并支持动态代理\",{\"1\":{\"103\":1}}],[\"在java的io源码中\",{\"1\":{\"80\":1}}],[\"在java中创建一个对象\",{\"1\":{\"70\":1}}],[\"在程序中\",{\"1\":{\"76\":1}}],[\"在访问的时候需要锁占用\",{\"1\":{\"74\":1}}],[\"在多线程的情况下\",{\"1\":{\"71\":1}}],[\"在判断singleton==null时不为null\",{\"1\":{\"70\":1}}],[\"在系统中只需要初始化一个实例\",{\"1\":{\"67\":1}}],[\"在什么样的场景会使用到单列模式呢\",{\"1\":{\"67\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"7\":1}}],[\"让其他的对象可以访问这个实例\",{\"1\":{\"67\":1}}],[\"单一职责\",{\"1\":{\"78\":2}}],[\"单例模式除了上面的写法\",{\"1\":{\"72\":1}}],[\"单例模式不需要对外提供构造方法\",{\"1\":{\"69\":1}}],[\"单例模式声明了一个名为\",{\"1\":{\"68\":1}}],[\"单例模式的实现\",{\"0\":{\"68\":1}}],[\"单例模式生成的实例的生命周期一般都是和进程的生命周期是一致的\",{\"1\":{\"67\":1}}],[\"单例模式可以解决一个全局的使用的实例\",{\"1\":{\"67\":1}}],[\"单例模式在允许在全局中只存在一个实例\",{\"1\":{\"67\":1}}],[\"单例模式\",{\"0\":{\"66\":1}}],[\"单词\",{\"1\":{\"23\":1}}],[\"享元模式和代理模式\",{\"1\":{\"65\":1}}],[\"门面模式\",{\"1\":{\"65\":1}}],[\"桥接模式\",{\"1\":{\"65\":1}}],[\"尽量以通俗易懂的语言和代码案例去讲述\",{\"1\":{\"64\":1}}],[\"剩下的设计模式会在写完java面试系列文章之后做为补充\",{\"1\":{\"64\":1}}],[\"优先讲解面试过程中常见遇到的几种设计模式\",{\"1\":{\"64\":1}}],[\"那prometheus不适合什么\",{\"1\":{\"116\":1}}],[\"那它的缺点是\",{\"1\":{\"92\":1}}],[\"那么每秒的增量率\",{\"1\":{\"143\":1}}],[\"那么就需要在被观察对象执行代码逻辑中加入调用通知某个对象进行变更的逻辑\",{\"1\":{\"102\":1}}],[\"那么为什么还需要使用适配器模式呢\",{\"1\":{\"78\":1}}],[\"那么如何学习好设计模式呢\",{\"1\":{\"64\":1}}],[\"那为什么要使用volatile关键字来修饰静态的instance对象呢\",{\"1\":{\"70\":1}}],[\"那本系列教程将会讲述23种经典的设计模式\",{\"1\":{\"64\":1}}],[\"要求springboot>=2\",{\"1\":{\"148\":1}}],[\"要做一些优化工作\",{\"1\":{\"102\":1}}],[\"要做到知其然并知其所以然\",{\"1\":{\"64\":1}}],[\"要深挖技术背后的原因\",{\"1\":{\"64\":1}}],[\"刻意的去练习\",{\"1\":{\"64\":1}}],[\"都可以通过以下配置\",{\"1\":{\"164\":1}}],[\"都是以当前时间为基准的\",{\"1\":{\"134\":1}}],[\"都是以time\",{\"1\":{\"126\":1}}],[\"都是在不改变同一个接口功能的前提下\",{\"1\":{\"103\":1}}],[\"都是在程序启动之初创建\",{\"1\":{\"69\":1}}],[\"都很方便替换\",{\"1\":{\"78\":1}}],[\"都会让程序员在技术的海洋里迷失\",{\"1\":{\"64\":1}}],[\"都需要良好的程序设计\",{\"1\":{\"64\":1}}],[\"多维的数据结构\",{\"1\":{\"113\":1}}],[\"多应用\",{\"1\":{\"64\":1}}],[\"多练\",{\"1\":{\"64\":1}}],[\"说的简单一点就是多写\",{\"1\":{\"64\":1}}],[\"方案二\",{\"0\":{\"149\":1}}],[\"方案一\",{\"0\":{\"148\":1}}],[\"方案设计\",{\"1\":{\"64\":1}}],[\"方法之前和之后做了功能的增强\",{\"1\":{\"105\":1}}],[\"方法\",{\"1\":{\"71\":1,\"87\":3,\"98\":1}}],[\"方法才会初始化实例instance\",{\"1\":{\"70\":1}}],[\"方法获取实例\",{\"1\":{\"69\":1}}],[\"方便统一管理和修改\",{\"1\":{\"67\":1}}],[\"方志朋\",{\"0\":{\"0\":1}}],[\"越来越体会到系统是运营出来的\",{\"1\":{\"64\":1}}],[\"还还支持\",{\"1\":{\"133\":1}}],[\"还可以使用predict\",{\"1\":{\"128\":1}}],[\"还可以提升性能\",{\"1\":{\"70\":1}}],[\"还有一系列其他的组件\",{\"1\":{\"114\":1}}],[\"还有其他的写法\",{\"1\":{\"72\":1}}],[\"还生产桌子\",{\"1\":{\"96\":1}}],[\"还是自己自己做的一些开源项目中\",{\"1\":{\"64\":1}}],[\"还不会编写\",{\"1\":{\"14\":1}}],[\"这允许在系统或服务之间建立依赖关系\",{\"1\":{\"158\":1}}],[\"这在系统出现大量故障的时候非常有用\",{\"1\":{\"154\":1}}],[\"这里使用prometheus\",{\"1\":{\"143\":1}}],[\"这里我们以单例模式经典的懒汉式初始化方式为例\",{\"1\":{\"68\":1}}],[\"这两个标签对于同一个实例来说基本不变\",{\"1\":{\"141\":1}}],[\"这个文件是告警规则计算的配置\",{\"1\":{\"159\":1}}],[\"这个对于prometheus的告警消息来说\",{\"1\":{\"158\":1}}],[\"这个内置指标对请求耗时统计不是做的很好\",{\"1\":{\"148\":1}}],[\"这个平均值是不能反应的请求的真实状态\",{\"1\":{\"129\":1}}],[\"这个配置文件是prometheus启动的时候会读取的配置\",{\"1\":{\"119\":1}}],[\"这个页面提供了对prometheus数据的查询和告警信息的查询\",{\"1\":{\"118\":1}}],[\"这个数据结构包括一个指标名和一系列的键值对\",{\"1\":{\"113\":1}}],[\"这个代理类本身已经继承了jdk包中的proxy对象\",{\"1\":{\"107\":1}}],[\"这可能会引起无限循环或抛出异常\",{\"1\":{\"108\":1}}],[\"这使得它可以代理更多类型的类\",{\"1\":{\"108\":1}}],[\"这几个handler构成了一个链式的处理顺序\",{\"1\":{\"86\":1}}],[\"这样真的一目了然\",{\"1\":{\"166\":1}}],[\"这样webhook的程序收到告警消息后\",{\"1\":{\"161\":1}}],[\"这样可以避免接受一些与实际问题相关的告警\",{\"1\":{\"155\":1}}],[\"这样不仅增加了代码的耦合性\",{\"1\":{\"102\":1}}],[\"这样代码会非常的臃肿\",{\"1\":{\"78\":1}}],[\"这样只会原地踏步走\",{\"1\":{\"64\":1}}],[\"这时我们需要一个拓展坞\",{\"1\":{\"76\":1}}],[\"这时程序会出错\",{\"1\":{\"70\":1}}],[\"这种方式可以避免在时间窗口范围内的\",{\"1\":{\"143\":1}}],[\"这种情况下在多线程下是不安全的\",{\"1\":{\"73\":1}}],[\"这种双重检查模式经常在面试中被考察\",{\"1\":{\"70\":1}}],[\"这种模式称为饿汉模式\",{\"1\":{\"69\":1}}],[\"这种模式是在类加载的时候就完成了对象的实例化\",{\"1\":{\"69\":1}}],[\"这些操作符使用于瞬时向量的查询\",{\"1\":{\"136\":1}}],[\"这些类型的指标在存储的时候\",{\"1\":{\"126\":1}}],[\"这些组件构成了一个完整的监控系统\",{\"1\":{\"115\":1}}],[\"这些在流水线的处理类对象构成了一个单项链表结构\",{\"1\":{\"85\":1}}],[\"这些规则的执行有先后顺序\",{\"1\":{\"85\":1}}],[\"这些对象一般只提供具体的方法\",{\"1\":{\"67\":1}}],[\"这些年技术层出不穷\",{\"1\":{\"64\":1}}],[\"这些年无论是生产环境遇到的事故\",{\"1\":{\"64\":1}}],[\"这些都离不开设计模式的思想\",{\"1\":{\"64\":1}}],[\"这是脚注内容\",{\"1\":{\"39\":1}}],[\"这是项目主页的案例\",{\"1\":{\"1\":1,\"2\":1}}],[\"功能强大\",{\"1\":{\"108\":1}}],[\"功能限制\",{\"1\":{\"107\":1}}],[\"功能详情\",{\"1\":{\"59\":1,\"63\":1}}],[\"功能\",{\"0\":{\"56\":1,\"60\":1},\"1\":{\"57\":1,\"61\":1}}],[\"功能亮点\",{\"0\":{\"49\":1,\"53\":1}}],[\"few\",{\"1\":{\"158\":1}}],[\"from\",{\"1\":{\"166\":1}}],[\"frontmatter\",{\"1\":{\"7\":1,\"15\":3,\"43\":1,\"45\":1}}],[\"front\",{\"1\":{\"1\":1,\"2\":1}}],[\"free\",{\"1\":{\"120\":1,\"128\":1,\"144\":1}}],[\"freed\",{\"1\":{\"119\":1}}],[\"float64类型的值\",{\"1\":{\"125\":1}}],[\"flink\",{\"1\":{\"110\":1}}],[\"flush\",{\"1\":{\"82\":1}}],[\"furniturefactory\",{\"1\":{\"97\":1,\"98\":3}}],[\"failures\",{\"1\":{\"166\":8}}],[\"factory=new\",{\"1\":{\"95\":1}}],[\"factory\",{\"1\":{\"90\":1,\"92\":2,\"93\":1,\"96\":1,\"98\":3}}],[\"fangzhipeng\",{\"1\":{\"82\":3,\"101\":3}}],[\"first\",{\"1\":{\"119\":1,\"159\":1,\"167\":1}}],[\"fingerprint\",{\"1\":{\"161\":3}}],[\"finished\",{\"1\":{\"82\":1}}],[\"finally\",{\"1\":{\"82\":2}}],[\"final\",{\"1\":{\"71\":1}}],[\"file=alertmanager\",{\"1\":{\"157\":1}}],[\"files定义recoding\",{\"1\":{\"167\":1}}],[\"filesystem\",{\"1\":{\"120\":1,\"128\":4,\"144\":1}}],[\"files是配置告警规则文件的路径\",{\"1\":{\"119\":1}}],[\"files\",{\"1\":{\"119\":1,\"159\":1,\"167\":1}}],[\"filewriter\",{\"1\":{\"82\":7}}],[\"filenotfoundexception\",{\"1\":{\"82\":1}}],[\"filepath=\",{\"1\":{\"82\":1}}],[\"filepath\",{\"1\":{\"82\":8}}],[\"file\",{\"1\":{\"80\":1,\"82\":8}}],[\"filereaderwriter=new\",{\"1\":{\"82\":1}}],[\"filereaderwriter\",{\"1\":{\"82\":5}}],[\"filereader\",{\"1\":{\"80\":3,\"82\":7}}],[\"for\",{\"1\":{\"82\":2,\"101\":1,\"158\":5,\"159\":2}}],[\"forezp\",{\"1\":{\"75\":2,\"82\":1,\"87\":2,\"101\":5,\"149\":1}}],[\"foo\",{\"0\":{\"51\":1,\"55\":1,\"60\":1},\"1\":{\"61\":1}}],[\"blog\",{\"1\":{\"162\":2}}],[\"been\",{\"1\":{\"158\":2,\"161\":1}}],[\"bean\",{\"1\":{\"149\":1}}],[\"before\",{\"1\":{\"105\":2,\"107\":2,\"158\":2}}],[\"bin\",{\"1\":{\"122\":1}}],[\"by\",{\"1\":{\"119\":1,\"136\":2,\"141\":4,\"145\":2,\"151\":2,\"157\":1,\"158\":3,\"164\":1,\"167\":1}}],[\"bytes的差值\",{\"1\":{\"128\":1}}],[\"bytes\",{\"1\":{\"119\":12,\"120\":1,\"128\":2}}],[\"bytearrayinputstream\",{\"1\":{\"82\":1}}],[\"bytearrayoutputstream\",{\"1\":{\"82\":4}}],[\"byte\",{\"1\":{\"82\":6}}],[\"buildandstart\",{\"1\":{\"149\":1}}],[\"builder\",{\"1\":{\"149\":3}}],[\"bucket指标去统计\",{\"1\":{\"129\":1}}],[\"bucket\",{\"1\":{\"119\":1,\"129\":10,\"145\":13,\"149\":12,\"151\":1}}],[\"buck\",{\"1\":{\"119\":3}}],[\"bufferedwriter\",{\"1\":{\"82\":8}}],[\"bufferedreader\",{\"1\":{\"80\":2,\"82\":7}}],[\"bufferedreader和filereader都是使用到包装器模式\",{\"1\":{\"80\":1}}],[\"b\",{\"1\":{\"82\":3,\"145\":1}}],[\"book\",{\"1\":{\"162\":1}}],[\"boolean\",{\"1\":{\"149\":1}}],[\"boot<\",{\"1\":{\"148\":2}}],[\"boot\",{\"0\":{\"0\":1,\"148\":1},\"1\":{\"147\":1,\"148\":3}}],[\"bottomk\",{\"1\":{\"141\":1}}],[\"bout\",{\"1\":{\"82\":8}}],[\"backlink\",{\"1\":{\"161\":1}}],[\"basiccontroller\",{\"1\":{\"148\":1}}],[\"basics\",{\"1\":{\"146\":1}}],[\"base64\",{\"1\":{\"82\":4}}],[\"baz\",{\"0\":{\"59\":1},\"1\":{\"50\":1,\"54\":1,\"58\":1}}],[\"bar\",{\"0\":{\"50\":1,\"54\":1,\"56\":1},\"1\":{\"57\":1}}],[\"此篇文章不讲解这部分内容\",{\"1\":{\"122\":1}}],[\"此外\",{\"1\":{\"102\":1}}],[\"此种模式是不推荐的\",{\"1\":{\"74\":1}}],[\"此页面应当包含\",{\"1\":{\"45\":1}}],[\"此文字有脚注\",{\"1\":{\"24\":1}}],[\"徽章\",{\"1\":{\"44\":1}}],[\"徽章文字\",{\"1\":{\"44\":1}}],[\"per\",{\"1\":{\"166\":4}}],[\"p\",{\"1\":{\"162\":1}}],[\"port\",{\"1\":{\"149\":1}}],[\"population\",{\"1\":{\"141\":2}}],[\"postmapping\",{\"1\":{\"161\":1}}],[\"post请求\",{\"1\":{\"156\":1}}],[\"posthandle\",{\"1\":{\"149\":1}}],[\"post\",{\"1\":{\"140\":6}}],[\"power\",{\"1\":{\"136\":1}}],[\"plcmt=topnav\",{\"1\":{\"122\":1}}],[\"plugin\",{\"1\":{\"18\":1}}],[\"pg=community\",{\"1\":{\"122\":1}}],[\"put\",{\"1\":{\"140\":1}}],[\"push\",{\"1\":{\"114\":1}}],[\"publisher=new\",{\"1\":{\"101\":1}}],[\"publisherimpl\",{\"1\":{\"101\":2}}],[\"publisher接口的实现类publisherimpl\",{\"1\":{\"101\":1}}],[\"publisher\",{\"1\":{\"101\":6}}],[\"public\",{\"1\":{\"44\":1,\"69\":2,\"70\":2,\"71\":2,\"73\":2,\"74\":2,\"77\":9,\"82\":15,\"87\":12,\"92\":8,\"95\":7,\"98\":9,\"101\":10,\"105\":9,\"107\":6,\"108\":7,\"148\":2,\"149\":8,\"161\":20}}],[\"path\",{\"1\":{\"166\":15}}],[\"pattern\",{\"1\":{\"75\":1,\"90\":1,\"93\":1,\"96\":1,\"99\":1}}],[\"parti\",{\"1\":{\"162\":1}}],[\"parameter\",{\"1\":{\"141\":1}}],[\"page\",{\"1\":{\"159\":1}}],[\"pause\",{\"1\":{\"119\":1,\"130\":1}}],[\"package\",{\"1\":{\"87\":2,\"101\":5,\"149\":1}}],[\"prehandle\",{\"1\":{\"149\":1}}],[\"predict\",{\"1\":{\"128\":1,\"144\":3}}],[\"properties中开启prometheus的暴露接口\",{\"1\":{\"148\":1}}],[\"profiling\",{\"1\":{\"119\":1}}],[\"promql提供了另外一个灵敏度更高的函数irate\",{\"1\":{\"143\":1}}],[\"promql提供了两个向量匹配符号\",{\"1\":{\"139\":1}}],[\"promql还支持常见的比较运算符\",{\"1\":{\"137\":1}}],[\"promql支持常见的逻辑和数学操作符\",{\"1\":{\"136\":1}}],[\"promql被广泛应用于指标视图的配置\",{\"1\":{\"131\":1}}],[\"promql是prometheus提供的数据查询语言\",{\"1\":{\"131\":1}}],[\"promql快速入门\",{\"0\":{\"131\":1}}],[\"promql非常的强大和灵活\",{\"1\":{\"113\":1}}],[\"prometheus会定时的根据拉取expr定时表达式的数据\",{\"1\":{\"164\":1}}],[\"prometheus支持两种规则表达式\",{\"1\":{\"163\":1}}],[\"prometheus预处理计算\",{\"0\":{\"163\":1}}],[\"prometheus作为存储端\",{\"1\":{\"152\":1}}],[\"prometheus作为采集端\",{\"1\":{\"152\":1}}],[\"prometheus作为一个采集组件\",{\"1\":{\"123\":1}}],[\"prometheus告警与alertmanager实战\",{\"0\":{\"152\":1}}],[\"prometheuslab\",{\"1\":{\"149\":1}}],[\"prometheus官方提供了java客户端\",{\"1\":{\"149\":1}}],[\"prometheus依赖是将micrometer的指标转换成prometheus格式的指标\",{\"1\":{\"148\":1}}],[\"prometheus<\",{\"1\":{\"148\":1,\"149\":3}}],[\"prometheus的告警分为两部分内容\",{\"1\":{\"152\":1}}],[\"prometheus的时间序列是通过指标名和一组标签来唯一定义\",{\"1\":{\"131\":1}}],[\"prometheus的数据模型\",{\"0\":{\"124\":1}}],[\"prometheus每发生一个请求\",{\"1\":{\"127\":1}}],[\"prometheus定义来四种类型的指标\",{\"1\":{\"126\":1}}],[\"prometheus可以通过调用\",{\"1\":{\"125\":1}}],[\"prometheus可以很好地记录任何纯粹的数字时间序列\",{\"1\":{\"116\":1}}],[\"prometheus配置文件热更新\",{\"0\":{\"121\":1}}],[\"prometheus配置文件讲解\",{\"0\":{\"119\":1}}],[\"prometheus环境搭建\",{\"0\":{\"117\":1}}],[\"prometheus是为可靠性而设计的\",{\"1\":{\"116\":1}}],[\"prometheus是一个开源的监控系统\",{\"1\":{\"112\":1}}],[\"prometheus适用的场景\",{\"0\":{\"116\":1}}],[\"prometheus发现到监控目标后\",{\"1\":{\"115\":1}}],[\"prometheus通过时间序列来存储所有的数据的\",{\"1\":{\"125\":1}}],[\"prometheus通过时序数据来收集和存储指标\",{\"1\":{\"112\":1}}],[\"prometheus通过pull的方式去周期性\",{\"1\":{\"115\":1}}],[\"prometheus生态包含了一系列组件\",{\"1\":{\"114\":1}}],[\"prometheus提供非常的多的聚合函数\",{\"1\":{\"141\":1}}],[\"prometheus提供了http接口的方式让外部第三方访问数据\",{\"1\":{\"115\":1}}],[\"prometheus提供一些关键的特性\",{\"1\":{\"113\":1}}],[\"prometheus提供的特性\",{\"0\":{\"113\":1}}],[\"prometheus让监控从传统的黑盒子监控提升到了白盒监控\",{\"1\":{\"113\":1}}],[\"prometheus和传统的监控系统相比\",{\"1\":{\"113\":1}}],[\"prometheus受启发于google的brogmon监控系统\",{\"1\":{\"112\":1}}],[\"prometheus概述\",{\"0\":{\"111\":1}}],[\"prometheus\",{\"1\":{\"110\":1,\"114\":1,\"115\":1,\"118\":4,\"119\":1,\"120\":3,\"121\":1,\"125\":10,\"126\":3,\"127\":2,\"129\":12,\"132\":7,\"133\":1,\"134\":4,\"136\":3,\"141\":6,\"143\":4,\"145\":22,\"146\":2,\"148\":1,\"149\":4,\"152\":1,\"157\":1,\"159\":1,\"161\":1,\"162\":3,\"167\":2}}],[\"prometheus简明教程\",{\"0\":{\"109\":1}}],[\"proxy\",{\"1\":{\"107\":2,\"108\":2}}],[\"proxyhandler\",{\"1\":{\"107\":4}}],[\"proxy类和java\",{\"1\":{\"107\":1}}],[\"process\",{\"1\":{\"82\":1}}],[\"printstacktrace\",{\"1\":{\"82\":7}}],[\"println\",{\"1\":{\"77\":3,\"82\":3,\"87\":6,\"92\":1,\"98\":1,\"101\":1,\"105\":3,\"107\":2,\"108\":2}}],[\"private\",{\"1\":{\"69\":2,\"70\":2,\"71\":3,\"73\":2,\"74\":2,\"77\":1,\"82\":7,\"87\":1,\"101\":2,\"105\":1,\"107\":1,\"108\":1}}],[\"标签\",{\"1\":{\"136\":1}}],[\"标签为\",{\"1\":{\"43\":1}}],[\"标题和页面信息\",{\"1\":{\"45\":1}}],[\"标记\",{\"0\":{\"25\":1}}],[\"日\",{\"1\":{\"43\":1}}],[\"月\",{\"1\":{\"43\":1}}],[\"年\",{\"1\":{\"43\":1,\"133\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"42\":1}}],[\"↩︎\",{\"1\":{\"39\":1}}],[\"幻灯片\",{\"0\":{\"39\":1}}],[\"幻灯片页\",{\"0\":{\"3\":1}}],[\"交互演示\",{\"0\":{\"37\":1,\"38\":1}}],[\"捐赠一杯咖啡\",{\"1\":{\"36\":1}}],[\"向量匹配符号\",{\"0\":{\"139\":1}}],[\"向量里面的标签是左侧和右侧共同匹配的标签\",{\"1\":{\"136\":1}}],[\"向\",{\"1\":{\"36\":1}}],[\"样式化\",{\"0\":{\"36\":1}}],[\"导致告警处理者漏处理一些告警消息\",{\"1\":{\"154\":1}}],[\"导致连接它的应用的几百个实例都出现异常\",{\"1\":{\"154\":1}}],[\"导致请求耗时的平均值远大于100ms\",{\"1\":{\"129\":1}}],[\"导致工厂类的代码会随着产品类型的增多而变得越来越复杂\",{\"1\":{\"92\":1}}],[\"导入成功后\",{\"1\":{\"122\":1}}],[\"导入文件\",{\"0\":{\"34\":1}}],[\"导航栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"−1\",{\"1\":{\"33\":1}}],[\"route配置\",{\"1\":{\"158\":1}}],[\"route\",{\"1\":{\"157\":2,\"158\":1}}],[\"right\",{\"1\":{\"140\":1}}],[\"ratio\",{\"1\":{\"166\":4}}],[\"rate1m\",{\"1\":{\"167\":1}}],[\"rate\",{\"1\":{\"143\":1,\"145\":2,\"166\":2,\"167\":1}}],[\"rate5m\",{\"1\":{\"140\":12,\"166\":12}}],[\"range\",{\"0\":{\"133\":1},\"1\":{\"143\":1,\"144\":1}}],[\"ray\",{\"0\":{\"63\":1},\"1\":{\"51\":1,\"55\":1,\"62\":1}}],[\"rule规则文件的路径\",{\"1\":{\"167\":1}}],[\"rule产生的新的指标\",{\"1\":{\"166\":1}}],[\"rule的命令规范很重要\",{\"1\":{\"165\":1}}],[\"rule的最佳实践\",{\"0\":{\"165\":1}}],[\"rule的具体配置\",{\"1\":{\"164\":1}}],[\"rule的规则定义如下\",{\"1\":{\"164\":1}}],[\"rule类似\",{\"1\":{\"164\":1}}],[\"rule是预先计算成本较高的表达式\",{\"1\":{\"163\":1}}],[\"rules选项是recording\",{\"1\":{\"164\":1}}],[\"rules\",{\"0\":{\"164\":1},\"1\":{\"119\":2,\"157\":2,\"158\":3,\"159\":2,\"164\":1,\"167\":1}}],[\"rule\",{\"0\":{\"163\":1},\"1\":{\"119\":2,\"159\":4,\"162\":1,\"163\":1,\"164\":2,\"167\":5}}],[\"rw\",{\"1\":{\"82\":2}}],[\"recoding\",{\"1\":{\"167\":1}}],[\"record\",{\"1\":{\"164\":2,\"166\":5,\"167\":1}}],[\"recording的计算规则和alert的计算规则\",{\"1\":{\"164\":1}}],[\"recording\",{\"0\":{\"163\":1,\"165\":1},\"1\":{\"163\":1,\"165\":1,\"167\":1}}],[\"receiver可以集成邮箱\",{\"1\":{\"158\":1}}],[\"receivers配置\",{\"1\":{\"158\":1}}],[\"receivers\",{\"1\":{\"157\":2,\"158\":1}}],[\"receiver\",{\"1\":{\"157\":1,\"158\":1,\"161\":2}}],[\"region\",{\"1\":{\"159\":1,\"167\":1}}],[\"registry\",{\"1\":{\"148\":2,\"149\":2}}],[\"register\",{\"1\":{\"101\":4,\"149\":2}}],[\"repeat\",{\"1\":{\"157\":1,\"158\":2}}],[\"resolve\",{\"1\":{\"157\":1,\"158\":2}}],[\"response\",{\"1\":{\"149\":3}}],[\"responsebody\",{\"1\":{\"148\":1,\"149\":1}}],[\"resulting\",{\"1\":{\"141\":1}}],[\"result\",{\"1\":{\"82\":8}}],[\"release\",{\"1\":{\"122\":1}}],[\"releases\",{\"1\":{\"120\":1}}],[\"reload\",{\"1\":{\"121\":1,\"156\":1}}],[\"reflect\",{\"1\":{\"107\":2}}],[\"realsubject\",{\"1\":{\"104\":1,\"105\":10,\"107\":4,\"108\":1}}],[\"readline\",{\"1\":{\"82\":1}}],[\"read\",{\"1\":{\"82\":9}}],[\"readerwriter的基本实现类是filereaderwriter\",{\"1\":{\"82\":1}}],[\"readerwriter\",{\"1\":{\"82\":21}}],[\"requestbody\",{\"1\":{\"161\":1}}],[\"requestparam\",{\"1\":{\"148\":1,\"149\":1}}],[\"requestmapping\",{\"1\":{\"148\":1,\"149\":1}}],[\"requests\",{\"1\":{\"125\":12,\"126\":4,\"127\":3,\"132\":8,\"133\":1,\"134\":4,\"136\":3,\"140\":5,\"141\":6,\"143\":5,\"148\":10,\"159\":1,\"164\":2,\"166\":10,\"167\":2}}],[\"request\",{\"1\":{\"86\":1,\"129\":13,\"136\":1,\"145\":13,\"149\":5,\"166\":8}}],[\"returnvalue\",{\"1\":{\"108\":2}}],[\"return\",{\"1\":{\"69\":1,\"70\":1,\"71\":1,\"73\":1,\"74\":1,\"82\":9,\"87\":1,\"92\":3,\"95\":2,\"98\":3,\"107\":1,\"108\":2,\"148\":1,\"149\":3,\"161\":1}}],[\"r−i​\",{\"1\":{\"33\":1}}],[\"r−i+1\",{\"1\":{\"33\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"33\":1}}],[\"rgba\",{\"1\":{\"28\":1}}],[\"ωyω​\",{\"1\":{\"33\":2}}],[\"∂ωr∂r​\",{\"1\":{\"33\":1}}],[\"elements\",{\"1\":{\"141\":4}}],[\"else\",{\"1\":{\"87\":3,\"92\":1}}],[\"errors\",{\"1\":{\"140\":7}}],[\"equal\",{\"1\":{\"137\":4,\"157\":1,\"158\":2}}],[\"equals\",{\"1\":{\"92\":2}}],[\"even\",{\"1\":{\"119\":1}}],[\"evaluation\",{\"1\":{\"119\":2,\"164\":2}}],[\"externalurl\",{\"1\":{\"161\":2}}],[\"extends\",{\"1\":{\"87\":3,\"92\":2,\"98\":1,\"149\":1}}],[\"ex\",{\"1\":{\"149\":1}}],[\"exception\",{\"1\":{\"149\":4}}],[\"exception=\",{\"1\":{\"148\":3}}],[\"example\",{\"1\":{\"149\":4,\"164\":1}}],[\"exist\",{\"1\":{\"119\":1}}],[\"exit\",{\"1\":{\"82\":1}}],[\"expr执行后生成新的指标的名称\",{\"1\":{\"164\":1}}],[\"expr\",{\"1\":{\"159\":2,\"164\":2,\"166\":5,\"167\":1}}],[\"expression>\",{\"1\":{\"141\":1}}],[\"exposure\",{\"1\":{\"148\":1}}],[\"exponentiation\",{\"1\":{\"136\":1}}],[\"expoter的指标时序\",{\"1\":{\"123\":1}}],[\"exporter暴露的端口指标\",{\"1\":{\"120\":1}}],[\"exporter的dashboard\",{\"1\":{\"122\":1}}],[\"exporter的面板\",{\"1\":{\"122\":1}}],[\"exporter的任务\",{\"1\":{\"120\":1}}],[\"exporter的端口为9100\",{\"1\":{\"120\":1}}],[\"exporter的指标了\",{\"1\":{\"120\":1}}],[\"exporter的指标\",{\"0\":{\"120\":1},\"1\":{\"117\":1,\"123\":1}}],[\"exporter是prometheus生态的一员\",{\"1\":{\"120\":1}}],[\"exporter采集的指标中\",{\"1\":{\"128\":1}}],[\"exporter采集的指标生产\",{\"1\":{\"122\":1}}],[\"exporter采集的指标\",{\"1\":{\"117\":1}}],[\"exporters是用来暴露或者导出被监控对象的指标的\",{\"1\":{\"114\":1}}],[\"exporter\",{\"1\":{\"110\":1,\"117\":1,\"120\":3,\"149\":2,\"152\":1}}],[\"expansiondockadapter并持有需要被适配的iusb接口\",{\"1\":{\"77\":1}}],[\"expansiondockadapter\",{\"1\":{\"77\":5}}],[\"entity\",{\"1\":{\"161\":1}}],[\"enterprise\",{\"1\":{\"122\":3}}],[\"env\",{\"1\":{\"159\":1}}],[\"environment\",{\"1\":{\"119\":1}}],[\"endsat\",{\"1\":{\"161\":2}}],[\"endtime\",{\"1\":{\"149\":2}}],[\"endpoints\",{\"1\":{\"148\":1}}],[\"enable\",{\"1\":{\"121\":2}}],[\"en\",{\"1\":{\"108\":4}}],[\"encodetostring\",{\"1\":{\"82\":2}}],[\"encode\",{\"1\":{\"82\":2}}],[\"encryptionfilereaderwriter\",{\"1\":{\"82\":3}}],[\"encryptionfilereaderwriter是一个装饰器\",{\"1\":{\"82\":1}}],[\"enhancer\",{\"1\":{\"108\":2}}],[\"enhance\",{\"1\":{\"18\":1}}],[\"e\",{\"1\":{\"82\":14,\"161\":1}}],[\"echarts\",{\"0\":{\"30\":1}}],[\"图中\",{\"1\":{\"76\":1,\"104\":1}}],[\"图表\",{\"0\":{\"29\":1}}],[\"图片增强\",{\"0\":{\"27\":1}}],[\"025\",{\"1\":{\"149\":1}}],[\"01\",{\"1\":{\"149\":1}}],[\"0<\",{\"1\":{\"149\":3}}],[\"071374449\",{\"1\":{\"148\":1}}],[\"049234863\",{\"1\":{\"148\":1}}],[\"04\",{\"1\":{\"140\":2}}],[\"005\",{\"1\":{\"149\":1}}],[\"009242327\",{\"1\":{\"130\":1}}],[\"009608685\",{\"1\":{\"119\":1}}],[\"002707693\",{\"1\":{\"119\":1}}],[\"000421166\",{\"1\":{\"130\":1}}],[\"000194843\",{\"1\":{\"130\":1}}],[\"00013637\",{\"1\":{\"130\":1}}],[\"000123743\",{\"1\":{\"119\":1}}],[\"000251038\",{\"1\":{\"119\":1}}],[\"05\",{\"1\":{\"119\":2,\"130\":1,\"140\":3,\"149\":1}}],[\"0版本\",{\"1\":{\"112\":2,\"148\":1}}],[\"0\",{\"1\":{\"28\":1,\"82\":3,\"101\":1,\"119\":8,\"129\":5,\"130\":9,\"140\":6,\"141\":1,\"144\":1,\"145\":5,\"148\":9,\"149\":27,\"151\":1,\"157\":2,\"158\":2,\"159\":6}}],[\"slack或者webhook等\",{\"1\":{\"157\":1}}],[\"slack配置等内容\",{\"1\":{\"157\":1}}],[\"sdk\",{\"1\":{\"152\":1}}],[\"sdks\",{\"1\":{\"114\":1}}],[\"scope>\",{\"1\":{\"148\":1}}],[\"scalar\",{\"1\":{\"144\":1,\"145\":1}}],[\"scrape\",{\"1\":{\"119\":4,\"120\":1,\"150\":1}}],[\"smallest\",{\"1\":{\"141\":1}}],[\"same\",{\"1\":{\"141\":1,\"158\":1}}],[\"sample由三部分组成\",{\"1\":{\"125\":1}}],[\"sample\",{\"1\":{\"125\":1,\"141\":2}}],[\"successfully\",{\"1\":{\"158\":1}}],[\"success\",{\"1\":{\"148\":3}}],[\"subtraction\",{\"1\":{\"136\":1}}],[\"subject\",{\"1\":{\"100\":1,\"104\":1,\"105\":3,\"107\":5,\"108\":5}}],[\"sum作为后缀\",{\"1\":{\"129\":1}}],[\"sum\",{\"1\":{\"119\":1,\"129\":1,\"130\":1,\"136\":1,\"141\":6,\"145\":2,\"148\":2,\"149\":1,\"151\":2,\"159\":1,\"164\":2,\"166\":4,\"167\":1}}],[\"summary在通过promql进行查询时有更好的性能表现\",{\"1\":{\"130\":1}}],[\"summary是在sdk侧已经计算好了分位数\",{\"1\":{\"130\":1}}],[\"summary和histogram类似\",{\"1\":{\"130\":1}}],[\"summary\",{\"0\":{\"130\":1},\"1\":{\"119\":2,\"126\":1,\"130\":2,\"148\":1,\"159\":1}}],[\"search=\",{\"1\":{\"159\":1}}],[\"search=node+exporter+mac\",{\"1\":{\"122\":1}}],[\"sent\",{\"1\":{\"158\":2}}],[\"sending\",{\"1\":{\"158\":2}}],[\"send\",{\"1\":{\"158\":1}}],[\"select\",{\"1\":{\"141\":2}}],[\"selectors查询\",{\"1\":{\"133\":1}}],[\"selectors\",{\"0\":{\"132\":1,\"133\":1}}],[\"servlet\",{\"1\":{\"149\":4}}],[\"server中配置告警规则\",{\"1\":{\"152\":1}}],[\"server中配置alertmanager的地址\",{\"1\":{\"152\":1}}],[\"server中的告警规则\",{\"1\":{\"152\":1}}],[\"server进行计算的\",{\"1\":{\"130\":1}}],[\"server\",{\"1\":{\"122\":1,\"148\":10,\"149\":2,\"153\":1}}],[\"server是最核心的组件\",{\"1\":{\"114\":1}}],[\"series的形式存储在prometheus的level\",{\"1\":{\"126\":1}}],[\"series中每个点被称为一个样子\",{\"1\":{\"125\":1}}],[\"series\",{\"0\":{\"125\":1},\"1\":{\"125\":1}}],[\"seconds指标\",{\"1\":{\"130\":1}}],[\"seconds\",{\"1\":{\"119\":9,\"129\":13,\"130\":9,\"136\":1,\"145\":13,\"148\":10,\"149\":19,\"151\":1}}],[\"second\",{\"1\":{\"119\":1}}],[\"severity\",{\"1\":{\"157\":2,\"158\":4,\"159\":1}}],[\"sever\",{\"1\":{\"117\":1}}],[\"setattribute\",{\"1\":{\"149\":1}}],[\"setcallback\",{\"1\":{\"108\":1}}],[\"setsuperclass\",{\"1\":{\"108\":1}}],[\"setnextapproval\",{\"1\":{\"87\":3}}],[\"so\",{\"1\":{\"166\":1}}],[\"source\",{\"1\":{\"157\":1,\"158\":2}}],[\"somthing\",{\"1\":{\"105\":2,\"107\":1,\"108\":1}}],[\"sofa=\",{\"1\":{\"98\":1}}],[\"sofa\",{\"1\":{\"91\":2,\"92\":17,\"94\":2,\"95\":7,\"98\":5}}],[\"srp\",{\"1\":{\"92\":1}}],[\"src\",{\"1\":{\"75\":1}}],[\"showname\",{\"1\":{\"92\":2,\"95\":1,\"98\":3}}],[\"sighup信号或者请求alertmanager\",{\"1\":{\"156\":1}}],[\"size\",{\"1\":{\"101\":1}}],[\"simplefactory\",{\"1\":{\"92\":3}}],[\"simplesofafactory\",{\"1\":{\"91\":1,\"92\":1}}],[\"simple\",{\"1\":{\"90\":1}}],[\"sington\",{\"1\":{\"75\":1}}],[\"singleton=memory\",{\"1\":{\"70\":1}}],[\"s\",{\"1\":{\"82\":3,\"133\":1}}],[\"sb\",{\"1\":{\"82\":3}}],[\"stdvar\",{\"1\":{\"141\":1}}],[\"stddev\",{\"1\":{\"141\":1}}],[\"still\",{\"1\":{\"119\":1}}],[\"starsliao\",{\"1\":{\"162\":1}}],[\"startsat\",{\"1\":{\"161\":2}}],[\"starttime\",{\"1\":{\"149\":6}}],[\"starter\",{\"0\":{\"148\":1},\"1\":{\"147\":1,\"148\":3}}],[\"status\",{\"1\":{\"149\":2,\"161\":4}}],[\"status=\",{\"1\":{\"148\":3,\"149\":15}}],[\"staticproxy\",{\"1\":{\"104\":1,\"105\":7}}],[\"static\",{\"1\":{\"69\":2,\"70\":2,\"71\":3,\"73\":2,\"74\":2,\"77\":1,\"82\":1,\"87\":1,\"92\":1,\"95\":1,\"98\":1,\"101\":1,\"105\":2,\"107\":2,\"108\":2,\"119\":2,\"120\":2,\"150\":1,\"159\":1,\"161\":1}}],[\"standard\",{\"1\":{\"141\":2}}],[\"staff\",{\"1\":{\"87\":7}}],[\"string>\",{\"1\":{\"161\":5}}],[\"stringdata\",{\"1\":{\"82\":4}}],[\"stringbuilder\",{\"1\":{\"82\":2}}],[\"string\",{\"1\":{\"77\":1,\"82\":24,\"87\":1,\"92\":5,\"95\":1,\"98\":3,\"101\":3,\"105\":1,\"107\":1,\"108\":1,\"148\":2,\"149\":3,\"161\":9}}],[\"sys\",{\"1\":{\"119\":3}}],[\"system\",{\"1\":{\"77\":3,\"82\":3,\"87\":6,\"92\":1,\"98\":1,\"101\":1,\"105\":3,\"107\":2,\"108\":2,\"149\":2}}],[\"synchronized\",{\"1\":{\"70\":1,\"74\":1}}],[\"svg\",{\"1\":{\"28\":1}}],[\"springboot\",{\"1\":{\"150\":1}}],[\"springboot已经有来micrometer的指标库\",{\"1\":{\"148\":1}}],[\"springframework\",{\"1\":{\"148\":2,\"149\":2}}],[\"spring事务等领域有着广泛的应用\",{\"1\":{\"103\":1}}],[\"spring\",{\"0\":{\"0\":3},\"1\":{\"103\":1}}],[\"level\",{\"1\":{\"166\":4}}],[\"le\",{\"1\":{\"145\":2,\"151\":1}}],[\"left修改器进行查询\",{\"1\":{\"140\":1}}],[\"left\",{\"1\":{\"140\":2,\"166\":1}}],[\"less\",{\"1\":{\"137\":2}}],[\"le=\",{\"1\":{\"129\":12,\"145\":10,\"149\":12}}],[\"length\",{\"1\":{\"82\":2}}],[\"long\",{\"1\":{\"149\":4,\"158\":3}}],[\"localhost\",{\"1\":{\"118\":1,\"119\":2,\"120\":4,\"121\":1,\"141\":1,\"145\":10,\"149\":1,\"150\":1,\"160\":1}}],[\"logger\",{\"1\":{\"161\":1}}],[\"logy\",{\"1\":{\"33\":2}}],[\"logo\",{\"1\":{\"28\":2}}],[\"latest\",{\"1\":{\"146\":1,\"161\":1}}],[\"largest\",{\"1\":{\"141\":1}}],[\"lang\",{\"1\":{\"107\":2}}],[\"lable\",{\"1\":{\"132\":1}}],[\"labelvalues\",{\"1\":{\"149\":2}}],[\"labelnames\",{\"1\":{\"149\":2}}],[\"label\",{\"1\":{\"132\":5}}],[\"labels\",{\"1\":{\"132\":4,\"136\":1,\"158\":1,\"159\":2,\"161\":2,\"164\":1,\"166\":1,\"167\":1}}],[\"lab\",{\"1\":{\"75\":1}}],[\"labs\",{\"1\":{\"75\":1}}],[\"lazyinstancesafe\",{\"1\":{\"74\":5}}],[\"lazyinstancenosafe\",{\"1\":{\"73\":5}}],[\"lazyinstance\",{\"1\":{\"70\":6}}],[\"linear函数是用来基于当定的时间范围的时序来预测未来一段时间的数据\",{\"1\":{\"144\":1}}],[\"linear函数对指标的数据变化趋势进行预测\",{\"1\":{\"128\":1}}],[\"linear\",{\"1\":{\"128\":1,\"144\":2}}],[\"link\",{\"1\":{\"28\":1}}],[\"lifecycle\",{\"1\":{\"121\":2}}],[\"libraries\",{\"1\":{\"114\":1}}],[\"library\",{\"1\":{\"108\":1}}],[\"list>\",{\"1\":{\"141\":1}}],[\"list<observer>\",{\"1\":{\"101\":1}}],[\"list\",{\"1\":{\"101\":5}}],[\"light\",{\"1\":{\"28\":1}}],[\"t\",{\"1\":{\"144\":1}}],[\"timeout对于prometheus的告警消息是不生效的\",{\"1\":{\"158\":1}}],[\"timeout\",{\"1\":{\"157\":1,\"158\":2}}],[\"timeseries格式如下\",{\"1\":{\"141\":1}}],[\"timestamp\",{\"1\":{\"125\":3}}],[\"time\",{\"1\":{\"125\":1}}],[\"title\",{\"1\":{\"28\":1}}],[\"tar\",{\"1\":{\"118\":2,\"122\":3}}],[\"targets\",{\"1\":{\"119\":2,\"120\":2,\"150\":1,\"159\":1}}],[\"target\",{\"1\":{\"108\":6,\"157\":1,\"158\":2}}],[\"table=\",{\"1\":{\"98\":1}}],[\"table\",{\"1\":{\"97\":1,\"98\":9,\"119\":1}}],[\"type\",{\"1\":{\"92\":3,\"119\":6,\"125\":1,\"126\":1,\"130\":1,\"148\":2,\"149\":2}}],[\"txt\",{\"1\":{\"82\":1}}],[\"test<\",{\"1\":{\"148\":1}}],[\"testcglibproxy\",{\"1\":{\"108\":2}}],[\"testjdkproxy\",{\"1\":{\"107\":2}}],[\"teststatic\",{\"1\":{\"105\":2}}],[\"test\",{\"1\":{\"82\":1,\"159\":2}}],[\"text\",{\"1\":{\"82\":2}}],[\"tex\",{\"0\":{\"33\":1}}],[\"together\",{\"1\":{\"158\":1}}],[\"topk\",{\"1\":{\"141\":2}}],[\"to\",{\"1\":{\"139\":3,\"140\":2,\"158\":8,\"161\":4,\"166\":1}}],[\"total的后缀\",{\"1\":{\"166\":1}}],[\"total和http\",{\"1\":{\"149\":1}}],[\"total这个指标有4个标签\",{\"1\":{\"141\":1}}],[\"total指标的不同标签维度的所有指标\",{\"1\":{\"132\":1}}],[\"total都会累积1\",{\"1\":{\"127\":1}}],[\"total表示prometheus服务的http请求的数量\",{\"1\":{\"127\":1}}],[\"total结尾\",{\"1\":{\"127\":1}}],[\"total\",{\"1\":{\"119\":4,\"125\":11,\"126\":3,\"127\":1,\"132\":7,\"133\":1,\"134\":4,\"136\":3,\"141\":5,\"143\":5,\"149\":5,\"151\":1,\"159\":1,\"166\":4,\"167\":1}}],[\"tobytearray\",{\"1\":{\"82\":2}}],[\"tostring\",{\"1\":{\"82\":1,\"101\":1,\"161\":1}}],[\"toc\",{\"1\":{\"45\":1}}],[\"than\",{\"1\":{\"137\":2}}],[\"thanos\",{\"1\":{\"113\":1}}],[\"that\",{\"1\":{\"119\":1,\"158\":1,\"161\":1}}],[\"then\",{\"1\":{\"166\":1}}],[\"the\",{\"1\":{\"119\":3,\"130\":1,\"141\":4,\"158\":2,\"161\":5,\"166\":1}}],[\"there\",{\"1\":{\"28\":2}}],[\"throwable\",{\"1\":{\"107\":1,\"108\":1}}],[\"throws\",{\"1\":{\"107\":1,\"108\":1,\"149\":4}}],[\"this\",{\"1\":{\"77\":1,\"82\":3,\"87\":1,\"101\":1,\"105\":1,\"107\":1,\"108\":2}}],[\"truncated\",{\"1\":{\"161\":1}}],[\"truncatedalerts\",{\"1\":{\"161\":2}}],[\"true\",{\"1\":{\"1\":1,\"2\":1,\"149\":1}}],[\"try\",{\"1\":{\"82\":6}}],[\"tree\",{\"1\":{\"75\":1}}],[\"卡片\",{\"0\":{\"28\":1}}],[\"任务列表\",{\"0\":{\"26\":1}}],[\"脚注\",{\"0\":{\"24\":1}}],[\"的请求量\",{\"1\":{\"167\":1}}],[\"的指标情况\",{\"1\":{\"132\":2}}],[\"的所有的数据\",{\"1\":{\"132\":1}}],[\"的所有方法\",{\"1\":{\"104\":1}}],[\"的包含时间和值的流式数据\",{\"1\":{\"125\":1}}],[\"的项目\",{\"1\":{\"112\":1}}],[\"的代码如下\",{\"1\":{\"105\":1}}],[\"的抽象方法getname\",{\"1\":{\"92\":2}}],[\"的方法\",{\"1\":{\"68\":1,\"95\":1}}],[\"的静态对象和\",{\"1\":{\"68\":1}}],[\"的\",{\"1\":{\"23\":1,\"43\":1,\"156\":1}}],[\"irate\",{\"1\":{\"143\":1}}],[\"irate函数是通过区间向量中最后两个样本数据来计算区间向量的增长速率\",{\"1\":{\"143\":1}}],[\"irate同样用于计算区间向量的计算率\",{\"1\":{\"143\":1}}],[\"ir⋯\",{\"1\":{\"33\":1}}],[\"ignoring\",{\"1\":{\"139\":1,\"140\":2}}],[\"iin\",{\"1\":{\"82\":3}}],[\"i++\",{\"1\":{\"82\":2,\"101\":1}}],[\"i\",{\"1\":{\"82\":6,\"101\":3}}],[\"img\",{\"1\":{\"116\":1}}],[\"import\",{\"1\":{\"101\":2,\"149\":6}}],[\"implements\",{\"1\":{\"77\":2,\"82\":3,\"95\":2,\"98\":1,\"101\":2,\"105\":2,\"107\":1,\"108\":1,\"149\":1}}],[\"image\",{\"1\":{\"68\":1,\"81\":1,\"94\":1,\"100\":1,\"110\":1,\"118\":2,\"120\":1,\"122\":2,\"125\":1,\"132\":2,\"133\":1,\"151\":2,\"152\":1,\"159\":2,\"160\":1,\"167\":1}}],[\"iusb\",{\"1\":{\"77\":9}}],[\"io读写等\",{\"1\":{\"120\":1}}],[\"ioexception\",{\"1\":{\"82\":6,\"149\":1}}],[\"io\",{\"1\":{\"75\":1,\"87\":2,\"101\":5,\"118\":1,\"146\":1,\"149\":3,\"157\":1,\"161\":1,\"162\":1}}],[\"inprogress\",{\"1\":{\"164\":2}}],[\"inputstream\",{\"1\":{\"82\":1}}],[\"initial\",{\"1\":{\"158\":2}}],[\"initially\",{\"1\":{\"158\":1}}],[\"ini文件下\",{\"1\":{\"122\":1}}],[\"inhibiting\",{\"1\":{\"158\":1}}],[\"inhibit\",{\"1\":{\"157\":2,\"158\":3}}],[\"instrumentation\",{\"1\":{\"149\":2,\"166\":1}}],[\"instant\",{\"0\":{\"132\":1},\"1\":{\"145\":1}}],[\"instances\",{\"1\":{\"166\":1}}],[\"instance的标签值相等\",{\"1\":{\"158\":1}}],[\"instance=\",{\"1\":{\"141\":1,\"145\":10}}],[\"instance为被采集的实例\",{\"1\":{\"141\":1}}],[\"instance\",{\"1\":{\"68\":1,\"70\":5,\"71\":2,\"73\":4,\"74\":4,\"141\":2,\"157\":1,\"158\":2,\"166\":13,\"167\":2}}],[\"incoming\",{\"1\":{\"158\":1}}],[\"inc\",{\"1\":{\"149\":1}}],[\"include=prometheus\",{\"1\":{\"148\":1}}],[\"increase是promql中的一个函数\",{\"1\":{\"127\":1}}],[\"increase\",{\"1\":{\"127\":1,\"143\":2,\"151\":2,\"159\":1}}],[\"infinity\",{\"1\":{\"145\":1}}],[\"information\",{\"1\":{\"119\":1}}],[\"info\",{\"1\":{\"119\":3,\"161\":1}}],[\"inflaterinputstream\",{\"1\":{\"82\":2}}],[\"invoke\",{\"1\":{\"107\":6,\"108\":1}}],[\"invocationhandler\",{\"1\":{\"107\":1}}],[\"invocationhandler接口来实现动态代理\",{\"1\":{\"107\":1}}],[\"in\",{\"1\":{\"82\":3,\"119\":1,\"141\":2}}],[\"intersection\",{\"1\":{\"138\":1}}],[\"interval是全局配置告警规则任务的计算\",{\"1\":{\"119\":1}}],[\"interval\",{\"1\":{\"119\":3,\"157\":2,\"158\":4,\"164\":3,\"167\":1}}],[\"interceptorregistry\",{\"1\":{\"149\":1}}],[\"intercept\",{\"1\":{\"108\":1}}],[\"interface\",{\"1\":{\"77\":2,\"82\":1,\"95\":1,\"98\":1,\"101\":2,\"105\":1}}],[\"int\",{\"1\":{\"77\":10,\"82\":3,\"87\":8,\"101\":1,\"161\":1}}],[\"inner\",{\"1\":{\"71\":2}}],[\"innerclzsingleton\",{\"1\":{\"71\":5}}],[\"ifurniturefactory\",{\"1\":{\"97\":1,\"98\":5}}],[\"ifactory的具体实现类americasofafactory\",{\"1\":{\"95\":1}}],[\"ifactory的具体实现类chinesesofafactory\",{\"1\":{\"95\":1}}],[\"ifactory\",{\"1\":{\"94\":1,\"95\":4}}],[\"if\",{\"1\":{\"70\":2,\"73\":1,\"74\":1,\"82\":4,\"87\":3,\"92\":2,\"119\":1,\"158\":1}}],[\"is\",{\"1\":{\"28\":2}}],[\"identify\",{\"1\":{\"161\":1}}],[\"identifying\",{\"1\":{\"161\":1}}],[\"identifies\",{\"1\":{\"161\":1}}],[\"id\",{\"1\":{\"23\":1}}],[\"itypec\",{\"1\":{\"77\":2}}],[\"it\",{\"1\":{\"16\":2,\"158\":1}}],[\"我们都会选择使用histogram类型的指标去做分位数的统计\",{\"1\":{\"130\":1}}],[\"我们还可以通过histogram\",{\"1\":{\"129\":1}}],[\"我们可以根据指标的名称可以反推出指标的表达式\",{\"1\":{\"166\":1}}],[\"我们可以将一组相关的规则设置定义在一个group下\",{\"1\":{\"159\":1}}],[\"我们可以计算所有handler\",{\"1\":{\"141\":1}}],[\"我们可以使用offset关键字\",{\"1\":{\"134\":1}}],[\"我们可以使用求平均值来量化指标\",{\"1\":{\"129\":1}}],[\"我们可以直接输入指标名查询所有的这个指标名的时间序列\",{\"1\":{\"132\":1}}],[\"我们可以提前预测在未来什么时间节点上需要对资源进行扩容\",{\"1\":{\"116\":1}}],[\"我们可以看出代理模式有三个关键角色\",{\"1\":{\"104\":1}}],[\"我们可以看出适配器模式中包含三个关键角色\",{\"1\":{\"76\":1}}],[\"我们可以得出以下的一些结论\",{\"1\":{\"88\":1}}],[\"我们经常有一些审批流程\",{\"1\":{\"87\":1}}],[\"我们来思考一下\",{\"1\":{\"83\":1}}],[\"我们以拓展坞作为适配器将typec接口转换成usb接口为例进行讲解\",{\"1\":{\"76\":1}}],[\"我们主要讲解最常用到的适配器模式\",{\"1\":{\"76\":1}}],[\"我们需要有一些专注力\",{\"1\":{\"64\":1}}],[\"我们支持\",{\"1\":{\"57\":1,\"61\":1}}],[\"我觉得需要刻意练习\",{\"1\":{\"64\":1}}],[\"我在右对齐\",{\"1\":{\"22\":1}}],[\"我是居中的\",{\"1\":{\"22\":1}}],[\"highqps\",{\"1\":{\"159\":2}}],[\"histogram类型的http\",{\"1\":{\"149\":1}}],[\"histogram类型的指标可以使用histogram\",{\"1\":{\"145\":1}}],[\"histogram和summary的区别在于\",{\"1\":{\"130\":1}}],[\"histogram的指标\",{\"1\":{\"129\":1}}],[\"histogram直方图可以解决上面的问题\",{\"1\":{\"129\":1}}],[\"histogram直方图是用来统计和分析样本的分布情况\",{\"1\":{\"129\":1}}],[\"histogram直方图\",{\"0\":{\"129\":1}}],[\"histogram\",{\"1\":{\"126\":1,\"145\":3,\"149\":6,\"151\":1}}],[\"hello接口相关的指标\",{\"1\":{\"148\":1}}],[\"hello\",{\"1\":{\"148\":8,\"149\":19}}],[\"help\",{\"1\":{\"119\":6,\"125\":1,\"126\":1,\"130\":1,\"148\":2,\"149\":4}}],[\"h\",{\"1\":{\"133\":1}}],[\"have\",{\"1\":{\"161\":1}}],[\"has\",{\"1\":{\"158\":2}}],[\"hash\",{\"1\":{\"119\":4}}],[\"handle\",{\"1\":{\"87\":7}}],[\"handlerinterceptoradapter\",{\"1\":{\"149\":2}}],[\"handler=~\",{\"1\":{\"132\":2}}],[\"handler=\",{\"1\":{\"125\":6,\"126\":1,\"129\":12,\"132\":1,\"133\":1,\"136\":4,\"141\":1,\"143\":5,\"145\":12,\"159\":1,\"167\":1}}],[\"handler\",{\"1\":{\"107\":3,\"125\":1,\"132\":2,\"136\":2,\"141\":3,\"145\":2,\"149\":4,\"167\":2}}],[\"handlerc\",{\"1\":{\"86\":1}}],[\"handlerb\",{\"1\":{\"86\":1}}],[\"http\",{\"1\":{\"119\":1,\"120\":1,\"121\":1,\"125\":12,\"126\":4,\"127\":3,\"129\":13,\"132\":8,\"133\":1,\"134\":4,\"136\":4,\"140\":12,\"141\":6,\"143\":5,\"145\":13,\"148\":11,\"149\":23,\"151\":2,\"157\":1,\"158\":1,\"159\":3,\"160\":1,\"164\":2,\"167\":2}}],[\"httpservletresponse\",{\"1\":{\"149\":4}}],[\"httpservletrequest\",{\"1\":{\"149\":4}}],[\"httpserver\",{\"1\":{\"149\":3}}],[\"httpserver是用于导出指标的服务\",{\"1\":{\"149\":1}}],[\"httpserver<\",{\"1\":{\"149\":1}}],[\"https\",{\"1\":{\"28\":2,\"75\":1,\"120\":1,\"122\":2,\"146\":1,\"157\":1,\"161\":1,\"162\":4}}],[\"hugryinstance\",{\"1\":{\"69\":7}}],[\"how\",{\"1\":{\"158\":3,\"161\":1}}],[\"hook\",{\"1\":{\"157\":2,\"158\":2}}],[\"hope\",{\"1\":{\"28\":4,\"36\":1,\"43\":1}}],[\"home\",{\"1\":{\"1\":1,\"2\":1}}],[\"h2o\",{\"1\":{\"21\":1}}],[\"上面的表达式rate\",{\"1\":{\"166\":1}}],[\"上面的表达式等价于\",{\"1\":{\"143\":1}}],[\"上面的语句等同于\",{\"1\":{\"132\":1}}],[\"上面的配置是采集prometheus自身的监控指标\",{\"1\":{\"119\":1}}],[\"上面的测试输出结果\",{\"1\":{\"95\":1}}],[\"上图是装饰器的uml图\",{\"1\":{\"81\":1}}],[\"上下角标\",{\"0\":{\"21\":1}}],[\"上一篇\",{\"1\":{\"7\":1}}],[\"危险容器\",{\"1\":{\"19\":1}}],[\"提供了非常多的面板和插件\",{\"1\":{\"122\":1}}],[\"提供了单节点和分布式的数据存储方案\",{\"1\":{\"113\":1}}],[\"提供了数据查询的promql\",{\"1\":{\"113\":1}}],[\"提供了数据采集\",{\"1\":{\"112\":1}}],[\"提供更大的灵活性\",{\"1\":{\"108\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"18\":1}}],[\"提供一个静态工厂方法用于创建不同的产品对象\",{\"1\":{\"91\":1}}],[\"提供整个责任链的可扩展性\",{\"1\":{\"88\":1}}],[\"提升代码的可扩展性\",{\"1\":{\"88\":1}}],[\"提升代码的复用性\",{\"1\":{\"67\":1}}],[\"提高了系统的灵活性和可维护性\",{\"1\":{\"88\":1}}],[\"提示\",{\"1\":{\"44\":1}}],[\"提示容器\",{\"1\":{\"19\":1}}],[\"=~\",{\"1\":{\"132\":2}}],[\"=>\",{\"1\":{\"125\":3}}],[\"=factory\",{\"1\":{\"95\":1}}],[\"==\",{\"1\":{\"70\":2,\"73\":1,\"74\":1,\"137\":1}}],[\"=\",{\"1\":{\"19\":1,\"33\":1,\"69\":1,\"70\":1,\"71\":1,\"73\":1,\"74\":1,\"77\":3,\"80\":2,\"82\":36,\"87\":4,\"92\":5,\"98\":1,\"101\":3,\"105\":2,\"107\":4,\"108\":5,\"132\":4,\"137\":1,\"148\":2,\"149\":8,\"164\":1}}],[\"as\",{\"1\":{\"166\":1}}],[\"aggregate\",{\"1\":{\"166\":1}}],[\"again\",{\"1\":{\"158\":1}}],[\"annotations的内容在告警产生时会一同作为参数发送到alertmanager\",{\"1\":{\"159\":1}}],[\"annotations\",{\"1\":{\"159\":2,\"161\":2}}],[\"an\",{\"1\":{\"158\":3}}],[\"and\",{\"1\":{\"119\":1,\"138\":1,\"139\":1,\"166\":1}}],[\"actuator<\",{\"1\":{\"148\":1}}],[\"actuator的依赖包中\",{\"1\":{\"148\":1}}],[\"actuator\",{\"0\":{\"148\":1},\"1\":{\"147\":1,\"148\":1}}],[\"average\",{\"1\":{\"141\":1}}],[\"avg\",{\"1\":{\"141\":1}}],[\"avail\",{\"1\":{\"128\":3}}],[\"already\",{\"1\":{\"158\":2}}],[\"allows\",{\"1\":{\"158\":1}}],[\"allocated\",{\"1\":{\"119\":2}}],[\"alloc\",{\"1\":{\"119\":6}}],[\"all\",{\"1\":{\"141\":1}}],[\"alert\",{\"1\":{\"158\":2,\"159\":2,\"161\":3,\"162\":2}}],[\"alerts\",{\"1\":{\"158\":5,\"159\":1,\"160\":1,\"161\":5}}],[\"alertname\",{\"1\":{\"157\":2,\"158\":3}}],[\"alerting\",{\"1\":{\"119\":2,\"159\":1,\"161\":1}}],[\"alertmanager收到告警消息后\",{\"1\":{\"161\":1}}],[\"alertmanager查看告警消息\",{\"0\":{\"160\":1}}],[\"alertmanager持续多长时间未接收到告警后标记告警状态为resolved\",{\"1\":{\"158\":1}}],[\"alertmanager会启动它的告警恢复逻辑\",{\"1\":{\"158\":1}}],[\"alertmanager安装\",{\"0\":{\"157\":1}}],[\"alertmanager则不会发送消息到下游\",{\"1\":{\"156\":1}}],[\"alertmanager处理来自客户端的告警消息\",{\"1\":{\"153\":1}}],[\"alertmanager介绍\",{\"0\":{\"153\":1}}],[\"alertmanager作为告警收敛的组件\",{\"1\":{\"152\":1}}],[\"alertmanager的主要功能包括告警消息的分组\",{\"1\":{\"152\":1}}],[\"alertmanagers是用来处理prometheus根据告警规则任务计算出来的告警消息的\",{\"1\":{\"119\":1}}],[\"alertmanagers是配置alertmanagers的地址的\",{\"1\":{\"119\":1}}],[\"alertmanagers\",{\"1\":{\"119\":1,\"159\":1}}],[\"alertmanager提供了对告警消息的管理\",{\"1\":{\"115\":1}}],[\"alertmanager是用来管理告警消息的\",{\"1\":{\"114\":1}}],[\"alertmanager\",{\"1\":{\"110\":1,\"119\":2,\"156\":2,\"157\":1,\"161\":1}}],[\"about\",{\"1\":{\"119\":1,\"158\":1}}],[\"abstract\",{\"1\":{\"87\":2,\"92\":2,\"96\":1,\"98\":2}}],[\"aftercompletion\",{\"1\":{\"149\":1}}],[\"after\",{\"1\":{\"105\":2,\"107\":2}}],[\"aop\",{\"1\":{\"103\":1,\"149\":1}}],[\"added\",{\"1\":{\"158\":1}}],[\"addinterceptor\",{\"1\":{\"149\":1}}],[\"addinterceptors\",{\"1\":{\"149\":1}}],[\"addition\",{\"1\":{\"136\":1}}],[\"add\",{\"1\":{\"101\":1}}],[\"adapter\",{\"1\":{\"77\":2}}],[\"adaptee\",{\"1\":{\"76\":1}}],[\"article\",{\"1\":{\"162\":1}}],[\"artifactid>\",{\"1\":{\"108\":1,\"148\":3,\"149\":3}}],[\"arrive\",{\"1\":{\"158\":1}}],[\"arraylist<alert>\",{\"1\":{\"161\":1}}],[\"arraylist<>\",{\"1\":{\"101\":1}}],[\"arraylist\",{\"1\":{\"101\":1}}],[\"are\",{\"1\":{\"141\":1,\"158\":2}}],[\"architecture\",{\"1\":{\"115\":1}}],[\"args\",{\"1\":{\"77\":1,\"82\":1,\"87\":1,\"92\":1,\"95\":1,\"98\":1,\"101\":1,\"105\":1,\"107\":3,\"108\":3}}],[\"amd64\",{\"1\":{\"118\":2,\"122\":2}}],[\"america\",{\"1\":{\"92\":1}}],[\"americasofafactory\",{\"1\":{\"95\":1}}],[\"americasofa\",{\"1\":{\"92\":2,\"95\":1}}],[\"americasofa类实现了抽象产品类\",{\"1\":{\"92\":1}}],[\"amount<1000\",{\"1\":{\"87\":1}}],[\"amount\",{\"1\":{\"87\":12}}],[\"apistatinterceptor\",{\"1\":{\"149\":2}}],[\"api\",{\"1\":{\"132\":4,\"136\":1}}],[\"aproval\",{\"1\":{\"87\":7}}],[\"append\",{\"1\":{\"82\":1}}],[\"attrs\",{\"0\":{\"23\":1}}],[\"a\",{\"1\":{\"19\":1,\"119\":1,\"125\":2,\"130\":1,\"158\":5}}],[\"c661e8050434\",{\"1\":{\"162\":1}}],[\"csdn\",{\"1\":{\"162\":1}}],[\"critical\",{\"1\":{\"157\":1,\"158\":2}}],[\"createhttpserver\",{\"1\":{\"149\":1}}],[\"create\",{\"1\":{\"108\":1}}],[\"createsofa\",{\"1\":{\"92\":1,\"95\":4}}],[\"createcoffee\",{\"1\":{\"92\":1}}],[\"caused\",{\"1\":{\"161\":1}}],[\"calculate\",{\"1\":{\"141\":5}}],[\"catch\",{\"1\":{\"82\":7}}],[\"currenttimemillis\",{\"1\":{\"149\":2}}],[\"currently\",{\"1\":{\"119\":1}}],[\"curl\",{\"1\":{\"121\":1,\"122\":1}}],[\"cycles\",{\"1\":{\"119\":1,\"130\":1}}],[\"cd\",{\"1\":{\"118\":1}}],[\"cglib无法从代理对象中调用自身的方法\",{\"1\":{\"108\":1}}],[\"cglib无法代理final方法和final类\",{\"1\":{\"108\":1}}],[\"cglib能够代理普通类和接口类\",{\"1\":{\"108\":1}}],[\"cglib动态代理需要引入额外的库\",{\"1\":{\"108\":1}}],[\"cglib动态代理的缺点\",{\"1\":{\"108\":1}}],[\"cglib动态代理的优点\",{\"1\":{\"108\":1}}],[\"cglib动态代理可以代理没有实现任何接口的类\",{\"1\":{\"108\":1}}],[\"cglib动态代理通常能够提供更好的性能\",{\"1\":{\"108\":1}}],[\"cglib可以代理非接口类型的类\",{\"1\":{\"108\":1}}],[\"cglib\",{\"1\":{\"108\":1}}],[\"cglibproxyfactory\",{\"1\":{\"108\":3}}],[\"cglib代码模式需要实现methodinterceptor\",{\"1\":{\"108\":1}}],[\"cglib代码\",{\"0\":{\"108\":1}}],[\"cn\",{\"1\":{\"92\":2}}],[\"chu\",{\"1\":{\"162\":1}}],[\"china\",{\"1\":{\"92\":2,\"95\":1,\"98\":3}}],[\"chinesetable\",{\"1\":{\"97\":1,\"98\":3}}],[\"chinesesofafactory\",{\"1\":{\"94\":1,\"95\":2}}],[\"chinesesofa\",{\"1\":{\"92\":2,\"95\":1,\"98\":1}}],[\"chinesesofa类实现了抽象产品类\",{\"1\":{\"92\":1}}],[\"chinese\",{\"1\":{\"91\":1,\"94\":1}}],[\"chain\",{\"1\":{\"87\":2}}],[\"cfo审批通过\",{\"1\":{\"87\":2}}],[\"cfo\",{\"1\":{\"87\":5}}],[\"cfo继承了aproval\",{\"1\":{\"87\":1}}],[\"cfo三个角色\",{\"1\":{\"87\":1}}],[\"ctorinstance\",{\"1\":{\"70\":1}}],[\"client的数据\",{\"1\":{\"152\":1}}],[\"client\",{\"1\":{\"82\":1,\"87\":1,\"92\":1,\"95\":1,\"98\":1,\"101\":1,\"105\":1,\"107\":1,\"108\":1,\"114\":1}}],[\"close\",{\"1\":{\"82\":9}}],[\"cloud\",{\"0\":{\"0\":1}}],[\"class\",{\"1\":{\"69\":1,\"70\":2,\"71\":2,\"73\":1,\"74\":1,\"77\":3,\"82\":4,\"87\":5,\"92\":5,\"95\":3,\"98\":4,\"101\":3,\"105\":3,\"107\":2,\"108\":2,\"148\":1,\"149\":2,\"161\":2}}],[\"core\",{\"1\":{\"149\":2}}],[\"core包是指标的关键包\",{\"1\":{\"149\":1}}],[\"core<\",{\"1\":{\"149\":1}}],[\"count作为后缀\",{\"1\":{\"129\":1}}],[\"counter类型的http\",{\"1\":{\"149\":1}}],[\"counter类型的指标和计数器一样\",{\"1\":{\"127\":1}}],[\"counter\",{\"0\":{\"127\":1},\"1\":{\"119\":1,\"125\":2,\"126\":3,\"149\":10}}],[\"count\",{\"1\":{\"119\":1,\"129\":1,\"130\":1,\"136\":1,\"141\":4,\"148\":2,\"149\":26,\"151\":2}}],[\"collect\",{\"1\":{\"158\":1}}],[\"collection\",{\"1\":{\"119\":1,\"130\":1}}],[\"color\",{\"1\":{\"28\":1}}],[\"code的的请求总数\",{\"1\":{\"141\":1}}],[\"code=\",{\"1\":{\"125\":6,\"126\":1,\"140\":10,\"141\":1,\"143\":5}}],[\"code\",{\"1\":{\"82\":1,\"108\":1,\"125\":1,\"140\":9,\"141\":2,\"167\":2}}],[\"controller\",{\"1\":{\"148\":1}}],[\"content\",{\"1\":{\"82\":7}}],[\"configs是配置采集任务的\",{\"1\":{\"119\":1}}],[\"configs\",{\"1\":{\"119\":3,\"120\":3,\"150\":2,\"157\":1,\"158\":1,\"159\":1}}],[\"configuration\",{\"1\":{\"119\":1,\"149\":1,\"161\":1}}],[\"config\",{\"1\":{\"119\":1,\"157\":1,\"161\":1}}],[\"consul\",{\"1\":{\"113\":1,\"119\":1}}],[\"const\",{\"1\":{\"19\":1}}],[\"concrete\",{\"1\":{\"100\":2}}],[\"connect\",{\"1\":{\"77\":6}}],[\"commonannotations\",{\"1\":{\"161\":2}}],[\"commonlabels\",{\"1\":{\"161\":2}}],[\"complement\",{\"1\":{\"138\":1}}],[\"compress\",{\"1\":{\"82\":2}}],[\"compressionfilereaderwriter\",{\"1\":{\"82\":3}}],[\"compressionfilereaderwriter是一个装饰器\",{\"1\":{\"82\":1}}],[\"componentimpl提供基本的实现方法\",{\"1\":{\"81\":1}}],[\"componentdecoratora\",{\"1\":{\"81\":1}}],[\"componentdecoratorb和componentdecoratora分别对componentimpl进行了增强\",{\"1\":{\"81\":1}}],[\"componentdecoratorb\",{\"1\":{\"81\":1}}],[\"com\",{\"1\":{\"28\":2,\"75\":1,\"82\":3,\"101\":3,\"120\":1,\"122\":2,\"162\":2}}],[\"与java动态代理不同\",{\"1\":{\"108\":1}}],[\"与\",{\"1\":{\"19\":1}}],[\"信息容器\",{\"1\":{\"19\":1}}],[\"v\",{\"1\":{\"143\":1,\"144\":1}}],[\"v1\",{\"1\":{\"132\":4,\"136\":1}}],[\"vector\",{\"0\":{\"132\":1,\"133\":1,\"139\":1},\"1\":{\"133\":1,\"139\":2,\"141\":2,\"143\":1,\"144\":1,\"145\":1}}],[\"version\",{\"1\":{\"161\":2}}],[\"version=\",{\"1\":{\"119\":1}}],[\"version>\",{\"1\":{\"108\":1,\"148\":1,\"149\":3}}],[\"version>3\",{\"1\":{\"108\":1}}],[\"victoriametrics\",{\"1\":{\"113\":1}}],[\"victoriametrics系列\",{\"1\":{\"110\":1}}],[\"variance\",{\"1\":{\"141\":1}}],[\"variable\",{\"1\":{\"19\":1}}],[\"values\",{\"1\":{\"141\":2}}],[\"value1\",{\"1\":{\"132\":1}}],[\"value2\",{\"1\":{\"132\":1}}],[\"value\",{\"1\":{\"125\":3,\"132\":5,\"141\":3}}],[\"value键值对\",{\"1\":{\"112\":1}}],[\"void\",{\"1\":{\"77\":5,\"82\":5,\"87\":6,\"92\":2,\"95\":1,\"98\":2,\"101\":7,\"105\":5,\"107\":2,\"108\":2,\"149\":3}}],[\"volatile\",{\"1\":{\"70\":1}}],[\"vue\",{\"0\":{\"38\":1}}],[\"vuepress\",{\"0\":{\"17\":1},\"1\":{\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"18\":1,\"44\":1}}],[\"micrometer<\",{\"1\":{\"148\":1}}],[\"minutes\",{\"1\":{\"158\":1}}],[\"minimum\",{\"1\":{\"141\":1}}],[\"min\",{\"1\":{\"141\":1}}],[\"mister\",{\"1\":{\"28\":2}}],[\"modelandview\",{\"1\":{\"149\":3}}],[\"modifiers\",{\"0\":{\"140\":1}}],[\"modulo\",{\"1\":{\"136\":1}}],[\"more\",{\"1\":{\"42\":1,\"158\":3}}],[\"multiplication\",{\"1\":{\"136\":1}}],[\"m\",{\"1\":{\"133\":2}}],[\"myjob\",{\"1\":{\"166\":9}}],[\"my\",{\"1\":{\"119\":1}}],[\"mysql等\",{\"1\":{\"114\":1}}],[\"mcclient\",{\"1\":{\"77\":1}}],[\"memstats\",{\"1\":{\"119\":9}}],[\"memory=allocate\",{\"1\":{\"70\":1}}],[\"metric\",{\"1\":{\"125\":1,\"132\":1,\"166\":2}}],[\"metrics|\",{\"1\":{\"132\":2}}],[\"metrics接口耗时\",{\"1\":{\"129\":1}}],[\"metrics接口来获取自身的数据\",{\"1\":{\"125\":1}}],[\"metrics接口暴露\",{\"1\":{\"125\":1}}],[\"metrics\",{\"1\":{\"119\":1,\"120\":1,\"125\":9,\"126\":1,\"129\":12,\"132\":6,\"133\":1,\"136\":5,\"141\":1,\"143\":5,\"145\":13,\"149\":11,\"159\":1,\"167\":2}}],[\"method=\",{\"1\":{\"140\":14,\"148\":3}}],[\"methodproxy\",{\"1\":{\"108\":2}}],[\"methodinterceptor\",{\"1\":{\"108\":1}}],[\"method\",{\"1\":{\"93\":1,\"107\":5,\"108\":3,\"140\":12}}],[\"mermaid\",{\"0\":{\"32\":1}}],[\"ms\",{\"1\":{\"43\":1}}],[\"mr\",{\"1\":{\"28\":1,\"36\":1}}],[\"md\",{\"1\":{\"18\":1}}],[\"map<string\",{\"1\":{\"161\":5}}],[\"maximum\",{\"1\":{\"141\":1}}],[\"max\",{\"1\":{\"141\":1,\"148\":4,\"161\":1}}],[\"management\",{\"1\":{\"148\":1}}],[\"manager\",{\"1\":{\"87\":6}}],[\"manager继承了aproval\",{\"1\":{\"87\":1}}],[\"many的向量匹配\",{\"1\":{\"140\":1}}],[\"many\",{\"1\":{\"139\":1,\"161\":1}}],[\"match\",{\"1\":{\"157\":2,\"158\":4}}],[\"matches\",{\"1\":{\"139\":2}}],[\"matching\",{\"0\":{\"139\":1},\"1\":{\"139\":1}}],[\"matter\",{\"1\":{\"1\":1,\"2\":1}}],[\"mac的版本\",{\"1\":{\"118\":1}}],[\"mac连接typec\",{\"1\":{\"77\":1}}],[\"maketable\",{\"1\":{\"98\":3}}],[\"makesofa\",{\"1\":{\"98\":3}}],[\"main\",{\"1\":{\"75\":2,\"77\":1,\"82\":1,\"87\":1,\"92\":1,\"95\":1,\"98\":1,\"101\":1,\"105\":1,\"107\":1,\"108\":1}}],[\"markdown\",{\"0\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1},\"1\":{\"5\":1,\"13\":2,\"14\":3,\"15\":1,\"16\":3,\"17\":2,\"18\":1,\"19\":1,\"34\":1,\"43\":1,\"44\":2},\"2\":{\"41\":1}}],[\"主题实现类\",{\"1\":{\"104\":1,\"105\":1}}],[\"主题和观察者之间松耦合\",{\"1\":{\"102\":1}}],[\"主题包含了一个自定义徽章可以使用\",{\"1\":{\"44\":1}}],[\"主题扩展了更多\",{\"1\":{\"18\":1}}],[\"主题扩展\",{\"0\":{\"18\":1}}],[\"主要原因\",{\"1\":{\"83\":1}}],[\"主要从\",{\"1\":{\"13\":1}}],[\"主要功能与配置演示\",{\"0\":{\"4\":1}}],[\"请求状态码\",{\"1\":{\"149\":2}}],[\"请求路径\",{\"1\":{\"149\":2}}],[\"请求的最大耗时\",{\"1\":{\"148\":1}}],[\"请求的总耗时\",{\"1\":{\"148\":1}}],[\"请求的总次数\",{\"1\":{\"148\":1}}],[\"请求都是在100ms以内\",{\"1\":{\"129\":1}}],[\"请使用绝对链接\",{\"1\":{\"44\":1}}],[\"请阅读\",{\"1\":{\"17\":1}}],[\"请先阅读\",{\"1\":{\"14\":1}}],[\"关于这些扩展\",{\"1\":{\"17\":1}}],[\"语法\",{\"0\":{\"33\":1},\"1\":{\"18\":1}}],[\"语法进行了扩展\",{\"1\":{\"17\":1}}],[\"语法扩展\",{\"1\":{\"16\":1}}],[\"对meric使用了rate操作将metric原来的名称去掉\",{\"1\":{\"166\":1}}],[\"对应的java实体如下\",{\"1\":{\"161\":1}}],[\"对处理者来说是一个灾难\",{\"1\":{\"154\":1}}],[\"对照分析\",{\"1\":{\"116\":1}}],[\"对监控指标进行长期趋势分析\",{\"1\":{\"116\":1}}],[\"对final方法和final类的限制\",{\"1\":{\"108\":1}}],[\"对原有功能的做扩展或者增强\",{\"1\":{\"103\":1}}],[\"对象之间关系也比较清晰\",{\"1\":{\"102\":1}}],[\"对一些基础类无法修改\",{\"1\":{\"83\":1}}],[\"对读取的字符进行先解压再解密\",{\"1\":{\"82\":1}}],[\"对读取的字符进行解压\",{\"1\":{\"82\":2}}],[\"对读取的字符进行解密\",{\"1\":{\"82\":2}}],[\"对它进行功能的增强\",{\"1\":{\"82\":2}}],[\"对写入的字符进行先加密再压缩\",{\"1\":{\"82\":1}}],[\"对写入的字符进行压缩\",{\"1\":{\"82\":1}}],[\"对写入的字符进行加密\",{\"1\":{\"82\":1}}],[\"对写入字符进行压缩\",{\"1\":{\"82\":1}}],[\"对写入文件的字符的加密\",{\"1\":{\"82\":1}}],[\"对于请求数量在5分钟的时间窗口内\",{\"1\":{\"143\":1}}],[\"对于分位数的计算而言\",{\"1\":{\"130\":1}}],[\"对于标签值无约束\",{\"1\":{\"125\":1}}],[\"对于需要代理的类数量较多或变化频繁的情况下\",{\"1\":{\"104\":1}}],[\"对于\",{\"1\":{\"44\":1}}],[\"对\",{\"1\":{\"17\":1}}],[\"为了解决该问题\",{\"1\":{\"143\":1}}],[\"为了丰富文档写作\",{\"1\":{\"17\":1}}],[\"为目标对象生成代理对象\",{\"1\":{\"108\":1}}],[\"为什么要使用观察者模式\",{\"0\":{\"102\":1}}],[\"为什么要使用责任链模式\",{\"0\":{\"88\":1}}],[\"为什么要使用装饰器模式\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"为每个\",{\"1\":{\"15\":1}}],[\"插件来实现\",{\"1\":{\"16\":1}}],[\"扩展\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"17\":1}}],[\"中间件有着广泛的应用\",{\"1\":{\"104\":1}}],[\"中使用\",{\"1\":{\"19\":1}}],[\"中的创建对象的方法\",{\"1\":{\"98\":1}}],[\"中的\",{\"1\":{\"17\":1}}],[\"中很重要的一个概念\",{\"1\":{\"15\":1}}],[\"中设置页面信息\",{\"1\":{\"43\":1}}],[\"中设置\",{\"1\":{\"1\":1,\"2\":1}}],[\"是应用于指标的操作函数列表\",{\"1\":{\"166\":1}}],[\"是和预聚合前的名称保存一致\",{\"1\":{\"166\":1}}],[\"是单调递增的\",{\"1\":{\"127\":1}}],[\"是全局配置默认采集时间间隔\",{\"1\":{\"119\":1}}],[\"是用来开发应用指标的工具包\",{\"1\":{\"114\":1}}],[\"是一个强大的高性能的代码生成库\",{\"1\":{\"108\":1}}],[\"是一种行为型设计模式\",{\"1\":{\"99\":1}}],[\"是一种创建型设计模式\",{\"1\":{\"93\":1,\"96\":1}}],[\"是会经常使用到的一个设计模式\",{\"1\":{\"85\":1}}],[\"是不能改变原有的基础功能\",{\"1\":{\"81\":1}}],[\"是为了保持简单性\",{\"1\":{\"78\":1}}],[\"是作为适配的中间类\",{\"1\":{\"76\":1}}],[\"是\",{\"1\":{\"15\":1}}],[\"配置讲解\",{\"0\":{\"158\":1}}],[\"配置文件中包含了4个部分\",{\"1\":{\"157\":1}}],[\"配置和启动alertmanager\",{\"1\":{\"152\":1}}],[\"配置请求的p95耗时\",{\"1\":{\"151\":1}}],[\"配置的表达式如下\",{\"1\":{\"151\":2}}],[\"配置grafana视图\",{\"0\":{\"151\":1}}],[\"配置完成后\",{\"1\":{\"150\":1}}],[\"配置完成后保存\",{\"1\":{\"122\":1}}],[\"配置如下\",{\"1\":{\"150\":1}}],[\"配置prometheus采集\",{\"0\":{\"150\":1}}],[\"配置prometheus采集node\",{\"1\":{\"117\":1}}],[\"配置界面的路径和配置如下\",{\"1\":{\"122\":1}}],[\"配置信息如下\",{\"1\":{\"120\":1}}],[\"配置\",{\"0\":{\"15\":1},\"1\":{\"158\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"1\":1,\"2\":1}}],[\"演示\",{\"1\":{\"14\":1}}],[\"和alert\",{\"1\":{\"164\":1}}],[\"和status\",{\"1\":{\"149\":2}}],[\"和many\",{\"1\":{\"139\":1}}],[\"和maketable\",{\"1\":{\"98\":1}}],[\"和handler不为\",{\"1\":{\"132\":1}}],[\"和handler为\",{\"1\":{\"132\":1}}],[\"和值的总和\",{\"1\":{\"129\":1}}],[\"和直方图类似\",{\"1\":{\"126\":1}}],[\"和静态代理类似\",{\"1\":{\"107\":1}}],[\"和一个具体方法showname\",{\"1\":{\"92\":1}}],[\"和持有一个aproval对象\",{\"1\":{\"87\":1}}],[\"和双重检查模式一样\",{\"1\":{\"71\":1}}],[\"和\",{\"1\":{\"14\":1,\"43\":1}}],[\"介绍\",{\"0\":{\"14\":1,\"57\":1,\"61\":1},\"1\":{\"14\":1,\"15\":1}}],[\"文章标题列表\",{\"1\":{\"45\":1}}],[\"文章加密\",{\"2\":{\"12\":1}}],[\"文件系统里剩余的磁盘字节数\",{\"1\":{\"120\":1}}],[\"文件夹的图片\",{\"1\":{\"44\":1}}],[\"文件放置在一起\",{\"1\":{\"44\":1}}],[\"文件\",{\"1\":{\"13\":1}}],[\"文件生成页面\",{\"1\":{\"13\":1}}],[\"文字结尾应该有深蓝色的\",{\"1\":{\"44\":1}}],[\"文字\",{\"1\":{\"10\":2}}],[\"文字段落\",{\"1\":{\"10\":24}}],[\"24\",{\"1\":{\"140\":3,\"144\":1}}],[\"296\",{\"1\":{\"130\":1}}],[\"2s\",{\"1\":{\"129\":1}}],[\"21\",{\"1\":{\"119\":1,\"140\":2}}],[\"25\",{\"1\":{\"119\":1,\"130\":1,\"149\":1}}],[\"253\",{\"1\":{\"28\":1}}],[\"20\",{\"1\":{\"129\":1,\"145\":1}}],[\"20ms的请求又多少个\",{\"1\":{\"129\":1}}],[\"200\",{\"1\":{\"125\":9,\"126\":1,\"141\":1,\"143\":5,\"148\":3}}],[\"2017年底发布了基于全新存储层的2\",{\"1\":{\"112\":1}}],[\"2016年5月继kubernetes之后成为第二个正式加入cncf\",{\"1\":{\"112\":1}}],[\"20230830224136440\",{\"1\":{\"110\":1}}],[\"20231023210926364\",{\"1\":{\"167\":1}}],[\"20231021174948512\",{\"1\":{\"160\":1}}],[\"20231021174854220\",{\"1\":{\"159\":1}}],[\"20231021174512876\",{\"1\":{\"159\":1}}],[\"20231021170507878\",{\"1\":{\"152\":1}}],[\"20231021115611700\",{\"1\":{\"151\":1}}],[\"20231021115719027\",{\"1\":{\"151\":1}}],[\"20231014211256244\",{\"1\":{\"133\":1}}],[\"20231014210912914\",{\"1\":{\"132\":1}}],[\"20231014210829763\",{\"1\":{\"132\":1}}],[\"20231012215203283\",{\"1\":{\"125\":1}}],[\"20231010201727866\",{\"1\":{\"122\":1}}],[\"20231009220040376\",{\"1\":{\"122\":1}}],[\"20231008231356066\",{\"1\":{\"120\":1}}],[\"20231008084050835\",{\"1\":{\"118\":1}}],[\"20231008083006727\",{\"1\":{\"118\":1}}],[\"20231030213851667\",{\"1\":{\"68\":1}}],[\"20231107230028268\",{\"1\":{\"100\":1}}],[\"20231105210628018\",{\"1\":{\"94\":1}}],[\"20231102232111957\",{\"1\":{\"81\":1}}],[\"2020\",{\"1\":{\"43\":1}}],[\"2和3可能会发生重排序\",{\"1\":{\"70\":1}}],[\"230\",{\"1\":{\"28\":1}}],[\"2\",{\"1\":{\"10\":14,\"26\":1,\"70\":1,\"77\":1,\"108\":1,\"118\":2,\"119\":1,\"129\":2,\"145\":1,\"149\":4}}],[\"1m\",{\"1\":{\"145\":2,\"151\":2,\"159\":2,\"164\":1,\"167\":2}}],[\"175\",{\"1\":{\"140\":1}}],[\"171390910999984\",{\"1\":{\"129\":1}}],[\"1d\",{\"1\":{\"134\":1}}],[\"127\",{\"1\":{\"148\":3,\"149\":1,\"157\":1,\"158\":1,\"159\":3}}],[\"1255515\",{\"1\":{\"130\":1}}],[\"120665690\",{\"1\":{\"162\":1}}],[\"120\",{\"1\":{\"129\":1,\"140\":4,\"145\":1}}],[\"1205\",{\"1\":{\"125\":3,\"126\":1}}],[\"1s\",{\"1\":{\"129\":1}}],[\"1831\",{\"1\":{\"129\":7}}],[\"1830\",{\"1\":{\"129\":1}}],[\"1829\",{\"1\":{\"129\":1}}],[\"1828\",{\"1\":{\"129\":1}}],[\"1827\",{\"1\":{\"129\":1}}],[\"1h\",{\"1\":{\"128\":1,\"157\":1,\"158\":1}}],[\"11\",{\"1\":{\"148\":1}}],[\"1186\",{\"1\":{\"125\":2}}],[\"1194\",{\"1\":{\"125\":2}}],[\"1696984033\",{\"1\":{\"125\":2}}],[\"1696984153\",{\"1\":{\"125\":2}}],[\"1696984318\",{\"1\":{\"125\":2}}],[\"10s\",{\"1\":{\"158\":1}}],[\"10ms\",{\"1\":{\"129\":1}}],[\"10ms的请求有多少个\",{\"1\":{\"129\":1}}],[\"10\",{\"1\":{\"122\":2,\"149\":1}}],[\"10000\",{\"1\":{\"87\":1}}],[\"1363728e+07\",{\"1\":{\"119\":1}}],[\"138\",{\"1\":{\"28\":1}}],[\"15s\",{\"1\":{\"119\":2}}],[\"15\",{\"1\":{\"28\":1,\"129\":1}}],[\"19th\",{\"1\":{\"21\":1}}],[\"1\",{\"1\":{\"10\":12,\"19\":1,\"24\":1,\"26\":1,\"43\":2,\"70\":1,\"77\":1,\"82\":3,\"118\":2,\"119\":4,\"122\":2,\"129\":3,\"130\":1,\"141\":2,\"145\":2,\"148\":3,\"149\":4,\"157\":1,\"158\":1,\"159\":4}}],[\"段落\",{\"1\":{\"10\":2}}],[\"页脚\",{\"1\":{\"7\":1,\"45\":1}}],[\"页面的导入路径如下\",{\"1\":{\"122\":1}}],[\"页面结构\",{\"0\":{\"45\":1}}],[\"页面内容\",{\"0\":{\"44\":1}}],[\"页面配置\",{\"0\":{\"42\":1},\"1\":{\"43\":1},\"2\":{\"47\":1}}],[\"页面引入配置\",{\"1\":{\"15\":1}}],[\"页面信息\",{\"0\":{\"43\":1},\"1\":{\"7\":1}}],[\"页面展示如下\",{\"1\":{\"118\":1}}],[\"页面展示\",{\"1\":{\"5\":1,\"34\":1}}],[\"链接\",{\"1\":{\"7\":1,\"19\":1}}],[\"编辑此页链接\",{\"1\":{\"7\":1}}],[\"贡献者\",{\"1\":{\"7\":1,\"45\":1}}],[\"侧边栏\",{\"1\":{\"7\":1,\"45\":1}}],[\"布局与功能禁用\",{\"0\":{\"7\":1}}],[\"展示prometheus数据\",{\"1\":{\"122\":1}}],[\"展示\",{\"0\":{\"13\":1},\"1\":{\"5\":1,\"34\":1}}],[\"项目主页配置\",{\"1\":{\"1\":1,\"2\":1}}],[\"你需要阅读\",{\"1\":{\"15\":1}}],[\"你需要在页面\",{\"1\":{\"1\":1,\"2\":1}}],[\"你应该创建和编写\",{\"1\":{\"13\":1}}],[\"你可以通过主题选项和页面\",{\"1\":{\"45\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"7\":1}}],[\"你可以将图片和\",{\"1\":{\"44\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"44\":1}}],[\"你可以在\",{\"1\":{\"43\":1}}],[\"你可以在这里放置你的主体内容\",{\"1\":{\"1\":1,\"2\":1}}],[\"你可以标记\",{\"1\":{\"25\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"13\":1}}],[\"想要使用此布局\",{\"1\":{\"1\":1,\"2\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
